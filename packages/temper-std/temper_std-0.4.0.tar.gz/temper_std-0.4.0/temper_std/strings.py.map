{ "version": 3, "file": "py/std/temper_std/strings.py", "sources": [ "std/strings.temper.md" ], "sourcesContent": [ "# String related abstractions\n\nA *StringBuilder* allows composing a string from left to right\nby appending substrings at the end.\n\n    @connected(\u0022StringBuilder\u0022)\n    export class StringBuilder {\n      private let substrings: ListBuilder\u003cString\u003e;\n\n      @connected(\u0022StringBuilder::constructor\u0022)\n      public constructor(): Void {\n        this.substrings = new ListBuilder\u003cString\u003e();\n      }\n\nYou can append a string at the end.\n\n      @connected(\u0022StringBuilder::append\u0022)\n      public append(substring: String): Void {\n        substrings.add(substring);\n      }\n\nA single codepoint can be appended.  If it's out of the range\nof valid code points, it appends the replacement character FEFF.\n\n      @connected(\u0022StringBuilder::appendCodePoint\u0022)\n      public appendCodePoint(cp: Int): Void {\n        let validCp = (0 \u003c cp \u0026\u0026 cp \u003c= 0x10FFFF) ? cp : 0xFFFD;\n        append(String.fromCodePoint(validCp));\n      }\n\n*appendBetween* can be connected to a function that appends a substring without\ncreating a new backing array for the substring.\n\n      @connected(\u0022StringBuilder::appendBetween\u0022)\n      public appendBetween(string: String, left: StringIndex, right: StringIndex): Void {\n        var limit = right;\n        let end = string.end;\n        // Do not loop infinitely if right is past the end of string\n        if (limit \u003e end) { limit = end; }\n\n        for (var index = left;\n             index \u003c limit;\n             index = string.next(index)) {\n          appendCodePoint(string[index]);\n        }\n      }\n\n      @connected(\u0022StringBuilder::toString\u0022)\n      public toString(): String {\n        this.substrings.join(\u0022\u0022) { (substring: String);; substring }\n      }\n    }\n" ], "names": [], "mappings": "AAMiB" }