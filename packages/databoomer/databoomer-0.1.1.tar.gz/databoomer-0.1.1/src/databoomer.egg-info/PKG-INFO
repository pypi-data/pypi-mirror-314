Metadata-Version: 2.1
Name: databoomer
Version: 0.1.1
Summary: Copy Python objects as portable code snippets between Jupyter notebooks
Author-email: Kaspar Kallas <kaspar.kana.kallas@gmail.com>
License: BSD-3-Clause
Project-URL: Homepage, https://github.com/KKallas/DataBoomer
Project-URL: Bug Tracker, https://github.com/KKallas/DataBoomer/issues
Keywords: repl,template,development,jupyter,base64
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Framework :: IPython
Classifier: Framework :: Jupyter
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE
Provides-Extra: test
Requires-Dist: pytest>=6.0; extra == "test"
Provides-Extra: jupyter
Requires-Dist: ipython; extra == "jupyter"

# DataBoomer

A Jupyter tool for seamlessly transferring complex Python objects between notebooks. DataBoomer serializes your objects as base64 string and creates self-contained code snippets that can perfectly recreate them in any notebook.

## Key Features
- One-click copying of serialized objects to clipboard
- Handles complex Python objects using `dill`
- Creates self-contained, portable code snippets
- Automatically detects variable names
- Preserves object state exactly as it was

## Install
```bash
pip install databoomer
```

## Usage in Jupyter
```python
from databoomer import DataBoomer
import pandas as pd

# Save a complex DataFrame with custom processing
df = pd.DataFrame({'values': [1, 2, 3]})
df['processed'] = df['values'] * 2
DataBoomer(df, comment="Preprocessed dataset")
# Copies to clipboard:
# # comment: Preprocessed dataset
# payload = '''[encoded_data]'''
# df = dill.loads(codecs.decode(payload.encode(), 'base64'))

# Custom variable names
model = train_complex_model()
DataBoomer(model, obj_name="trained_model", comment="Model trained on XYZ dataset")

# The copied code can be pasted into any notebook to recreate the exact object
```

## Why DataBoomer?
- **Share Objects**: Easily transfer complex objects between notebooks
- **Session Recovery**: Save important objects in a format that survives kernel restarts
- **Collaboration**: Share exact object states with colleagues
- **State Preservation**: Captures complete object state, including custom attributes and processing

Remember: DataBoomer creates portable, self-contained code snippets that recreate your objects exactly as they were. Just boom it, switch notebooks, paste, and you're ready to go.

Note: This tool is particularly useful when working with objects that are:
- Result of complex processing
- Trained models or fitted transformers
- Custom class instances with specific state
- Image snippets, selfcontained in the jupyter lab
