# The PEP 484 type hints stub file for the core module.
#
# Generated by SIP 6.8.6


import enum
import typing

import yasimavr.lib._sip


class SleepMode(enum.IntEnum):
    Invalid = ... # type: SleepMode
    Active = ... # type: SleepMode
    Pseudo = ... # type: SleepMode
    Idle = ... # type: SleepMode
    ADC = ... # type: SleepMode
    Standby = ... # type: SleepMode
    ExtStandby = ... # type: SleepMode
    PowerDown = ... # type: SleepMode
    PowerSave = ... # type: SleepMode


class CoreCrashCodes(enum.Enum):
    Crash_PC_Overflow = ... # type: CoreCrashCodes
    Crash_SP_Overflow = ... # type: CoreCrashCodes
    Crash_Bad_CPU_IO = ... # type: CoreCrashCodes
    Crash_Bad_CTL_IO = ... # type: CoreCrashCodes
    Crash_Invalid_Opcode = ... # type: CoreCrashCodes
    Crash_Invalid_Config = ... # type: CoreCrashCodes
    Crash_Flash_Addr_Overflow = ... # type: CoreCrashCodes
    Crash_Access_Refused = ... # type: CoreCrashCodes


class StdRegisters(enum.Enum):
    R_XL = ... # type: StdRegisters
    R_XH = ... # type: StdRegisters
    R_YL = ... # type: StdRegisters
    R_YH = ... # type: StdRegisters
    R_ZL = ... # type: StdRegisters
    R_ZH = ... # type: StdRegisters
    R_X = ... # type: StdRegisters
    R_Y = ... # type: StdRegisters
    R_Z = ... # type: StdRegisters
    R_SPL = ... # type: StdRegisters
    R_SPH = ... # type: StdRegisters
    R_SREG = ... # type: StdRegisters


class SREG_Bits(enum.Enum):
    SREG_C = ... # type: SREG_Bits
    SREG_Z = ... # type: SREG_Bits
    SREG_N = ... # type: SREG_Bits
    SREG_V = ... # type: SREG_Bits
    SREG_S = ... # type: SREG_Bits
    SREG_H = ... # type: SREG_Bits
    SREG_T = ... # type: SREG_Bits
    SREG_I = ... # type: SREG_Bits


class CoreConfiguration(yasimavr.lib._sip.wrapper):

    class Attributes(enum.IntFlag):
        ExtendedAddressing = ... # type: CoreConfiguration.Attributes
        ClearGIEOnInt = ... # type: CoreConfiguration.Attributes

    attributes = ... # type: int
    dataend = ... # type: int
    eepromend = ... # type: int
    eind = ... # type: 'reg_addr_t'
    flashend = ... # type: int
    fuses = ... # type: Vector
    fusesize = ... # type: int
    ioend = ... # type: int
    iostart = ... # type: int
    ramend = ... # type: int
    rampz = ... # type: 'reg_addr_t'
    ramstart = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CoreConfiguration') -> None: ...


class DeviceConfiguration(yasimavr.lib._sip.wrapper):

    core = ... # type: CoreConfiguration
    name = ... # type: str
    pins = ... # type: Vector

    def __init__(self, a0: CoreConfiguration) -> None: ...


class breakpoint_t(yasimavr.lib._sip.wrapper):

    addr = ... # type: int
    instr = ... # type: yasimavr.lib._sip.Buffer
    instr_len = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'breakpoint_t') -> None: ...


class Core(yasimavr.lib._sip.wrapper):

    class NVM(enum.IntEnum):
        Flash = ... # type: Core.NVM
        Fuses = ... # type: Core.NVM
        CommonCount = ... # type: Core.NVM
        ArchDefined = ... # type: Core.NVM
        GetCount = ... # type: Core.NVM

    @typing.overload
    def __init__(self, a0: CoreConfiguration) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Core') -> None: ...

    def use_extended_addressing(self) -> bool: ...
    def cpu_read_flash(self, pgm_addr: int) -> int: ...
    def cpu_write_data(self, a0: int, a1: int) -> None: ...
    def cpu_read_data(self, a0: int) -> int: ...
    def cpu_write_gpreg(self, a0: int, a1: int) -> None: ...
    def cpu_read_gpreg(self, a0: int) -> int: ...
    def cpu_write_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    def cpu_read_ioreg(self, a0: 'reg_addr_t') -> int: ...
    def set_direct_LPM_enabled(self, enabled: bool) -> None: ...
    def set_console_register(self, addr: 'reg_addr_t') -> None: ...
    def start_interrupt_inhibit(self, a0: int) -> None: ...
    def ioctl_write_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    def ioctl_read_ioreg(self, a0: 'reg_addr_t') -> int: ...
    def get_ioreg(self, a0: 'reg_addr_t') -> typing.Optional['IO_Register']: ...
    def exec_cycle(self) -> int: ...
    def reset(self) -> None: ...
    def init(self, a0: 'Device') -> bool: ...


class CycleTimer(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CycleTimer') -> None: ...

    def next(self, when: int) -> int: ...
    def remaining_delay(self) -> int: ...
    def paused(self) -> bool: ...
    def scheduled(self) -> bool: ...


class CallableCycleTimer(CycleTimer):

    @typing.overload
    def __init__(self, a0: typing.Callable[..., None]) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CallableCycleTimer') -> None: ...

    def next(self, when: int) -> int: ...


class CycleManager(yasimavr.lib._sip.wrapper):

    def __init__(self) -> None: ...

    def next_when(self) -> int: ...
    def process_timers(self) -> None: ...
    def resume(self, a0: CycleTimer) -> None: ...
    def pause(self, a0: CycleTimer) -> None: ...
    def cancel(self, a0: CycleTimer) -> None: ...
    def delay(self, a0: CycleTimer, a1: int) -> None: ...
    def schedule(self, a0: CycleTimer, a1: int) -> None: ...
    def increment_cycle(self, a0: int) -> None: ...
    def cycle(self) -> int: ...


class DeviceDebugProbe(yasimavr.lib._sip.wrapper):

    class WatchpointFlags(enum.IntFlag):
        Write = ... # type: DeviceDebugProbe.WatchpointFlags
        Read = ... # type: DeviceDebugProbe.WatchpointFlags
        Signal = ... # type: DeviceDebugProbe.WatchpointFlags
        Break = ... # type: DeviceDebugProbe.WatchpointFlags

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Device') -> None: ...
    @typing.overload
    def __init__(self, a0: 'DeviceDebugProbe') -> None: ...

    def watchpoint_signal(self) -> 'Signal': ...
    def remove_watchpoint(self, a0: int, a1: int) -> None: ...
    def insert_watchpoint(self, a0: int, a1: int, a2: int) -> None: ...
    def remove_breakpoint(self, a0: int) -> None: ...
    def insert_breakpoint(self, a0: int) -> None: ...
    def read_data(self, a0: int, a1: int) -> yasimavr.lib._sip.Buffer: ...
    def write_data(self, a0: int, a1: yasimavr.lib._sip.Buffer) -> None: ...
    def read_flash(self, a0: int, a1: int) -> yasimavr.lib._sip.Buffer: ...
    def write_flash(self, a0: int, a1: yasimavr.lib._sip.Buffer) -> None: ...
    def has_ioreg(self, a0: 'reg_addr_t') -> bool: ...
    def read_ioreg(self, a0: 'reg_addr_t', a1: bool = ...) -> int: ...
    def write_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    def read_pc(self) -> int: ...
    def write_pc(self, a0: int) -> None: ...
    def read_sp(self) -> int: ...
    def write_sp(self, a0: int) -> None: ...
    def read_sreg(self) -> int: ...
    def write_sreg(self, a0: int) -> None: ...
    def read_gpreg(self, a0: int) -> int: ...
    def write_gpreg(self, a0: int, a1: int) -> None: ...
    def set_device_state(self, a0: 'Device.State') -> None: ...
    def reset_device(self) -> None: ...
    def attached(self) -> bool: ...
    def detach(self) -> None: ...
    @typing.overload
    def attach(self, a0: 'Device') -> None: ...
    @typing.overload
    def attach(self, a0: 'DeviceDebugProbe') -> None: ...
    def device(self) -> typing.Optional['Device']: ...


class Device(yasimavr.lib._sip.wrapper):

    class Option(enum.IntFlag):
        ResetOnPinShorting = ... # type: Device.Option
        IgnoreBadCpuIO = ... # type: Device.Option
        IgnoreBadCpuLPM = ... # type: Device.Option
        DisablePseudoSleep = ... # type: Device.Option
        InfiniteLoopDetect = ... # type: Device.Option

    class ResetFlag(enum.IntFlag):
        PowerOn = ... # type: Device.ResetFlag
        WDT = ... # type: Device.ResetFlag
        BOD = ... # type: Device.ResetFlag
        SW = ... # type: Device.ResetFlag
        Ext = ... # type: Device.ResetFlag
        Halt = ... # type: Device.ResetFlag

    class State(enum.Enum):
        Limbo = ... # type: Device.State
        Ready = ... # type: Device.State
        Running = ... # type: Device.State
        Sleeping = ... # type: Device.State
        Halted = ... # type: Device.State
        Reset = ... # type: Device.State
        Break = ... # type: Device.State
        Done = ... # type: Device.State
        Crashed = ... # type: Device.State
        Destroying = ... # type: Device.State

    def __init__(self, a0: Core, a1: DeviceConfiguration) -> None: ...

    def crash(self, a0: int, a1: typing.Optional[str]) -> None: ...
    def logger(self) -> 'Logger': ...
    def log_handler(self) -> 'LogHandler': ...
    @typing.overload
    def find_pin(self, a0: typing.Optional[str]) -> typing.Optional['Pin']: ...
    @typing.overload
    def find_pin(self, a0: int) -> typing.Optional['Pin']: ...
    def cycle_manager(self) -> typing.Optional[CycleManager]: ...
    def ctlreq(self, a0: int, a1: int, a2: typing.Optional['ctlreq_data_t'] = ...) -> typing.Tuple[bool, 'ctlreq_data_t']: ...
    @typing.overload
    def find_peripheral(self, a0: typing.Optional[str]) -> typing.Optional['Peripheral']: ...
    @typing.overload
    def find_peripheral(self, a0: int) -> typing.Optional['Peripheral']: ...
    @typing.overload
    def add_ioreg_handler(self, a0: 'reg_addr_t', a1: 'IO_RegHandler', a2: int = ...) -> None: ...
    @typing.overload
    def add_ioreg_handler(self, a0: 'regbit_t', a1: 'IO_RegHandler', a2: bool = ...) -> None: ...
    def attach_peripheral(self, a0: 'Peripheral') -> None: ...
    def exec_cycle(self) -> int: ...
    def reset(self, a0: int = ...) -> None: ...
    def load_firmware(self, a0: 'Firmware') -> None: ...
    def init(self, a0: CycleManager) -> None: ...
    def frequency(self) -> int: ...
    def sleep_mode(self) -> SleepMode: ...
    def cycle(self) -> int: ...
    def state(self) -> 'Device.State': ...
    def config(self) -> DeviceConfiguration: ...
    def test_option(self, a0: 'Device.Option') -> bool: ...
    def set_option(self, a0: 'Device.Option', a1: bool) -> None: ...
    def core(self) -> Core: ...


class Firmware(yasimavr.lib._sip.wrapper):

    class Area(enum.Enum):
        Flash = ... # type: Firmware.Area
        Data = ... # type: Firmware.Area
        EEPROM = ... # type: Firmware.Area
        Fuses = ... # type: Firmware.Area
        Lock = ... # type: Firmware.Area
        Signature = ... # type: Firmware.Area
        UserSignatures = ... # type: Firmware.Area

    class Block(yasimavr.lib._sip.wrapper):

        base = ... # type: int
        buf = ... # type: bytes

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Firmware.Block') -> None: ...

    class Symbol(yasimavr.lib._sip.wrapper):

        addr = ... # type: int
        area = ... # type: 'Firmware.Area'
        name = ... # type: str
        size = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Firmware.Symbol') -> None: ...

    aref = ... # type: float
    console_register = ... # type: 'reg_addr_t'
    frequency = ... # type: int
    vcc = ... # type: float

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Firmware') -> None: ...

    def symbols(self) -> typing.List['Firmware.Symbol']: ...
    def add_symbol(self, a0: 'Firmware.Symbol') -> None: ...
    def bsssize(self) -> int: ...
    def datasize(self) -> int: ...
    def load_memory(self, a0: 'Firmware.Area', a1: 'NonVolatileMemory') -> bool: ...
    def blocks(self, a0: 'Firmware.Area') -> typing.List['Firmware.Block']: ...
    def memories(self) -> typing.List['Firmware.Area']: ...
    def memory_size(self, a0: 'Firmware.Area') -> int: ...
    def has_memory(self, a0: 'Firmware.Area') -> bool: ...
    def add_block(self, a0: 'Firmware.Area', a1: yasimavr.lib._sip.Buffer, a2: int = ...) -> None: ...
    @staticmethod
    def read_elf(a0: str) -> typing.Optional['Firmware']: ...


class LogWriter(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'LogWriter') -> None: ...

    @staticmethod
    def default_writer() -> typing.Optional['LogWriter']: ...
    def write(self, a0: int, a1: int, a2: int, a3: typing.Optional[str], a4: 'va_list') -> None: ...


class LogHandler(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'LogHandler') -> None: ...

    def writer(self) -> LogWriter: ...
    def set_writer(self, a0: LogWriter) -> None: ...
    def init(self, a0: CycleManager) -> None: ...


class Logger(yasimavr.lib._sip.wrapper):

    class Level(enum.IntEnum):
        Silent = ... # type: Logger.Level
        Output = ... # type: Logger.Level
        Error = ... # type: Logger.Level
        Warning = ... # type: Logger.Level
        Debug = ... # type: Logger.Level
        Trace = ... # type: Logger.Level

    @typing.overload
    def __init__(self, a0: int, a1: LogHandler) -> None: ...
    @typing.overload
    def __init__(self, a0: int, a1: typing.Optional['Logger'] = ...) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Logger') -> None: ...

    def write(self, a0: int, a1: int, a2: typing.Optional[str], a3: 'va_list') -> None: ...
    def filtered_write(self, a0: int, a1: typing.Optional[str], a2: 'va_list') -> None: ...
    def id(self) -> int: ...
    def dbg(self, a0: typing.Optional[str], *args: typing.Any) -> None: ...
    def wng(self, a0: typing.Optional[str], *args: typing.Any) -> None: ...
    def err(self, a0: typing.Optional[str], *args: typing.Any) -> None: ...
    def log(self, a0: int, a1: typing.Optional[str], *args: typing.Any) -> None: ...
    def parent(self) -> typing.Optional['Logger']: ...
    def set_parent(self, a0: typing.Optional['Logger']) -> None: ...
    def level(self) -> int: ...
    def set_level(self, a0: int) -> None: ...


class va_list(yasimavr.lib._sip.wrapper): ...


class IO_RegHandler(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'IO_RegHandler') -> None: ...

    def ioreg_write_handler(self, a0: 'reg_addr_t', a1: 'ioreg_write_t') -> None: ...
    def ioreg_read_handler(self, a0: 'reg_addr_t', a1: int) -> int: ...


class Peripheral(IO_RegHandler):

    def __init__(self, a0: int) -> None: ...

    @typing.overload
    def get_signal(self, a0: int) -> typing.Optional['Signal']: ...
    @typing.overload
    def get_signal(self, a0: typing.Optional[str]) -> typing.Optional['Signal']: ...
    def register_interrupt(self, a0: int, a1: 'InterruptHandler') -> bool: ...
    @typing.overload
    def clear_ioreg(self, a0: 'regbit_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'regbit_compound_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'reg_addr_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> None: ...
    @typing.overload
    def clear_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'regbit_t') -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'regbit_compound_t') -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> None: ...
    @typing.overload
    def set_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    @typing.overload
    def test_ioreg(self, a0: 'reg_addr_t', a1: int) -> bool: ...
    @typing.overload
    def test_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> bool: ...
    @typing.overload
    def test_ioreg(self, a0: 'regbit_t', a1: int = ...) -> bool: ...
    @typing.overload
    def write_ioreg(self, a0: 'regbit_t', a1: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'regbit_compound_t', a1: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'reg_addr_t', a1: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'reg_addr_t', a1: int, a2: int) -> None: ...
    @typing.overload
    def write_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t', a2: int) -> None: ...
    @typing.overload
    def read_ioreg(self, a0: 'reg_addr_t') -> int: ...
    @typing.overload
    def read_ioreg(self, a0: 'regbit_t') -> int: ...
    @typing.overload
    def read_ioreg(self, a0: 'regbit_compound_t') -> int: ...
    @typing.overload
    def read_ioreg(self, a0: 'reg_addr_t', a1: 'bitmask_t') -> int: ...
    @typing.overload
    def add_ioreg(self, a0: 'regbit_t', a1: bool = ...) -> None: ...
    @typing.overload
    def add_ioreg(self, a0: 'regbit_compound_t', a1: bool = ...) -> None: ...
    @typing.overload
    def add_ioreg(self, a0: 'reg_addr_t', a1: int = ..., a2: bool = ...) -> None: ...
    def logger(self) -> Logger: ...
    def device(self) -> typing.Optional[Device]: ...
    def sleep(self, on: bool, mode: SleepMode) -> None: ...
    def ioreg_write_handler(self, a0: 'reg_addr_t', a1: 'ioreg_write_t') -> None: ...
    def ioreg_read_handler(self, a0: 'reg_addr_t', a1: int) -> int: ...
    def ctlreq(self, a0: int, a1: typing.Optional['ctlreq_data_t']) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: Device) -> bool: ...
    def name(self) -> str: ...
    def id(self) -> int: ...


class InterruptController(Peripheral):

    class State(enum.IntEnum):
        Raised = ... # type: InterruptController.State
        Cancelled = ... # type: InterruptController.State
        Acknowledged = ... # type: InterruptController.State
        Returned = ... # type: InterruptController.State
        RaisedFromSleep = ... # type: InterruptController.State
        Reset = ... # type: InterruptController.State

    class SignalId(enum.IntEnum):
        StateChange = ... # type: InterruptController.SignalId

    class IRQ_t(yasimavr.lib._sip.wrapper):

        address = ... # type: int
        nmi = ... # type: bool
        vector = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'InterruptController.IRQ_t') -> None: ...

    NO_INTERRUPT = ... # type: 'InterruptController.IRQ_t'

    @typing.overload
    def __init__(self, a0: int) -> None: ...
    @typing.overload
    def __init__(self, a0: 'InterruptController') -> None: ...

    def sleep(self, a0: bool, a1: SleepMode) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional['ctlreq_data_t']) -> bool: ...
    def reset(self) -> None: ...


class InterruptHandler(yasimavr.lib._sip.wrapper):

    def __init__(self) -> None: ...

    def interrupt_ack_handler(self, a0: int) -> None: ...
    def interrupt_raised(self, a0: int) -> bool: ...
    def cancel_interrupt(self, a0: int) -> None: ...
    def raise_interrupt(self, a0: int) -> None: ...


class InterruptFlag(InterruptHandler):

    def __init__(self, a0: bool = ...) -> None: ...

    def interrupt_ack_handler(self, a0: int) -> None: ...
    def raised(self) -> bool: ...
    def clear_flag(self, a0: int = ...) -> bool: ...
    def set_flag(self, a0: int = ...) -> bool: ...
    def set_clear_on_ack(self, a0: bool) -> None: ...
    def update_from_ioreg(self) -> int: ...
    def init(self, a0: Device, a1: 'regbit_t', a2: 'regbit_t', a3: int) -> bool: ...


class NonVolatileMemory(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self, a0: int) -> None: ...
    @typing.overload
    def __init__(self, a0: 'NonVolatileMemory') -> None: ...

    @typing.overload
    def spm_write(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def spm_write(self, a0: yasimavr.lib._sip.Buffer, a1: yasimavr.lib._sip.Buffer, a2: int) -> None: ...
    @typing.overload
    def write(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def write(self, a0: yasimavr.lib._sip.Buffer, a1: int) -> None: ...
    @typing.overload
    def read(self, a0: int) -> int: ...
    @typing.overload
    def read(self, a0: int, a1: int) -> bytes: ...
    @typing.overload
    def erase(self) -> None: ...
    @typing.overload
    def erase(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def erase(self, a0: yasimavr.lib._sip.Buffer, a1: int) -> None: ...
    def program(self, a0: yasimavr.lib._sip.Buffer, a1: int = ...) -> bool: ...
    @typing.overload
    def block(self) -> bytes: ...
    @typing.overload
    def block(self, a0: int, a1: int) -> bytes: ...
    def __getitem__(self, a0: int) -> int: ...
    @typing.overload
    def programmed(self, a0: int) -> bool: ...
    @typing.overload
    def programmed(self, a0: int, a1: int) -> bytes: ...
    def size(self) -> int: ...


class MemorySectionManager(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        Leave = ... # type: MemorySectionManager.SignalId
        Enter = ... # type: MemorySectionManager.SignalId

    class AccessFlag(enum.IntFlag):
        Read = ... # type: MemorySectionManager.AccessFlag
        Write = ... # type: MemorySectionManager.AccessFlag

    def __init__(self, a0: int, a1: int, a2: int) -> None: ...

    def signal(self) -> 'Signal': ...
    def fetch_address(self, a0: int) -> bool: ...
    def set_fetch_allowed(self, a0: int, a1: bool) -> None: ...
    def address_access_flags(self, a0: int) -> int: ...
    def can_write(self, a0: int) -> bool: ...
    def can_read(self, a0: int) -> bool: ...
    @typing.overload
    def access_flags(self, a0: int, a1: int) -> int: ...
    @typing.overload
    def access_flags(self, a0: int) -> int: ...
    @typing.overload
    def set_access_flags(self, a0: int, a1: int, a2: int) -> None: ...
    @typing.overload
    def set_access_flags(self, a0: int, a1: int) -> None: ...
    def address_to_section(self, a0: int) -> int: ...
    def page_to_section(self, a0: int) -> int: ...
    def section_size(self, a0: int) -> int: ...
    def section_end(self, a0: int) -> int: ...
    def section_start(self, a0: int) -> int: ...
    def set_section_limits(self, a0: Vector) -> None: ...
    def current_section(self) -> int: ...
    def section_count(self) -> int: ...
    def page_size(self) -> int: ...
    def page_count(self) -> int: ...


class NVM_request_t(yasimavr.lib._sip.wrapper):

    addr = ... # type: int
    cycles = ... # type: int
    data = ... # type: int
    kind = ... # type: int
    nvm = ... # type: int
    result = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'NVM_request_t') -> None: ...


class ctlreq_data_t(yasimavr.lib._sip.wrapper):

    data = ... # type: 'vardata_t'
    index = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ctlreq_data_t') -> None: ...


class base_reg_config_t(yasimavr.lib._sip.wrapper):

    reg_value = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'base_reg_config_t') -> None: ...


class DummyController(Peripheral):

    class dummy_register_t(yasimavr.lib._sip.wrapper):

        reg = ... # type: 'regbit_t'
        reset = ... # type: int

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'DummyController.dummy_register_t') -> None: ...

    def __init__(self, a0: int, a1: Vector) -> None: ...

    def reset(self) -> None: ...
    def init(self, a0: Device) -> bool: ...


class ioreg_write_t(yasimavr.lib._sip.wrapper):

    old = ... # type: int
    value = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ioreg_write_t') -> None: ...

    def anyedge(self) -> int: ...
    def negedge(self) -> int: ...
    def posedge(self) -> int: ...


class IO_Register(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self, a0: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, a0: 'IO_Register') -> None: ...

    def ioctl_write(self, a0: 'reg_addr_t', a1: int) -> None: ...
    def ioctl_read(self, a0: 'reg_addr_t') -> int: ...
    def cpu_write(self, a0: 'reg_addr_t', a1: int) -> bool: ...
    def cpu_read(self, a0: 'reg_addr_t') -> int: ...
    def set_handler(self, a0: IO_RegHandler, a1: int, a2: int) -> None: ...
    def set(self, a0: int) -> None: ...
    def value(self) -> int: ...


class SignalHook(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'SignalHook') -> None: ...

    def raised(self, a0: 'signal_data_t', a1: int) -> None: ...


class Pin(SignalHook):

    class SignalId(enum.IntEnum):
        StateChange = ... # type: Pin.SignalId
        DigitalChange = ... # type: Pin.SignalId
        VoltageChange = ... # type: Pin.SignalId

    class State(enum.IntEnum):
        Floating = ... # type: Pin.State
        PullUp = ... # type: Pin.State
        PullDown = ... # type: Pin.State
        Analog = ... # type: Pin.State
        High = ... # type: Pin.State
        Low = ... # type: Pin.State
        Shorted = ... # type: Pin.State

    class state_t(yasimavr.lib._sip.wrapper):

        level = ... # type: float
        state = ... # type: 'Pin.State'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'Pin.state_t') -> None: ...

    def __init__(self, a0: int) -> None: ...

    def raised(self, a0: 'signal_data_t', a1: int) -> None: ...
    def signal(self) -> 'DataSignal': ...
    def voltage(self) -> float: ...
    def digital_state(self) -> bool: ...
    def state(self) -> 'Pin.State': ...
    def id(self) -> int: ...
    def set_gpio_state(self, a0: 'Pin.State') -> None: ...
    def set_external_state(self, a0: 'Pin.State', a1: float = ...) -> None: ...
    @staticmethod
    def StateName(a0: 'Pin.State') -> typing.Optional[str]: ...


class signal_data_t(yasimavr.lib._sip.wrapper):

    data = ... # type: 'vardata_t'
    index = ... # type: int
    sigid = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'signal_data_t') -> None: ...


class Signal(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'Signal') -> None: ...

    @typing.overload
    def raise_(self, a0: signal_data_t) -> None: ...
    @typing.overload
    def raise_(self, a0: int = ..., a1: typing.Any = ..., a2: int = ...) -> None: ...
    def disconnect(self, a0: SignalHook) -> None: ...
    def connect(self, a0: SignalHook, a1: int = ...) -> None: ...


class DataSignal(Signal):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'DataSignal') -> None: ...

    @typing.overload
    def raise_(self, a0: signal_data_t) -> None: ...
    @typing.overload
    def raise_(self, a0: int = ..., a1: typing.Any = ..., a2: int = ...) -> None: ...
    def clear(self) -> None: ...
    def set_data(self, a0: int, a1: typing.Any = ..., a2: int = ...) -> None: ...
    def has_data(self, a0: int, a1: int = ...) -> bool: ...
    def data(self, a0: int, a1: int = ...) -> 'vardata_t': ...


class CallableSignalHook(SignalHook):

    @typing.overload
    def __init__(self, a0: typing.Callable[..., None]) -> None: ...
    @typing.overload
    def __init__(self, a0: 'CallableSignalHook') -> None: ...

    def raised(self, a0: signal_data_t, a1: int) -> None: ...


class DataSignalMux(SignalHook):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'DataSignalMux') -> None: ...

    def connected(self) -> bool: ...
    def selected_index(self) -> int: ...
    def set_selection(self, a0: int) -> None: ...
    def signal(self) -> DataSignal: ...
    @typing.overload
    def add_mux(self) -> int: ...
    @typing.overload
    def add_mux(self, a0: DataSignal) -> int: ...
    @typing.overload
    def add_mux(self, a0: DataSignal, a1: int) -> int: ...
    @typing.overload
    def add_mux(self, a0: DataSignal, a1: int, a2: int) -> int: ...
    def raised(self, a0: signal_data_t, a1: int) -> None: ...


class SleepConfig(yasimavr.lib._sip.wrapper):

    class mode_config_t(base_reg_config_t):

        int_mask = ... # type: yasimavr.lib._sip.Buffer
        mode = ... # type: SleepMode

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'SleepConfig.mode_config_t') -> None: ...

    modes = ... # type: Vector
    rb_enable = ... # type: 'regbit_t'
    rb_mode = ... # type: 'regbit_t'

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'SleepConfig') -> None: ...


class SleepController(Peripheral, SignalHook):

    def __init__(self, a0: SleepConfig) -> None: ...

    def raised(self, a0: signal_data_t, a1: int) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def init(self, a0: Device) -> bool: ...


class reg_addr_t(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self, a0: int = ...) -> None: ...
    @typing.overload
    def __init__(self, a0: 'reg_addr_t') -> None: ...

    def __ge__(self, a0: 'reg_addr_t') -> bool: ...
    def __gt__(self, a0: 'reg_addr_t') -> bool: ...
    def __le__(self, a0: 'reg_addr_t') -> bool: ...
    def __lt__(self, a0: 'reg_addr_t') -> bool: ...
    def __ne__(self, other: object): ...
    def __eq__(self, other: object): ...
    def __repr__(self) -> typing.Optional[str]: ...
    def __int__(self) -> int: ...
    def __index__(self) -> int: ...
    def valid(self) -> bool: ...


class bitmask_t(yasimavr.lib._sip.wrapper):

    bit = ... # type: int
    mask = ... # type: int

    @typing.overload
    def __init__(self, a0: int, a1: int) -> None: ...
    @typing.overload
    def __init__(self, a0: int) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'bitmask_t') -> None: ...
    @typing.overload
    def __init__(self, a0: 'regbit_t') -> None: ...

    def __repr__(self) -> typing.Optional[str]: ...
    def bitcount(self) -> int: ...
    def extract(self, a0: int) -> int: ...


class regbit_t(yasimavr.lib._sip.wrapper):

    addr = ... # type: reg_addr_t
    bit = ... # type: int
    mask = ... # type: int

    @typing.overload
    def __init__(self, a0: reg_addr_t, a1: int, a2: int) -> None: ...
    @typing.overload
    def __init__(self, a0: reg_addr_t, a1: int) -> None: ...
    @typing.overload
    def __init__(self, a0: reg_addr_t, a1: bitmask_t) -> None: ...
    @typing.overload
    def __init__(self, a0: reg_addr_t) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'regbit_t') -> None: ...

    def __repr__(self) -> typing.Optional[str]: ...
    def bitcount(self) -> int: ...
    def replace(self, a0: int, a1: int) -> int: ...
    def clear_from(self, a0: int, a1: int = ...) -> int: ...
    def set_to(self, a0: int, a1: int = ...) -> int: ...
    def extract(self, a0: int) -> int: ...
    def valid(self) -> bool: ...


class regbit_compound_t(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: regbit_t) -> None: ...
    @typing.overload
    def __init__(self, a0: Vector) -> None: ...
    @typing.overload
    def __init__(self, a0: 'regbit_compound_t') -> None: ...

    def bitcount(self) -> int: ...
    def extract(self, a0: int, a1: int) -> int: ...
    def compound(self, a0: int, a1: int) -> int: ...
    def addr_match(self, a0: reg_addr_t) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, a0: int) -> regbit_t: ...
    def add(self, a0: regbit_t) -> None: ...


class vardata_t(yasimavr.lib._sip.wrapper):

    class Type(enum.Enum):
        Invalid = ... # type: vardata_t.Type
        Pointer = ... # type: vardata_t.Type
        Double = ... # type: vardata_t.Type
        Uinteger = ... # type: vardata_t.Type
        Integer = ... # type: vardata_t.Type
        String = ... # type: vardata_t.Type
        Bytes = ... # type: vardata_t.Type

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'vardata_t') -> None: ...
    @typing.overload
    def __init__(self, a0: typing.Any) -> None: ...

    def __ne__(self, other: object): ...
    def __eq__(self, other: object): ...
    def value(self, a0: type = ...) -> typing.Any: ...
    def set(self, a0: typing.Any) -> None: ...
    def as_int(self) -> int: ...
    def as_uint(self) -> int: ...
    def as_double(self) -> float: ...
    def as_str(self) -> typing.Optional[str]: ...
    def as_ptr(self, a0: type = ...) -> typing.Any: ...
    def type(self) -> 'vardata_t.Type': ...


class ACP(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        Output = ... # type: ACP.SignalId
        DAC = ... # type: ACP.SignalId

    class Channel(enum.Enum):
        Pin = ... # type: ACP.Channel
        AcompRef = ... # type: ACP.Channel
        IntRef = ... # type: ACP.Channel

    class channel_config_t(base_reg_config_t):

        pin = ... # type: int
        type = ... # type: 'ACP.Channel'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ACP.channel_config_t') -> None: ...

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ACP') -> None: ...


class ADC(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        ConversionStarted = ... # type: ADC.SignalId
        AboutToSample = ... # type: ADC.SignalId
        ConversionComplete = ... # type: ADC.SignalId

    class Channel(enum.Enum):
        SingleEnded = ... # type: ADC.Channel
        Differential = ... # type: ADC.Channel
        Zero = ... # type: ADC.Channel
        IntRef = ... # type: ADC.Channel
        Temperature = ... # type: ADC.Channel
        AcompRef = ... # type: ADC.Channel

    class channel_config_t(base_reg_config_t):

        gain = ... # type: int
        per_num = ... # type: str
        pin_n = ... # type: int
        pin_p = ... # type: int
        type = ... # type: 'ADC.Channel'

        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, a0: 'ADC.channel_config_t') -> None: ...

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'ADC') -> None: ...


class Port(Peripheral, SignalHook):

    def __init__(self, name: str) -> None: ...

    def raised(self, a0: signal_data_t, a1: int) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...
    def init(self, a0: Device) -> bool: ...


class SPIClient(yasimavr.lib._sip.wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'SPIClient') -> None: ...

    def end_transfer(self, ok: bool) -> None: ...
    def start_transfer(self, mosi_frame: int) -> int: ...
    def selected(self) -> bool: ...


class SPI(SPIClient, CycleTimer):

    class SignalId(enum.IntEnum):
        HostTfrStart = ... # type: SPI.SignalId
        HostTfrComplete = ... # type: SPI.SignalId
        ClientTfrStart = ... # type: SPI.SignalId
        ClientTfrComplete = ... # type: SPI.SignalId

    def __init__(self) -> None: ...

    def end_transfer(self, a0: bool) -> None: ...
    def start_transfer(self, a0: int) -> int: ...
    def selected(self) -> bool: ...
    def next(self, a0: int) -> int: ...
    def pop_rx(self) -> int: ...
    def rx_available(self) -> int: ...
    def tfr_in_progress(self) -> bool: ...
    def set_rx_buffer_limit(self, a0: int) -> None: ...
    def cancel_tx(self) -> None: ...
    def push_tx(self, a0: int) -> None: ...
    def set_tx_buffer_limit(self, a0: int) -> None: ...
    def set_selected(self, a0: bool) -> None: ...
    def remove_client(self, a0: SPIClient) -> None: ...
    def add_client(self, a0: SPIClient) -> None: ...
    def set_frame_delay(self, a0: int) -> None: ...
    def signal(self) -> Signal: ...
    def is_host_mode(self) -> bool: ...
    def set_host_mode(self, a0: bool) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: CycleManager, a1: Logger) -> None: ...


class PrescaledTimer(CycleTimer):

    def __init__(self) -> None: ...

    @staticmethod
    def ticks_to_event(a0: int, a1: int, a2: int) -> int: ...
    def unregister_chained_timer(self, a0: 'PrescaledTimer') -> None: ...
    def register_chained_timer(self, a0: 'PrescaledTimer') -> None: ...
    def signal(self) -> Signal: ...
    def next(self, a0: int) -> int: ...
    def update(self) -> None: ...
    def timer_delay(self) -> int: ...
    def set_timer_delay(self, a0: int) -> None: ...
    def set_paused(self, a0: bool) -> None: ...
    def prescaler_factor(self) -> int: ...
    def set_prescaler(self, a0: int, a1: int) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: CycleManager, a1: Logger) -> None: ...


class TimerCounter(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        Event = ... # type: TimerCounter.SignalId
        CompMatch = ... # type: TimerCounter.SignalId

    class EventType(enum.IntFlag):
        Max = ... # type: TimerCounter.EventType
        Top = ... # type: TimerCounter.EventType
        Bottom = ... # type: TimerCounter.EventType
        Compare = ... # type: TimerCounter.EventType

    class SlopeMode(enum.Enum):
        Up = ... # type: TimerCounter.SlopeMode
        Down = ... # type: TimerCounter.SlopeMode
        Double = ... # type: TimerCounter.SlopeMode

    class TickSource(enum.Enum):
        Stopped = ... # type: TimerCounter.TickSource
        Timer = ... # type: TimerCounter.TickSource
        External = ... # type: TimerCounter.TickSource

    def __init__(self, a0: int, a1: int) -> None: ...

    def prescaler(self) -> PrescaledTimer: ...
    def ext_tick_hook(self) -> SignalHook: ...
    def signal(self) -> Signal: ...
    def set_countdown(self, a0: bool) -> None: ...
    def countdown(self) -> bool: ...
    def comp_enabled(self, a0: int) -> bool: ...
    def set_comp_enabled(self, a0: int, a1: bool) -> None: ...
    def comp_value(self, a0: int) -> int: ...
    def set_comp_value(self, a0: int, a1: int) -> None: ...
    def counter(self) -> int: ...
    def set_counter(self, a0: int) -> None: ...
    def slope_mode(self) -> 'TimerCounter.SlopeMode': ...
    def set_slope_mode(self, a0: 'TimerCounter.SlopeMode') -> None: ...
    def top(self) -> int: ...
    def set_top(self, a0: int) -> None: ...
    def tick(self) -> None: ...
    def tick_source(self) -> 'TimerCounter.TickSource': ...
    def set_tick_source(self, a0: 'TimerCounter.TickSource') -> None: ...
    def wrap(self) -> int: ...
    def update(self) -> None: ...
    def reschedule(self) -> None: ...
    def reset(self) -> None: ...
    def init(self, a0: CycleManager, a1: Logger) -> None: ...


class TWIPacket(yasimavr.lib._sip.wrapper):

    Nack = ... # type: int
    Ack = ... # type: int
    Write = ... # type: int
    Read = ... # type: int

    class Cmd(enum.IntEnum):
        Invalid = ... # type: TWIPacket.Cmd
        Address = ... # type: TWIPacket.Cmd
        AddrAck = ... # type: TWIPacket.Cmd
        DataRequest = ... # type: TWIPacket.Cmd
        Data = ... # type: TWIPacket.Cmd
        DataAck = ... # type: TWIPacket.Cmd

    ack = ... # type: int
    addr = ... # type: int
    cmd = ... # type: int
    data = ... # type: int
    hold = ... # type: int
    rw = ... # type: int

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'TWIPacket') -> None: ...


class TWIEndPoint(yasimavr.lib._sip.wrapper):

    def __init__(self) -> None: ...

    def bus_released(self) -> None: ...
    def bus_acquired(self) -> None: ...
    def packet_ended(self, a0: TWIPacket) -> None: ...
    def packet(self, a0: TWIPacket) -> None: ...
    def end_packet(self, a0: TWIPacket) -> None: ...
    def send_packet(self, a0: TWIPacket) -> None: ...
    def release_bus(self) -> None: ...
    def acquire_bus(self) -> bool: ...
    def bus(self) -> typing.Optional['TWIBus']: ...


class TWIBus(yasimavr.lib._sip.wrapper):

    class SignalId(enum.IntEnum):
        Start = ... # type: TWIBus.SignalId
        Address = ... # type: TWIBus.SignalId
        Data = ... # type: TWIBus.SignalId
        Packet_End = ... # type: TWIBus.SignalId
        Ack = ... # type: TWIBus.SignalId
        Stop = ... # type: TWIBus.SignalId

    def __init__(self) -> None: ...

    def remove_endpoint(self, a0: TWIEndPoint) -> None: ...
    def add_endpoint(self, a0: TWIEndPoint) -> None: ...
    def signal(self) -> Signal: ...


class TWI(TWIEndPoint):

    class State(enum.IntFlag):
        Flag_Active = ... # type: TWI.State
        Flag_Busy = ... # type: TWI.State
        Flag_Data = ... # type: TWI.State
        Flag_Tx = ... # type: TWI.State
        Disabled = ... # type: TWI.State
        Idle = ... # type: TWI.State
        Waiting = ... # type: TWI.State
        Addr = ... # type: TWI.State
        Addr_Busy = ... # type: TWI.State
        TX = ... # type: TWI.State
        TX_Req = ... # type: TWI.State
        TX_Busy = ... # type: TWI.State
        TX_Ack = ... # type: TWI.State
        RX = ... # type: TWI.State
        RX_Req = ... # type: TWI.State
        RX_Busy = ... # type: TWI.State
        RX_Ack = ... # type: TWI.State

    class BusState(enum.IntEnum):
        Bus_Idle = ... # type: TWI.BusState
        Bus_Busy = ... # type: TWI.BusState
        Bus_Owned = ... # type: TWI.BusState

    class Component(enum.IntEnum):
        Any = ... # type: TWI.Component
        Master = ... # type: TWI.Component
        Slave = ... # type: TWI.Component

    class SignalId(enum.IntEnum):
        StateChange = ... # type: TWI.SignalId
        BusStateChange = ... # type: TWI.SignalId
        Address = ... # type: TWI.SignalId
        AddrAck = ... # type: TWI.SignalId
        TxComplete = ... # type: TWI.SignalId
        RxComplete = ... # type: TWI.SignalId

    def __init__(self) -> None: ...

    def bus_released(self) -> None: ...
    def bus_acquired(self) -> None: ...
    def packet_ended(self, a0: TWIPacket) -> None: ...
    def packet(self, a0: TWIPacket) -> None: ...
    def slave_state(self) -> 'TWI.State': ...
    def master_state(self) -> 'TWI.State': ...
    def set_slave_ack(self, a0: bool) -> None: ...
    def start_slave_rx(self) -> bool: ...
    def start_slave_tx(self, a0: int) -> bool: ...
    def set_slave_enabled(self, a0: bool) -> None: ...
    def set_master_ack(self, a0: bool) -> None: ...
    def start_master_rx(self) -> bool: ...
    def start_master_tx(self, a0: int) -> bool: ...
    def send_address(self, a0: int, a1: bool) -> bool: ...
    def end_transfer(self) -> None: ...
    def start_transfer(self) -> bool: ...
    def set_bit_delay(self, a0: int) -> None: ...
    def set_master_enabled(self, a0: bool) -> None: ...
    def signal(self) -> Signal: ...
    def reset(self) -> None: ...
    def init(self, a0: CycleManager, a1: Logger) -> None: ...


class UARTEndPoint(yasimavr.lib._sip.wrapper):

    rx_hook = ... # type: SignalHook
    tx_signal = ... # type: Signal

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'UARTEndPoint') -> None: ...


class UART(SignalHook):

    class SignalId(enum.IntEnum):
        DataFrame = ... # type: UART.SignalId
        DataString = ... # type: UART.SignalId
        DataBytes = ... # type: UART.SignalId
        TX_Start = ... # type: UART.SignalId
        TX_Complete = ... # type: UART.SignalId
        RX_Start = ... # type: UART.SignalId
        RX_Complete = ... # type: UART.SignalId

    def __init__(self) -> None: ...

    def raised(self, a0: signal_data_t, a1: int) -> None: ...
    def set_paused(self, a0: bool) -> None: ...
    def clear_rx_overflow(self) -> None: ...
    def has_rx_overflow(self) -> bool: ...
    def pop_rx(self) -> int: ...
    def rx_available(self) -> int: ...
    def set_rx_enabled(self, a0: bool) -> None: ...
    def set_rx_buffer_limit(self, a0: int) -> None: ...
    def clear_tx_collision(self) -> None: ...
    def has_tx_collision(self) -> bool: ...
    def tx_pending(self) -> int: ...
    def cancel_tx_pending(self) -> None: ...
    def push_tx(self, a0: int) -> None: ...
    def set_tx_buffer_limit(self, a0: int) -> None: ...
    def set_frame_delay(self, a0: int) -> None: ...
    def signal(self) -> Signal: ...
    def reset(self) -> None: ...
    def init(self, a0: CycleManager, a1: Logger) -> None: ...


class VREF(Peripheral):

    class SignalId(enum.IntEnum):
        ARefChange = ... # type: VREF.SignalId
        IntRefChange = ... # type: VREF.SignalId
        VCCChange = ... # type: VREF.SignalId

    class Source(enum.IntEnum):
        VCC = ... # type: VREF.Source
        AVCC = ... # type: VREF.Source
        AREF = ... # type: VREF.Source
        Internal = ... # type: VREF.Source

    @typing.overload
    def __init__(self, ref_count: int) -> None: ...
    @typing.overload
    def __init__(self, a0: 'VREF') -> None: ...

    def reference(self, a0: int) -> float: ...
    def set_reference(self, a0: int, a1: 'VREF.Source', a2: float = ...) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def active(self) -> bool: ...


class WatchdogTimer(Peripheral):

    def __init__(self) -> None: ...

    def timeout(self) -> None: ...
    def set_timer(self, a0: int, a1: int, a2: int) -> None: ...
    def ctlreq(self, a0: int, a1: typing.Optional[ctlreq_data_t]) -> bool: ...
    def reset(self) -> None: ...


class AbstractSimLoop(yasimavr.lib._sip.wrapper):

    class State(enum.Enum):
        Running = ... # type: AbstractSimLoop.State
        Step = ... # type: AbstractSimLoop.State
        Standby = ... # type: AbstractSimLoop.State
        Stopped = ... # type: AbstractSimLoop.State
        Done = ... # type: AbstractSimLoop.State

    def __init__(self, a0: Device) -> None: ...

    def device(self) -> Device: ...
    def cycle_manager(self) -> CycleManager: ...
    def cycle(self) -> int: ...
    def state(self) -> 'AbstractSimLoop.State': ...


class SimLoop(AbstractSimLoop):

    def __init__(self, a0: Device) -> None: ...

    def run(self, a0: int = ...) -> None: ...
    def set_fast_mode(self, a0: bool) -> None: ...


class AsyncSimLoop(AbstractSimLoop):

    def __init__(self, a0: Device) -> None: ...

    def __exit__(self, a0: typing.Any, a1: typing.Any, a2: typing.Any) -> None: ...
    def __enter__(self) -> typing.Any: ...
    def loop_kill(self) -> None: ...
    def loop_pause(self) -> None: ...
    def loop_step(self) -> None: ...
    def loop_continue(self) -> None: ...
    def end_transaction(self) -> None: ...
    def start_transaction(self) -> bool: ...
    def run(self) -> None: ...
    def set_fast_mode(self, a0: bool) -> None: ...


CTLREQ_ADC_SET_TEMP = ... # type: int
CTLREQ_ADC_TRIGGER = ... # type: int
CTLREQ_BASE = ... # type: int
CTLREQ_CORE_BREAK = ... # type: int
CTLREQ_CORE_CRASH = ... # type: int
CTLREQ_CORE_HALT = ... # type: int
CTLREQ_CORE_NVM = ... # type: int
CTLREQ_CORE_RESET = ... # type: int
CTLREQ_CORE_RESET_FLAG = ... # type: int
CTLREQ_CORE_SECTIONS = ... # type: int
CTLREQ_CORE_SHORTING = ... # type: int
CTLREQ_CORE_SLEEP = ... # type: int
CTLREQ_CORE_WAKEUP = ... # type: int
CTLREQ_GET_SIGNAL = ... # type: int
CTLREQ_INTR_RAISE = ... # type: int
CTLREQ_INTR_REGISTER = ... # type: int
CTLREQ_NVM_REQUEST = ... # type: int
CTLREQ_SLEEP_CALL = ... # type: int
CTLREQ_SLEEP_PSEUDO = ... # type: int
CTLREQ_SPI_ADD_CLIENT = ... # type: int
CTLREQ_SPI_CLIENT = ... # type: int
CTLREQ_SPI_SELECT = ... # type: int
CTLREQ_TWI_ENDPOINT = ... # type: int
CTLREQ_UART_ENDPOINT = ... # type: int
CTLREQ_VREF_GET = ... # type: int
CTLREQ_VREF_SET = ... # type: int
CTLREQ_WATCHDOG_RESET = ... # type: int
INTERRUPT_NONE = ... # type: int
INVALID_CYCLE = ... # type: int
INVALID_REGISTER = ... # type: reg_addr_t
IOCTL_CLOCK = ... # type: int
IOCTL_CORE = ... # type: int
IOCTL_EEPROM = ... # type: int
IOCTL_EXTINT = ... # type: int
IOCTL_INTR = ... # type: int
IOCTL_NVM = ... # type: int
IOCTL_PORTMUX = ... # type: int
IOCTL_RST = ... # type: int
IOCTL_RTC = ... # type: int
IOCTL_SLEEP = ... # type: int
IOCTL_VREF = ... # type: int
IOCTL_WDT = ... # type: int
LIB_VERSION = ... # type: int
LIB_VERSION_STR = ... # type: str


def str_to_id(a0: typing.Optional[str]) -> int: ...
def id_to_str(a0: int) -> typing.Optional[str]: ...
def SleepModeName(a0: SleepMode) -> typing.Optional[str]: ...
def IOCTL_TWI(a0: str) -> int: ...
def IOCTL_SPI(a0: str) -> int: ...
def IOCTL_UART(a0: str) -> int: ...
def IOCTL_TIMER(a0: str, a1: str) -> int: ...
def IOCTL_ACP(a0: str) -> int: ...
def IOCTL_ADC(a0: str) -> int: ...
def IOCTL_PORT(a0: str) -> int: ...
def global_logger() -> Logger: ...
def data_space_map(addr: int, len: int, blockstart: int, blockend: int) -> typing.Tuple[bool, typing.Optional[int], typing.Optional[int], typing.Optional[int]]: ...
