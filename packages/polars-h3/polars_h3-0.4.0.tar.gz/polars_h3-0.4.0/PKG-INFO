Metadata-Version: 2.4
Name: polars-h3
Version: 0.4.0
Classifier: Programming Language :: Rust
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
Requires-Dist: polars
License-File: LICENSE
Summary: H3 bindings for Polars
Author-email: Sergey Filimonov <hello@sergey.fyi>, Lev Ostatnigrosh <levostatnigrosh@gmail.com>
License: MIT
Requires-Python: >=3.9
Description-Content-Type: text/markdown; charset=UTF-8; variant=GFM
Project-URL: homepage, https://github.com/Filimonov/polars-h3



<p align="center">
 <img src="https://sergey-filimonov.nyc3.cdn.digitaloceanspaces.com/polars-h3/polars-h3-logo.webp"  />
</p>


This is a [Polars](https://docs.pola.rs/) extension that adds support for the [H3 discrete global grid system](https://github.com/uber/h3/), so you can index points and geometries to hexagons directly in Polars. All credits goes to the [h3o](https://github.com/HydroniumLabs/h3o) for doing the heavy lifting.

# Highlights

- ğŸš€ **Blazing Fast:** Built entirely in Rust, offering lightning-fast, multi-core H3 operations within Polars. Ideal for high-performance data processing.

- ğŸŒ **H3 Feature Parity:** Comprehensive support for H3 functions, covering almost everything the standard H3 library provides, excluding geometric functions.

- ğŸ“‹ **Fully Tested:** Accurately tested against the standard H3 library.

# Get started

You can get started by installing it with pip (or [uv](https://github.com/astral-sh/uv)):
```bash
pip install polars-h3
```

You can use the extension as a drop-in replacement for the standard H3 functions.

```python
import polars_h3 as pl_h3
import polars as pl
 
>>> df = pl.DataFrame(
...     {
...         "lat": [37.7749],
...         "long": [-122.4194],
...     }
... ).with_columns(
...     pl_h3.latlng_to_cell(
...         "lat",
...         "long",
...         resolution=7,
...         return_dtype=pl.Utf8
...     ).alias("h3_cell"),
... )
>>> df
shape: (1, 3)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ lat     â”† long      â”† h3_cell         â”‚
â”‚ ---     â”† ---       â”† ---             â”‚
â”‚ f64     â”† f64       â”† str             â”‚
â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
â”‚ 37.7749 â”† -122.4194 â”† 872830828ffffff â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Check out the [quickstart notebook](notebooks/quickstart.ipynb) for more examples.

# Implemented functions

This extension implements most of the [H3 API](https://h3geo.org/docs/api/indexing). The full list of functions is below.

> âš ï¸ **Performance Note:** When possible, prefer using `pl.UInt64` for H3 indices instead of the `pl.Utf8` representation. String representations require casting operations which impact performance. Working directly with the native 64-bit integer format provides better computational efficiency.

We are unable to support the functions that work with geometries. 

### Full list of functions

âœ… = Supported
ğŸš§ = Pending
ğŸ›‘ = Not supported

| Function | Description | Supported|
| --: | --- | ---|
| `latlng_to_cell` | Convert latitude/longitude coordinate to cell ID | âœ…|
| `cell_to_lat` | Convert cell ID to latitude | âœ… |
| `cell_to_lng` | Convert cell ID to longitude | âœ… |
| `cell_to_latlng` | Convert cell ID to latitude/longitude | âœ… |
| `get_resolution` | Get resolution number of cell ID | âœ… |
| `str_to_int` | Convert VARCHAR cell ID to UBIGINT | âœ… |
| `int_to_str` | Convert BIGINT or UBIGINT cell ID to VARCHAR | âœ… |
| `is_valid_cell` | True if this is a valid cell ID | âœ… |
| `is_res_class_iii` | True if the cell's resolution is class III | âœ… |
| `is_pentagon` | True if the cell is a pentagon | âœ… |
| `get_icosahedron_faces` | List of icosahedron face IDs the cell is on | âœ… |
| `cell_to_parent` | Get coarser cell for a cell | âœ… |
| `cell_to_children` | Get finer cells for a cell | âœ… |
| `cell_to_center_child` | Provides the center child (finer) cell contained by cell at resolution childRes. | âœ… |
| `cell_to_child_pos` | Provides the position of the child cell within an ordered list of all children of the cell's parent at the specified resolution parentRes. | âœ… |
| `child_pos_to_cell` | Provides the child cell at a given position within an ordered list of all children of parent at the specified resolution childRes. | âœ… |
| `compact_cells` | Compacts a collection of H3 cells by recursively replacing children cells with their parents if all children are present. Input cells must all share the same resolution. | âœ… |
| `uncompact_cells` | Uncompacts the set compactedSet of indexes to the resolution res. h3Set must be at least of size uncompactCellsSize(compactedSet, numHexes, res). | âœ… |
| `grid_ring` | Produces the "hollow ring" of cells which are exactly grid distance k from the origin cell | âœ… |
| `grid_disk` | Produces the "filled-in disk" of cells which are at most grid distance k from the origin cell. Output order is not guaranteed. | âœ… |
| `grid_path_cells` | Find a grid path to connect two cells | âœ… |
| `grid_distance` | Find the grid distance between two cells | âœ… |
| `cell_to_local_ij` | Convert a cell ID to a local I,J coordinate space | âœ…|
| `local_ij_to_cell` | Convert a local I,J coordinate to a cell ID | âœ…|
| `cell_to_boundary` | Convert cell ID to cell boundary lat / longs | âœ… |
| `cell_to_vertex` | Get the vertex ID for a cell ID and vertex number |  âœ… |
| `cell_to_vertexes` | Get all vertex IDs for a cell ID | âœ…|
| `vertex_to_latlng` | Convert a vertex ID to latitude/longitude coordinate | âœ… |
| `is_valid_vertex` | True if passed a valid vertex ID | âœ…|
| `is_valid_directed_edge` | True if passed a valid directed edge ID | âœ… |
| `origin_to_directed_edges` | Get all directed edge IDs for a cell ID | âœ… |
| `directed_edge_to_cells` | Convert a directed edge ID to origin/destination cell IDs | âœ… |
| `get_directed_edge_origin` | Convert a directed edge ID to origin cell ID | âœ… |
| `get_directed_edge_destination` | Convert a directed edge ID to destination cell ID | âœ…|
| `cells_to_directed_edge` | Convert an origin/destination pair to directed edge ID | âœ… |
| `are_neighbor_cells` | True if the two cell IDs are directly adjacent | âœ… |
| `average_hexagon_area` | Get average area of a hexagon cell at resolution |  âœ… |
| `cell_area` | Get the area of a cell ID |  âœ…|
| `average_hexagon_edge_length` | Average hexagon edge length at resolution |  âœ…|
| `edge_length` | Get the length of a directed edge ID |  ğŸš§|
| `get_num_cells` | Get the number of cells at a resolution |  âœ…|
| `get_pentagons` | Get all pentagons at a resolution |  ğŸš§|
| `great_circle_distance` | Compute the great circle distance between two points (haversine) |  âœ…|
| `cells_to_multi_polygon_wkt` | Convert a set of cells to multipolygon WKT | ğŸ›‘ |
| `polygon_wkt_to_cells` | Convert polygon WKT to a set of cells | ğŸ›‘ |
| `directed_edge_to_boundary_wkt` | Convert directed edge ID to linestring WKT | ğŸ›‘ |


### Plotting

The library also comes with helper functions to plot hexes on a Folium map.


```python
import polars_h3 as pl_h3
import polars as pl

hex_map = pl_h3.graphing.plot_hex_outlines(df, "h3_cell")
display(hex_map)

# or if you have a metric to plot

hex_map = pl_h3.graphing.plot_hex_fills(df, "h3_cell", "metric_col")
display(hex_map)
```

