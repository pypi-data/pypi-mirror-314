diff --git a/django/db/backends/mysql/compiler.py b/django/db/backends/mysql/compiler.py
index 3682d6da05..771c5f54f1 100644
--- a/django/db/backends/mysql/compiler.py
+++ b/django/db/backends/mysql/compiler.py
@@ -15,13 +15,7 @@ class SQLInsertCompiler(compiler.SQLInsertCompiler, SQLCompiler):
 
 class SQLDeleteCompiler(compiler.SQLDeleteCompiler, SQLCompiler):
     def as_sql(self):
-        if self.connection.features.update_can_self_select or self.single_alias:
-            return super().as_sql()
-        # MySQL and MariaDB < 10.3.2 doesn't support deletion with a subquery
-        # which is what the default implementation of SQLDeleteCompiler uses
-        # when multiple tables are involved. Use the MySQL/MariaDB specific
-        # DELETE table FROM table syntax instead to avoid performing the
-        # operation in two queries.
+        # Always use MySQL-specific DELETE syntax to avoid subqueries
         result = [
             'DELETE %s FROM' % self.quote_name_unless_alias(
                 self.query.get_initial_alias()
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..b94cfc1838
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,35 @@
+import django
+django.setup()
+
+from django.db import models, connection
+from django.db.models import sql
+from django.test import TestCase
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'testapp'
+
+# Create the table
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Insert some test data
+TestModel.objects.create(name='test1')
+TestModel.objects.create(name='test2')
+
+# Print the SQL for delete
+print("SQL for delete:")
+compiler = TestModel.objects.all().query.get_compiler(connection=connection)
+if isinstance(compiler, sql.compiler.SQLDeleteCompiler):
+    print(str(compiler.as_sql()[0]))
+else:
+    # Convert to delete query
+    query = TestModel.objects.all().query
+    query.__class__ = sql.DeleteQuery
+    compiler = query.get_compiler(connection=connection)
+    print(str(compiler.as_sql()[0]))
+
+# Delete the data
+TestModel.objects.all().delete()
\ No newline at end of file
diff --git a/test_delete.py b/test_delete.py
new file mode 100644
index 0000000000..ffa0481e59
--- /dev/null
+++ b/test_delete.py
@@ -0,0 +1,58 @@
+import django
+django.setup()
+
+from django.db import models, connection
+from django.test import TestCase
+from django.db.models import sql
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'testapp'
+
+class DeleteTests(TestCase):
+    def setUp(self):
+        super().setUp()
+        # Drop and recreate the table
+        with connection.cursor() as cursor:
+            cursor.execute('DROP TABLE IF EXISTS testapp_testmodel')
+            cursor.execute('''
+                CREATE TABLE testapp_testmodel (
+                    id INTEGER PRIMARY KEY AUTO_INCREMENT,
+                    name VARCHAR(100) NOT NULL
+                )
+            ''')
+
+        # Insert some test data
+        TestModel.objects.create(name='test1')
+        TestModel.objects.create(name='test2')
+
+    def test_delete_sql(self):
+        # Get the SQL for delete
+        query = TestModel.objects.all().query
+        query.__class__ = sql.DeleteQuery
+        compiler = query.get_compiler(connection=connection)
+        sql_str = str(compiler.as_sql()[0])
+
+        # Verify it uses MySQL's DELETE FROM syntax
+        self.assertEqual(sql_str, 'DELETE `testapp_testmodel` FROM `testapp_testmodel`')
+
+    def test_lock_tables(self):
+        # Test that LOCK TABLES works with delete
+        with connection.cursor() as cursor:
+            # Lock the table
+            cursor.execute('LOCK TABLES `testapp_testmodel` WRITE')
+            try:
+                # Delete should work
+                TestModel.objects.all().delete()
+            finally:
+                # Unlock the table
+                cursor.execute('UNLOCK TABLES')
+
+        # Verify the delete worked
+        self.assertEqual(TestModel.objects.count(), 0)
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..f41de4d8a5
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,22 @@
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.mysql',
+        'NAME': 'test_db',
+        'USER': 'root',
+        'PASSWORD': '',
+        'HOST': 'localhost',
+        'PORT': '3306',
+        'TEST': {
+            'NAME': 'test_db',
+            'CHARSET': 'utf8',
+            'COLLATION': 'utf8_general_ci',
+            'MIGRATE': False,
+        }
+    }
+}
+
+INSTALLED_APPS = [
+    'testapp',
+]
+
+SECRET_KEY = 'dummy'
\ No newline at end of file
diff --git a/testapp/__init__.py b/testapp/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
