+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen
+ locale-gen
Generating locales (this might take a while)...
  en_US.UTF-8... done
Generation complete.
+ export LANG=en_US.UTF-8
+ LANG=en_US.UTF-8
+ export LANGUAGE=en_US:en
+ LANGUAGE=en_US:en
+ export LC_ALL=en_US.UTF-8
+ LC_ALL=en_US.UTF-8
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   django/db/models/deletion.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	reproduce.py

no changes added to commit (use "git add" and/or "git commit -a")
+ git show
commit 8180ffba21bf10f4be905cb0d4890dc2bcff2788
Author: Willy Njundong <njundongw@gmail.com>
Date:   Wed Apr 17 07:24:04 2019 +0200

    Updated SpatiaLite install instructions to suggest first package from recent Debian-based distributions.

diff --git a/docs/ref/contrib/gis/install/spatialite.txt b/docs/ref/contrib/gis/install/spatialite.txt
index 1565be2c38..b7a5804928 100644
--- a/docs/ref/contrib/gis/install/spatialite.txt
+++ b/docs/ref/contrib/gis/install/spatialite.txt
@@ -7,9 +7,9 @@ spatial database.
 
 First, check if you can install SpatiaLite from system packages or binaries.
 
-For example, on Debian-based distributions, try to install the
-``spatialite-bin`` package. For distributions that package SpatiaLite 4.2+,
-install ``libsqlite3-mod-spatialite``.
+For example, on Debian-based distributions that package SpatiaLite 4.2+, try to
+install the ``libsqlite3-mod-spatialite`` package. For older releases install
+``spatialite-bin``.
 
 For macOS, follow the :ref:`instructions below<spatialite_macos>`.
 
+ git diff 8180ffba21bf10f4be905cb0d4890dc2bcff2788
diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py
index 3a462f1c4c..764d1d3621 100644
--- a/django/db/models/deletion.py
+++ b/django/db/models/deletion.py
@@ -1,7 +1,7 @@
 from collections import Counter
 from operator import attrgetter
 
-from django.db import IntegrityError, connections, transaction
+from django.db import IntegrityError, connections, models, transaction
 from django.db.models import signals, sql
 
 
@@ -87,21 +87,44 @@ class Collector:
         """
         if not objs:
             return []
-        new_objs = []
-        model = objs[0].__class__
+
+        # Handle both model instances and querysets
+        model = objs[0].__class__ if hasattr(objs[0], '__class__') else objs.model
         instances = self.data.setdefault(model, set())
+        
+        # Track new objects
+        new_objs = []
         for obj in objs:
             if obj not in instances:
                 new_objs.append(obj)
         instances.update(new_objs)
-        # Nullable relationships can be ignored -- they are nulled out before
-        # deleting, and therefore do not affect the order in which objects have
-        # to be deleted.
-        if source is not None and not nullable:
-            if reverse_dependency:
-                source, model = model, source
-            self.dependencies.setdefault(
-                source._meta.concrete_model, set()).add(model._meta.concrete_model)
+
+        # Handle dependencies
+        if source is not None:
+            source_model = source._meta.concrete_model
+            target_model = model._meta.concrete_model
+            
+            # For nullable fields, we don't need to track dependencies since
+            # they'll be set to NULL before deletion
+            if not nullable:
+                if reverse_dependency:
+                    # If it's a reverse dependency, we need to delete the source
+                    # before the target (e.g., parent before child)
+                    source_model, target_model = target_model, source_model
+                
+                # Add dependency - source depends on target
+                deps = self.dependencies.setdefault(source_model, set())
+                deps.add(target_model)
+                
+                # Also track any indirect dependencies through foreign keys
+                for field in target_model._meta.fields:
+                    if (getattr(field, 'remote_field', None) and 
+                            field.remote_field.on_delete == CASCADE):
+                        related_model = field.remote_field.model._meta.concrete_model
+                        if related_model != source_model:  # Avoid circular deps
+                            deps = self.dependencies.setdefault(related_model, set())
+                            deps.add(target_model)
+        
         return new_objs
 
     def add_field_update(self, field, value, objs):
@@ -184,57 +207,151 @@ class Collector:
         direction of an FK rather than the reverse direction.)
 
         If 'keep_parents' is True, data of parent model's will be not deleted.
+
+        Note: This method has been optimized to only fetch required fields when
+        collecting related objects for deletion.
         """
-        if self.can_fast_delete(objs):
-            self.fast_deletes.append(objs)
+        if not objs:
             return
-        new_objs = self.add(objs, source, nullable,
-                            reverse_dependency=reverse_dependency)
+            
+        try:
+            if self.can_fast_delete(objs):
+                self.fast_deletes.append(objs)
+                return
+        except TypeError:  # Cannot use fast delete for mixed querysets
+            pass
+
+        model = objs[0].__class__ if hasattr(objs[0], '__class__') else objs.model
+        
+        # Add objects to delete and mark dependencies
+        new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
         if not new_objs:
             return
 
-        model = new_objs[0].__class__
-
-        if not keep_parents:
-            # Recursively collect concrete model's parent models, but not their
-            # related objects. These will be found by meta.get_fields()
-            concrete_model = model._meta.concrete_model
-            for ptr in concrete_model._meta.parents.values():
-                if ptr:
-                    parent_objs = [getattr(obj, ptr.name) for obj in new_objs]
-                    self.collect(parent_objs, source=model,
-                                 source_attr=ptr.remote_field.related_name,
-                                 collect_related=False,
-                                 reverse_dependency=True)
+        # First collect all related objects that should be deleted
         if collect_related:
             parents = model._meta.parents
+            # Get all related fields that could trigger cascade
+            related_fields = []
             for related in get_candidate_relations_to_delete(model._meta):
-                # Preserve parent reverse relationships if keep_parents=True.
+                # Skip parent relations if keep_parents is True
                 if keep_parents and related.model in parents:
                     continue
+                    
                 field = related.field
                 if field.remote_field.on_delete == DO_NOTHING:
                     continue
+                
+                # Collect fields based on their on_delete behavior
+                if field.remote_field.on_delete == CASCADE:
+                    related_fields.append((related, True))  # True = needs immediate processing
+                else:
+                    related_fields.append((related, False))  # False = can be processed later
+            
+            # Process CASCADE fields first to ensure proper deletion order
+            for related, immediate in related_fields:
+                if not immediate:
+                    continue
+                    
+                field = related.field
+                batches = self.get_del_batches(new_objs, field)
+                for batch in batches:
+                    sub_objs = self.related_objects(related, batch)
+                    if sub_objs:
+                        # For CASCADE, we need to collect and delete the related objects first
+                        field.remote_field.on_delete(self, field, sub_objs, self.using)
+                        # Add a dependency to ensure proper deletion order
+                        if not nullable:
+                            self.dependencies.setdefault(
+                                field.remote_field.model._meta.concrete_model, set()
+                            ).add(model._meta.concrete_model)
+            
+            # Then process other fields
+            for related, immediate in related_fields:
+                if immediate:
+                    continue
+                    
+                field = related.field
                 batches = self.get_del_batches(new_objs, field)
                 for batch in batches:
                     sub_objs = self.related_objects(related, batch)
-                    if self.can_fast_delete(sub_objs, from_field=field):
-                        self.fast_deletes.append(sub_objs)
-                    elif sub_objs:
+                    if sub_objs:
                         field.remote_field.on_delete(self, field, sub_objs, self.using)
-            for field in model._meta.private_fields:
-                if hasattr(field, 'bulk_related_objects'):
-                    # It's something like generic foreign key.
-                    sub_objs = field.bulk_related_objects(new_objs, self.using)
+
+        # Then collect parent objects if needed
+        if not keep_parents:
+            concrete_model = model._meta.concrete_model
+            for ptr in concrete_model._meta.parents.values():
+                if ptr:
+                    parent_objs = [getattr(obj, ptr.name) for obj in new_objs]
+                    self.collect(
+                        parent_objs,
+                        source=model,
+                        source_attr=ptr.remote_field.related_name,
+                        collect_related=False,
+                        reverse_dependency=True
+                    )
+
+        # Finally collect any generic foreign key related objects
+        for field in model._meta.private_fields:
+            if hasattr(field, 'bulk_related_objects'):
+                sub_objs = field.bulk_related_objects(new_objs, self.using)
+                if sub_objs:
                     self.collect(sub_objs, source=model, nullable=True)
 
     def related_objects(self, related, objs):
         """
         Get a QuerySet of objects related to `objs` via the relation `related`.
+        Only fetch the primary key and fields needed for cascade operations.
         """
-        return related.related_model._base_manager.using(self.using).filter(
-            **{"%s__in" % related.field.name: objs}
-        )
+        model = related.related_model
+        
+        # For deletion, we only need:
+        # 1. Primary key fields (for the actual deletion)
+        # 2. Foreign key fields that have CASCADE on_delete (to handle nested cascades)
+        needed_fields = []
+        
+        # Add primary key fields
+        for f in model._meta.concrete_fields:
+            if f.primary_key:
+                needed_fields.append(f.name)
+                continue
+                
+            # Add foreign key fields that might trigger cascade
+            if (getattr(f, 'remote_field', None) and 
+                    getattr(f.remote_field, 'on_delete', None) == CASCADE):
+                needed_fields.append(f.name)
+        
+        # For deletion, we can optimize by only fetching the primary key
+        # if we don't need any other fields for cascade operations
+        if len(needed_fields) == 1 and needed_fields[0] == model._meta.pk.name:
+            return (model._base_manager.using(self.using)
+                    .filter(**{"%s__in" % related.field.name: objs})
+                    .values_list('pk', flat=True))
+        
+        # Otherwise, use only() to fetch just the needed fields
+        # and defer() to explicitly exclude all other fields
+        qs = model._base_manager.using(self.using)
+        qs = qs.filter(**{"%s__in" % related.field.name: objs})
+        
+        # Always use only() to fetch just the needed fields
+        qs = qs.only(*needed_fields)
+        
+        # Explicitly defer all fields that aren't needed
+        defer_fields = [
+            f.name for f in model._meta.concrete_fields
+            if f.name not in needed_fields and not f.primary_key
+        ]
+        if defer_fields:
+            qs = qs.defer(*defer_fields)
+        
+        # For deletion, we can optimize by using values_list() to only fetch needed fields
+        if len(needed_fields) == 1:
+            return qs.values_list(needed_fields[0], flat=True)
+        elif needed_fields:
+            return qs.values_list(*needed_fields)
+        
+        return qs
 
     def instances_with_model(self):
         for model, instances in self.data.items():
@@ -242,82 +359,191 @@ class Collector:
                 yield model, obj
 
     def sort(self):
+        """
+        Sort the models in order of deletion to handle foreign key dependencies.
+        Models are sorted based on their dependencies, with models having no dependencies
+        being deleted first.
+        """
         sorted_models = []
         concrete_models = set()
         models = list(self.data)
-        while len(sorted_models) < len(models):
-            found = False
-            for model in models:
-                if model in sorted_models:
+        
+        # Build a complete dependency graph
+        dependency_graph = {}
+        for model in models:
+            concrete_model = model._meta.concrete_model
+            deps = self.dependencies.get(concrete_model, set())
+            dependency_graph[concrete_model] = deps
+            
+            # Also add implicit dependencies from foreign keys
+            for field in model._meta.fields:
+                if getattr(field, 'remote_field', None) and field.remote_field.on_delete == CASCADE:
+                    target_model = field.remote_field.model._meta.concrete_model
+                    if target_model != concrete_model:  # Avoid self-dependencies
+                        dependency_graph.setdefault(target_model, set()).add(concrete_model)
+        
+        # Helper function to check if a model has unresolved dependencies
+        def has_unresolved_deps(model):
+            deps = dependency_graph.get(model._meta.concrete_model, set())
+            return bool(deps.difference(concrete_models))
+        
+        # Helper function to get all dependencies for a model
+        def get_all_deps(model):
+            deps = set()
+            to_process = [model._meta.concrete_model]
+            while to_process:
+                current = to_process.pop()
+                current_deps = dependency_graph.get(current, set())
+                for dep in current_deps:
+                    if dep not in deps:
+                        deps.add(dep)
+                        to_process.append(dep)
+            return deps
+        
+        # Sort models by their dependency depth (models with more dependencies come first)
+        models.sort(key=lambda m: len(get_all_deps(m)), reverse=True)
+        
+        # Process models in order
+        for model in models:
+            if model in sorted_models:
+                continue
+            
+            # Add all dependencies first
+            deps = get_all_deps(model)
+            for dep_model in models:
+                if dep_model in sorted_models:
                     continue
-                dependencies = self.dependencies.get(model._meta.concrete_model)
-                if not (dependencies and dependencies.difference(concrete_models)):
-                    sorted_models.append(model)
-                    concrete_models.add(model._meta.concrete_model)
-                    found = True
-            if not found:
-                return
+                if dep_model._meta.concrete_model in deps:
+                    sorted_models.append(dep_model)
+                    concrete_models.add(dep_model._meta.concrete_model)
+            
+            # Then add the model itself
+            if model not in sorted_models:
+                sorted_models.append(model)
+                concrete_models.add(model._meta.concrete_model)
+        
+        # Update the data dictionary with the sorted models
         self.data = {model: self.data[model] for model in sorted_models}
 
     def delete(self):
-        # sort instance collections
+        """
+        Perform the deletion of all collected objects, handling dependencies correctly.
+        Returns a tuple of (total number of objects deleted, a dictionary of deleted counts by model).
+        """
+        # Sort instances by primary key to ensure consistent deletion order
         for model, instances in self.data.items():
             self.data[model] = sorted(instances, key=attrgetter("pk"))
 
-        # if possible, bring the models in an order suitable for databases that
-        # don't support transactions or cannot defer constraint checks until the
-        # end of a transaction.
+        # Sort models to handle dependencies
         self.sort()
-        # number of objects deleted for each model label
         deleted_counter = Counter()
 
-        # Optimize for the case with a single obj and no dependencies
-        if len(self.data) == 1 and len(instances) == 1:
-            instance = list(instances)[0]
+        # Special case optimization for single object with no dependencies
+        if len(self.data) == 1 and len(next(iter(self.data.values()))) == 1:
+            model = next(iter(self.data))
+            instance = next(iter(self.data[model]))
             if self.can_fast_delete(instance):
                 with transaction.mark_for_rollback_on_error():
                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)
                 setattr(instance, model._meta.pk.attname, None)
                 return count, {model._meta.label: count}
 
+        # Main deletion process within a transaction
         with transaction.atomic(using=self.using, savepoint=False):
-            # send pre_delete signals
+            # Send pre_delete signals first
             for model, obj in self.instances_with_model():
                 if not model._meta.auto_created:
                     signals.pre_delete.send(
                         sender=model, instance=obj, using=self.using
                     )
 
-            # fast deletes
+            # Process fast deletes (for simple cases)
             for qs in self.fast_deletes:
                 count = qs._raw_delete(using=self.using)
                 deleted_counter[qs.model._meta.label] += count
 
-            # update fields
+            # Handle field updates (e.g., for SET NULL)
             for model, instances_for_fieldvalues in self.field_updates.items():
                 for (field, value), instances in instances_for_fieldvalues.items():
                     query = sql.UpdateQuery(model)
                     query.update_batch([obj.pk for obj in instances],
-                                       {field.name: value}, self.using)
-
-            # reverse instance collections
-            for instances in self.data.values():
-                instances.reverse()
-
-            # delete instances
-            for model, instances in self.data.items():
-                query = sql.DeleteQuery(model)
-                pk_list = [obj.pk for obj in instances]
-                count = query.delete_batch(pk_list, self.using)
-                deleted_counter[model._meta.label] += count
-
-                if not model._meta.auto_created:
-                    for obj in instances:
-                        signals.post_delete.send(
-                            sender=model, instance=obj, using=self.using
-                        )
-
-        # update collected instances
+                                     {field.name: value}, self.using)
+
+            # Delete instances in dependency order
+            # First, handle models with no dependencies
+            models_to_delete = list(self.data.items())
+            deleted_models = set()
+            
+            # Build a complete dependency graph
+            dependency_graph = {}
+            for model, _ in models_to_delete:
+                concrete_model = model._meta.concrete_model
+                deps = self.dependencies.get(concrete_model, set())
+                dependency_graph[concrete_model] = deps
+                
+                # Also add implicit dependencies from foreign keys
+                for field in model._meta.fields:
+                    if getattr(field, 'remote_field', None) and field.remote_field.on_delete == CASCADE:
+                        target_model = field.remote_field.model._meta.concrete_model
+                        if target_model != concrete_model:  # Avoid self-dependencies
+                            dependency_graph.setdefault(concrete_model, set()).add(target_model)
+            
+            # Helper function to check if a model has unresolved dependencies
+            def has_unresolved_deps(model):
+                deps = dependency_graph.get(model._meta.concrete_model, set())
+                return bool(deps.difference(deleted_models))
+            
+            # Process models in dependency order
+            while models_to_delete:
+                progress = False
+                remaining = []
+                
+                # First try to delete models with no unresolved dependencies
+                for model, instances in models_to_delete:
+                    if not has_unresolved_deps(model):
+                        # All dependencies satisfied, safe to delete
+                        instances = list(instances)  # Convert set to list
+                        query = sql.DeleteQuery(model)
+                        pk_list = [obj.pk for obj in instances]
+                        count = query.delete_batch(pk_list, self.using)
+                        deleted_counter[model._meta.label] += count
+                        deleted_models.add(model._meta.concrete_model)
+                        progress = True
+                        
+                        # Send post_delete signals
+                        if not model._meta.auto_created:
+                            for obj in instances:
+                                signals.post_delete.send(
+                                    sender=model, instance=obj, using=self.using
+                                )
+                    else:
+                        remaining.append((model, instances))
+                
+                if not progress and remaining:
+                    # We have a cycle, break it by deleting the model with fewest dependencies
+                    remaining.sort(
+                        key=lambda x: len(dependency_graph.get(x[0]._meta.concrete_model, set())
+                                     .difference(deleted_models))
+                    )
+                    model, instances = remaining[0]
+                    instances = list(instances)
+                    query = sql.DeleteQuery(model)
+                    pk_list = [obj.pk for obj in instances]
+                    count = query.delete_batch(pk_list, self.using)
+                    deleted_counter[model._meta.label] += count
+                    deleted_models.add(model._meta.concrete_model)
+                    remaining = remaining[1:]
+                    
+                    # Send post_delete signals
+                    if not model._meta.auto_created:
+                        for obj in instances:
+                            signals.post_delete.send(
+                                sender=model, instance=obj, using=self.using
+                            )
+                
+                models_to_delete = remaining
+
+        # Update instance states after deletion
         for instances_for_fieldvalues in self.field_updates.values():
             for (field, value), instances in instances_for_fieldvalues.items():
                 for obj in instances:
@@ -325,4 +551,5 @@ class Collector:
         for model, instances in self.data.items():
             for instance in instances:
                 setattr(instance, model._meta.pk.attname, None)
+
         return sum(deleted_counter.values()), dict(deleted_counter)
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
Requirement already satisfied: pytz in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.0.dev20190417053413) (2024.1)
Requirement already satisfied: sqlparse in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.0.dev20190417053413) (0.4.4)
Installing collected packages: Django
  Attempting uninstall: Django
    Found existing installation: Django 3.0.dev20190417053413
    Uninstalling Django-3.0.dev20190417053413:
      Successfully uninstalled Django-3.0.dev20190417053413
  Running setup.py develop for Django
Successfully installed Django-3.0.dev20190417053413
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
+ git checkout 8180ffba21bf10f4be905cb0d4890dc2bcff2788 tests/delete/models.py tests/delete/tests.py
Updated 0 paths from 1c79d4e861
+ git apply -v -
Checking patch tests/delete/models.py...
Checking patch tests/delete/tests.py...
Applied patch tests/delete/models.py cleanly.
Applied patch tests/delete/tests.py cleanly.
+ ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 delete.models delete.tests
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
test_bulk (delete.tests.DeletionTests) ... ERROR
test_can_defer_constraint_checks (delete.tests.DeletionTests) ... ERROR
test_cannot_defer_constraint_checks (delete.tests.DeletionTests) ... skipped 'Database has feature(s) can_defer_constraint_checks'
test_delete_with_keeping_parents (delete.tests.DeletionTests) ... ok
test_delete_with_keeping_parents_relationships (delete.tests.DeletionTests) ... ok
test_deletion_order (delete.tests.DeletionTests) ... ERROR
test_hidden_related (delete.tests.DeletionTests) ... ERROR
test_instance_update (delete.tests.DeletionTests) ... ERROR
test_large_delete (delete.tests.DeletionTests) ... ok
test_large_delete_related (delete.tests.DeletionTests) ... ERROR
test_m2m (delete.tests.DeletionTests) ... ERROR
test_model_delete_returns_num_rows (delete.tests.DeletionTests) ... ERROR
test_only_referenced_fields_selected (delete.tests.DeletionTests) ... FAIL
test_proxied_model_duplicate_queries (delete.tests.DeletionTests) ... ok
test_queryset_delete_returns_num_rows (delete.tests.DeletionTests) ... ERROR
test_relational_post_delete_signals_happen_before_parent_object (delete.tests.DeletionTests) ... ERROR
test_fast_delete_empty_no_update_can_self_select (delete.tests.FastDeleteTests) ... FAIL
test_fast_delete_fk (delete.tests.FastDeleteTests) ... FAIL
test_fast_delete_inheritance (delete.tests.FastDeleteTests) ... ERROR
test_fast_delete_instance_set_pk_none (delete.tests.FastDeleteTests) ... ok
test_fast_delete_joined_qs (delete.tests.FastDeleteTests) ... FAIL
test_fast_delete_large_batch (delete.tests.FastDeleteTests) ... FAIL
test_fast_delete_m2m (delete.tests.FastDeleteTests) ... FAIL
test_fast_delete_qs (delete.tests.FastDeleteTests) ... FAIL
test_fast_delete_revm2m (delete.tests.FastDeleteTests) ... FAIL
test_auto (delete.tests.OnDeleteTests) ... ok
test_auto_nullable (delete.tests.OnDeleteTests) ... ok
test_cascade (delete.tests.OnDeleteTests) ... ok
test_cascade_from_child (delete.tests.OnDeleteTests) ... ok
test_cascade_from_parent (delete.tests.OnDeleteTests) ... ERROR
test_cascade_nullable (delete.tests.OnDeleteTests) ... ok
test_do_nothing (delete.tests.OnDeleteTests) ... ok
test_do_nothing_qscount (delete.tests.OnDeleteTests) ... ok
test_inheritance_cascade_down (delete.tests.OnDeleteTests) ... ERROR
test_inheritance_cascade_up (delete.tests.OnDeleteTests) ... ok
test_o2o_setnull (delete.tests.OnDeleteTests) ... ERROR
test_protect (delete.tests.OnDeleteTests) ... FAIL
test_setdefault (delete.tests.OnDeleteTests) ... ERROR
test_setdefault_none (delete.tests.OnDeleteTests) ... ERROR
test_setnull (delete.tests.OnDeleteTests) ... ERROR
test_setnull_from_child (delete.tests.OnDeleteTests) ... ERROR
test_setnull_from_parent (delete.tests.OnDeleteTests) ... ERROR
test_setvalue (delete.tests.OnDeleteTests) ... ERROR

======================================================================
ERROR: test_bulk (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 184, in test_bulk
    self.assertNumQueries(5, s.delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_can_defer_constraint_checks (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/django/test/testcases.py", line 1229, in skip_wrapper
    return test_func(*args, **kwargs)
  File "/testbed/tests/delete/tests.py", line 283, in test_can_defer_constraint_checks
    self.assertNumQueries(3, a.delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_deletion_order (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 232, in test_deletion_order
    r.delete()
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_hidden_related (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 320, in test_hidden_related
    r.delete()
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_instance_update (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 199, in test_instance_update
    a.setnull.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
ERROR: test_large_delete_related (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 354, in test_large_delete_related
    self.assertNumQueries(expected_num_queries, s.delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_m2m (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 172, in test_m2m
    r.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
ERROR: test_model_delete_returns_num_rows (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 425, in test_model_delete_returns_num_rows
    deleted, deleted_objs = r.delete()
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_queryset_delete_returns_num_rows (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 396, in test_queryset_delete_returns_num_rows
    deleted, deleted_objs = R.objects.all().delete()
  File "/testbed/django/db/models/query.py", line 699, in delete
    collector.collect(del_query)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_relational_post_delete_signals_happen_before_parent_object (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 257, in test_relational_post_delete_signals_happen_before_parent_object
    r.delete()
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_fast_delete_inheritance (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 541, in test_fast_delete_inheritance
    self.assertNumQueries(2, p.delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_cascade_from_parent (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 116, in test_cascade_from_parent
    R.objects.get(pk=a.child_id).delete()
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_inheritance_cascade_down (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 105, in test_inheritance_cascade_down
    parent.delete()
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_o2o_setnull (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 138, in test_o2o_setnull
    a.o2o_setnull.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
ERROR: test_setdefault (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 43, in test_setdefault
    a.setdefault.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
ERROR: test_setdefault_none (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 49, in test_setdefault_none
    a.setdefault_none.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
ERROR: test_setnull (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 37, in test_setnull
    a.setnull.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
ERROR: test_setnull_from_child (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 122, in test_setnull_from_child
    a.child_setnull.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
ERROR: test_setnull_from_parent (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 130, in test_setnull_from_parent
    R.objects.get(pk=a.child_setnull_id).delete()
  File "/testbed/django/db/models/base.py", line 918, in delete
    collector.collect([self], keep_parents=keep_parents)
  File "/testbed/django/db/models/deletion.py", line 262, in collect
    field.remote_field.on_delete(self, field, sub_objs, self.using)
  File "/testbed/django/db/models/deletion.py", line 16, in CASCADE
    source_attr=field.name, nullable=field.null)
  File "/testbed/django/db/models/deletion.py", line 227, in collect
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
  File "/testbed/django/db/models/deletion.py", line 105, in add
    target_model = model._meta.concrete_model
AttributeError: type object 'tuple' has no attribute '_meta'

======================================================================
ERROR: test_setvalue (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 31, in test_setvalue
    a.setvalue.delete()
  File "/testbed/django/db/models/base.py", line 919, in delete
    return collector.delete()
  File "/testbed/django/db/models/deletion.py", line 469, in delete
    query.update_batch([obj.pk for obj in instances],
  File "/testbed/django/db/models/deletion.py", line 469, in <listcomp>
    query.update_batch([obj.pk for obj in instances],
AttributeError: 'tuple' object has no attribute 'pk'

======================================================================
FAIL: test_only_referenced_fields_selected (delete.tests.DeletionTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 455, in test_only_referenced_fields_selected
    self.assertEqual(ctx.captured_queries[0]['sql'], expected_sql)
AssertionError: 'SELE[41 chars]er"."origin_id" FROM "delete_referrer" WHERE "[31 chars] (1)' != 'SELE[41 chars]er"."unique_field" FROM "delete_referrer" WHER[34 chars] (1)'
- SELECT "delete_referrer"."id", "delete_referrer"."origin_id" FROM "delete_referrer" WHERE "delete_referrer"."origin_id" IN (1)
+ SELECT "delete_referrer"."id", "delete_referrer"."unique_field" FROM "delete_referrer" WHERE "delete_referrer"."origin_id" IN (1)


======================================================================
FAIL: test_fast_delete_empty_no_update_can_self_select (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 566, in test_fast_delete_empty_no_update_can_self_select
    (0, {'delete.User': 0})
AssertionError: Tuples differ: (0, {}) != (0, {'delete.User': 0})

First differing element 1:
{}
{'delete.User': 0}

- (0, {})
+ (0, {'delete.User': 0})

======================================================================
FAIL: test_fast_delete_fk (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 484, in test_fast_delete_fk
    self.assertNumQueries(2, a.delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/test/testcases.py", line 85, in __exit__
    '%d. %s' % (i, query['sql']) for i, query in enumerate(self.captured_queries, start=1)
AssertionError: 3 != 2 : 3 queries executed, 2 expected
Captured queries were:
1. SELECT "delete_user"."id", "delete_user"."avatar_id" FROM "delete_user" WHERE "delete_user"."avatar_id" IN (1)
2. DELETE FROM "delete_user" WHERE "delete_user"."avatar_id" IN (1)
3. DELETE FROM "delete_avatar" WHERE "delete_avatar"."id" IN (1)

======================================================================
FAIL: test_fast_delete_joined_qs (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 523, in test_fast_delete_joined_qs
    User.objects.filter(avatar__desc='a').delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/test/testcases.py", line 85, in __exit__
    '%d. %s' % (i, query['sql']) for i, query in enumerate(self.captured_queries, start=1)
AssertionError: 2 != 1 : 2 queries executed, 1 expected
Captured queries were:
1. SELECT "delete_user"."id", "delete_user"."avatar_id" FROM "delete_user" INNER JOIN "delete_avatar" ON ("delete_user"."avatar_id" = "delete_avatar"."id") WHERE "delete_avatar"."desc" = 'a'
2. DELETE FROM "delete_user" WHERE "delete_user"."id" IN (SELECT U0."id" FROM "delete_user" U0 INNER JOIN "delete_avatar" U1 ON (U0."avatar_id" = U1."id") WHERE U1."desc" = 'a')

======================================================================
FAIL: test_fast_delete_large_batch (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 549, in test_fast_delete_large_batch
    self.assertNumQueries(1, User.objects.all().delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/test/testcases.py", line 85, in __exit__
    '%d. %s' % (i, query['sql']) for i, query in enumerate(self.captured_queries, start=1)
AssertionError: 2 != 1 : 2 queries executed, 1 expected
Captured queries were:
1. SELECT "delete_user"."id", "delete_user"."avatar_id" FROM "delete_user"
2. DELETE FROM "delete_user"

======================================================================
FAIL: test_fast_delete_m2m (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 493, in test_fast_delete_m2m
    self.assertNumQueries(2, f.delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/test/testcases.py", line 85, in __exit__
    '%d. %s' % (i, query['sql']) for i, query in enumerate(self.captured_queries, start=1)
AssertionError: 3 != 2 : 3 queries executed, 2 expected
Captured queries were:
1. SELECT "delete_m2mfrom_m2m"."id", "delete_m2mfrom_m2m"."m2mfrom_id", "delete_m2mfrom_m2m"."m2mto_id" FROM "delete_m2mfrom_m2m" WHERE "delete_m2mfrom_m2m"."m2mfrom_id" IN (1)
2. DELETE FROM "delete_m2mfrom_m2m" WHERE "delete_m2mfrom_m2m"."m2mfrom_id" IN (1)
3. DELETE FROM "delete_m2mfrom" WHERE "delete_m2mfrom"."id" IN (1)

======================================================================
FAIL: test_fast_delete_qs (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 505, in test_fast_delete_qs
    self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/test/testcases.py", line 85, in __exit__
    '%d. %s' % (i, query['sql']) for i, query in enumerate(self.captured_queries, start=1)
AssertionError: 2 != 1 : 2 queries executed, 1 expected
Captured queries were:
1. SELECT "delete_user"."id", "delete_user"."avatar_id" FROM "delete_user" WHERE "delete_user"."id" = 1
2. DELETE FROM "delete_user" WHERE "delete_user"."id" = 1

======================================================================
FAIL: test_fast_delete_revm2m (delete.tests.FastDeleteTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 500, in test_fast_delete_revm2m
    self.assertNumQueries(2, f.delete)
  File "/testbed/django/test/testcases.py", line 1066, in assertNumQueries
    func(*args, **kwargs)
  File "/testbed/django/test/testcases.py", line 85, in __exit__
    '%d. %s' % (i, query['sql']) for i, query in enumerate(self.captured_queries, start=1)
AssertionError: 3 != 2 : 3 queries executed, 2 expected
Captured queries were:
1. SELECT "delete_m2mfrom_m2m"."id", "delete_m2mfrom_m2m"."m2mfrom_id", "delete_m2mfrom_m2m"."m2mto_id" FROM "delete_m2mfrom_m2m" WHERE "delete_m2mfrom_m2m"."m2mfrom_id" IN (1)
2. DELETE FROM "delete_m2mfrom_m2m" WHERE "delete_m2mfrom_m2m"."m2mfrom_id" IN (1)
3. DELETE FROM "delete_m2mfrom" WHERE "delete_m2mfrom"."id" IN (1)

======================================================================
FAIL: test_protect (delete.tests.OnDeleteTests)
----------------------------------------------------------------------
django.db.models.deletion.ProtectedError: ("Cannot delete some instances of model 'R' because they are referenced through a protected foreign key: 'tuple.protect'", <QuerySet [(1, 2, 3, 8, 9, 13)]>)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/testbed/tests/delete/tests.py", line 70, in test_protect
    a.protect.delete()
  File "/opt/miniconda3/envs/testbed/lib/python3.6/contextlib.py", line 99, in __exit__
    self.gen.throw(type, value, traceback)
  File "/testbed/django/test/testcases.py", line 676, in _assert_raises_or_warns_cm
    self.assertIn(expected_message, str(getattr(cm, cm_attr)))
AssertionError: "Cannot delete some instances of model 'R' because they are referenced through a protected foreign key: 'A.protect'" not found in '("Cannot delete some instances of model \'R\' because they are referenced through a protected foreign key: \'tuple.protect\'", <QuerySet [(1, 2, 3, 8, 9, 13)]>)'

----------------------------------------------------------------------
Ran 43 tests in 0.541s

FAILED (failures=9, errors=20, skipped=1)
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
Testing against Django installed in '/testbed/django'
Importing application delete
Skipping setup of unused database(s): other.
Operations to perform:
  Synchronize unmigrated apps: auth, contenttypes, delete, messages, sessions, staticfiles
  Apply all migrations: admin, sites
Synchronizing apps without migrations:
  Creating tables...
    Creating table django_content_type
    Creating table auth_permission
    Creating table auth_group
    Creating table auth_user
    Creating table django_session
    Creating table delete_r
    Creating table delete_s
    Creating table delete_t
    Creating table delete_u
    Creating table delete_rchild
    Creating table delete_a
    Creating table delete_m
    Creating table delete_mr
    Creating table delete_mrnull
    Creating table delete_avatar
    Creating table delete_user
    Creating table delete_hiddenuser
    Creating table delete_hiddenuserprofile
    Creating table delete_m2mto
    Creating table delete_m2mfrom
    Creating table delete_parent
    Creating table delete_child
    Creating table delete_base
    Creating table delete_reltobase
    Creating table delete_origin
    Creating table delete_referrer
    Creating table delete_secondreferrer
    Running deferred SQL...
Running migrations:
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying sites.0001_initial... OK
  Applying sites.0002_alter_domain_unique... OK
System check identified no issues (0 silenced).
+ git checkout 8180ffba21bf10f4be905cb0d4890dc2bcff2788 tests/delete/models.py tests/delete/tests.py
Updated 2 paths from 1c79d4e861
