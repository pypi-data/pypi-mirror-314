diff --git a/django/db/backends/mysql/schema.py b/django/db/backends/mysql/schema.py
index 562b209eef..29fbdda015 100644
--- a/django/db/backends/mysql/schema.py
+++ b/django/db/backends/mysql/schema.py
@@ -167,8 +167,95 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
 
     def _alter_column_type_sql(self, model, old_field, new_field, new_type):
         new_type = self._set_field_new_type_null_status(old_field, new_type)
+        # If the field has a collation, ensure it's included in the type
+        if getattr(new_field, 'db_collation', None):
+            new_type = f"{new_type} COLLATE {new_field.db_collation}"
         return super()._alter_column_type_sql(model, old_field, new_field, new_type)
 
+    def _alter_field(
+        self,
+        model,
+        old_field,
+        new_field,
+        old_type,
+        new_type,
+        old_db_params,
+        new_db_params,
+        strict=False,
+    ):
+        """Propagate collation to foreign key fields when altering a field."""
+        # Drop any FK constraints, we'll remake them later
+        fks_dropped = set()
+        if (
+            self.connection.features.supports_foreign_keys
+            and old_field.remote_field
+            and old_field.db_constraint
+        ):
+            fk_names = self._constraint_names(
+                model, [old_field.column], foreign_key=True
+            )
+            if strict and len(fk_names) != 1:
+                raise ValueError(
+                    "Found wrong number (%s) of foreign key constraints for %s.%s"
+                    % (
+                        len(fk_names),
+                        model._meta.db_table,
+                        old_field.column,
+                    )
+                )
+            for fk_name in fk_names:
+                fks_dropped.add((old_field.column,))
+                self.execute(self._delete_fk_sql(model, fk_name))
+
+        # If this is a primary key with collation, we need to handle related fields
+        related_models = []
+        if new_field.primary_key and getattr(new_field, 'db_collation', None):
+            # Get all related fields that reference this field
+            for rel in model._meta.get_fields():
+                if hasattr(rel, 'field') and rel.field.related_model == model:
+                    # Drop the FK constraint
+                    fk_names = self._constraint_names(
+                        rel.model, [rel.field.column], foreign_key=True
+                    )
+                    for fk_name in fk_names:
+                        self.execute(self._delete_fk_sql(rel.model, fk_name))
+                    related_models.append((rel.model, rel.field))
+
+        # Call parent to handle the main field alteration
+        super()._alter_field(
+            model, old_field, new_field, old_type, new_type,
+            old_db_params, new_db_params, strict,
+        )
+
+        # If this is a primary key with collation, update all foreign keys
+        if new_field.primary_key and getattr(new_field, 'db_collation', None):
+            for rel_model, rel_field in related_models:
+                # Get the column type
+                rel_type = rel_field.db_type(self.connection)
+                # Add collation to the type
+                rel_type = f"{rel_type} COLLATE {new_field.db_collation}"
+                # Alter the related field to match the collation
+                self.execute(
+                    self.sql_alter_column % {
+                        "table": self.quote_name(rel_model._meta.db_table),
+                        "changes": self.sql_alter_column_type % {
+                            "column": self.quote_name(rel_field.column),
+                            "type": rel_type,
+                        }
+                    }
+                )
+                # Recreate the FK constraint
+                self.execute(
+                    self.sql_create_fk % {
+                        "table": self.quote_name(rel_model._meta.db_table),
+                        "name": self._create_index_name(rel_model, [rel_field.column], suffix="_fk"),
+                        "column": self.quote_name(rel_field.column),
+                        "to_table": self.quote_name(model._meta.db_table),
+                        "to_column": self.quote_name(new_field.column),
+                        "deferrable": self.connection.ops.deferrable_sql(),
+                    }
+                )
+
     def _rename_field_sql(self, table, old_field, new_field, new_type):
         new_type = self._set_field_new_type_null_status(old_field, new_type)
         return super()._rename_field_sql(table, old_field, new_field, new_type)
diff --git a/docs/ref/models/fields.txt b/docs/ref/models/fields.txt
index 491bd791a8..c615da4a78 100644
--- a/docs/ref/models/fields.txt
+++ b/docs/ref/models/fields.txt
@@ -624,6 +624,11 @@ The default form widget for this field is a :class:`~django.forms.TextInput`.
 
     Optional. The database collation name of the field.
 
+    When used on a primary key field, the collation will be automatically propagated
+    to any foreign key fields that reference it. This ensures that the collation
+    matches between the primary key and foreign key fields, which is required by
+    some database backends (e.g., MySQL).
+
     .. note::
 
         Collation names are not standardized. As such, this will not be
diff --git a/docs/releases/4.2.txt b/docs/releases/4.2.txt
new file mode 100644
index 0000000000..48a03b798e
--- /dev/null
+++ b/docs/releases/4.2.txt
@@ -0,0 +1,45 @@
+======================
+Django 4.2 release notes
+======================
+
+*Expected April 2023*
+
+Welcome to Django 4.2!
+
+These release notes cover the :ref:`new features <whats-new-4.2>`, as well as some
+:ref:`backwards incompatible changes <backwards-incompatible-4.2>` you'll want to
+be aware of when upgrading from Django 4.1 or earlier. We've :ref:`begun the
+deprecation process for some features <deprecated-4.2>`.
+
+See the :doc:`/howto/upgrade-version` guide if you're updating an existing
+project.
+
+Python compatibility
+==================
+
+Django 4.2 supports Python 3.8, 3.9, 3.10, and 3.11. We **highly recommend** and
+only officially support the latest release of each series.
+
+.. _whats-new-4.2:
+
+What's new in Django 4.2
+=======================
+
+MySQL collation propagation
+-------------------------
+
+When altering a primary key field to add a collation in MySQL, Django now
+automatically propagates the collation to any foreign key fields that reference it.
+This ensures that the collation matches between the primary key and foreign key
+fields, which is required by MySQL to maintain referential integrity.
+
+For example::
+
+    class Account(models.Model):
+        id = models.CharField(primary_key=True, max_length=22, db_collation='utf8_bin')
+
+    class Profile(models.Model):
+        account = models.ForeignKey(Account, on_delete=models.CASCADE)
+
+When the ``Account.id`` field's collation is changed, Django will automatically
+update the collation of ``Profile.account_id`` to match.
\ No newline at end of file
diff --git a/tests/schema/test_collation.py b/tests/schema/test_collation.py
new file mode 100644
index 0000000000..2bf1264e3b
--- /dev/null
+++ b/tests/schema/test_collation.py
@@ -0,0 +1,98 @@
+from django.db import connection, models
+from django.test import TestCase, skipUnlessDBFeature
+
+
+class CollationTests(TestCase):
+    """Tests for db_collation behavior with foreign keys."""
+
+    @skipUnlessDBFeature('supports_collation_on_charfield')
+    def test_db_collation_propagation(self):
+        """
+        Test that changing a primary key's collation propagates to foreign keys.
+        """
+        # Create initial models without collation
+        class Account(models.Model):
+            id = models.CharField(primary_key=True, max_length=22)
+            name = models.CharField(max_length=100)
+
+            class Meta:
+                app_label = 'schema'
+
+        class Address(models.Model):
+            id = models.CharField(primary_key=True, max_length=22)
+            account = models.OneToOneField(Account, on_delete=models.CASCADE)
+            street = models.CharField(max_length=100)
+
+            class Meta:
+                app_label = 'schema'
+
+        class Profile(models.Model):
+            id = models.CharField(primary_key=True, max_length=22)
+            account = models.ForeignKey(Account, null=True, blank=True, on_delete=models.CASCADE)
+            bio = models.TextField()
+
+            class Meta:
+                app_label = 'schema'
+
+        # Create the tables
+        with connection.schema_editor() as editor:
+            editor.create_model(Account)
+            editor.create_model(Address)
+            editor.create_model(Profile)
+
+        # Now update Account to add collation
+        class NewAccount(models.Model):
+            id = models.CharField(primary_key=True, max_length=22, db_collation='utf8_bin')
+            name = models.CharField(max_length=100)
+
+            class Meta:
+                app_label = 'schema'
+
+        # Alter the table
+        with connection.schema_editor() as editor:
+            editor.alter_field(Account, Account._meta.get_field('id'), NewAccount._meta.get_field('id'))
+
+        # Check that the collation was propagated
+        with connection.cursor() as cursor:
+            # Check Account table
+            cursor.execute("""
+                SELECT COLLATION_NAME
+                FROM information_schema.COLUMNS 
+                WHERE TABLE_SCHEMA = DATABASE()
+                AND TABLE_NAME = 'schema_account'
+                AND COLUMN_NAME = 'id'
+            """)
+            account_collation = cursor.fetchone()[0]
+            self.assertEqual(account_collation.lower(), 'utf8_bin')
+
+            # Check Address table
+            cursor.execute("""
+                SELECT COLLATION_NAME
+                FROM information_schema.COLUMNS 
+                WHERE TABLE_SCHEMA = DATABASE()
+                AND TABLE_NAME = 'schema_address'
+                AND COLUMN_NAME = 'account_id'
+            """)
+            address_collation = cursor.fetchone()[0]
+            self.assertEqual(address_collation.lower(), 'utf8_bin')
+
+            # Check Profile table
+            cursor.execute("""
+                SELECT COLLATION_NAME
+                FROM information_schema.COLUMNS 
+                WHERE TABLE_SCHEMA = DATABASE()
+                AND TABLE_NAME = 'schema_profile'
+                AND COLUMN_NAME = 'account_id'
+            """)
+            profile_collation = cursor.fetchone()[0]
+            self.assertEqual(profile_collation.lower(), 'utf8_bin')
+
+            # Verify foreign key constraints exist and work
+            cursor.execute("""
+                SELECT COUNT(*)
+                FROM information_schema.KEY_COLUMN_USAGE
+                WHERE TABLE_SCHEMA = DATABASE()
+                AND REFERENCED_TABLE_NAME = 'schema_account'
+            """)
+            fk_count = cursor.fetchone()[0]
+            self.assertEqual(fk_count, 2)  # One for Address, one for Profile
\ No newline at end of file
