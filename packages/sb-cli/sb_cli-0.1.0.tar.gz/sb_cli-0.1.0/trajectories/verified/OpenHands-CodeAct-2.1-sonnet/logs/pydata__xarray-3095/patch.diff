diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 00000000..4fd476bf
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,25 @@
+import xarray
+
+# Create test dataset
+ds = xarray.Dataset(
+    coords={'x': ['foo'], 'y': ('x', ['bar'])},
+    data_vars={'z': ('x', ['baz'])}
+)
+
+print("\nOriginal dataset:")
+print(ds)
+
+print("\nShallow copy:")
+print(ds.copy())
+
+print("\nDeep copy:")
+print(ds.copy(deep=True))
+
+print("\nOriginal DataArray:")
+print(ds.z)
+
+print("\nDataArray shallow copy:")
+print(ds.z.copy())
+
+print("\nDataArray deep copy:")
+print(ds.z.copy(deep=True))
\ No newline at end of file
diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py
index e262d9ee..085832d8 100644
--- a/xarray/core/indexing.py
+++ b/xarray/core/indexing.py
@@ -1230,7 +1230,13 @@ class PandasIndexAdapter(ExplicitlyIndexedNDArrayMixin):
     """Wrap a pandas.Index to preserve dtypes and handle explicit indexing."""
 
     def __init__(self, array, dtype=None):
-        self.array = utils.safe_cast_to_index(array)
+        if isinstance(array, pd.Index) and array.dtype.kind == 'U':
+            # For unicode dtypes, we need to preserve the original dtype
+            # We need to use np.array to preserve the dtype
+            values = np.array(array, dtype=array.dtype)
+            self.array = pd.Index(values, dtype=array.dtype)
+        else:
+            self.array = utils.safe_cast_to_index(array)
         if dtype is None:
             if isinstance(array, pd.PeriodIndex):
                 dtype = np.dtype('O')
@@ -1239,6 +1245,9 @@ class PandasIndexAdapter(ExplicitlyIndexedNDArrayMixin):
                 dtype = array.categories.dtype
             elif not utils.is_valid_numpy_dtype(array.dtype):
                 dtype = np.dtype('O')
+            elif isinstance(array, pd.Index) and array.dtype.kind == 'U':
+                # For unicode dtypes, preserve the original dtype
+                dtype = array.dtype
             else:
                 dtype = array.dtype
         self._dtype = dtype
@@ -1255,7 +1264,17 @@ class PandasIndexAdapter(ExplicitlyIndexedNDArrayMixin):
             with suppress(AttributeError):
                 # this might not be public API
                 array = array.astype('object')
-        return np.asarray(array.values, dtype=dtype)
+        # For unicode dtypes, we need to preserve the original dtype
+        if array.dtype.kind == 'U':
+            # We need to use np.array to preserve the dtype
+            values = np.array(array, dtype=array.dtype)
+            return values
+        # For other dtypes, we need to preserve the original dtype
+        if dtype is None:
+            dtype = array.dtype
+        # We need to preserve the dtype when converting to numpy array
+        values = np.array(array, dtype=dtype)
+        return values
 
     @property
     def shape(self):
diff --git a/xarray/core/utils.py b/xarray/core/utils.py
index 8ce30a3c..b07319d8 100644
--- a/xarray/core/utils.py
+++ b/xarray/core/utils.py
@@ -76,14 +76,26 @@ def safe_cast_to_index(array: Any) -> pd.Index:
     always return an index with dtype=object.
     """
     if isinstance(array, pd.Index):
-        index = array
+        if array.dtype.kind == 'U':
+            # For unicode dtypes, we need to preserve the original dtype
+            # We need to use np.array to preserve the dtype
+            values = np.array(array, dtype=array.dtype)
+            index = pd.Index(values, dtype=array.dtype)
+        else:
+            index = array
     elif hasattr(array, 'to_index'):
         index = array.to_index()
     else:
         kwargs = {}
-        if hasattr(array, 'dtype') and array.dtype.kind == 'O':
-            kwargs['dtype'] = object
-        index = pd.Index(np.asarray(array), **kwargs)
+        if hasattr(array, 'dtype'):
+            if array.dtype.kind == 'O':
+                kwargs['dtype'] = object
+            elif array.dtype.kind == 'U':
+                # For unicode dtypes, preserve the original dtype
+                kwargs['dtype'] = array.dtype
+        # We need to use np.array to preserve the dtype
+        values = np.array(array, dtype=kwargs.get('dtype', None))
+        index = pd.Index(values, **kwargs)
     return _maybe_cast_to_cftimeindex(index)
 
 
diff --git a/xarray/core/variable.py b/xarray/core/variable.py
index 379be8f5..7822398a 100644
--- a/xarray/core/variable.py
+++ b/xarray/core/variable.py
@@ -807,7 +807,19 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,
             if deep:
                 if isinstance(data, dask_array_type):
                     data = data.copy()
-                elif not isinstance(data, PandasIndexAdapter):
+                elif isinstance(data, PandasIndexAdapter):
+                    # For PandasIndexAdapter, we need to preserve the dtype
+                    index = data.array
+                    if isinstance(index, pd.MultiIndex):
+                        data = PandasIndexAdapter(index.copy(deep=True))
+                    else:
+                        # For regular Index objects, we need to explicitly preserve the dtype
+                        # We need to use np.array to preserve the dtype
+                        values = np.array(index, dtype=index.dtype)
+                        data = PandasIndexAdapter(pd.Index(values, dtype=index.dtype))
+                        # We need to set the dtype explicitly
+                        data._dtype = index.dtype
+                else:
                     # pandas.Index is immutable
                     data = np.array(data)
         else:
@@ -1947,7 +1959,17 @@ class IndexVariable(Variable):
                 # point, which doesn't have a copy method, so make a deep copy
                 # of the underlying `pandas.MultiIndex` and create a new
                 # `PandasIndexAdapter` instance with it.
-                data = PandasIndexAdapter(self._data.array.copy(deep=True))
+                # We need to preserve the dtype when copying the index
+                index = self._data.array
+                if isinstance(index, pd.MultiIndex):
+                    data = PandasIndexAdapter(index.copy(deep=True))
+                else:
+                    # For regular Index objects, we need to explicitly preserve the dtype
+                    # We need to use np.array to preserve the dtype
+                    values = np.array(index, dtype=index.dtype)
+                    data = PandasIndexAdapter(pd.Index(values, dtype=index.dtype))
+                    # We need to set the dtype explicitly
+                    data._dtype = index.dtype
             else:
                 data = self._data
         else:
