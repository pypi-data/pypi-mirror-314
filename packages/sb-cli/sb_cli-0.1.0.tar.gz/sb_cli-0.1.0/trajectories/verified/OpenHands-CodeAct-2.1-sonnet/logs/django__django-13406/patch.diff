diff --git a/django/db/models/query.py b/django/db/models/query.py
index b48d0df9c0..06d4e7e67d 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -123,22 +123,25 @@ class ValuesListIterable(BaseIterable):
         query = queryset.query
         compiler = query.get_compiler(queryset.db)
 
-        if queryset._fields:
-            # extra(select=...) cols are always at the start of the row.
-            names = [
-                *query.extra_select,
-                *query.values_select,
-                *query.annotation_select,
-            ]
-            fields = [*queryset._fields, *(f for f in query.annotation_select if f not in queryset._fields)]
-            if fields != names:
-                # Reorder according to fields.
-                index_map = {name: idx for idx, name in enumerate(names)}
-                rowfactory = operator.itemgetter(*[index_map[f] for f in fields])
-                return map(
-                    rowfactory,
-                    compiler.results_iter(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)
-                )
+        # If we have values_select but no _fields, use values_select as fields
+        if not queryset._fields and query.values_select:
+            queryset._fields = query.values_select
+
+        # extra(select=...) cols are always at the start of the row.
+        names = [
+            *query.extra_select,
+            *query.values_select,
+            *query.annotation_select,
+        ]
+        fields = [*queryset._fields, *(f for f in query.annotation_select if f not in queryset._fields)]
+        if fields != names:
+            # Reorder according to fields.
+            index_map = {name: idx for idx, name in enumerate(names)}
+            rowfactory = operator.itemgetter(*[index_map[f] for f in fields])
+            return map(
+                rowfactory,
+                compiler.results_iter(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)
+            )
         return compiler.results_iter(tuple_expected=True, chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)
 
 
@@ -211,6 +214,23 @@ class QuerySet:
     @query.setter
     def query(self, value):
         self._query = value
+        # If this is a values/values_list query, set the appropriate iterable class
+        if value.values_query_type == 'values':
+            self._iterable_class = ValuesIterable
+            self._fields = value.values_select
+        elif value.values_query_type == 'values_list':
+            # Use the stored iterable class if available
+            if value._iterable_class:
+                self._iterable_class = value._iterable_class
+            else:
+                if value.values_list_flat:
+                    self._iterable_class = FlatValuesListIterable
+                elif value.values_list_named:
+                    self._iterable_class = NamedValuesListIterable
+                else:
+                    self._iterable_class = ValuesListIterable
+            # Use the stored fields if available
+            self._fields = value._fields if value._fields is not None else value.values_select
 
     def as_manager(cls):
         # Address the circular dependency between `Queryset` and `Manager`.
@@ -822,6 +842,7 @@ class QuerySet:
         if expressions:
             clone = clone.annotate(**expressions)
         clone._fields = fields
+        clone.query.values_select = fields
         clone.query.set_values(fields)
         return clone
 
@@ -836,6 +857,24 @@ class QuerySet:
             raise TypeError("'flat' and 'named' can't be used together.")
         if flat and len(fields) > 1:
             raise TypeError("'flat' is not valid when values_list is called with more than one field.")
+        clone = self._chain()
+        clone._fields = fields
+        clone.query.values_select = fields
+        clone.query.set_values(fields)
+        clone.query.values_query_type = 'values_list'
+        clone.query.values_list_flat = flat
+        clone.query.values_list_named = named
+        clone.query.tuple_expected = not flat and not named
+        if flat:
+            clone._iterable_class = FlatValuesListIterable
+        elif named:
+            clone._iterable_class = NamedValuesListIterable
+        else:
+            clone._iterable_class = ValuesListIterable
+        # Store the fields in the query for pickling
+        clone.query._fields = fields
+        # Store the iterable class in the query for pickling
+        clone.query._iterable_class = clone._iterable_class
 
         field_names = {f for f in fields if not hasattr(f, 'resolve_expression')}
         _fields = []
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 4648daf395..2efa47d43c 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -152,6 +152,14 @@ class Query(BaseExpression):
         self.alias_map = {}
         # Whether to provide alias to columns during reference resolving.
         self.alias_cols = alias_cols
+        # Store whether this is a values/values_list query and its type
+        self.values_query_type = None  # None, 'values', 'values_list', 'values_list_flat'
+        self.values_select = ()
+        self.values_list_flat = False
+        self.values_list_named = False
+        self.tuple_expected = False
+        self._fields = None
+        self._iterable_class = None
         # Sometimes the query contains references to aliases in outer queries (as
         # a result of split_exclude). Correct alias quoting needs to know these
         # aliases too.
@@ -2181,6 +2189,8 @@ class Query(BaseExpression):
         self.select_related = False
         self.clear_deferred_loading()
         self.clear_select_fields()
+        self.values_query_type = 'values'
+        self.values_select = fields
 
         if fields:
             field_names = []
