diff --git a/django/core/handlers/asgi.py b/django/core/handlers/asgi.py
index 7fbabe4510..42a68523dd 100644
--- a/django/core/handlers/asgi.py
+++ b/django/core/handlers/asgi.py
@@ -1,3 +1,4 @@
+import asyncio
 import logging
 import sys
 import tempfile
@@ -159,6 +160,9 @@ class ASGIHandler(base.BaseHandler):
             return
         # Get the response, using the async mode of BaseHandler.
         response = await self.get_response_async(request)
+        # Handle coroutines in the middleware chain
+        if asyncio.iscoroutine(response):
+            response = await response
         response._handler_class = self.__class__
         # Increase chunk size on file responses (ASGI servers handles low-level
         # chunking).
diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py
index 169df6b3cf..7692f7a51b 100644
--- a/django/core/handlers/base.py
+++ b/django/core/handlers/base.py
@@ -115,6 +115,13 @@ class BaseHandler:
                 if debug:
                     logger.debug('Synchronous %s adapted.', name)
                 return sync_to_async(method, thread_sensitive=True)
+            # For async methods in async mode, wrap them to handle coroutines
+            async def wrapper(*args, **kwargs):
+                response = await method(*args, **kwargs)
+                if asyncio.iscoroutine(response):
+                    response = await response
+                return response
+            return wrapper
         elif method_is_async:
             if debug:
                 logger.debug('Asynchronous %s adapted.', name)
@@ -146,6 +153,9 @@ class BaseHandler:
         # Setup default url resolver for this thread.
         set_urlconf(settings.ROOT_URLCONF)
         response = await self._middleware_chain(request)
+        # Handle coroutines in the middleware chain
+        if asyncio.iscoroutine(response):
+            response = await response
         response._resource_closers.append(request.close)
         if response.status_code >= 400:
             await sync_to_async(log_response)(
@@ -269,7 +279,7 @@ class BaseHandler:
 
         # Make sure the response is not a coroutine
         if asyncio.iscoroutine(response):
-            raise RuntimeError('Response is still a coroutine.')
+            response = await response
         return response
 
     def resolve_request(self, request):
diff --git a/django/core/handlers/exception.py b/django/core/handlers/exception.py
index 98fb46083a..99124b3f45 100644
--- a/django/core/handlers/exception.py
+++ b/django/core/handlers/exception.py
@@ -36,6 +36,9 @@ def convert_exception_to_response(get_response):
         async def inner(request):
             try:
                 response = await get_response(request)
+                # Handle coroutines in the middleware chain
+                if asyncio.iscoroutine(response):
+                    response = await response
             except Exception as exc:
                 response = await sync_to_async(response_for_exception)(request, exc)
             return response
diff --git a/fix_async_middleware.patch b/fix_async_middleware.patch
new file mode 100644
index 0000000000..2035ece5dd
--- /dev/null
+++ b/fix_async_middleware.patch
@@ -0,0 +1,70 @@
+diff --git a/django/core/handlers/asgi.py b/django/core/handlers/asgi.py
+index 7fbabe4510..42a68523dd 100644
+--- a/django/core/handlers/asgi.py
++++ b/django/core/handlers/asgi.py
+@@ -1,3 +1,4 @@
++import asyncio
+ import logging
+ import sys
+ import tempfile
+@@ -159,6 +160,9 @@ class ASGIHandler(base.BaseHandler):
+             return
+         # Get the response, using the async mode of BaseHandler.
+         response = await self.get_response_async(request)
++        # Handle coroutines in the middleware chain
++        if asyncio.iscoroutine(response):
++            response = await response
+         response._handler_class = self.__class__
+         # Increase chunk size on file responses (ASGI servers handles low-level
+         # chunking).
+diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py
+index 169df6b3cf..7692f7a51b 100644
+--- a/django/core/handlers/base.py
++++ b/django/core/handlers/base.py
+@@ -115,6 +115,13 @@ class BaseHandler:
+                 if debug:
+                     logger.debug('Synchronous %s adapted.', name)
+                 return sync_to_async(method, thread_sensitive=True)
++            # For async methods in async mode, wrap them to handle coroutines
++            async def wrapper(*args, **kwargs):
++                response = await method(*args, **kwargs)
++                if asyncio.iscoroutine(response):
++                    response = await response
++                return response
++            return wrapper
+         elif method_is_async:
+             if debug:
+                 logger.debug('Asynchronous %s adapted.', name)
+@@ -146,6 +153,9 @@ class BaseHandler:
+         # Setup default url resolver for this thread.
+         set_urlconf(settings.ROOT_URLCONF)
+         response = await self._middleware_chain(request)
++        # Handle coroutines in the middleware chain
++        if asyncio.iscoroutine(response):
++            response = await response
+         response._resource_closers.append(request.close)
+         if response.status_code >= 400:
+             await sync_to_async(log_response)(
+@@ -269,7 +279,7 @@ class BaseHandler:
+ 
+         # Make sure the response is not a coroutine
+         if asyncio.iscoroutine(response):
+-            raise RuntimeError('Response is still a coroutine.')
++            response = await response
+         return response
+ 
+     def resolve_request(self, request):
+diff --git a/django/core/handlers/exception.py b/django/core/handlers/exception.py
+index 98fb46083a..99124b3f45 100644
+--- a/django/core/handlers/exception.py
++++ b/django/core/handlers/exception.py
+@@ -36,6 +36,9 @@ def convert_exception_to_response(get_response):
+         async def inner(request):
+             try:
+                 response = await get_response(request)
++                # Handle coroutines in the middleware chain
++                if asyncio.iscoroutine(response):
++                    response = await response
+             except Exception as exc:
+                 response = await sync_to_async(response_for_exception)(request, exc)
+             return response
diff --git a/middleware.py b/middleware.py
new file mode 100644
index 0000000000..139417471f
--- /dev/null
+++ b/middleware.py
@@ -0,0 +1,14 @@
+# Create a custom middleware to debug response types
+class DebugMiddleware:
+    def __init__(self, get_response):
+        self.get_response = get_response
+
+    async def __call__(self, request):
+        print(f"Before get_response in __call__")
+        response = await self.get_response(request)
+        print(f"After get_response in __call__, response type: {type(response)}")
+        return response
+
+    async def process_response(self, request, response):
+        print(f"Response type in process_response: {type(response)}")
+        return response
\ No newline at end of file
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..9ddbd1f8c8
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,50 @@
+import os
+import django
+from django.conf import settings
+from django.core.handlers.asgi import ASGIHandler
+from django.http import HttpResponse
+from django.middleware.common import CommonMiddleware
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='dummy',
+    ROOT_URLCONF=[],  # Empty list since we won't use URLs
+    MIDDLEWARE=[
+        'middleware.DebugMiddleware',
+    ],
+    ALLOWED_HOSTS=['*'],  # Allow all hosts for testing
+)
+
+django.setup()
+
+# Create a dummy async view
+async def async_view(request):
+    print("In async_view")
+    return HttpResponse("Hello World")
+
+# Create a mock ASGI scope
+scope = {
+    'type': 'http',
+    'method': 'GET',
+    'path': '/',
+    'headers': [],
+}
+
+# Create mock receive and send functions
+async def receive():
+    return {'type': 'http.request', 'body': b'', 'more_body': False}
+
+async def send(message):
+    print(f"Sent message: {message}")
+
+# Create handler and process request
+async def test():
+    handler = ASGIHandler()
+    handler._get_response_async = async_view  # Override to use our test view
+    await handler(scope, receive, send)
+
+if __name__ == '__main__':
+    import asyncio
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(test())
\ No newline at end of file
diff --git a/test_asgi.py b/test_asgi.py
new file mode 100644
index 0000000000..ff72a97193
--- /dev/null
+++ b/test_asgi.py
@@ -0,0 +1,65 @@
+import asyncio
+import django
+from django.conf import settings
+from django.core.handlers.asgi import ASGIHandler, ASGIRequest
+from django.http import HttpResponse
+import tempfile
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='dummy',
+    ROOT_URLCONF=[],
+    ALLOWED_HOSTS=['*'],
+)
+
+django.setup()
+
+# Create a custom middleware
+class DebugMiddleware:
+    def __init__(self, get_response):
+        self.get_response = get_response
+        self.async_capable = True
+
+    async def __call__(self, request):
+        print("Before get_response in middleware")
+        response = await self.get_response(request)
+        print(f"After get_response in middleware, response type: {type(response)}")
+        return response
+
+# Create a test view
+async def test_view(request):
+    print("In test_view")
+    return HttpResponse("Hello World")
+
+# Create a test request
+async def test():
+    # Create handler
+    handler = ASGIHandler()
+    
+    # Create scope
+    scope = {
+        'type': 'http',
+        'method': 'GET',
+        'path': '/',
+        'headers': [],
+    }
+    
+    # Create receive function
+    async def receive():
+        return {'type': 'http.request', 'body': b'', 'more_body': False}
+    
+    # Create send function
+    async def send(message):
+        print(f"Sent message: {message}")
+    
+    # Create middleware chain
+    handler.load_middleware(is_async=True)
+    handler._middleware_chain = DebugMiddleware(test_view)
+    
+    # Call handler
+    await handler(scope, receive, send)
+
+if __name__ == '__main__':
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(test())
\ No newline at end of file
diff --git a/test_async.py b/test_async.py
new file mode 100644
index 0000000000..174bb3eade
--- /dev/null
+++ b/test_async.py
@@ -0,0 +1,53 @@
+import asyncio
+import django
+from django.conf import settings
+from django.http import HttpResponse
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='dummy',
+    ROOT_URLCONF=[],
+    ALLOWED_HOSTS=['*'],
+)
+
+django.setup()
+
+# Create a custom middleware
+class DebugMiddleware:
+    def __init__(self, get_response):
+        self.get_response = get_response
+
+    async def __call__(self, request):
+        print("Before get_response in middleware")
+        response = await self.get_response(request)
+        print(f"After get_response in middleware, response type: {type(response)}")
+        return response
+
+# Create a test view
+async def test_view(request):
+    print("In test_view")
+    return HttpResponse("Hello World")
+
+# Create a test request
+class MockRequest:
+    def __init__(self):
+        self.method = 'GET'
+        self.path = '/'
+        self.META = {}
+        self.close = lambda: None
+
+async def test():
+    # Create middleware chain
+    middleware = DebugMiddleware(test_view)
+    
+    # Create request
+    request = MockRequest()
+    
+    # Call middleware
+    response = await middleware(request)
+    print(f"Final response type: {type(response)}")
+
+if __name__ == '__main__':
+    loop = asyncio.get_event_loop()
+    loop.run_until_complete(test())
\ No newline at end of file
