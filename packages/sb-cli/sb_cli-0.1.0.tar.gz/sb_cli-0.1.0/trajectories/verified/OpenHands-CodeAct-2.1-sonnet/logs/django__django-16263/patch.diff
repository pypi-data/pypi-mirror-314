diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 9735ce10c8..7dc072665a 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -435,12 +435,43 @@ class Query(BaseExpression):
         annotation.set_source_expressions(new_exprs)
         return annotation, col_cnt
 
+    def _get_simple_aggregation(self, using, added_aggregate_names):
+        """
+        Get aggregation result for simple cases (no subquery needed).
+        """
+        # For count queries with no filters or ordering, we can use a simpler query
+        if len(added_aggregate_names) == 1 and added_aggregate_names[0] == "__count":
+            # Clear any existing select fields to make the query as simple as possible
+            self.default_cols = False
+            self.select = ()
+            self.select_related = False
+            self.clear_ordering(force=True)
+            
+        compiler = self.get_compiler(using=using)
+        result = compiler.execute_sql(SINGLE)
+        if result is None:
+            result = [0]
+        return {added_aggregate_names[0]: result[0]}
+
     def get_aggregation(self, using, added_aggregate_names):
         """
         Return the dictionary with the values of the existing aggregations.
         """
         if not self.annotation_select:
             return {}
+            
+        # For count() queries, we want to ignore any annotations that aren't used in filters
+        # or ordering, since they would unnecessarily complicate the query
+        if len(added_aggregate_names) == 1 and added_aggregate_names[0] == "__count":
+            # This is a count() query
+            if not self.where and not self.order_by:
+                # If there are no filters or ordering, we can safely remove all annotations
+                # except the count annotation
+                self.annotations = {k: v for k, v in self.annotations.items() if k == "__count"}
+                self.annotation_select_mask = None
+                self._annotation_select_cache = None
+                return self._get_simple_aggregation(using, added_aggregate_names)
+        
         existing_annotations = [
             annotation
             for alias, annotation in self.annotations.items()
@@ -550,6 +581,17 @@ class Query(BaseExpression):
         Perform a COUNT() query using the current filter constraints.
         """
         obj = self.clone()
+        
+        # For count() queries, we want to ignore any annotations that aren't used in filters
+        # or ordering, since they would unnecessarily complicate the query
+        if not obj.where and not obj.order_by:
+            # If there are no filters or ordering, we can safely remove all annotations
+            # and use a simple COUNT(*) query
+            obj = self.__class__(self.model)
+            obj.add_annotation(Count("*"), alias="__count", is_summary=True)
+            return obj.get_aggregation(using, ["__count"])["__count"]
+        
+        # If there are filters or ordering, we need to keep the annotations
         obj.add_annotation(Count("*"), alias="__count", is_summary=True)
         return obj.get_aggregation(using, ["__count"])["__count"]
 
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..591248647f
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,88 @@
+from django.conf import settings
+from django.db import models
+from django.db.models import Count
+
+# Configure Django settings
+import os
+import tempfile
+import time
+
+db_file = os.path.join(tempfile.gettempdir(), f'django_test_{int(time.time())}.db')
+
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': db_file,
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+import django
+django.setup()
+
+# Define test models
+import random
+import string
+APP_LABEL = ''.join(random.choices(string.ascii_lowercase, k=20))
+
+class Chapter(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = APP_LABEL
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    chapters = models.ManyToManyField(Chapter)
+    class Meta:
+        app_label = APP_LABEL
+
+# Create the tables
+from django.db import connection, connections
+
+# Close all existing connections
+for conn in connections.all():
+    conn.close()
+
+# Create tables
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Chapter)
+    schema_editor.create_model(Book)
+    schema_editor.create_model(Book.chapters.through)
+
+# Create some test data
+chapter1 = Chapter.objects.create(title='Chapter 1')
+chapter2 = Chapter.objects.create(title='Chapter 2')
+book = Book.objects.create(title='Test Book')
+book.chapters.add(chapter1, chapter2)
+
+# Test the queries
+from django.db import connection
+from django.db import reset_queries
+
+def print_last_query():
+    if connection.queries:
+        print("Last SQL query:")
+        print(connection.queries[-1]['sql'])
+    else:
+        print("No queries executed")
+
+# Enable query logging
+settings.DEBUG = True
+
+# Test case 1: Simple count
+reset_queries()
+count1 = Book.objects.count()
+print("\nSimple count:")
+print_last_query()
+
+# Test case 2: Count with unused annotation
+reset_queries()
+count2 = Book.objects.annotate(Count('chapters')).count()
+print("\nCount with unused annotation:")
+print_last_query()
+
+print(f"\nBoth counts return same value: {count1 == count2} ({count1}, {count2})")
\ No newline at end of file
diff --git a/reproduce2.py b/reproduce2.py
new file mode 100644
index 0000000000..61bd7d5f25
--- /dev/null
+++ b/reproduce2.py
@@ -0,0 +1,83 @@
+from django.conf import settings
+from django.db import models
+from django.db.models import Count
+
+# Configure Django settings
+import os
+import tempfile
+import random
+import string
+
+db_file = os.path.join(tempfile.gettempdir(), ''.join(random.choices(string.ascii_lowercase, k=20)) + '.db')
+
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': db_file,
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+import django
+django.setup()
+
+# Define test models
+APP_LABEL = ''.join(random.choices(string.ascii_lowercase, k=20))
+
+class Chapter(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = APP_LABEL
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    chapters = models.ManyToManyField(Chapter)
+    class Meta:
+        app_label = APP_LABEL
+
+# Create the tables
+from django.db import connection
+
+# Create tables
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Chapter)
+    schema_editor.create_model(Book)
+    schema_editor.create_model(Book.chapters.through)
+
+# Create some test data
+chapter1 = Chapter.objects.create(title='Chapter 1')
+chapter2 = Chapter.objects.create(title='Chapter 2')
+book = Book.objects.create(title='Test Book')
+book.chapters.add(chapter1, chapter2)
+
+# Test the queries
+from django.db import connection
+from django.db import reset_queries
+
+def print_last_query():
+    if connection.queries:
+        print("Last SQL query:")
+        print(connection.queries[-1]['sql'])
+    else:
+        print("No queries executed")
+
+# Enable query logging
+settings.DEBUG = True
+
+# Test case 1: Simple count
+reset_queries()
+count1 = Book.objects.count()
+print("\nSimple count:")
+print_last_query()
+
+# Test case 2: Count with unused annotation
+reset_queries()
+count2 = Book.objects.annotate(Count('chapters')).count()
+print("\nCount with unused annotation:")
+print_last_query()
+
+print(f"\nBoth counts return same value: {count1 == count2} ({count1}, {count2})")
\ No newline at end of file
diff --git a/reproduce3.py b/reproduce3.py
new file mode 100644
index 0000000000..7d3a44cf4d
--- /dev/null
+++ b/reproduce3.py
@@ -0,0 +1,89 @@
+from django.conf import settings
+from django.db import models
+from django.db.models import Count
+
+# Configure Django settings
+import os
+import tempfile
+import random
+import string
+
+db_file = os.path.join(tempfile.gettempdir(), ''.join(random.choices(string.ascii_lowercase, k=20)) + '.db')
+if os.path.exists(db_file):
+    os.unlink(db_file)
+
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': db_file,
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+import django
+django.setup()
+
+# Define test models
+APP_LABEL = ''.join(random.choices(string.ascii_lowercase, k=20))
+
+class Chapter(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = APP_LABEL
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    chapters = models.ManyToManyField(Chapter)
+    class Meta:
+        app_label = APP_LABEL
+
+# Create the tables
+from django.db import connection, connections
+
+# Close all existing connections
+for conn in connections.all():
+    conn.close()
+
+# Create tables
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Chapter)
+    schema_editor.create_model(Book)
+    schema_editor.create_model(Book.chapters.through)
+
+# Create some test data
+chapter1 = Chapter.objects.create(title='Chapter 1')
+chapter2 = Chapter.objects.create(title='Chapter 2')
+book = Book.objects.create(title='Test Book')
+book.chapters.add(chapter1, chapter2)
+
+# Test the queries
+from django.db import connection
+from django.db import reset_queries
+
+def print_last_query():
+    if connection.queries:
+        print("Last SQL query:")
+        print(connection.queries[-1]['sql'])
+    else:
+        print("No queries executed")
+
+# Enable query logging
+settings.DEBUG = True
+
+# Test case 1: Simple count
+reset_queries()
+count1 = Book.objects.count()
+print("\nSimple count:")
+print_last_query()
+
+# Test case 2: Count with unused annotation
+reset_queries()
+count2 = Book.objects.annotate(Count('chapters')).count()
+print("\nCount with unused annotation:")
+print_last_query()
+
+print(f"\nBoth counts return same value: {count1 == count2} ({count1}, {count2})")
\ No newline at end of file
diff --git a/reproduce4.py b/reproduce4.py
new file mode 100644
index 0000000000..fc7d89abae
--- /dev/null
+++ b/reproduce4.py
@@ -0,0 +1,89 @@
+from django.conf import settings
+from django.db import models
+from django.db.models import Count
+
+# Configure Django settings
+import os
+import tempfile
+import random
+import string
+
+db_file = os.path.join(tempfile.gettempdir(), ''.join(random.choices(string.ascii_lowercase, k=20)) + '.db')
+if os.path.exists(db_file):
+    os.unlink(db_file)
+
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+import django
+django.setup()
+
+# Define test models
+APP_LABEL = ''.join(random.choices(string.ascii_lowercase, k=20))
+
+class Chapter(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = APP_LABEL
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    chapters = models.ManyToManyField(Chapter)
+    class Meta:
+        app_label = APP_LABEL
+
+# Create the tables
+from django.db import connection, connections
+
+# Close all existing connections
+for conn in connections.all():
+    conn.close()
+
+# Create tables
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Chapter)
+    schema_editor.create_model(Book)
+    schema_editor.create_model(Book.chapters.through)
+
+# Create some test data
+chapter1 = Chapter.objects.create(title='Chapter 1')
+chapter2 = Chapter.objects.create(title='Chapter 2')
+book = Book.objects.create(title='Test Book')
+book.chapters.add(chapter1, chapter2)
+
+# Test the queries
+from django.db import connection
+from django.db import reset_queries
+
+def print_last_query():
+    if connection.queries:
+        print("Last SQL query:")
+        print(connection.queries[-1]['sql'])
+    else:
+        print("No queries executed")
+
+# Enable query logging
+settings.DEBUG = True
+
+# Test case 1: Simple count
+reset_queries()
+count1 = Book.objects.count()
+print("\nSimple count:")
+print_last_query()
+
+# Test case 2: Count with unused annotation
+reset_queries()
+count2 = Book.objects.annotate(Count('chapters')).count()
+print("\nCount with unused annotation:")
+print_last_query()
+
+print(f"\nBoth counts return same value: {count1 == count2} ({count1}, {count2})")
\ No newline at end of file
diff --git a/reproduce5.py b/reproduce5.py
new file mode 100644
index 0000000000..c63ea7758f
--- /dev/null
+++ b/reproduce5.py
@@ -0,0 +1,103 @@
+from django.conf import settings
+from django.db import models
+from django.db.models import Count
+
+# Configure Django settings
+import os
+import tempfile
+import random
+import string
+
+db_file = os.path.join(tempfile.gettempdir(), ''.join(random.choices(string.ascii_lowercase, k=20)) + '.db')
+if os.path.exists(db_file):
+    os.unlink(db_file)
+
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+import django
+django.setup()
+
+# Define test models
+APP_LABEL = ''.join(random.choices(string.ascii_lowercase, k=20))
+
+class Chapter(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = APP_LABEL
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    chapters = models.ManyToManyField(Chapter)
+    class Meta:
+        app_label = APP_LABEL
+
+# Create the tables
+from django.db import connection, connections
+
+# Close all existing connections
+for conn in connections.all():
+    conn.close()
+
+# Create tables
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.create_model(Chapter)
+        schema_editor.create_model(Book)
+        schema_editor.create_model(Book.chapters.through)
+    except Exception as e:
+        print(f"Error creating tables: {e}")
+        # Try to delete tables first
+        try:
+            schema_editor.delete_model(Book.chapters.through)
+            schema_editor.delete_model(Book)
+            schema_editor.delete_model(Chapter)
+        except:
+            pass
+        # Try to create tables again
+        schema_editor.create_model(Chapter)
+        schema_editor.create_model(Book)
+        schema_editor.create_model(Book.chapters.through)
+
+# Create some test data
+chapter1 = Chapter.objects.create(title='Chapter 1')
+chapter2 = Chapter.objects.create(title='Chapter 2')
+book = Book.objects.create(title='Test Book')
+book.chapters.add(chapter1, chapter2)
+
+# Test the queries
+from django.db import connection
+from django.db import reset_queries
+
+def print_last_query():
+    if connection.queries:
+        print("Last SQL query:")
+        print(connection.queries[-1]['sql'])
+    else:
+        print("No queries executed")
+
+# Enable query logging
+settings.DEBUG = True
+
+# Test case 1: Simple count
+reset_queries()
+count1 = Book.objects.count()
+print("\nSimple count:")
+print_last_query()
+
+# Test case 2: Count with unused annotation
+reset_queries()
+count2 = Book.objects.annotate(Count('chapters')).count()
+print("\nCount with unused annotation:")
+print_last_query()
+
+print(f"\nBoth counts return same value: {count1 == count2} ({count1}, {count2})")
\ No newline at end of file
diff --git a/reproduce6.py b/reproduce6.py
new file mode 100644
index 0000000000..bdb32c6381
--- /dev/null
+++ b/reproduce6.py
@@ -0,0 +1,108 @@
+from django.conf import settings
+from django.db import models
+from django.db.models import Count
+
+# Configure Django settings
+import os
+import tempfile
+import random
+import string
+
+db_file = os.path.join(tempfile.gettempdir(), ''.join(random.choices(string.ascii_lowercase, k=20)) + '.db')
+if os.path.exists(db_file):
+    os.unlink(db_file)
+
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+import django
+django.setup()
+
+# Define test models
+APP_LABEL = ''.join(random.choices(string.ascii_lowercase, k=20))
+
+class Chapter(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = APP_LABEL
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    chapters = models.ManyToManyField(Chapter)
+    class Meta:
+        app_label = APP_LABEL
+
+# Create the tables
+from django.db import connection, connections
+
+# Close all existing connections
+for conn in connections.all():
+    conn.close()
+
+# Create tables
+with connection.cursor() as cursor:
+    cursor.execute("""
+    CREATE TABLE IF NOT EXISTS {app}_chapter (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        title VARCHAR(100) NOT NULL
+    )
+    """.format(app=APP_LABEL))
+    
+    cursor.execute("""
+    CREATE TABLE IF NOT EXISTS {app}_book (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        title VARCHAR(100) NOT NULL
+    )
+    """.format(app=APP_LABEL))
+    
+    cursor.execute("""
+    CREATE TABLE IF NOT EXISTS {app}_book_chapters (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        book_id INTEGER NOT NULL REFERENCES {app}_book(id),
+        chapter_id INTEGER NOT NULL REFERENCES {app}_chapter(id),
+        UNIQUE(book_id, chapter_id)
+    )
+    """.format(app=APP_LABEL))
+
+# Create some test data
+chapter1 = Chapter.objects.create(title='Chapter 1')
+chapter2 = Chapter.objects.create(title='Chapter 2')
+book = Book.objects.create(title='Test Book')
+book.chapters.add(chapter1, chapter2)
+
+# Test the queries
+from django.db import connection
+from django.db import reset_queries
+
+def print_last_query():
+    if connection.queries:
+        print("Last SQL query:")
+        print(connection.queries[-1]['sql'])
+    else:
+        print("No queries executed")
+
+# Enable query logging
+settings.DEBUG = True
+
+# Test case 1: Simple count
+reset_queries()
+count1 = Book.objects.count()
+print("\nSimple count:")
+print_last_query()
+
+# Test case 2: Count with unused annotation
+reset_queries()
+count2 = Book.objects.annotate(Count('chapters')).count()
+print("\nCount with unused annotation:")
+print_last_query()
+
+print(f"\nBoth counts return same value: {count1 == count2} ({count1}, {count2})")
\ No newline at end of file
diff --git a/reproduce7.py b/reproduce7.py
new file mode 100644
index 0000000000..1de65b3580
--- /dev/null
+++ b/reproduce7.py
@@ -0,0 +1,130 @@
+from django.conf import settings
+from django.db import models
+from django.db.models import Count, F, Q
+
+# Configure Django settings
+import os
+import tempfile
+import random
+import string
+
+db_file = os.path.join(tempfile.gettempdir(), ''.join(random.choices(string.ascii_lowercase, k=20)) + '.db')
+if os.path.exists(db_file):
+    os.unlink(db_file)
+
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+import django
+django.setup()
+
+# Define test models
+APP_LABEL = ''.join(random.choices(string.ascii_lowercase, k=20))
+
+class Chapter(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = APP_LABEL
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    chapters = models.ManyToManyField(Chapter)
+    class Meta:
+        app_label = APP_LABEL
+
+# Create the tables
+from django.db import connection
+
+# Create tables
+with connection.cursor() as cursor:
+    cursor.execute("""
+    CREATE TABLE IF NOT EXISTS {app}_chapter (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        title VARCHAR(100) NOT NULL
+    )
+    """.format(app=APP_LABEL))
+    
+    cursor.execute("""
+    CREATE TABLE IF NOT EXISTS {app}_book (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        title VARCHAR(100) NOT NULL
+    )
+    """.format(app=APP_LABEL))
+    
+    cursor.execute("""
+    CREATE TABLE IF NOT EXISTS {app}_book_chapters (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        book_id INTEGER NOT NULL REFERENCES {app}_book(id),
+        chapter_id INTEGER NOT NULL REFERENCES {app}_chapter(id),
+        UNIQUE(book_id, chapter_id)
+    )
+    """.format(app=APP_LABEL))
+
+# Create some test data
+chapter1 = Chapter.objects.create(title='Chapter 1')
+chapter2 = Chapter.objects.create(title='Chapter 2')
+book = Book.objects.create(title='Test Book')
+book.chapters.add(chapter1, chapter2)
+
+# Test the queries
+from django.db import connection
+from django.db import reset_queries
+
+def print_last_query():
+    if connection.queries:
+        print("Last SQL query:")
+        print(connection.queries[-1]['sql'])
+    else:
+        print("No queries executed")
+
+# Enable query logging
+settings.DEBUG = True
+
+# Test case 1: Simple count
+reset_queries()
+count1 = Book.objects.count()
+print("\nSimple count:")
+print_last_query()
+
+# Test case 2: Count with unused annotation
+reset_queries()
+count2 = Book.objects.annotate(Count('chapters')).count()
+print("\nCount with unused annotation:")
+print_last_query()
+
+# Test case 3: Count with annotation used in filter
+reset_queries()
+count3 = Book.objects.annotate(num_chapters=Count('chapters')).filter(num_chapters__gt=0).count()
+print("\nCount with annotation used in filter:")
+print_last_query()
+
+# Test case 4: Count with annotation used in ordering
+reset_queries()
+count4 = Book.objects.annotate(num_chapters=Count('chapters')).order_by('num_chapters').count()
+print("\nCount with annotation used in ordering:")
+print_last_query()
+
+# Test case 5: Count with multiple annotations, some used and some unused
+reset_queries()
+count5 = Book.objects.annotate(
+    num_chapters=Count('chapters'),
+    unused=Count('chapters'),
+).filter(num_chapters__gt=0).count()
+print("\nCount with multiple annotations:")
+print_last_query()
+
+print(f"\nResults:")
+print(f"Simple count: {count1}")
+print(f"Count with unused annotation: {count2}")
+print(f"Count with annotation used in filter: {count3}")
+print(f"Count with annotation used in ordering: {count4}")
+print(f"Count with multiple annotations: {count5}")
\ No newline at end of file
