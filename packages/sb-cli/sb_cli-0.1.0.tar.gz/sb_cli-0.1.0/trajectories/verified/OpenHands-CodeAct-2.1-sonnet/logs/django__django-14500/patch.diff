diff --git a/db.sqlite3 b/db.sqlite3
new file mode 100644
index 0000000000..308135ecc9
Binary files /dev/null and b/db.sqlite3 differ
diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py
index 57042a8690..a2d592ddc9 100644
--- a/django/db/migrations/executor.py
+++ b/django/db/migrations/executor.py
@@ -33,10 +33,26 @@ class MigrationExecutor:
             if target[1] is None:
                 for root in self.loader.graph.root_nodes():
                     if root[0] == target[0]:
+                        # First, find any squashed migrations that need to be unapplied
+                        for key, squashed in self.loader.replacements.items():
+                            if key in applied and key[0] == target[0]:
+                                plan.append((self.loader.graph.nodes[key], True))
+                                applied.pop(key)
+                                # Also mark all replaced migrations as needing to be unapplied
+                                for replaced in squashed.replaces:
+                                    if replaced in applied:
+                                        plan.append((self.loader.graph.nodes[replaced], True))
+                                        applied.pop(replaced)
+                        # Then unapply the regular migrations
                         for migration in self.loader.graph.backwards_plan(root):
                             if migration in applied:
                                 plan.append((self.loader.graph.nodes[migration], True))
                                 applied.pop(migration)
+                                # Also mark any squashed migrations that contain this migration as needing to be unapplied
+                                for key, squashed in self.loader.replacements.items():
+                                    if migration in squashed.replaces and key in applied:
+                                        plan.append((self.loader.graph.nodes[key], True))
+                                        applied.pop(key)
             # If the migration is already applied, do backwards mode,
             # otherwise do forwards mode.
             elif target in applied:
@@ -50,10 +66,26 @@ class MigrationExecutor:
                     if n[0] == target[0]
                 )
                 for node in next_in_app:
+                    # First, find any squashed migrations that need to be unapplied
+                    for key, squashed in self.loader.replacements.items():
+                        if key in applied and key[0] == target[0]:
+                            plan.append((self.loader.graph.nodes[key], True))
+                            applied.pop(key)
+                            # Also mark all replaced migrations as needing to be unapplied
+                            for replaced in squashed.replaces:
+                                if replaced in applied:
+                                    plan.append((self.loader.graph.nodes[replaced], True))
+                                    applied.pop(replaced)
+                    # Then unapply the regular migrations
                     for migration in self.loader.graph.backwards_plan(node):
                         if migration in applied:
                             plan.append((self.loader.graph.nodes[migration], True))
                             applied.pop(migration)
+                            # Also mark any squashed migrations that contain this migration as needing to be unapplied
+                            for key, squashed in self.loader.replacements.items():
+                                if migration in squashed.replaces and key in applied:
+                                    plan.append((self.loader.graph.nodes[key], True))
+                                    applied.pop(key)
             else:
                 for migration in self.loader.graph.forwards_plan(target):
                     if migration not in applied:
@@ -118,10 +150,19 @@ class MigrationExecutor:
         else:
             # No need to check for `elif all_backwards` here, as that condition
             # would always evaluate to true.
+            # First, find any squashed migrations that contain the migrations we're unapplying
+            for migration, _ in plan:
+                for key, squashed in self.loader.replacements.items():
+                    if (migration.app_label, migration.name) in squashed.replaces:
+                        # If this migration is part of a squashed migration, mark the squashed migration as unapplied
+                        self.recorder.record_unapplied(*key)
+                        # Also mark all other replaced migrations as unapplied
+                        for replaced_app_label, replaced_name in squashed.replaces:
+                            if (replaced_app_label, replaced_name) != (migration.app_label, migration.name):
+                                self.recorder.record_unapplied(replaced_app_label, replaced_name)
+            # Then unapply the migrations
             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
 
-        self.check_replacements()
-
         return state
 
     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
@@ -195,6 +236,8 @@ class MigrationExecutor:
         for migration, _ in plan:
             self.unapply_migration(states[migration], migration, fake=fake)
             applied_migrations.remove(migration)
+            # Check replacements after each unapply to ensure squashed migrations are marked correctly
+            self.check_replacements()
 
         # Generate the post migration state by starting from the state before
         # the last migration is unapplied and mutating it to include all the
@@ -254,8 +297,25 @@ class MigrationExecutor:
         if migration.replaces:
             for app_label, name in migration.replaces:
                 self.recorder.record_unapplied(app_label, name)
+            # Also mark the squashed migration as unapplied
+            self.recorder.record_unapplied(migration.app_label, migration.name)
         else:
             self.recorder.record_unapplied(migration.app_label, migration.name)
+            # Check if this migration is part of any squashed migrations
+            for key, squashed in self.loader.replacements.items():
+                if (migration.app_label, migration.name) in squashed.replaces:
+                    # If this migration is part of a squashed migration, mark the squashed migration as unapplied
+                    self.recorder.record_unapplied(*key)
+                    # Also mark all other replaced migrations as unapplied
+                    for replaced_app_label, replaced_name in squashed.replaces:
+                        if (replaced_app_label, replaced_name) != (migration.app_label, migration.name):
+                            self.recorder.record_unapplied(replaced_app_label, replaced_name)
+        # Check if any squashed migrations need to be marked as unapplied
+        for key, squashed in self.loader.replacements.items():
+            if key in self.loader.applied_migrations:
+                # If any of the replaced migrations are unapplied, mark the squashed migration as unapplied
+                if any(m not in self.loader.applied_migrations for m in squashed.replaces):
+                    self.recorder.record_unapplied(*key)
         # Report progress
         if self.progress_callback:
             self.progress_callback("unapply_success", migration, fake)
@@ -263,7 +323,8 @@ class MigrationExecutor:
 
     def check_replacements(self):
         """
-        Mark replacement migrations applied if their replaced set all are.
+        Mark replacement migrations applied if their replaced set all are,
+        and mark them unapplied if any of their replaced migrations are unapplied.
 
         Do this unconditionally on every migrate, rather than just when
         migrations are applied or unapplied, to correctly handle the case
@@ -274,9 +335,31 @@ class MigrationExecutor:
         """
         applied = self.recorder.applied_migrations()
         for key, migration in self.loader.replacements.items():
-            all_applied = all(m in applied for m in migration.replaces)
-            if all_applied and key not in applied:
-                self.recorder.record_applied(*key)
+            # Check if any of the replaced migrations are unapplied
+            any_unapplied = any(m not in applied for m in migration.replaces)
+            if any_unapplied:
+                # If any replaced migration is unapplied, mark the squashed migration as unapplied
+                if key in applied:
+                    self.recorder.record_unapplied(*key)
+                # Also mark all replaced migrations as unapplied
+                for replaced in migration.replaces:
+                    if replaced in applied:
+                        self.recorder.record_unapplied(*replaced)
+            else:
+                # If all replaced migrations are applied, mark the squashed migration as applied
+                if key not in applied:
+                    self.recorder.record_applied(*key)
+            # Also check if any replaced migrations are unapplied
+            for replaced in migration.replaces:
+                if replaced not in applied:
+                    # If a replaced migration is unapplied, mark the squashed migration as unapplied
+                    if key in applied:
+                        self.recorder.record_unapplied(*key)
+                        # Also mark all other replaced migrations as unapplied
+                        for other_replaced in migration.replaces:
+                            if other_replaced != replaced and other_replaced in applied:
+                                self.recorder.record_unapplied(*other_replaced)
+                        break
 
     def detect_soft_applied(self, project_state, migration):
         """
diff --git a/django/db/migrations/graph.py b/django/db/migrations/graph.py
index f70e359018..71c4919897 100644
--- a/django/db/migrations/graph.py
+++ b/django/db/migrations/graph.py
@@ -156,39 +156,33 @@ class MigrationGraph:
 
     def remove_replacement_node(self, replacement, replaced):
         """
-        The inverse operation to `remove_replaced_nodes`. Almost. Remove the
-        replacement node `replacement` and remap its child nodes to `replaced`
-        - the list of nodes it would have replaced. Don't remap its parent
-        nodes as they are expected to be correct already.
+        The inverse operation to `remove_replaced_nodes`. Almost. Instead of removing
+        the replacement node, keep both it and its replaced nodes in the graph,
+        but ensure they are properly linked so that when unapplying migrations,
+        both sets are handled correctly.
         """
-        self.nodes.pop(replacement, None)
         try:
-            replacement_node = self.node_map.pop(replacement)
+            replacement_node = self.node_map[replacement]
         except KeyError as err:
             raise NodeNotFoundError(
-                "Unable to remove replacement node %r. It was either never added"
+                "Unable to find replacement node %r. It was either never added"
                 " to the migration graph, or has been removed already." % (replacement,),
                 replacement
             ) from err
-        replaced_nodes = set()
-        replaced_nodes_parents = set()
+
+        # Get all replaced nodes that exist
+        replaced_nodes = []
         for key in replaced:
             replaced_node = self.node_map.get(key)
             if replaced_node:
-                replaced_nodes.add(replaced_node)
-                replaced_nodes_parents |= replaced_node.parents
-        # We're only interested in the latest replaced node, so filter out
-        # replaced nodes that are parents of other replaced nodes.
-        replaced_nodes -= replaced_nodes_parents
-        for child in replacement_node.children:
-            child.parents.remove(replacement_node)
-            for replaced_node in replaced_nodes:
-                replaced_node.add_child(child)
-                child.add_parent(replaced_node)
-        for parent in replacement_node.parents:
-            parent.children.remove(replacement_node)
-            # NOTE: There is no need to remap parent dependencies as we can
-            # assume the replaced nodes already have the correct ancestry.
+                replaced_nodes.append(replaced_node)
+
+        # Add dependencies between replacement and replaced nodes
+        for replaced_node in replaced_nodes:
+            # Make the replacement node depend on all replaced nodes
+            # This ensures that when unapplying, the replacement is unapplied first
+            replacement_node.add_parent(replaced_node)
+            replaced_node.add_child(replacement_node)
 
     def validate_consistency(self):
         """Ensure there are no dummy nodes remaining in the graph."""
diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py
index eb370164f3..5eced481be 100644
--- a/django/db/migrations/loader.py
+++ b/django/db/migrations/loader.py
@@ -245,15 +245,15 @@ class MigrationLoader:
                     self.applied_migrations[key] = migration
                 else:
                     self.applied_migrations.pop(key, None)
-                # A replacing migration can be used if either all or none of
-                # its replacement targets have been applied.
-                if all(applied_statuses) or (not any(applied_statuses)):
-                    self.graph.remove_replaced_nodes(key, migration.replaces)
+                # Keep both the squashed migration and its replaced migrations
+                # in the graph to handle unapply correctly
+                if all(applied_statuses):
+                    self.applied_migrations[key] = migration
                 else:
-                    # This replacing migration cannot be used because it is
-                    # partially applied. Remove it from the graph and remap
-                    # dependencies to it (#25945).
-                    self.graph.remove_replacement_node(key, migration.replaces)
+                    self.applied_migrations.pop(key, None)
+                # Add dependencies between the squashed migration and its replaced migrations
+                for replaced in migration.replaces:
+                    self.graph.add_dependency(migration, key, replaced, skip_validation=True)
         # Ensure the graph is consistent.
         try:
             self.graph.validate_consistency()
diff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py
index 1a37c6b7d0..922f71a8b2 100644
--- a/django/db/migrations/recorder.py
+++ b/django/db/migrations/recorder.py
@@ -84,12 +84,33 @@ class MigrationRecorder:
     def record_applied(self, app, name):
         """Record that a migration was applied."""
         self.ensure_schema()
+        # Create the migration record
         self.migration_qs.create(app=app, name=name)
+        # Also mark any squashed migrations that contain this migration as applied
+        for migration in self.migration_qs.all():
+            if hasattr(migration, 'replaces') and (app, name) in migration.replaces:
+                self.migration_qs.get_or_create(app=migration.app, name=migration.name)
 
     def record_unapplied(self, app, name):
         """Record that a migration was unapplied."""
         self.ensure_schema()
+        # Delete the migration record
         self.migration_qs.filter(app=app, name=name).delete()
+        # Also delete any squashed migrations that contain this migration
+        for migration in self.migration_qs.all():
+            if hasattr(migration, 'replaces') and (app, name) in migration.replaces:
+                self.migration_qs.filter(app=migration.app, name=migration.name).delete()
+                # Also delete all other replaced migrations
+                for replaced_app, replaced_name in migration.replaces:
+                    self.migration_qs.filter(app=replaced_app, name=replaced_name).delete()
+                # Also delete any squashed migrations that contain any of the replaced migrations
+                for replaced_app, replaced_name in migration.replaces:
+                    for other_migration in self.migration_qs.all():
+                        if hasattr(other_migration, 'replaces') and (replaced_app, replaced_name) in other_migration.replaces:
+                            self.migration_qs.filter(app=other_migration.app, name=other_migration.name).delete()
+                            # Also delete all other replaced migrations in the squashed migration
+                            for other_replaced_app, other_replaced_name in other_migration.replaces:
+                                self.migration_qs.filter(app=other_replaced_app, name=other_replaced_name).delete()
 
     def flush(self):
         """Delete all migration records. Useful for testing migrations."""
diff --git a/loader.py.patch b/loader.py.patch
new file mode 100644
index 0000000000..4e192f2c6f
--- /dev/null
+++ b/loader.py.patch
@@ -0,0 +1,23 @@
+diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py
+index 0000000..0000000 100644
+--- a/django/db/migrations/loader.py
++++ b/django/db/migrations/loader.py
+@@ -248,13 +248,12 @@ class MigrationLoader:
+                 # A replacing migration can be used if either all or none of
+                 # its replacement targets have been applied.
+-                if all(applied_statuses) or (not any(applied_statuses)):
+-                    self.graph.remove_replaced_nodes(key, migration.replaces)
+-                else:
+-                    # This replacing migration cannot be used because it is
+-                    # partially applied. Remove it from the graph and remap
+-                    # dependencies to it (#25945).
+-                    self.graph.remove_replacement_node(key, migration.replaces)
++                # Keep both the squashed migration and its replaced migrations
++                # in the graph to handle unapply correctly
++                if all(applied_statuses):
++                    self.applied_migrations[key] = migration
++                else:
++                    self.applied_migrations.pop(key, None)
++                # Add dependencies between the squashed migration and its replaced migrations
++                for replaced in migration.replaces:
++                    self.graph.add_dependency(migration, key, replaced, skip_validation=True)
\ No newline at end of file
diff --git a/reproduce_squash_issue.py b/reproduce_squash_issue.py
new file mode 100644
index 0000000000..ee17082f92
--- /dev/null
+++ b/reproduce_squash_issue.py
@@ -0,0 +1,122 @@
+import os
+import sys
+import django
+
+# Add test_app to Python path
+sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+from django.db import connection
+from django.db.migrations.loader import MigrationLoader
+from django.db.migrations.recorder import MigrationRecorder
+from django.db.migrations.executor import MigrationExecutor
+
+# Setup Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_project.settings')
+
+# Create a test project settings
+os.makedirs('test_project', exist_ok=True)
+with open('test_project/settings.py', 'w') as f:
+    f.write('''
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': 'db.sqlite3',
+    }
+}
+INSTALLED_APPS = ['test_app']
+SECRET_KEY = 'dummy'
+''')
+
+with open('test_project/__init__.py', 'w') as f:
+    f.write('')
+
+# Create a test app with migrations
+os.makedirs('test_app/migrations', exist_ok=True)
+with open('test_app/__init__.py', 'w') as f:
+    f.write('')
+
+# Create initial migration
+with open('test_app/migrations/0001_initial.py', 'w') as f:
+    f.write('''
+from django.db import migrations, models
+
+class Migration(migrations.Migration):
+    initial = True
+    dependencies = []
+    operations = [
+        migrations.CreateModel(
+            name='TestModel',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('name', models.CharField(max_length=100)),
+            ],
+        ),
+    ]
+''')
+
+# Create second migration
+with open('test_app/migrations/0002_add_field.py', 'w') as f:
+    f.write('''
+from django.db import migrations, models
+
+class Migration(migrations.Migration):
+    dependencies = [('test_app', '0001_initial')]
+    operations = [
+        migrations.AddField(
+            model_name='TestModel',
+            name='description',
+            field=models.TextField(null=True),
+        ),
+    ]
+''')
+
+# Create squashed migration
+with open('test_app/migrations/0001_squashed_0002.py', 'w') as f:
+    f.write('''
+from django.db import migrations, models
+
+class Migration(migrations.Migration):
+    replaces = [
+        ('test_app', '0001_initial'),
+        ('test_app', '0002_add_field'),
+    ]
+    dependencies = []
+    operations = [
+        migrations.CreateModel(
+            name='TestModel',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('name', models.CharField(max_length=100)),
+                ('description', models.TextField(null=True)),
+            ],
+        ),
+    ]
+''')
+
+django.setup()
+
+# Initialize migrations
+executor = MigrationExecutor(connection)
+recorder = MigrationRecorder(connection)
+recorder.ensure_schema()
+
+# Print available migrations
+loader = MigrationLoader(connection)
+print("Available migrations:", loader.disk_migrations)
+
+# Apply the squashed migration first
+executor.migrate([('test_app', '0001_squashed_0002')], fake=True)
+
+print("Initial state:")
+print("Applied migrations:", sorted(recorder.applied_migrations()))
+
+# Now unapply one of the original migrations
+executor.migrate([('test_app', '0001_initial')], fake=True)
+
+print("\nAfter unapplying one migration:")
+print("Applied migrations:", sorted(recorder.applied_migrations()))
+
+# Now unapply the migrations
+executor.migrate([('test_app', None)])
+
+print("\nAfter unapplying:")
+print("Applied migrations:", sorted(recorder.applied_migrations()))
\ No newline at end of file
diff --git a/test_app/__init__.py b/test_app/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/apps.py b/test_app/apps.py
new file mode 100644
index 0000000000..ae6f331d8b
--- /dev/null
+++ b/test_app/apps.py
@@ -0,0 +1,4 @@
+from django.apps import AppConfig
+
+class TestAppConfig(AppConfig):
+    name = 'test_app'
\ No newline at end of file
diff --git a/test_app/migrations/0001_initial.py b/test_app/migrations/0001_initial.py
new file mode 100644
index 0000000000..a1cc1d8835
--- /dev/null
+++ b/test_app/migrations/0001_initial.py
@@ -0,0 +1,15 @@
+
+from django.db import migrations, models
+
+class Migration(migrations.Migration):
+    initial = True
+    dependencies = []
+    operations = [
+        migrations.CreateModel(
+            name='TestModel',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('name', models.CharField(max_length=100)),
+            ],
+        ),
+    ]
diff --git a/test_app/migrations/0001_squashed_0002.py b/test_app/migrations/0001_squashed_0002.py
new file mode 100644
index 0000000000..8a2758d6c3
--- /dev/null
+++ b/test_app/migrations/0001_squashed_0002.py
@@ -0,0 +1,19 @@
+
+from django.db import migrations, models
+
+class Migration(migrations.Migration):
+    replaces = [
+        ('test_app', '0001_initial'),
+        ('test_app', '0002_add_field'),
+    ]
+    dependencies = []
+    operations = [
+        migrations.CreateModel(
+            name='TestModel',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('name', models.CharField(max_length=100)),
+                ('description', models.TextField(null=True)),
+            ],
+        ),
+    ]
diff --git a/test_app/migrations/0002_add_field.py b/test_app/migrations/0002_add_field.py
new file mode 100644
index 0000000000..6a69259502
--- /dev/null
+++ b/test_app/migrations/0002_add_field.py
@@ -0,0 +1,12 @@
+
+from django.db import migrations, models
+
+class Migration(migrations.Migration):
+    dependencies = [('test_app', '0001_initial')]
+    operations = [
+        migrations.AddField(
+            model_name='TestModel',
+            name='description',
+            field=models.TextField(null=True),
+        ),
+    ]
diff --git a/test_app/migrations/__init__.py b/test_app/migrations/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/models.py b/test_app/models.py
new file mode 100644
index 0000000000..b4facae6b9
--- /dev/null
+++ b/test_app/models.py
@@ -0,0 +1,5 @@
+from django.db import models
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    description = models.TextField(null=True)
\ No newline at end of file
diff --git a/test_project/__init__.py b/test_project/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_project/settings.py b/test_project/settings.py
new file mode 100644
index 0000000000..a38bde405c
--- /dev/null
+++ b/test_project/settings.py
@@ -0,0 +1,9 @@
+
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': 'db.sqlite3',
+    }
+}
+INSTALLED_APPS = ['test_app']
+SECRET_KEY = 'dummy'
