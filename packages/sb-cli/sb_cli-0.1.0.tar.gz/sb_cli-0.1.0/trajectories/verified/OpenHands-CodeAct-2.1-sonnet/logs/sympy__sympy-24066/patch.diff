diff --git a/edge_cases.py b/edge_cases.py
new file mode 100644
index 0000000000..12e76c9ebc
--- /dev/null
+++ b/edge_cases.py
@@ -0,0 +1,73 @@
+from sympy import exp, log, sin, cos, tan, sinh, cosh, tanh
+from sympy.physics import units
+from sympy.physics.units.systems.si import SI
+
+def test_case(expr, name=""):
+    print(f"\nTesting {name}:")
+    try:
+        result = SI._collect_factor_and_dimension(expr)
+        print(f"Success! Result: {result}")
+    except ValueError as e:
+        print(f"Error: {e}")
+
+# Test case 1: Simple dimensionless number in exp
+test_case(exp(2), "exp(2)")
+
+# Test case 2: Dimensionless expression in exp
+expr = units.meter / units.meter
+test_case(exp(expr), "exp(meter/meter)")
+
+# Test case 3: Dimensional expression in exp (should fail)
+expr = units.meter
+test_case(exp(expr), "exp(meter)")
+
+# Test case 4: Complex expression with multiple exp terms
+expr = 1 + exp(2) + exp(units.second/(units.ohm * units.farad))
+test_case(expr, "1 + exp(2) + exp(dimensionless)")
+
+# Test case 5: Nested exp with dimensionless
+expr = exp(exp(units.meter/units.meter))
+test_case(expr, "exp(exp(dimensionless))")
+
+# Test case 6: Nested exp with dimensional (should fail)
+expr = exp(exp(units.meter))
+test_case(expr, "exp(exp(meter))")
+
+# Test case 7: Mixed dimensional operations
+expr = 2*units.meter + exp(1)
+test_case(expr, "2*meter + exp(1)")
+
+# Test case 8: Other transcendental functions with dimensional arguments (should fail)
+expr = log(units.meter)
+test_case(expr, "log(meter)")
+
+expr = sin(units.meter)
+test_case(expr, "sin(meter)")
+
+expr = cos(units.second)
+test_case(expr, "cos(second)")
+
+expr = tan(units.kilogram)
+test_case(expr, "tan(kilogram)")
+
+# Test case 9: Other transcendental functions with dimensionless arguments
+expr = sin(units.meter/units.meter)
+test_case(expr, "sin(meter/meter)")
+
+expr = cos(2)
+test_case(expr, "cos(2)")
+
+expr = sinh(units.second/units.second)
+test_case(expr, "sinh(second/second)")
+
+# Test case 10: Complex expressions with multiple transcendental functions
+expr = sin(2) + cos(units.meter/units.meter) + tanh(1)
+test_case(expr, "sin(2) + cos(meter/meter) + tanh(1)")
+
+# Test case 11: Nested transcendental functions
+expr = sin(cos(units.meter/units.meter))
+test_case(expr, "sin(cos(meter/meter))")
+
+# Test case 12: Mixed dimensional operations with transcendental functions
+expr = units.meter * sin(1)
+test_case(expr, "meter * sin(1)")
\ No newline at end of file
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..f1a35c9e03
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,17 @@
+from sympy import exp
+from sympy.physics import units
+from sympy.physics.units.systems.si import SI
+
+expr = units.second / (units.ohm * units.farad)
+dim = SI._collect_factor_and_dimension(expr)[1]
+
+print("First assertion:")
+print(f"Is dimensionless: {SI.get_dimension_system().is_dimensionless(dim)}")
+assert SI.get_dimension_system().is_dimensionless(dim)
+
+print("\nSecond test:")
+buggy_expr = 100 + exp(expr)
+try:
+    SI._collect_factor_and_dimension(buggy_expr)
+except ValueError as e:
+    print(f"Error: {e}")
\ No newline at end of file
diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py
index 3daf84c108..788e2085a9 100644
--- a/sympy/physics/units/unitsystem.py
+++ b/sympy/physics/units/unitsystem.py
@@ -8,6 +8,9 @@
 from sympy.core.function import (Derivative, Function)
 from sympy.core.mul import Mul
 from sympy.core.power import Pow
+from sympy.functions.elementary.exponential import exp, log
+from sympy.functions.elementary.trigonometric import sin, cos, tan, asin, acos, atan
+from sympy.functions.elementary.hyperbolic import sinh, cosh, tanh, asinh, acosh, atanh
 from sympy.core.singleton import S
 from sympy.physics.units.dimensions import _QuantityMapper
 from sympy.physics.units.quantities import Quantity
@@ -190,10 +193,23 @@ def _collect_factor_and_dimension(self, expr):
                 dim /= idim**count
             return factor, dim
         elif isinstance(expr, Function):
-            fds = [self._collect_factor_and_dimension(
-                arg) for arg in expr.args]
-            return (expr.func(*(f[0] for f in fds)),
-                    *(d[1] for d in fds))
+            # Functions that require dimensionless arguments
+            dimensionless_functions = (
+                exp, log,  # exponential functions
+                sin, cos, tan, asin, acos, atan,  # trigonometric functions
+                sinh, cosh, tanh, asinh, acosh, atanh,  # hyperbolic functions
+            )
+            if expr.func in dimensionless_functions:
+                fds = [self._collect_factor_and_dimension(arg) for arg in expr.args]
+                for arg_factor, arg_dim in fds:
+                    if not self.get_dimension_system().is_dimensionless(arg_dim):
+                        raise ValueError(
+                            'Dimension of "{}" is {}, but it should be dimensionless'.format(
+                                expr.args[0], arg_dim))
+                return expr.func(*(f[0] for f in fds)), Dimension(1)
+            else:
+                fds = [self._collect_factor_and_dimension(arg) for arg in expr.args]
+                return (expr.func(*(f[0] for f in fds)), *(d[1] for d in fds))
         elif isinstance(expr, Dimension):
             return S.One, expr
         else:
