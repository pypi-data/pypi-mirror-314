diff --git a/django/core/handlers/wsgi.py b/django/core/handlers/wsgi.py
index 2c1c4db241..b2f3e57002 100644
--- a/django/core/handlers/wsgi.py
+++ b/django/core/handlers/wsgi.py
@@ -152,8 +152,9 @@ class WSGIHandler(base.BaseHandler):
 def get_path_info(environ):
     """Return the HTTP request's PATH_INFO as a string."""
     path_info = get_bytes_from_wsgi(environ, 'PATH_INFO', '/')
-
-    return repercent_broken_unicode(path_info).decode()
+    if isinstance(path_info, str):
+        path_info = path_info.encode('iso-8859-1')
+    return repercent_broken_unicode(path_info).decode('utf-8')
 
 
 def get_script_name(environ):
diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py
index 14dab517c9..d096620b84 100644
--- a/django/core/servers/basehttp.py
+++ b/django/core/servers/basehttp.py
@@ -77,9 +77,7 @@ class WSGIServer(simple_server.WSGIServer):
             super().handle_error(request, client_address)
 
 
-class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):
-    """A threaded version of the WSGIServer"""
-    daemon_threads = True
+from django.core.servers.threadedwsgi import ThreadedWSGIServer  # noqa
 
 
 class ServerHandler(simple_server.ServerHandler):
diff --git a/django/core/servers/threadedwsgi.py b/django/core/servers/threadedwsgi.py
new file mode 100644
index 0000000000..7b4315063b
--- /dev/null
+++ b/django/core/servers/threadedwsgi.py
@@ -0,0 +1,44 @@
+"""
+A threaded WSGI server that properly handles database connections.
+"""
+
+import threading
+import socketserver
+from django.core.servers.basehttp import WSGIServer
+from django.db import connections
+
+
+class DatabaseAwareThreadingMixIn(socketserver.ThreadingMixIn):
+    """A ThreadingMixIn that ensures database connections are closed when threads exit."""
+    daemon_threads = True
+    _threads = []  # Use a list instead of set to avoid join() issues
+
+    def process_request_thread(self, request, client_address):
+        try:
+            super().process_request_thread(request, client_address)
+        finally:
+            # Close all database connections in this thread
+            connections.close_all()
+
+    def process_request(self, request, client_address):
+        """Start a new thread to process the request."""
+        t = threading.Thread(target=self.process_request_thread,
+                           args=(request, client_address))
+        t.daemon = self.daemon_threads
+        self._threads.append(t)
+        t.start()
+
+    def server_close(self):
+        """Wait for all non-daemon threads to complete."""
+        # Only wait for non-daemon threads since daemon threads will be terminated abruptly
+        live_threads = [t for t in self._threads if t.is_alive() and not t.daemon]
+        for t in live_threads:
+            t.join()
+        self._threads.clear()
+        # Call parent's server_close() but skip ThreadingMixIn's since it tries to join _threads
+        WSGIServer.server_close(self)
+
+
+class ThreadedWSGIServer(DatabaseAwareThreadingMixIn, WSGIServer):
+    """A threaded WSGI server that properly closes database connections."""
+    pass
\ No newline at end of file
diff --git a/django/test/testcases.py b/django/test/testcases.py
index 92f566b7b0..736095f016 100644
--- a/django/test/testcases.py
+++ b/django/test/testcases.py
@@ -1417,6 +1417,8 @@ class FSFilesHandler(WSGIHandler):
         * the host is provided as part of the base_url
         * the request's path isn't under the media path (or equal)
         """
+        if isinstance(path, bytes):
+            path = path.decode('utf-8')
         return path.startswith(self.base_url[2]) and not self.base_url[1]
 
     def file_path(self, url):
@@ -1460,6 +1462,21 @@ class _StaticFilesHandler(FSFilesHandler):
     def get_base_url(self):
         return settings.STATIC_URL
 
+    def _should_handle(self, path):
+        """
+        Check if the path should be handled. Ignore the path if:
+        * the host is provided as part of the base_url
+        * the request's path isn't under the media path (or equal)
+        """
+        if isinstance(path, bytes):
+            path = path.decode('utf-8')
+        base_url = self.get_base_url()
+        if base_url is None:
+            return False
+        if isinstance(base_url, bytes):
+            base_url = base_url.decode('utf-8')
+        return path.startswith(base_url)
+
 
 class _MediaFilesHandler(FSFilesHandler):
     """
@@ -1511,6 +1528,7 @@ class LiveServerThread(threading.Thread):
             self.error = e
             self.is_ready.set()
         finally:
+            # Ensure all database connections are closed in this thread
             connections.close_all()
 
     def _create_server(self):
@@ -1524,6 +1542,8 @@ class LiveServerThread(threading.Thread):
         if hasattr(self, 'httpd'):
             # Stop the WSGI server
             self.httpd.shutdown()
+            # Close all database connections in the main thread
+            connections.close_all()
             self.httpd.server_close()
         self.join()
 
diff --git a/tests/test_db_connections.py b/tests/test_db_connections.py
new file mode 100644
index 0000000000..e363605026
--- /dev/null
+++ b/tests/test_db_connections.py
@@ -0,0 +1,104 @@
+"""
+Test that database connections are properly closed in LiveServerTestCase.
+"""
+import os
+import sys
+import unittest
+import django
+from django.test import LiveServerTestCase
+from django.db import connections
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        MIDDLEWARE=[],
+        ROOT_URLCONF=None,
+        SECRET_KEY='dummy',
+    )
+    django.setup()
+
+class TestDatabaseConnections(LiveServerTestCase):
+    def test_db_connections(self):
+        """Test that database connections are properly closed."""
+        # Get initial connection count
+        initial_connections = len(connections.all())
+        print(f"Initial connections: {initial_connections}")
+
+        # Make some requests to create threads
+        import urllib.request
+        import threading
+        import queue
+
+        # Create a queue to store any exceptions from threads
+        exceptions_queue = queue.Queue()
+
+        def make_request(url, exceptions_queue):
+            try:
+                urllib.request.urlopen(url)
+            except urllib.error.URLError:
+                # Expected 404 error, we just want to create threads
+                pass
+            except Exception as e:
+                exceptions_queue.put(e)
+
+        # Create and start threads for concurrent requests
+        threads = []
+        for i in range(10):
+            t = threading.Thread(target=make_request, 
+                               args=(f"{self.live_server_url}/test{i}", exceptions_queue))
+            threads.append(t)
+            t.start()
+
+        # Wait for all threads to complete
+        for t in threads:
+            t.join()
+
+        # Check if any exceptions occurred in the threads
+        if not exceptions_queue.empty():
+            raise exceptions_queue.get()
+
+        # Get connection count after requests
+        mid_connections = len(connections.all())
+        print(f"Connections after requests: {mid_connections}")
+
+        # The connection count should be the same as initial
+        self.assertEqual(initial_connections, mid_connections,
+                        "Database connections were not properly closed")
+
+        # Test reconnection after connection close
+        for conn in connections.all():
+            conn.close()
+            conn.connect()
+            conn.close()
+
+        # Make more concurrent requests after reconnection
+        threads = []
+        for i in range(10):
+            t = threading.Thread(target=make_request, 
+                               args=(f"{self.live_server_url}/test{i}", exceptions_queue))
+            threads.append(t)
+            t.start()
+
+        # Wait for all threads to complete
+        for t in threads:
+            t.join()
+
+        # Check if any exceptions occurred in the threads
+        if not exceptions_queue.empty():
+            raise exceptions_queue.get()
+
+        # Get final connection count
+        final_connections = len(connections.all())
+        print(f"Connections after reconnection: {final_connections}")
+        self.assertEqual(initial_connections, final_connections,
+                        "Database connections were not properly closed after reconnection")
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
