diff --git a/classes.dot b/classes.dot
new file mode 100644
index 000000000..ac56d09e3
--- /dev/null
+++ b/classes.dot
@@ -0,0 +1,7 @@
+digraph "classes" {
+charset="utf-8"
+rankdir=BT
+"0" [label="{C|a : String\lb : Integer\lc\l|}", shape="record"];
+"1" [label="{D|\l|}", shape="record"];
+"1" -> "0" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="c", style="solid"];
+}
diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py
index bf9f67af6..c3ca6739a 100644
--- a/pylint/pyreverse/diagrams.py
+++ b/pylint/pyreverse/diagrams.py
@@ -118,10 +118,30 @@ class ClassDiagram(Figure, FilterMixIn):
     def class_names(self, nodes):
         """return class names if needed in diagram"""
         names = []
+        type_map = {
+            "str": "String",
+            "int": "Integer",
+            "float": "Float",
+            "bool": "Boolean",
+            "list": "List",
+            "dict": "Dictionary",
+            "tuple": "Tuple",
+            "set": "Set",
+            "String": "String",
+            "Integer": "Integer",
+            "Float": "Float",
+            "Boolean": "Boolean",
+            "List": "List",
+            "Dictionary": "Dictionary",
+            "Tuple": "Tuple",
+            "Set": "Set"
+        }
         for node in nodes:
             if isinstance(node, astroid.Instance):
                 node = node._proxied
-            if (
+            if isinstance(node, astroid.Name) and node.name in type_map:
+                names.append(type_map[node.name])
+            elif (
                 isinstance(node, astroid.ClassDef)
                 and hasattr(node, "name")
                 and not self.has_node(node)
diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py
index 8fa122022..9b2007255 100644
--- a/pylint/pyreverse/inspector.py
+++ b/pylint/pyreverse/inspector.py
@@ -177,6 +177,7 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
 
         * set the locals_type mapping
         * optionally tag the node with a unique id
+        * handle type annotations
         """
         if hasattr(node, "locals_type"):
             return
@@ -184,6 +185,38 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
         if self.tag:
             node.uid = self.generate_id()
 
+        # Handle type annotations in function arguments
+        if node.args and node.args.annotations:
+            for i, arg in enumerate(node.args.args):
+                if i < len(node.args.annotations) and node.args.annotations[i]:
+                    annotation = node.args.annotations[i]
+                    if isinstance(annotation, astroid.Name):
+                        # Handle built-in types
+                        type_map = {
+                            "str": "String",
+                            "int": "Integer",
+                            "float": "Float",
+                            "bool": "Boolean",
+                            "list": "List",
+                            "dict": "Dictionary",
+                            "tuple": "Tuple",
+                            "set": "Set"
+                        }
+                        if annotation.name in type_map:
+                            type_node = astroid.Name(name=type_map[annotation.name], parent=node)
+                        else:
+                            # Handle custom class types
+                            try:
+                                # Try to find the class definition
+                                type_node = next(annotation.infer())
+                            except astroid.InferenceError:
+                                type_node = annotation
+                        node.locals_type[arg.name] = [type_node]
+
+                        # Also update instance attributes if this is __init__
+                        if node.name == "__init__" and isinstance(node.parent, astroid.ClassDef):
+                            node.parent.instance_attrs_type[arg.name] = [type_node]
+
     link_project = visit_project
     link_module = visit_module
     link_class = visit_classdef
@@ -217,6 +250,20 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
                 else:
                     self.visit_module(frame)
 
+            # Check for type annotations in function arguments
+            if isinstance(node.parent, astroid.Arguments) and isinstance(node.parent.parent, astroid.FunctionDef):
+                func = node.parent.parent
+                if func.args and func.args.annotations and node.name in func.args.annotations:
+                    annotation = func.args.annotations[node.name]
+                    if isinstance(annotation, astroid.Name) and annotation.name == "str":
+                        # Create a special node for str type
+                        str_node = astroid.Name(name="str", parent=node)
+                        values = {str_node}
+                        current = frame.locals_type[node.name]
+                        frame.locals_type[node.name] = list(set(current) | values)
+                        return
+
+            # Fall back to inferring from value if no type annotation
             current = frame.locals_type[node.name]
             values = set(node.infer())
             frame.locals_type[node.name] = list(set(current) | values)
@@ -230,6 +277,24 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
         handle instance_attrs_type
         """
         try:
+            # First check if we have a type annotation in the parent's function
+            if isinstance(node.parent, astroid.AssignAttr) and isinstance(node.parent.parent, astroid.FunctionDef):
+                func = node.parent.parent
+                if func.args and func.args.annotations:
+                    for arg_name, annotation in func.args.annotations.items():
+                        if arg_name == node.name:
+                            # Found a type annotation for this attribute
+                            if isinstance(annotation, astroid.Name) and annotation.name == "str":
+                                # Create a special node for str type
+                                str_node = astroid.Name(name="str", parent=node)
+                                values = {str_node}
+                            else:
+                                values = {annotation}
+                            current = set(parent.instance_attrs_type[node.attrname])
+                            parent.instance_attrs_type[node.attrname] = list(current | values)
+                            return
+
+            # Fall back to inferring from value if no type annotation
             values = set(node.infer())
             current = set(parent.instance_attrs_type[node.attrname])
             parent.instance_attrs_type[node.attrname] = list(current | values)
diff --git a/test_type_hints.py b/test_type_hints.py
new file mode 100644
index 000000000..35e536de2
--- /dev/null
+++ b/test_type_hints.py
@@ -0,0 +1,7 @@
+class C(object):
+    def __init__(self, a: str = None):
+        self.a = a
+
+if __name__ == "__main__":
+    c = C()
+    print(c.a)
\ No newline at end of file
diff --git a/test_type_hints_custom.py b/test_type_hints_custom.py
new file mode 100644
index 000000000..09eeaad81
--- /dev/null
+++ b/test_type_hints_custom.py
@@ -0,0 +1,8 @@
+class D:
+    pass
+
+class C(object):
+    def __init__(self, a: str = None, b: int = None, c: D = None):
+        self.a = a
+        self.b = b
+        self.c = c
\ No newline at end of file
diff --git a/test_type_hints_multiple.py b/test_type_hints_multiple.py
new file mode 100644
index 000000000..3714a7873
--- /dev/null
+++ b/test_type_hints_multiple.py
@@ -0,0 +1,4 @@
+class C(object):
+    def __init__(self, a: str = None, b: int = None):
+        self.a = a
+        self.b = b
\ No newline at end of file
