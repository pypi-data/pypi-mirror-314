diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 000000000..6fec116b9
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,73 @@
+import typing
+import os
+import tempfile
+import shutil
+
+# Create test function with Literal annotations
+test_code = '''
+import typing
+from typing import Literal
+
+@typing.overload
+def foo(x: "typing.Literal[True]") -> int: ...
+
+@typing.overload
+def foo(x: "typing.Literal[False]") -> str: ...
+
+@typing.overload
+def foo(x: "Literal[42]") -> float: ...
+
+@typing.overload
+def foo(x: "Literal['hello']") -> bytes: ...
+
+@typing.overload
+def foo(x: "Literal[None]") -> None: ...
+
+def foo(x: typing.Union[bool, int, str, None]):
+    """A function with multiple Literal overloads."""
+    if x is True:
+        return 1
+    elif x is False:
+        return "foo"
+    elif x == 42:
+        return 3.14
+    elif x == "hello":
+        return b"world"
+    else:
+        return None
+'''
+
+# Create sphinx project structure
+temp_dir = tempfile.mkdtemp()
+os.makedirs(os.path.join(temp_dir, 'source'))
+
+# Create conf.py
+with open(os.path.join(temp_dir, 'source', 'conf.py'), 'w') as f:
+    f.write('''
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+extensions = ['sphinx.ext.autodoc']
+nitpick = True
+nitpick_ignore = []
+''')
+
+# Create test module
+with open(os.path.join(temp_dir, 'source', 'test_module.py'), 'w') as f:
+    f.write(test_code)
+
+# Create index.rst
+with open(os.path.join(temp_dir, 'source', 'index.rst'), 'w') as f:
+    f.write('''
+Test Module
+===========
+
+.. automodule:: test_module
+   :members:
+''')
+
+# Run sphinx-build
+os.system(f'cd {temp_dir} && sphinx-build -b html -n -W source build')
+
+# Cleanup
+shutil.rmtree(temp_dir)
\ No newline at end of file
diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py
index 9875a9f4b..5609b9c01 100644
--- a/sphinx/domains/python.py
+++ b/sphinx/domains/python.py
@@ -82,8 +82,18 @@ class ModuleEntry(NamedTuple):
 
 def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:
     """Convert a type string to a cross reference node."""
+    print(f"type_to_xref called with text: {text!r}")
     if text == 'None':
         reftype = 'obj'
+    # Don't create cross-references for literal values (True, False, numbers, strings)
+    elif text in ('True', 'False', 'None') or text.isdigit():
+        return nodes.Text(text)
+    # Handle string literals - they might be quoted with single or double quotes
+    elif (text.startswith('"') and text.endswith('"')) or (text.startswith("'") and text.endswith("'")):
+        return nodes.Text(text)
+    # Handle unquoted strings that should be literals
+    elif text.isalpha() and text.islower():  # Heuristic: lowercase words are likely literals
+        return nodes.Text(repr(text))
     else:
         reftype = 'class'
 
diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py
index cf4318cda..a6f3931f6 100644
--- a/sphinx/util/typing.py
+++ b/sphinx/util/typing.py
@@ -177,7 +177,20 @@ def _restify_py37(cls: Optional[Type]) -> str:
             args = ', '.join(restify(a) for a in cls.__args__[:-1])
             text += r"\ [[%s], %s]" % (args, restify(cls.__args__[-1]))
         elif cls.__module__ == 'typing' and getattr(origin, '_name', None) == 'Literal':
-            text += r"\ [%s]" % ', '.join(repr(a) for a in cls.__args__)
+            # For Literal types, don't wrap the values in :class: directives
+            # Convert each argument to a string representation that won't be treated as a cross-reference
+            def format_literal_arg(arg):
+                if isinstance(arg, bool):
+                    return str(arg)
+                elif isinstance(arg, (int, float)):
+                    return str(arg)
+                elif isinstance(arg, str):
+                    return repr(arg)  # Use repr to get quotes
+                elif arg is None:
+                    return 'None'
+                else:
+                    return repr(arg)
+            text = ':obj:`~typing.Literal`\\ [%s]' % ', '.join(format_literal_arg(a) for a in cls.__args__)
         elif cls.__args__:
             text += r"\ [%s]" % ", ".join(restify(a) for a in cls.__args__)
