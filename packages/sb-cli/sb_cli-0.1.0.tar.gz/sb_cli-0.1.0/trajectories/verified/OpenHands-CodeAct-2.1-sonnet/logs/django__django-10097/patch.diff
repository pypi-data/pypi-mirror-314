diff --git a/django/core/validators.py b/django/core/validators.py
index 92394a7eae..4c2ca7e762 100644
--- a/django/core/validators.py
+++ b/django/core/validators.py
@@ -94,7 +94,7 @@ class URLValidator(RegexValidator):
 
     regex = _lazy_re_compile(
         r'^(?:[a-z0-9\.\-\+]*)://'  # scheme is validated separately
-        r'(?:\S+(?::\S*)?@)?'  # user:pass authentication
+        r'(?:[^/:@\s]+(?::[^/:@\s]+)?@)?'  # user:pass authentication
         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
         r'(?::\d{2,5})?'  # port
         r'(?:[/?#][^\s]*)?'  # resource path
@@ -108,11 +108,49 @@ class URLValidator(RegexValidator):
             self.schemes = schemes
 
     def __call__(self, value):
+        if not value:
+            raise ValidationError(self.message, code=self.code)
+
         # Check first if the scheme is valid
         scheme = value.split('://')[0].lower()
         if scheme not in self.schemes:
             raise ValidationError(self.message, code=self.code)
 
+        # First check for unencoded special characters in username/password
+        try:
+            scheme, netloc, path, query, fragment = urlsplit(value)
+            if '@' in netloc:
+                userinfo, host = netloc.split('@', 1)
+                # Check for multiple @ symbols in netloc
+                if netloc.count('@') > 1:
+                    raise ValidationError(self.message, code=self.code)
+                # Check for unencoded special chars in userinfo
+                if ':' in userinfo:
+                    username, password = userinfo.split(':', 1)
+                    # Check for unencoded special chars in username
+                    if any(c in username for c in '/:@'):
+                        raise ValidationError(self.message, code=self.code)
+                    # Check for unencoded special chars in password
+                    if any(c in password for c in '/:@'):
+                        raise ValidationError(self.message, code=self.code)
+                else:
+                    # Check for unencoded special chars in username when no password
+                    if any(c in userinfo for c in '/:@'):
+                        raise ValidationError(self.message, code=self.code)
+                # Check for unencoded colon in userinfo
+                if ':' in userinfo and not '%3A' in userinfo:
+                    raise ValidationError(self.message, code=self.code)
+                # Check for unencoded forward slash in userinfo
+                if '/' in userinfo and not '%2F' in userinfo:
+                    raise ValidationError(self.message, code=self.code)
+                # Check for unencoded @ in userinfo
+                if '@' in userinfo and not '%40' in userinfo:
+                    raise ValidationError(self.message, code=self.code)
+                # Reconstruct the URL without userinfo for further validation
+                value = urlunsplit((scheme, host, path, query, fragment))
+        except ValueError:  # for example, "Invalid IPv6 URL"
+            raise ValidationError(self.message, code=self.code)
+
         # Then check full URL
         try:
             super().__call__(value)
diff --git a/test_url_validator.py b/test_url_validator.py
new file mode 100644
index 0000000000..f557508c17
--- /dev/null
+++ b/test_url_validator.py
@@ -0,0 +1,44 @@
+from django.core.validators import URLValidator
+from django.core.exceptions import ValidationError
+
+def test_url_validation():
+    validator = URLValidator()
+    
+    # Test cases that should be invalid according to RFC 1738
+    invalid_urls = [
+        'http://foo/bar@example.com',  # Unencoded / in username
+        'http://foo:bar@example.com',  # Unencoded : in username
+        'http://foo@bar@example.com',  # Unencoded @ in username
+        'http://user:pass/word@example.com',  # Unencoded / in password
+        'http://user:pass:word@example.com',  # Unencoded : in password
+        'http://user:pass@word@example.com',  # Unencoded @ in password
+    ]
+    
+    print("Testing URLs that should be invalid:")
+    for url in invalid_urls:
+        try:
+            validator(url)
+            print("❌ FAIL: {} was incorrectly accepted".format(url))
+        except ValidationError:
+            print("✓ PASS: {} was correctly rejected".format(url))
+    
+    # Test cases that should be valid (with properly encoded characters)
+    valid_urls = [
+        'http://foo%2Fbar@example.com',  # Encoded / in username
+        'http://foo%3Abar@example.com',  # Encoded : in username 
+        'http://foo%40bar@example.com',  # Encoded @ in username
+        'http://user:pass%2Fword@example.com',  # Encoded / in password
+        'http://user:pass%3Aword@example.com',  # Encoded : in password
+        'http://user:pass%40word@example.com',  # Encoded @ in password
+    ]
+    
+    print("\nTesting URLs that should be valid:")
+    for url in valid_urls:
+        try:
+            validator(url)
+            print("✓ PASS: {} was correctly accepted".format(url))
+        except ValidationError:
+            print("❌ FAIL: {} was incorrectly rejected".format(url))
+
+if __name__ == '__main__':
+    test_url_validation()
\ No newline at end of file
