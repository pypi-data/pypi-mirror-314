diff --git a/db.sqlite3 b/db.sqlite3
new file mode 100644
index 0000000000..ae3a17fe9a
Binary files /dev/null and b/db.sqlite3 differ
diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index abbb1e37cb..3e54eadc67 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -7,6 +7,7 @@ from django.core.exceptions import EmptyResultSet, FieldError
 from django.db import DatabaseError, NotSupportedError
 from django.db.models.constants import LOOKUP_SEP
 from django.db.models.expressions import F, OrderBy, Random, RawSQL, Ref, Value
+from django.db.models import F
 from django.db.models.functions import Cast
 from django.db.models.query_utils import Q, select_related_descend
 from django.db.models.sql.constants import (
@@ -343,6 +344,30 @@ class SQLCompiler:
             if not self.query.extra or col not in self.query.extra:
                 # 'col' is of the form 'field' or 'field1__field2' or
                 # '-field1__field2__field', etc.
+                # Special handling for _id fields
+                pieces = col.split(LOOKUP_SEP)
+                if len(pieces) == 2 and pieces[1].endswith('_id'):
+                    try:
+                        field_obj = self.query.get_meta().get_field(pieces[0])
+                        if field_obj.is_relation and field_obj.attname == pieces[1]:
+                            # This is a direct reference to a foreign key's _id field
+                            # Use the field's attname directly
+                            order_by.append((
+                                OrderBy(
+                                    RawSQL(
+                                        '%s.%s' % (
+                                            self.quote_name_unless_alias(field_obj.model._meta.db_table),
+                                            field_obj.attname
+                                        ),
+                                        []
+                                    ),
+                                    descending=descending
+                                ),
+                                False
+                            ))
+                            continue
+                    except FieldDoesNotExist:
+                        pass
                 order_by.extend(self.find_ordering_name(
                     field, self.query.get_meta(), default_order=asc))
             else:
@@ -727,7 +752,11 @@ class SQLCompiler:
         # If we get to this point and the field is a relation to another model,
         # append the default ordering for that model unless it is the pk
         # shortcut or the attribute name of the field that is specified.
-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':
+        # Also handle _id suffix for foreign keys
+        if (field.is_relation and opts.ordering and 
+            name != 'pk' and name != getattr(field, 'attname', None) and 
+            not (name.endswith('_id') and name == field.attname) and
+            not (len(pieces) == 2 and pieces[1].endswith('_id') and pieces[1] == field.attname)):
             # Firstly, avoid infinite loops.
             already_seen = already_seen or set()
             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)
@@ -757,6 +786,22 @@ class SQLCompiler:
         match. Executing SQL where this is not true is an error.
         """
         alias = alias or self.query.get_initial_alias()
+        
+        # Special handling for _id fields
+        if len(pieces) == 2 and pieces[1].endswith('_id'):
+            try:
+                field = opts.get_field(pieces[0])
+                if field.is_relation and field.attname == pieces[1]:
+                    # This is a direct reference to a foreign key's _id field
+                    # Use the field's attname directly
+                    targets = [field]
+                    joins = [alias]
+                    path = []
+                    transform_function = lambda field, alias: field.get_col(alias)
+                    return field, targets, alias, joins, path, opts, transform_function
+            except FieldDoesNotExist:
+                pass
+                
         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
         alias = joins[-1]
         return field, targets, alias, joins, path, opts, transform_function
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index d65141b834..440e965aac 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1445,13 +1445,24 @@ class Query(BaseExpression):
             field = None
             filtered_relation = None
             try:
+                # First try to get the field directly
                 field = opts.get_field(name)
             except FieldDoesNotExist:
-                if name in self.annotation_select:
-                    field = self.annotation_select[name].output_field
-                elif name in self._filtered_relations and pos == 0:
-                    filtered_relation = self._filtered_relations[name]
-                    field = opts.get_field(filtered_relation.relation_name)
+                # If not found and name ends with _id, try to get the related field
+                if name.endswith('_id'):
+                    try:
+                        field = opts.get_field(name[:-3])
+                        if field.is_relation:
+                            # Use the foreign key field itself
+                            field = opts.get_field(name)
+                    except FieldDoesNotExist:
+                        pass
+                if field is None:
+                    if name in self.annotation_select:
+                        field = self.annotation_select[name].output_field
+                    elif name in self._filtered_relations and pos == 0:
+                        filtered_relation = self._filtered_relations[name]
+                        field = opts.get_field(filtered_relation.relation_name)
             if field is not None:
                 # Fields that contain one-to-many relations with a generic
                 # model (like a GenericForeignKey) cannot generate reverse
@@ -1548,6 +1559,10 @@ class Query(BaseExpression):
         that value. Final field is needed for example in some value
         conversions (convert 'obj' in fk__id=obj to pk val using the foreign
         key field for example).
+
+        Special handling for _id fields: If a field name ends with _id and it's
+        a foreign key's attname, treat it as a direct field reference rather than
+        a relation traversal.
         """
         joins = [alias]
         # The transform can't be applied yet, as joins must be trimmed later.
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..9c21521195
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,84 @@
+from django.db import models
+from django.conf import settings
+import os
+
+# Configure Django settings
+BASE_DIR = os.path.dirname(os.path.abspath(__file__))
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DEFAULT_AUTO_FIELD='django.db.models.BigAutoField',
+)
+
+import django
+django.setup()
+
+# Define the models
+class OneModel(models.Model):
+    class Meta:
+        ordering = ("-id",)
+        managed = False
+        db_table = 'one_model'
+        app_label = 'contenttypes'
+    id = models.BigAutoField(primary_key=True)
+    root = models.ForeignKey("OneModel", on_delete=models.CASCADE, null=True)
+    oneval = models.BigIntegerField(null=True)
+
+class TwoModel(models.Model):
+    class Meta:
+        managed = False
+        db_table = 'two_model'
+        app_label = 'contenttypes'
+    id = models.BigAutoField(primary_key=True)
+    record = models.ForeignKey(OneModel, on_delete=models.CASCADE)
+    twoval = models.BigIntegerField(null=True)
+
+# Create tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    try:
+        schema_editor.delete_model(TwoModel)
+        schema_editor.delete_model(OneModel)
+    except:
+        pass
+    schema_editor.create_model(OneModel)
+    schema_editor.create_model(TwoModel)
+
+# Create some test data
+one1 = OneModel.objects.create(oneval=1)
+one2 = OneModel.objects.create(oneval=2, root=one1)
+one3 = OneModel.objects.create(oneval=3, root=one2)
+
+two1 = TwoModel.objects.create(record=one1, twoval=10)
+two2 = TwoModel.objects.create(record=one2, twoval=20)
+two3 = TwoModel.objects.create(record=one3, twoval=30)
+
+# Test the queries
+print("\nTesting order_by('record__root_id'):")
+qs = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+qs = qs.order_by("record__root_id")
+print(qs.query)
+
+print("\nTesting order_by('record__root'):")
+qs = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+qs = qs.order_by("record__root")
+print(qs.query)
+
+print("\nTesting order_by('-record__root_id'):")
+qs = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+qs = qs.order_by("-record__root_id")
+print(qs.query)
+
+print("\nTesting order_by('record__root__id'):")
+qs = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+qs = qs.order_by("record__root__id")
+print(qs.query)
\ No newline at end of file
