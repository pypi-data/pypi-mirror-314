diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 000000000..690c940d1
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,17 @@
+from typing import TypeVar, Generic
+from sphinx.ext.autodoc.mock import _make_subclass, _MockObject
+
+# Create a TypeVar for testing
+T = TypeVar('T')
+
+# Create a generic class that will be mocked
+class GenericClass(Generic[T]):
+    def __init__(self, value: T):
+        self.value = value
+
+# Try to mock the generic class
+try:
+    mock_class = _make_subclass('GenericClass', 'test_module', superclass=GenericClass)
+    print("Success: Mock class created")
+except TypeError as e:
+    print(f"Error: {str(e)}")
\ No newline at end of file
diff --git a/reproduce_error_complex.py b/reproduce_error_complex.py
new file mode 100644
index 000000000..a146c9f05
--- /dev/null
+++ b/reproduce_error_complex.py
@@ -0,0 +1,41 @@
+from typing import TypeVar, Generic, List
+from sphinx.ext.autodoc.mock import _make_subclass, _MockObject
+
+# Create TypeVars for testing
+T = TypeVar('T')
+U = TypeVar('U')
+
+# Create a more complex generic class hierarchy
+class BaseGeneric(Generic[T]):
+    def __init__(self, value: T):
+        self.value = value
+
+class ComplexGeneric(BaseGeneric[T], Generic[T, U]):
+    def __init__(self, value: T, other: U):
+        super().__init__(value)
+        self.other = other
+        
+    def process(self) -> List[U]:
+        return [self.other]
+
+# Try to mock the complex generic class
+try:
+    # First create a mock for BaseGeneric
+    mock_base = _make_subclass('BaseGeneric', 'test_module', superclass=BaseGeneric)
+    print("Success: Base mock class created")
+    
+    # Then try to create a mock for ComplexGeneric
+    mock_complex = _make_subclass('ComplexGeneric', 'test_module', superclass=ComplexGeneric)
+    print("Success: Complex mock class created")
+    
+    # Try to create an instance and access its attributes
+    instance = mock_complex()
+    print("Success: Instance created")
+    print(f"Accessing value: {instance.value}")
+    print(f"Accessing other: {instance.other}")
+    print(f"Calling process(): {instance.process()}")
+    
+except TypeError as e:
+    print(f"Error: {str(e)}")
+except Exception as e:
+    print(f"Unexpected error: {str(e)}")
\ No newline at end of file
diff --git a/sphinx/ext/autodoc/mock.py b/sphinx/ext/autodoc/mock.py
index 98a3a3a96..fba149e02 100644
--- a/sphinx/ext/autodoc/mock.py
+++ b/sphinx/ext/autodoc/mock.py
@@ -14,7 +14,8 @@ import sys
 from importlib.abc import Loader, MetaPathFinder
 from importlib.machinery import ModuleSpec
 from types import FunctionType, MethodType, ModuleType
-from typing import Any, Generator, Iterator, List, Sequence, Tuple, Union
+from typing import Any, Generator, Iterator, List, Sequence, Tuple, Union, Generic
+import typing
 
 from sphinx.util import logging
 
@@ -73,6 +74,36 @@ def _make_subclass(name: str, module: str, superclass: Any = _MockObject,
     attrs = {'__module__': module, '__display_name__': module + '.' + name}
     attrs.update(attributes or {})
 
+    # Handle generic types
+    if hasattr(superclass, '__origin__') and superclass.__origin__ is Generic:
+        # If the superclass is a Generic type, preserve its type parameters
+        return superclass
+    elif isinstance(superclass, type) and issubclass(superclass, Generic):
+        # If it's a generic class, create a new class that preserves generic behavior
+        bases = (superclass,)
+        # Get original type parameters if available
+        if hasattr(superclass, '__parameters__'):
+            attrs['__parameters__'] = superclass.__parameters__
+        if hasattr(superclass, '__orig_bases__'):
+            attrs['__orig_bases__'] = superclass.__orig_bases__
+        
+        # Create a special __new__ method that handles generic instantiation
+        def __new__(cls, *args, **kwargs):
+            # If called with type arguments, return a new generic type
+            if not args and not kwargs:
+                return super(type(cls), cls).__new__(cls)
+            return cls
+            
+        attrs['__new__'] = __new__
+        
+        # Create a special __init__ that accepts any arguments
+        def __init__(self, *args, **kwargs):
+            pass
+            
+        attrs['__init__'] = __init__
+        
+        return type(name, bases, attrs)
+    
     return type(name, (superclass,), attrs)
 
 
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..d8b379a58
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,45 @@
+from typing import TypeVar, Generic, Dict, List, Optional
+from sphinx.ext.autodoc.mock import _make_subclass
+
+# Test various edge cases
+T = TypeVar('T')
+U = TypeVar('U')
+V = TypeVar('V')
+
+# Case 1: Generic with multiple type parameters
+class MultiGeneric(Generic[T, U, V]):
+    pass
+
+# Case 2: Generic with bounded type parameter
+S = TypeVar('S', bound=str)
+class BoundedGeneric(Generic[S]):
+    pass
+
+# Case 3: Generic with nested type parameters
+class NestedGeneric(Generic[T]):
+    def __init__(self, data: Dict[str, List[Optional[T]]]):
+        self.data = data
+
+# Test all cases
+try:
+    print("Testing MultiGeneric...")
+    mock1 = _make_subclass('MultiGeneric', 'test_module', superclass=MultiGeneric)
+    print("Success: MultiGeneric mock created")
+    
+    print("\nTesting BoundedGeneric...")
+    mock2 = _make_subclass('BoundedGeneric', 'test_module', superclass=BoundedGeneric)
+    print("Success: BoundedGeneric mock created")
+    
+    print("\nTesting NestedGeneric...")
+    mock3 = _make_subclass('NestedGeneric', 'test_module', superclass=NestedGeneric)
+    print("Success: NestedGeneric mock created")
+    
+    # Try to use the mocks
+    instance1 = mock1()
+    instance2 = mock2()
+    instance3 = mock3()
+    
+    print("\nAll mocks instantiated successfully!")
+    
+except Exception as e:
+    print(f"Error: {type(e).__name__}: {str(e)}")
\ No newline at end of file
