diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..66bd713401
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,67 @@
+from sympy import Symbol, Mod
+
+# Create symbolic variables
+i = Symbol('i', integer=True)
+x = Symbol('x')  # non-integer variable
+
+print("Test cases:")
+print("-" * 40)
+
+# Original test case
+print("1. Original test case: Mod(3*i, 2)")
+result = Mod(3*i, 2)
+print(f"Result: {result}")
+print(f"Expected: Mod(i, 2)")
+print()
+
+# Test with negative coefficient
+print("2. Negative coefficient: Mod(-3*i, 2)")
+result = Mod(-3*i, 2)
+print(f"Result: {result}")
+print(f"Expected: Mod(-i, 2)")
+print()
+
+# Test with non-integer variable
+print("3. Non-integer variable: Mod(3*x, 2)")
+result = Mod(3*x, 2)
+print(f"Result: {result}")
+print(f"Expected: Mod(3*x, 2)")  # Should not simplify
+print()
+
+# Test with more complex expression
+print("4. Complex expression: Mod(6*i + 3, 2)")
+result = Mod(6*i + 3, 2)
+print(f"Result: {result}")
+print(f"Expected: Mod(1, 2)")  # 6*i is even so drops out
+print()
+
+# Test with larger modulus
+print("5. Larger modulus: Mod(15*i, 4)")
+result = Mod(15*i, 4)
+print(f"Result: {result}")
+print(f"Expected: Mod(3*i, 4)")  # 15 ≡ 3 (mod 4)
+print()
+
+# Additional test cases
+print("6. Zero coefficient: Mod(0*i, 2)")
+result = Mod(0*i, 2)
+print(f"Result: {result}")
+print(f"Expected: 0")
+print()
+
+print("7. Coefficient equal to modulus: Mod(4*i, 4)")
+result = Mod(4*i, 4)
+print(f"Result: {result}")
+print(f"Expected: 0")
+print()
+
+print("8. Large negative coefficient: Mod(-7*i, 3)")
+result = Mod(-7*i, 3)
+print(f"Result: {result}")
+print(f"Expected: Mod(-i, 3)")  # -7 ≡ -1 (mod 3)
+print()
+
+print("9. Multiple of modulus plus one: Mod(9*i, 4)")
+result = Mod(9*i, 4)
+print(f"Result: {result}")
+print(f"Expected: Mod(i, 4)")  # 9 ≡ 1 (mod 4)
\ No newline at end of file
diff --git a/sympy/core/mod.py b/sympy/core/mod.py
index eae25630cc..fa0a85b375 100644
--- a/sympy/core/mod.py
+++ b/sympy/core/mod.py
@@ -1,6 +1,7 @@
 from __future__ import print_function, division
 
 from sympy.core.numbers import nan
+from sympy.core.singleton import S
 from .function import Function
 
 
@@ -123,6 +124,24 @@ def doit(p, q):
             for arg in p.args:
                 both_l[isinstance(arg, cls)].append(arg)
 
+            # Check if we can simplify coefficients for integer variables
+            if len(non_mod_l) == 2 and q.is_Integer:
+                coeff, var = non_mod_l
+                if (coeff.is_Integer and var.is_Symbol and 
+                    var.is_integer and not mod_l):
+                    # For integer coefficients and variables mod n,
+                    # a*x ≡ (a mod n)*x (mod n)
+                    sign = 1 if coeff >= 0 else -1
+                    abs_coeff = abs(int(coeff))
+                    reduced_coeff = abs_coeff % int(q)
+                    if reduced_coeff == 0:
+                        return S.Zero
+                    elif reduced_coeff == 1:
+                        return cls(sign * var, q, evaluate=False)
+                    else:
+                        # Create a new expression without evaluating
+                        return cls(sign * reduced_coeff * var, q, evaluate=False)
+
             if mod_l and all(inner.args[1] == q for inner in mod_l):
                 # finding distributive term
                 non_mod_l = [cls(x, q) for x in non_mod_l]
@@ -135,7 +154,7 @@ def doit(p, q):
                         non_mod.append(j)
                 prod_mod = Mul(*mod)
                 prod_non_mod = Mul(*non_mod)
-                prod_mod1 = Mul(*[i.args[0] for i in mod_l])
+                prod_mod1 = Mul(*[i.args[0] for i in mod_l]) if mod_l else S.One
                 net = prod_mod1*prod_mod
                 return prod_non_mod*cls(net, q)
