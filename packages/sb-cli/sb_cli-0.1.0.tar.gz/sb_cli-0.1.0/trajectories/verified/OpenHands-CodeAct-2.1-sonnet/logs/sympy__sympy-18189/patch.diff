diff --git a/edge_cases.py b/edge_cases.py
new file mode 100644
index 0000000000..b9e6d75944
--- /dev/null
+++ b/edge_cases.py
@@ -0,0 +1,32 @@
+from sympy.solvers.diophantine import diophantine
+from sympy import symbols
+
+print("Test 1: No syms parameter")
+n, m = symbols('n m', integer=True)
+eq = n**4 + m**4 - 2**4 - 3**4
+result = diophantine(eq, permute=True)
+print(result)
+
+print("\nTest 2: Empty syms list")
+result = diophantine(eq, syms=[], permute=True)
+print(result)
+
+print("\nTest 3: Partial syms list")
+result = diophantine(eq, syms=[n], permute=True)
+print(result)
+
+print("\nTest 4: Syms with extra variables")
+x = symbols('x', integer=True)
+result = diophantine(eq, syms=[n, m, x], permute=True)
+print(result)
+
+print("\nTest 5: Linear equation with syms")
+eq2 = 2*n + 3*m - 5
+result = diophantine(eq2, syms=(m,n))
+print(result)
+
+print("\nTest 6: Three variable equation with syms")
+x, y, z = symbols('x y z', integer=True)
+eq3 = x**2 + y**2 - z**2
+result = diophantine(eq3, syms=(z,y,x), permute=True)
+print(result)
\ No newline at end of file
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..a84d5c5829
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,16 @@
+from sympy.solvers.diophantine import diophantine
+from sympy import symbols
+
+n, m = symbols('n m', integer=True)
+eq = n**4 + m**4 - 2**4 - 3**4
+
+print("Testing with syms=(m,n):")
+result1 = diophantine(eq, syms=(m,n), permute=True)
+print(result1)
+
+print("\nTesting with syms=(n,m):")
+result2 = diophantine(eq, syms=(n,m), permute=True)
+print(result2)
+
+# They should be equal
+print("\nAre results equal?", result1 == result2)
\ No newline at end of file
diff --git a/sympy/solvers/diophantine.py b/sympy/solvers/diophantine.py
index 6092e35dab..93a4ba5b08 100644
--- a/sympy/solvers/diophantine.py
+++ b/sympy/solvers/diophantine.py
@@ -180,9 +180,21 @@ def diophantine(eq, param=symbols("t", integer=True), syms=None,
                     'syms should be given as a sequence, e.g. a list')
             syms = [i for i in syms if i in var]
             if syms != var:
-                dict_sym_index = dict(zip(syms, range(len(syms))))
-                return {tuple([t[dict_sym_index[i]] for i in var])
-                            for t in diophantine(eq, param)}
+                # If syms is a subset of var, we need to keep the original order for non-specified variables
+                if set(syms).issubset(set(var)):
+                    # Create a mapping for the specified symbols
+                    dict_sym_index = {}
+                    for i, s in enumerate(syms):
+                        dict_sym_index[s] = i
+                    # Add remaining variables to the mapping
+                    next_idx = len(syms)
+                    for v in var:
+                        if v not in dict_sym_index:
+                            dict_sym_index[v] = next_idx
+                            next_idx += 1
+                    var_order = var.copy()  # Save original var order
+                    # Put specified symbols first, keep others in original order
+                    var = list(syms) + [v for v in var if v not in syms]
         n, d = eq.as_numer_denom()
         if n.is_number:
             return set()
@@ -348,6 +360,14 @@ def diophantine(eq, param=symbols("t", integer=True), syms=None,
                 final_soln.add(sol)
         else:
                 final_soln.add(sol)
+    # If syms was provided and different from var_order, reorder the solutions
+    try:
+        if 'var_order' in locals() and var != var_order:
+            final_soln = {tuple([t[dict_sym_index[i]] for i in var_order])
+                         for t in final_soln}
+    except (NameError, UnboundLocalError):
+        pass
+
     return final_soln
