diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..87e4ee5352
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,37 @@
+from sympy import *
+from sympy.core.cache import clear_cache
+
+def test_case_1():
+    x, y, z = symbols('x y z')
+    clear_cache()
+    expr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))
+    # This works fine
+    print("Test 1 (no real assumption):")
+    try:
+        result = expr.subs({1: 1.0})
+        print("Success!")
+    except Exception as e:
+        print(f"Failed with: {type(e).__name__}: {str(e)}")
+
+def test_case_2():
+    clear_cache()
+    x, y, z = symbols('x y z', real=True)
+    expr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))
+    print("\nTest 2 (with real assumption):")
+    try:
+        result = expr.subs({1: 1.0})
+        print("Success!")
+    except Exception as e:
+        print(f"Failed with: {type(e).__name__}: {str(e)}")
+
+    # Try again without clearing cache
+    print("\nTest 3 (second attempt without clearing cache):")
+    try:
+        result = expr.subs({1: 1.0})
+        print("Success!")
+    except Exception as e:
+        print(f"Failed with: {type(e).__name__}: {str(e)}")
+
+if __name__ == "__main__":
+    test_case_1()
+    test_case_2()
\ No newline at end of file
diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py
index 860989f7c1..7298b4bb79 100644
--- a/sympy/functions/elementary/hyperbolic.py
+++ b/sympy/functions/elementary/hyperbolic.py
@@ -9,6 +9,7 @@
 from sympy.functions.elementary.integers import floor
 
 from sympy.core.logic import fuzzy_or, fuzzy_and
+from sympy.functions.elementary.piecewise import Piecewise
 
 
 
@@ -245,6 +246,10 @@ def _eval_is_real(self):
         if arg.is_real:
             return True
 
+        # Skip real/imag decomposition for Piecewise expressions
+        if arg.has(Piecewise):
+            return None
+
         # if `im` is of the form n*pi
         # else, check if it is a number
         re, im = arg.as_real_imag()
diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py
index bfec61de64..2e3f37c9b4 100644
--- a/sympy/polys/polytools.py
+++ b/sympy/polys/polytools.py
@@ -4390,14 +4390,17 @@ def _parallel_poly_from_expr(exprs, opt):
         for i in _polys:
             exprs[i] = exprs[i].as_expr()
 
+    # Check for Piecewise expressions before attempting polynomial conversion
+    for expr in exprs:
+        if expr.has(Piecewise):
+            # Skip polynomial conversion for expressions with Piecewise
+            opt.polys = False
+            return exprs, opt
+
     reps, opt = _parallel_dict_from_expr(exprs, opt)
     if not opt.gens:
         raise PolificationFailed(opt, origs, exprs, True)
 
-    for k in opt.gens:
-        if isinstance(k, Piecewise):
-            raise PolynomialError("Piecewise generators do not make sense")
-
     coeffs_list, lengths = [], []
 
     all_monoms = []
@@ -6696,7 +6699,18 @@ def cancel(f, *gens, **args):
 
     try:
         if f.has(Piecewise):
-            raise PolynomialError()
+            # If we have a Piecewise expression, skip polynomial conversion
+            # and handle it directly
+            if f.is_Add or f.is_Mul:
+                c, nc = sift(f.args, lambda x:
+                    x.is_commutative is True and not x.has(Piecewise),
+                    binary=True)
+                nc = [cancel(i) for i in nc]
+                return f.func(cancel(f.func(*c)), *nc)
+            else:
+                # For other expressions containing Piecewise, just return
+                # the original expression
+                return f
         R, (F, G) = sring((p, q), *gens, **args)
         if not R.ngens:
             if not isinstance(f, (tuple, Tuple)):
@@ -6706,7 +6720,7 @@ def cancel(f, *gens, **args):
     except PolynomialError as msg:
         if f.is_commutative and not f.has(Piecewise):
             raise PolynomialError(msg)
-        # Handling of noncommutative and/or piecewise expressions
+        # Handling of noncommutative expressions
         if f.is_Add or f.is_Mul:
             c, nc = sift(f.args, lambda x:
                 x.is_commutative is True and not x.has(Piecewise),
