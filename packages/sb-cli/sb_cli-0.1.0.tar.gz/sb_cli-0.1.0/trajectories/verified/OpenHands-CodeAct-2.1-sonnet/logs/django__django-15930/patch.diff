diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index 822968ef56..41bc1eeaf6 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -1286,9 +1286,23 @@ class When(Expression):
         c = self.copy()
         c.is_summary = summarize
         if hasattr(c.condition, "resolve_expression"):
-            c.condition = c.condition.resolve_expression(
-                query, allow_joins, reuse, summarize, False
-            )
+            try:
+                c.condition = c.condition.resolve_expression(
+                    query, allow_joins, reuse, summarize, False
+                )
+            except EmptyResultSet:
+                # When the condition involves an empty IN clause, we want to treat it
+                # as a True condition if negated (NOT IN []) or False if not negated (IN [])
+                if isinstance(self.condition, Q):
+                    # Check if the Q object is negated
+                    negated = self.condition.negated
+                    # For empty IN clauses, we want to return True if negated (NOT IN [])
+                    # and False if not negated (IN [])
+                    from django.db.models.expressions import RawSQL
+                    from django.db.models.fields import BooleanField
+                    c.condition = RawSQL("1 = %s", [1 if negated else 0], output_field=BooleanField())
+                else:
+                    c.condition = RawSQL("1 = 0", [], output_field=BooleanField())
         c.result = c.result.resolve_expression(
             query, allow_joins, reuse, summarize, for_save
         )
@@ -1296,11 +1310,27 @@ class When(Expression):
 
     def as_sql(self, compiler, connection, template=None, **extra_context):
         connection.ops.check_expression_support(self)
-        template_params = extra_context
+        template_params = extra_context.copy()
         sql_params = []
-        condition_sql, condition_params = compiler.compile(self.condition)
-        template_params["condition"] = condition_sql
-        sql_params.extend(condition_params)
+        try:
+            condition_sql, condition_params = compiler.compile(self.condition)
+            if not condition_sql:
+                # Empty condition, treat it as False
+                condition_sql = "1 = 0"
+            template_params["condition"] = condition_sql
+            sql_params.extend(condition_params)
+        except EmptyResultSet:
+            # When the condition involves an empty IN clause, we want to treat it
+            # as a True condition if negated (NOT IN []) or False if not negated (IN [])
+            if isinstance(self.condition, Q):
+                # Check if the Q object is negated
+                negated = self.condition.negated
+                # For empty IN clauses, we want to return True if negated (NOT IN [])
+                # and False if not negated (IN [])
+                template_params["condition"] = "1 = " + ("1" if negated else "0")
+            else:
+                # For non-Q objects, treat EmptyResultSet as False
+                template_params["condition"] = "1 = 0"
         result_sql, result_params = compiler.compile(self.result)
         template_params["result"] = result_sql
         sql_params.extend(result_params)
diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py
index 866e38df83..51eb4dfab3 100644
--- a/django/db/models/lookups.py
+++ b/django/db/models/lookups.py
@@ -40,6 +40,15 @@ class Lookup(Expression):
                     "Bilateral transformations on nested querysets are not implemented."
                 )
         self.bilateral_transforms = bilateral_transforms
+        self._negated = False
+
+    @property
+    def negated(self):
+        return self._negated
+
+    @negated.setter
+    def negated(self, value):
+        self._negated = value
 
     def apply_bilateral_transforms(self, value):
         for transform in self.bilateral_transforms:
@@ -442,7 +451,14 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):
                 rhs = [r for r in self.rhs if r is not None]
 
             if not rhs:
-                raise EmptyResultSet
+                # For empty lists, we want to return True if negated (NOT IN [])
+                # and False if not negated (IN []).
+                # Instead of raising EmptyResultSet, we return a boolean expression
+                # that matches the semantics of IN/NOT IN with empty lists:
+                #   IN []  -> false (no value is in an empty list)
+                #   NOT IN [] -> true (all values are not in an empty list)
+                # We use a dummy value that will never match any real ID
+                rhs = [None]
 
             # rhs should be an iterable; use batch_process_rhs() to
             # prepare/transform those values.
