diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 00000000..0e0b5fa5
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,10 @@
+import numpy as np
+import xarray as xr
+
+dta = xr.DataArray([1., 1., 1.])
+wgt = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))
+
+result = dta.weighted(wgt).mean()
+print("Result:", result)
+print("Expected: 1.0")
+print("Type of weights:", wgt.dtype)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..2e237a88
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,36 @@
+import numpy as np
+import xarray as xr
+
+# Test case 1: All weights are False
+print("\nTest case 1: All weights are False")
+dta1 = xr.DataArray([1., 2., 3.])
+wgt1 = xr.DataArray(np.array([0, 0, 0], dtype=bool))
+try:
+    result1 = dta1.weighted(wgt1).mean()
+    print("Result:", result1)
+except Exception as e:
+    print("Error (expected):", str(e))
+
+# Test case 2: Mix of True/False with NaN in data
+print("\nTest case 2: Mix of True/False with NaN in data")
+dta2 = xr.DataArray([1., np.nan, 3.])
+wgt2 = xr.DataArray(np.array([1, 1, 0], dtype=bool))
+result2 = dta2.weighted(wgt2).mean()
+print("Result:", result2)
+print("Expected: 1.0 (only the first value should be counted)")
+
+# Test case 3: Single True weight
+print("\nTest case 3: Single True weight")
+dta3 = xr.DataArray([1., 2., 3.])
+wgt3 = xr.DataArray(np.array([1, 0, 0], dtype=bool))
+result3 = dta3.weighted(wgt3).mean()
+print("Result:", result3)
+print("Expected: 1.0")
+
+# Test case 4: All True weights
+print("\nTest case 4: All True weights")
+dta4 = xr.DataArray([1., 2., 3.])
+wgt4 = xr.DataArray(np.array([1, 1, 1], dtype=bool))
+result4 = dta4.weighted(wgt4).mean()
+print("Result:", result4)
+print("Expected: 2.0")
\ No newline at end of file
diff --git a/test_multidim_bool.py b/test_multidim_bool.py
new file mode 100644
index 00000000..942a232e
--- /dev/null
+++ b/test_multidim_bool.py
@@ -0,0 +1,25 @@
+import numpy as np
+import xarray as xr
+
+# Create 2D data and weights
+data = xr.DataArray([[1., 2., 3.], [4., 5., 6.]], dims=['x', 'y'])
+weights = xr.DataArray([[True, True, False], [True, False, False]], dims=['x', 'y'])
+
+# Test weighted mean
+result = data.weighted(weights).mean()
+print("\nTest multidimensional boolean weights")
+print("Data shape:", data.shape)
+print("Weights shape:", weights.shape)
+print("Result:", result)
+print("Expected: 3.0 (mean of [1,2,4])")
+
+# Test weighted mean along specific dimension
+result_y = data.weighted(weights).mean(dim='y')
+print("\nTest mean along y dimension")
+print("Result:", result_y)
+print("Expected: [1.5, 4.0] (means along y dimension)")
+
+result_x = data.weighted(weights).mean(dim='x')
+print("\nTest mean along x dimension")
+print("Result:", result_x)
+print("Expected: [2.5, 2.0, nan] (means along x dimension)")
\ No newline at end of file
diff --git a/xarray/core/weighted.py b/xarray/core/weighted.py
index 996d2e4c..1faadd81 100644
--- a/xarray/core/weighted.py
+++ b/xarray/core/weighted.py
@@ -142,7 +142,10 @@ class Weighted:
         # we need to mask data values that are nan; else the weights are wrong
         mask = da.notnull()
 
-        sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
+        # Convert boolean weights to float to ensure proper numeric multiplication
+        weights = self.weights.astype(float) if self.weights.dtype == bool else self.weights
+
+        sum_of_weights = self._reduce(mask, weights, dim=dim, skipna=False)
 
         # 0-weights are not valid
         valid_weights = sum_of_weights != 0.0
