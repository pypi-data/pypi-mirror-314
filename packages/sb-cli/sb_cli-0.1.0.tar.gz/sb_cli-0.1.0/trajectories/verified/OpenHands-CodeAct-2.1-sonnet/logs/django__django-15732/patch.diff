diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index f2ca8c8df9..885d72e583 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -568,16 +568,18 @@ class BaseDatabaseSchemaEditor:
             exclude=meta_constraint_names | meta_index_names,
             **constraint_kwargs,
         )
-        if len(constraint_names) != 1:
+        if not constraint_names:
             raise ValueError(
-                "Found wrong number (%s) of constraints for %s(%s)"
+                "Found no constraints for %s(%s)"
                 % (
-                    len(constraint_names),
                     model._meta.db_table,
                     ", ".join(columns),
                 )
             )
-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))
+        # Drop all matching constraints - this handles the case where a field has both
+        # a unique=True constraint and a unique_together constraint
+        for constraint_name in constraint_names:
+            self.execute(self._delete_constraint_sql(sql, model, constraint_name))
 
     def alter_db_table(self, model, old_db_table, new_db_table):
         """Rename the table a model points to."""
diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py
index 5f41053283..68f068751e 100644
--- a/django/db/migrations/autodetector.py
+++ b/django/db/migrations/autodetector.py
@@ -116,6 +116,7 @@ class MigrationAutodetector:
         graph is an optional argument that, if provided, can help improve
         dependency generation and avoid potential circular dependencies.
         """
+        print("DEBUG: _detect_changes called")
         # The first phase is generating all the operations for each app
         # and gathering them into a big per-app list.
         # Then go through that list, order it, and split into migrations to
@@ -134,6 +135,7 @@ class MigrationAutodetector:
         self.new_proxy_keys = set()
         self.new_unmanaged_keys = set()
         for (app_label, model_name), model_state in self.from_state.models.items():
+            print(f"DEBUG: Processing from_state model {app_label}.{model_name}")
             if not model_state.options.get("managed", True):
                 self.old_unmanaged_keys.add((app_label, model_name))
             elif app_label not in self.from_state.real_apps:
@@ -141,8 +143,10 @@ class MigrationAutodetector:
                     self.old_proxy_keys.add((app_label, model_name))
                 else:
                     self.old_model_keys.add((app_label, model_name))
+                    print(f"DEBUG: Added {app_label}.{model_name} to old_model_keys")
 
         for (app_label, model_name), model_state in self.to_state.models.items():
+            print(f"DEBUG: Processing to_state model {app_label}.{model_name}")
             if not model_state.options.get("managed", True):
                 self.new_unmanaged_keys.add((app_label, model_name))
             elif app_label not in self.from_state.real_apps or (
@@ -152,6 +156,7 @@ class MigrationAutodetector:
                     self.new_proxy_keys.add((app_label, model_name))
                 else:
                     self.new_model_keys.add((app_label, model_name))
+                    print(f"DEBUG: Added {app_label}.{model_name} to new_model_keys")
 
         self.from_state.resolve_fields_and_relations()
         self.to_state.resolve_fields_and_relations()
@@ -201,9 +206,13 @@ class MigrationAutodetector:
         self.generate_added_constraints()
         self.generate_altered_db_table()
 
+        print("DEBUG: Before sorting:", self.generated_operations)
         self._sort_migrations()
+        print("DEBUG: After sorting:", self.generated_operations)
         self._build_migration_list(graph)
+        print("DEBUG: After building migration list:", self.migrations)
         self._optimize_migrations()
+        print("DEBUG: After optimizing:", self.migrations)
 
         return self.migrations
 
@@ -214,6 +223,7 @@ class MigrationAutodetector:
         deletion to the field that uses it.
         """
         self.kept_model_keys = self.old_model_keys & self.new_model_keys
+        print(f"DEBUG: kept_model_keys = {self.kept_model_keys}")
         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
         self.through_users = {}
@@ -274,8 +284,10 @@ class MigrationAutodetector:
         dependency (which _should_ be impossible as the operations are
         all split at this point so they can't depend and be depended on).
         """
+        print("DEBUG: _build_migration_list called with generated_operations:", self.generated_operations)
         self.migrations = {}
         num_ops = sum(len(x) for x in self.generated_operations.values())
+        print("DEBUG: _build_migration_list: num_ops =", num_ops)
         chop_mode = False
         while num_ops:
             # On every iteration, we step through all the apps and see if there
@@ -382,6 +394,7 @@ class MigrationAutodetector:
         Reorder to make things possible. Reordering may be needed so FKs work
         nicely inside the same app.
         """
+        print("DEBUG: _sort_migrations called with generated_operations:", self.generated_operations)
         for app_label, ops in sorted(self.generated_operations.items()):
             # construct a dependency graph for intra-app dependencies
             dependency_graph = {op: set() for op in ops}
@@ -401,6 +414,7 @@ class MigrationAutodetector:
             )
 
     def _optimize_migrations(self):
+        print("DEBUG: _optimize_migrations called with migrations:", self.migrations)
         # Add in internal dependencies among the migrations
         for app_label, migrations in self.migrations.items():
             for m1, m2 in zip(migrations, migrations[1:]):
@@ -484,11 +498,13 @@ class MigrationAutodetector:
     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
         # Dependencies are
         # (app_label, model_name, field_name, create/delete as True/False)
+        print(f"DEBUG: Adding operation {operation} to {app_label}")
         operation._auto_deps = dependencies or []
         if beginning:
             self.generated_operations.setdefault(app_label, []).insert(0, operation)
         else:
             self.generated_operations.setdefault(app_label, []).append(operation)
+        print(f"DEBUG: Current operations for {app_label}: {self.generated_operations.get(app_label, [])}")
 
     def swappable_first_key(self, item):
         """
@@ -1425,6 +1441,7 @@ class MigrationAutodetector:
         return dependencies
 
     def _get_altered_foo_together_operations(self, option_name):
+        print(f"DEBUG: _get_altered_foo_together_operations called with {option_name}")
         for app_label, model_name in sorted(self.kept_model_keys):
             old_model_name = self.renamed_models.get(
                 (app_label, model_name), model_name
@@ -1449,6 +1466,53 @@ class MigrationAutodetector:
             new_value = new_model_state.options.get(option_name)
             new_value = set(new_value) if new_value else set()
 
+            # If we're dealing with unique_together, check if any of the fields
+            # already have unique=True. If so, we can safely remove those constraints
+            # since they're redundant.
+            if option_name == "unique_together":
+                print(f"DEBUG: old_value before filtering: {old_value}")
+                print(f"DEBUG: new_value before filtering: {new_value}")
+                
+                # First check if any unique_together constraints were removed
+                if old_value and not new_value:
+                    # Check if all fields in the removed unique_together constraints have unique=True
+                    all_fields_unique = all(
+                        all(
+                            old_model_state.get_field(field).unique
+                            for field in fields
+                        )
+                        for fields in old_value
+                    )
+                    # If all fields are unique, we can safely remove the constraint
+                    if all_fields_unique:
+                        print("DEBUG: All fields in unique_together have unique=True, removing constraint")
+                        yield (
+                            old_value,
+                            new_value,
+                            app_label,
+                            model_name,
+                            [],
+                        )
+                        continue
+
+                # Otherwise, filter out redundant constraints
+                old_value = {
+                    fields for fields in old_value
+                    if not all(
+                        old_model_state.get_field(field).unique
+                        for field in fields
+                    )
+                }
+                new_value = {
+                    fields for fields in new_value
+                    if not all(
+                        new_model_state.get_field(field).unique
+                        for field in fields
+                    )
+                }
+                print(f"DEBUG: old_value after filtering: {old_value}")
+                print(f"DEBUG: new_value after filtering: {new_value}")
+
             if old_value != new_value:
                 dependencies = []
                 for foo_togethers in new_value:
@@ -1472,6 +1536,7 @@ class MigrationAutodetector:
                 )
 
     def _generate_removed_altered_foo_together(self, operation):
+        print(f"DEBUG: _generate_removed_altered_foo_together called with {operation}")
         for (
             old_value,
             new_value,
@@ -1479,6 +1544,7 @@ class MigrationAutodetector:
             model_name,
             dependencies,
         ) in self._get_altered_foo_together_operations(operation.option_name):
+            print(f"DEBUG: Processing {app_label}.{model_name} with old_value={old_value}, new_value={new_value}")
             if operation == operations.AlterIndexTogether:
                 old_value = {
                     value
@@ -1486,17 +1552,30 @@ class MigrationAutodetector:
                     if value
                     not in self.renamed_index_together_values[app_label, model_name]
                 }
-            removal_value = new_value.intersection(old_value)
-            if removal_value or old_value:
+            # If we're removing all constraints, set to None
+            if not new_value and old_value:
+                print(f"DEBUG: Removing all {operation.option_name} constraints")
                 self.add_operation(
                     app_label,
-                    operation(
-                        name=model_name, **{operation.option_name: removal_value}
-                    ),
+                    operation(name=model_name, **{operation.option_name: None}),
                     dependencies=dependencies,
                 )
+            else:
+                # Otherwise, only keep the constraints that exist in both old and new
+                removal_value = new_value.intersection(old_value)
+                print(f"DEBUG: removal_value={removal_value}")
+                if removal_value != old_value:
+                    print(f"DEBUG: Adding operation to modify {operation.option_name}")
+                    self.add_operation(
+                        app_label,
+                        operation(
+                            name=model_name, **{operation.option_name: removal_value}
+                        ),
+                        dependencies=dependencies,
+                    )
 
     def generate_removed_altered_unique_together(self):
+        print("DEBUG: generate_removed_altered_unique_together called")
         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
 
     def generate_removed_altered_index_together(self):
@@ -1641,6 +1720,11 @@ class MigrationAutodetector:
         and dependencies of the changes so they extend the graph from the leaf
         nodes for each app.
         """
+        print("DEBUG: arrange_for_graph called with changes:", changes)
+        print("DEBUG: arrange_for_graph: migrations have operations:", {
+            app_label: [m.operations for m in migrations]
+            for app_label, migrations in changes.items()
+        })
         leaves = graph.leaf_nodes()
         name_map = {}
         for app_label, migrations in list(changes.items()):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..1740f53a86
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,76 @@
+import os
+import django
+from django.db import models
+from django.db import migrations
+from django.db.migrations.state import ProjectState
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.loader import MigrationLoader
+from django.db.migrations.questioner import MigrationQuestioner
+from django.db.migrations.operations import RemoveConstraint
+from django.apps import apps
+
+# Create a test settings module
+with open('/testbed/test_settings.py', 'w') as f:
+    f.write("""
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+INSTALLED_APPS = ['test_app']
+SECRET_KEY = 'dummy'
+""")
+
+# Set up Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+django.setup()
+
+# Create initial model state
+class FooBar(models.Model):
+    name = models.CharField(max_length=100, unique=True)
+    
+    class Meta:
+        app_label = 'test_app'
+        unique_together = (('name',),)
+
+# Create project state
+before_state = ProjectState()
+before_state.add_model(migrations.state.ModelState.from_model(FooBar))
+
+# Create new state without unique_together
+class FooBar(models.Model):
+    name = models.CharField(max_length=100, unique=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+after_state = ProjectState()
+after_state.add_model(migrations.state.ModelState.from_model(FooBar))
+
+# Detect changes
+autodetector = MigrationAutodetector(
+    before_state,
+    after_state,
+    MigrationQuestioner({"ask_rename_model": False})
+)
+
+loader = MigrationLoader(None)
+changes = autodetector.changes(graph=loader.graph)
+print("Changes detected:", changes)
+
+# Try to apply the changes
+if changes:
+    for app_label, migrations_list in changes.items():
+        for migration in migrations_list:
+            print("\nMigration operations:")
+            for operation in migration.operations:
+                print(f"- {operation}")
+                try:
+                    # Try to simulate the operation
+                    operation.state_forwards(app_label, before_state)
+                    print("  Operation succeeded")
+                except Exception as e:
+                    print(f"  Operation failed: {str(e)}")
+else:
+    print("\nNo changes detected - this is unexpected! The unique_together constraint should be detected as removed.")
\ No newline at end of file
diff --git a/test_app/__init__.py b/test_app/__init__.py
new file mode 100644
index 0000000000..816811148a
--- /dev/null
+++ b/test_app/__init__.py
@@ -0,0 +1 @@
+# Test app
\ No newline at end of file
diff --git a/test_app/apps.py b/test_app/apps.py
new file mode 100644
index 0000000000..ae6f331d8b
--- /dev/null
+++ b/test_app/apps.py
@@ -0,0 +1,4 @@
+from django.apps import AppConfig
+
+class TestAppConfig(AppConfig):
+    name = 'test_app'
\ No newline at end of file
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..a6cb523074
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,9 @@
+
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+INSTALLED_APPS = ['test_app']
+SECRET_KEY = 'dummy'
