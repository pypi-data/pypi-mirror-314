diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index 2b59dd301a..e78a8dca61 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -552,11 +552,31 @@ class ResolvedOuterRef(F):
     """
     contains_aggregate = False
 
-    def as_sql(self, *args, **kwargs):
-        raise ValueError(
-            'This queryset contains a reference to an outer query and may '
-            'only be used in a subquery.'
-        )
+    def as_sql(self, compiler, connection, **kwargs):
+        """
+        Generate the SQL for this reference.
+        """
+        # Get the current query being compiled
+        query = compiler.query
+
+        # If this is a subquery (which it should be), get the outer query
+        outer_query = getattr(self, 'outer_query', None) or getattr(query, 'outer_query', None)
+        if not outer_query:
+            raise ValueError(
+                'This queryset contains a reference to an outer query and may '
+                'only be used in a subquery.'
+            )
+
+        # Get the referenced field from the outer query's model
+        field = outer_query.model._meta.get_field(self.name)
+        
+        # Build the column reference using the outer query's base table
+        qn = compiler.quote_name_unless_alias
+        outer_alias = outer_query.get_initial_alias()
+        column = field.get_col(outer_alias)
+        
+        # Always use the outer query's base table to ensure consistent references
+        return "%s.%s" % (qn(outer_query.base_table), qn(column.target.column)), []
 
     def relabeled_clone(self, relabels):
         return self
@@ -564,10 +584,30 @@ class ResolvedOuterRef(F):
 
 class OuterRef(F):
     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
-                           summarize=False, for_save=False, simple_col=False):
+                           summarize=False, for_save=False, simple_col=False, outer_query=None):
         if isinstance(self.name, self.__class__):
             return self.name
-        return ResolvedOuterRef(self.name)
+        resolved = ResolvedOuterRef(self.name)
+        if outer_query is not None:
+            resolved.outer_query = outer_query
+        elif query is not None:
+            # For negated conditions, we need to ensure the outer query reference is preserved
+            if hasattr(query, 'outer_query'):
+                resolved.outer_query = query.outer_query
+            # Also check if this is a subquery in a negated condition
+            elif hasattr(query, 'where'):
+                def find_outer_query(node):
+                    if hasattr(node, 'outer_query'):
+                        return node.outer_query
+                    if hasattr(node, 'parent_query'):
+                        return find_outer_query(node.parent_query)
+                    if hasattr(node, 'query'):
+                        return find_outer_query(node.query)
+                    return None
+                outer_query = find_outer_query(query.where)
+                if outer_query:
+                    resolved.outer_query = outer_query
+        return resolved
 
 
 class Func(SQLiteNumericMixin, Expression):
@@ -1058,6 +1098,20 @@ class Subquery(Expression):
     def as_sql(self, compiler, connection, template=None, **extra_context):
         connection.ops.check_expression_support(self)
         template_params = {**self.extra, **extra_context}
+
+        # For negated conditions, we need to ensure the outer query reference is preserved
+        if hasattr(compiler.query, 'outer_query'):
+            def set_outer_query(node):
+                if hasattr(node, 'children'):
+                    for child in node.children:
+                        set_outer_query(child)
+                if hasattr(node, 'query'):
+                    node.query.outer_query = compiler.query.outer_query
+                if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                    node.rhs.query.outer_query = compiler.query.outer_query
+            set_outer_query(self.query.where)
+            self.query.outer_query = compiler.query.outer_query
+
         subquery_sql, sql_params = self.query.as_sql(compiler, connection)
         template_params['subquery'] = subquery_sql[1:-1]
 
@@ -1087,7 +1141,48 @@ class Exists(Subquery):
         clone.negated = not self.negated
         return clone
 
+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
+        # Set up outer query reference for proper OuterRef resolution
+        if query is not None:
+            self.query.outer_query = query
+            # For negated conditions, we need to ensure all subqueries have the outer query reference
+            def set_outer_query(node):
+                if hasattr(node, 'children'):
+                    for child in node.children:
+                        set_outer_query(child)
+                if hasattr(node, 'query'):
+                    node.query.outer_query = query
+                if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                    node.rhs.query.outer_query = query
+                if hasattr(node, 'lhs') and hasattr(node.lhs, 'query'):
+                    node.lhs.query.outer_query = query
+            set_outer_query(self.query.where)
+            # Also set outer_query on any subqueries in the where clause
+            def set_subquery_outer_query(node):
+                if hasattr(node, 'query'):
+                    node.query.outer_query = query
+                if hasattr(node, 'children'):
+                    for child in node.children:
+                        set_subquery_outer_query(child)
+                if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                    node.rhs.query.outer_query = query
+                if hasattr(node, 'lhs') and hasattr(node.lhs, 'query'):
+                    node.lhs.query.outer_query = query
+            set_subquery_outer_query(self.query.where)
+        return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
+
     def as_sql(self, compiler, connection, template=None, **extra_context):
+        # For negated conditions, we need to ensure all subqueries have the outer query reference
+        if self.negated and hasattr(compiler.query, 'outer_query'):
+            def set_outer_query(node):
+                if hasattr(node, 'children'):
+                    for child in node.children:
+                        set_outer_query(child)
+                if hasattr(node, 'query'):
+                    node.query.outer_query = compiler.query.outer_query
+                if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                    node.rhs.query.outer_query = compiler.query.outer_query
+            set_outer_query(self.query.where)
         sql, params = super().as_sql(compiler, connection, template, **extra_context)
         if self.negated:
             sql = 'NOT {}'.format(sql)
diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py
index 105dc93251..2fbc57d195 100644
--- a/django/db/models/lookups.py
+++ b/django/db/models/lookups.py
@@ -89,7 +89,11 @@ class Lookup:
                 # transformed before being used for lookup
                 value = Value(value, output_field=self.lhs.output_field)
             value = self.apply_bilateral_transforms(value)
-            value = value.resolve_expression(compiler.query)
+            # For negated conditions, we need to ensure the outer query reference is preserved
+            if hasattr(compiler.query, 'outer_query'):
+                value = value.resolve_expression(compiler.query.outer_query)
+            else:
+                value = value.resolve_expression(compiler.query)
         if hasattr(value, 'as_sql'):
             return compiler.compile(value)
         else:
@@ -353,6 +357,19 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):
             placeholder = '(' + ', '.join(sqls) + ')'
             return (placeholder, sqls_params)
         else:
+            # For negated conditions, we need to ensure the outer query reference is preserved
+            if hasattr(compiler.query, 'outer_query'):
+                def set_outer_query(node):
+                    if hasattr(node, 'query'):
+                        node.query.outer_query = compiler.query.outer_query
+                    if hasattr(node, 'children'):
+                        for child in node.children:
+                            set_outer_query(child)
+                    if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                        node.rhs.query.outer_query = compiler.query.outer_query
+                    if hasattr(node, 'lhs') and hasattr(node.lhs, 'query'):
+                        node.lhs.query.outer_query = compiler.query.outer_query
+                set_outer_query(self.rhs)
             if not getattr(self.rhs, 'has_select_fields', True):
                 self.rhs.clear_select_clause()
                 self.rhs.add_fields(['pk'])
diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 77e023b92f..7aea457ec5 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -403,6 +403,20 @@ class SQLCompiler:
         return r
 
     def compile(self, node):
+        # For negated conditions, we need to ensure the outer query reference is preserved
+        if hasattr(self.query, 'outer_query'):
+            def set_outer_query(node):
+                if hasattr(node, 'query'):
+                    node.query.outer_query = self.query.outer_query
+                if hasattr(node, 'children'):
+                    for child in node.children:
+                        set_outer_query(child)
+                if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                    node.rhs.query.outer_query = self.query.outer_query
+                if hasattr(node, 'lhs') and hasattr(node.lhs, 'query'):
+                    node.lhs.query.outer_query = self.query.outer_query
+            set_outer_query(node)
+
         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
         if vendor_impl:
             sql, params = vendor_impl(self, self.connection)
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 35f3c5e1ea..430a2fd244 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -170,6 +170,7 @@ class Query(BaseExpression):
         self.used_aliases = set()
         self.filter_is_sticky = False
         self.subquery = False
+        self.outer_query = None  # Reference to the outer query for subqueries
 
         # SQL-related attributes
         # Select and related select clauses are expressions to use in the
@@ -279,7 +280,36 @@ class Query(BaseExpression):
             raise ValueError("Need either using or connection")
         if using:
             connection = connections[using]
-        return connection.ops.compiler(self.compiler)(self, connection, using)
+        compiler = connection.ops.compiler(self.compiler)(self, connection, using)
+        # For negated conditions, we need to ensure the outer query reference is preserved
+        if hasattr(self, 'outer_query'):
+            compiler.query.outer_query = self.outer_query
+            # Also propagate outer_query to any subqueries in negated conditions
+            def set_outer_query(node):
+                if hasattr(node, 'query'):
+                    node.query.outer_query = self.outer_query
+                if hasattr(node, 'children'):
+                    for child in node.children:
+                        set_outer_query(child)
+                if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                    node.rhs.query.outer_query = self.outer_query
+                if hasattr(node, 'lhs') and hasattr(node.lhs, 'query'):
+                    node.lhs.query.outer_query = self.outer_query
+            if hasattr(self, 'where'):
+                set_outer_query(self.where)
+                # Also set outer_query on any subqueries in the where clause
+                def set_subquery_outer_query(node):
+                    if hasattr(node, 'query'):
+                        node.query.outer_query = self.outer_query
+                    if hasattr(node, 'children'):
+                        for child in node.children:
+                            set_subquery_outer_query(child)
+                    if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                        node.rhs.query.outer_query = self.outer_query
+                    if hasattr(node, 'lhs') and hasattr(node.lhs, 'query'):
+                        node.lhs.query.outer_query = self.outer_query
+                set_subquery_outer_query(self.where)
+        return compiler
 
     def get_meta(self):
         """
diff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py
index bf0828dc8b..646e2c7285 100644
--- a/django/db/models/sql/where.py
+++ b/django/db/models/sql/where.py
@@ -76,6 +76,12 @@ class WhereNode(tree.Node):
         else:
             full_needed, empty_needed = 1, len(self.children)
 
+        # For negated conditions, we need to ensure the outer query reference is preserved
+        if self.negated and hasattr(compiler.query, 'outer_query'):
+            for child in self.children:
+                if hasattr(child, 'query'):
+                    child.query.outer_query = compiler.query.outer_query
+
         for child in self.children:
             try:
                 sql, params = compiler.compile(child)
@@ -197,11 +203,34 @@ class WhereNode(tree.Node):
         if hasattr(node, 'lhs'):
             node.lhs = cls._resolve_leaf(node.lhs, query, *args, **kwargs)
         if hasattr(node, 'rhs'):
+            # For negated conditions, we need to ensure the outer query reference is preserved
+            if getattr(node, 'negated', False) and hasattr(query, 'outer_query'):
+                if hasattr(node.rhs, 'query'):
+                    node.rhs.query.outer_query = query.outer_query
+                elif hasattr(node.rhs, 'children'):
+                    for child in node.rhs.children:
+                        if hasattr(child, 'query'):
+                            child.query.outer_query = query.outer_query
             node.rhs = cls._resolve_leaf(node.rhs, query, *args, **kwargs)
 
-    def resolve_expression(self, *args, **kwargs):
+    def resolve_expression(self, query=None, *args, **kwargs):
         clone = self.clone()
-        clone._resolve_node(clone, *args, **kwargs)
+        if query is not None:
+            clone.parent_query = query
+            # For negated conditions, we need to ensure the outer query reference is preserved
+            if hasattr(query, 'outer_query'):
+                def set_outer_query(node):
+                    if hasattr(node, 'query'):
+                        node.query.outer_query = query.outer_query
+                    if hasattr(node, 'children'):
+                        for child in node.children:
+                            set_outer_query(child)
+                    if hasattr(node, 'rhs') and hasattr(node.rhs, 'query'):
+                        node.rhs.query.outer_query = query.outer_query
+                    if hasattr(node, 'lhs') and hasattr(node.lhs, 'query'):
+                        node.lhs.query.outer_query = query.outer_query
+                set_outer_query(clone)
+        clone._resolve_node(clone, query, *args, **kwargs)
         clone.resolved = True
         return clone
 
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..db5f1dfad6
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,8 @@
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+INSTALLED_APPS = ['testapp']
+SECRET_KEY = 'dummy'
\ No newline at end of file
diff --git a/testapp/__init__.py b/testapp/__init__.py
new file mode 100644
index 0000000000..a7506fdc94
--- /dev/null
+++ b/testapp/__init__.py
@@ -0,0 +1 @@
+# Empty init file
\ No newline at end of file
diff --git a/testapp/models.py b/testapp/models.py
new file mode 100644
index 0000000000..b66daef682
--- /dev/null
+++ b/testapp/models.py
@@ -0,0 +1,10 @@
+from django.db import models
+
+class Number(models.Model):
+    pass
+
+class Tag(models.Model):
+    category = models.ForeignKey(Number, on_delete=models.CASCADE)
+
+class Item(models.Model):
+    tags = models.ManyToManyField(Tag)
\ No newline at end of file
