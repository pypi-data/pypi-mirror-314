diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py
index a778cd413b..1ba83cdd32 100644
--- a/django/db/models/aggregates.py
+++ b/django/db/models/aggregates.py
@@ -77,16 +77,16 @@ class Aggregate(Func):
             # returning self.filter and including that in this loop.
             expressions = super(Aggregate, c).get_source_expressions()
             for index, expr in enumerate(expressions):
-                if expr.contains_aggregate:
+                if expr.contains_aggregate or expr.contains_over_clause:
                     before_resolved = self.get_source_expressions()[index]
                     name = (
                         before_resolved.name
                         if hasattr(before_resolved, "name")
                         else repr(before_resolved)
                     )
+                    error_type = "aggregate" if expr.contains_aggregate else "window function"
                     raise FieldError(
-                        "Cannot compute %s('%s'): '%s' is an aggregate"
-                        % (c.name, name, name)
+                        f"Cannot compute {c.name}('{name}'): '{name}' is an {error_type}"
                     )
         if (default := c.default) is None:
             return c
diff --git a/django/db/models/functions/window_aggregates.py b/django/db/models/functions/window_aggregates.py
new file mode 100644
index 0000000000..7b4b8a361b
--- /dev/null
+++ b/django/db/models/functions/window_aggregates.py
@@ -0,0 +1,77 @@
+"""
+Functions for aggregating over window functions.
+"""
+from django.db.models import Aggregate, Value, F, Sum
+from django.db.models.expressions import RawSQL
+from django.db.models.fields import FloatField
+from django.db import NotSupportedError
+
+
+class WindowAggregate(Aggregate):
+    """
+    An aggregate that can be used to aggregate over window functions.
+    This is done by using a subquery with the window function.
+    """
+    template = None  # Don't use the standard template
+    window_compatible = True
+    allow_distinct = False
+
+    def __init__(self, expression, window_fn, **extra):
+        """
+        Args:
+            expression: The expression to aggregate
+            window_fn: The window function to use (e.g., SUM(x) OVER (ORDER BY y))
+            **extra: Additional arguments to pass to Aggregate
+        """
+        self.window_fn = window_fn
+        # Convert string field references to F() expressions
+        if isinstance(expression, str):
+            expression = F(expression)
+        super().__init__(expression, output_field=FloatField(), **extra)
+
+    def resolve_expression(self, *args, **kwargs):
+        c = super().resolve_expression(*args, **kwargs)
+        c.window_fn = c.window_fn.resolve_expression(*args, **kwargs)
+        return c
+
+    def get_source_expressions(self):
+        return [self.source_expressions[0], self.window_fn]
+
+    def set_source_expressions(self, exprs):
+        self.source_expressions = exprs[:1]
+        self.window_fn = exprs[1]
+
+    def get_refs(self):
+        """
+        Get the references used by this expression.
+        """
+        return set()
+
+    def as_sql(self, compiler, connection, **extra_context):
+        """
+        Generate SQL using a subquery with the window function.
+        """
+        if connection.vendor == 'sqlite':
+            raise NotSupportedError(
+                "SQLite does not support aggregating over window functions. "
+                "Consider using PostgreSQL or another database that supports this feature."
+            )
+
+        # Get the SQL for the inner window function
+        window_sql, window_params = compiler.compile(self.window_fn)
+
+        # Get the table name from the query
+        opts = compiler.query.model._meta
+        qn = compiler.quote_name_unless_alias
+        table_name = qn(opts.db_table)
+
+        # Build the complete SQL
+        sql = """
+            SELECT COALESCE(SUM(window_result), 0)
+            FROM (
+                SELECT %s as window_result
+                FROM %s
+            ) subq
+        """ % (window_sql, table_name)
+
+        return sql, window_params
\ No newline at end of file
diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..b839eef996
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,103 @@
+import os
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_project.settings')
+
+import django
+from django.conf import settings
+from pathlib import Path
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'test_app',
+        ],
+    )
+django.setup()
+
+from django.db import models, connection
+from django.db.models import F, Sum, Window
+from django.db.models.functions import Coalesce
+from django.db.models.functions.window_aggregates import WindowAggregate
+
+# Create a test model
+class Transaction(models.Model):
+    date = models.DateField()
+    DJR = models.FloatField(null=True)
+
+    class Meta:
+        app_label = 'test_app'
+
+# Create the database table
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Transaction)
+
+# Add some test data
+from datetime import date
+test_data = [
+    Transaction(date=date(2023, 1, 1), DJR=10.0),
+    Transaction(date=date(2023, 1, 2), DJR=20.0),
+    Transaction(date=date(2023, 1, 3), DJR=30.0),
+]
+Transaction.objects.bulk_create(test_data)
+
+print("Original query that fails:")
+queryset = Transaction.objects.all()
+queryset = queryset.annotate(
+    cumul_DJR=Coalesce(Window(Sum("DJR"), order_by=F("date").asc()), 0.0)
+)
+
+try:
+    aggregate = queryset.aggregate(
+        DJR_total=Sum("DJR"),
+        cumul_DJR_total=Sum("cumul_DJR")
+    )
+    print("No error raised - this is unexpected!")
+except Exception as e:
+    print(f"Got expected error: {e}")
+
+print("\nFixed query using WindowAggregate:")
+window_fn = Window(Sum("DJR"), order_by=F("date").asc())
+try:
+    aggregate = Transaction.objects.aggregate(
+        DJR_total=Sum("DJR"),
+        cumul_DJR_total=WindowAggregate("DJR", window_fn)
+    )
+    print("Query succeeded!")
+    print(aggregate)
+except Exception as e:
+    print(f"Got error: {e}")
+
+print("\nEdge case - empty table:")
+Transaction.objects.all().delete()
+try:
+    aggregate = Transaction.objects.aggregate(
+        DJR_total=Sum("DJR"),
+        cumul_DJR_total=WindowAggregate("DJR", window_fn)
+    )
+    print("Query succeeded!")
+    print(aggregate)
+except Exception as e:
+    print(f"Got error: {e}")
+
+print("\nEdge case - NULL values:")
+test_data = [
+    Transaction(date=date(2023, 1, 1), DJR=None),
+    Transaction(date=date(2023, 1, 2), DJR=20.0),
+    Transaction(date=date(2023, 1, 3), DJR=None),
+]
+Transaction.objects.bulk_create(test_data)
+try:
+    aggregate = Transaction.objects.aggregate(
+        DJR_total=Sum("DJR"),
+        cumul_DJR_total=WindowAggregate("DJR", window_fn)
+    )
+    print("Query succeeded!")
+    print(aggregate)
+except Exception as e:
+    print(f"Got error: {e}")
\ No newline at end of file
diff --git a/test_app/__init__.py b/test_app/__init__.py
new file mode 100644
index 0000000000..816811148a
--- /dev/null
+++ b/test_app/__init__.py
@@ -0,0 +1 @@
+# Test app
\ No newline at end of file
