diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index b99f03cd88..6e5b67aa1f 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -68,8 +68,9 @@ JoinInfo = namedtuple(
 )
 
 
-def _get_col(target, field, alias, simple_col):
-    if simple_col:
+def _get_col(target, field, alias, simple_col, check_constraint=False):
+    # For check constraints, we always want to use SimpleCol to avoid table name qualification
+    if simple_col or check_constraint:
         return SimpleCol(target, field)
     return target.get_col(alias, field)
 
@@ -1182,7 +1183,8 @@ class Query(BaseExpression):
 
     def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
                      can_reuse=None, allow_joins=True, split_subq=True,
-                     reuse_with_filtered_relation=False, simple_col=False):
+                     reuse_with_filtered_relation=False, simple_col=False,
+                     check_constraint=False):
         """
         Build a WhereNode for a single filter clause but don't add it
         to this Query. Query.add_q() will then add this filter to the where
@@ -1271,11 +1273,11 @@ class Query(BaseExpression):
             if num_lookups > 1:
                 raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
             if len(targets) == 1:
-                col = _get_col(targets[0], join_info.final_field, alias, simple_col)
+                col = _get_col(targets[0], join_info.final_field, alias, simple_col, check_constraint)
             else:
                 col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
         else:
-            col = _get_col(targets[0], join_info.final_field, alias, simple_col)
+            col = _get_col(targets[0], join_info.final_field, alias, simple_col, check_constraint)
 
         condition = self.build_lookup(lookups, col, value)
         lookup_type = condition.lookup_name
@@ -1297,7 +1299,7 @@ class Query(BaseExpression):
                 #   <=>
                 # NOT (col IS NOT NULL AND col = someval).
                 lookup_class = targets[0].get_lookup('isnull')
-                col = _get_col(targets[0], join_info.targets[0], alias, simple_col)
+                col = _get_col(targets[0], join_info.targets[0], alias, simple_col, check_constraint)
                 clause.add(lookup_class(col, False), AND)
         return clause, used_joins if not require_outer else ()
 
@@ -1322,11 +1324,13 @@ class Query(BaseExpression):
         self.demote_joins(existing_inner)
 
     def build_where(self, q_object):
-        return self._add_q(q_object, used_aliases=set(), allow_joins=False, simple_col=True)[0]
+        # For check constraints, we want to use SimpleCol for all fields to avoid table name qualification
+        # This ensures consistent behavior between AND and OR clauses
+        return self._add_q(q_object, used_aliases=set(), allow_joins=False, simple_col=True, check_constraint=True)[0]
 
     def _add_q(self, q_object, used_aliases, branch_negated=False,
                current_negated=False, allow_joins=True, split_subq=True,
-               simple_col=False):
+               simple_col=False, check_constraint=False):
         """Add a Q-object to the current filter."""
         connector = q_object.connector
         current_negated = current_negated ^ q_object.negated
@@ -1338,13 +1342,15 @@ class Query(BaseExpression):
             if isinstance(child, Node):
                 child_clause, needed_inner = self._add_q(
                     child, used_aliases, branch_negated,
-                    current_negated, allow_joins, split_subq)
+                    current_negated, allow_joins, split_subq,
+                    simple_col=simple_col, check_constraint=check_constraint)
                 joinpromoter.add_votes(needed_inner)
             else:
                 child_clause, needed_inner = self.build_filter(
                     child, can_reuse=used_aliases, branch_negated=branch_negated,
                     current_negated=current_negated, allow_joins=allow_joins,
                     split_subq=split_subq, simple_col=simple_col,
+                    check_constraint=check_constraint,
                 )
                 joinpromoter.add_votes(needed_inner)
             if child_clause:
@@ -1639,7 +1645,7 @@ class Query(BaseExpression):
             join_info.transform_function(targets[0], final_alias)
             if reuse is not None:
                 reuse.update(join_list)
-            col = _get_col(targets[0], join_info.targets[0], join_list[-1], simple_col)
+            col = _get_col(targets[0], join_info.targets[0], join_list[-1], simple_col, check_constraint)
             return col
 
     def split_exclude(self, filter_expr, can_reuse, names_with_path):
diff --git a/fix_check_constraint.patch b/fix_check_constraint.patch
new file mode 100644
index 0000000000..0e54791335
--- /dev/null
+++ b/fix_check_constraint.patch
@@ -0,0 +1,91 @@
+diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
+index b99f03cd88..6e5b67aa1f 100644
+--- a/django/db/models/sql/query.py
++++ b/django/db/models/sql/query.py
+@@ -68,8 +68,9 @@ JoinInfo = namedtuple(
+ )
+ 
+ 
+-def _get_col(target, field, alias, simple_col):
+-    if simple_col:
++def _get_col(target, field, alias, simple_col, check_constraint=False):
++    # For check constraints, we always want to use SimpleCol to avoid table name qualification
++    if simple_col or check_constraint:
+         return SimpleCol(target, field)
+     return target.get_col(alias, field)
+ 
+@@ -1182,7 +1183,8 @@ class Query(BaseExpression):
+ 
+     def build_filter(self, filter_expr, branch_negated=False, current_negated=False,
+                      can_reuse=None, allow_joins=True, split_subq=True,
+-                     reuse_with_filtered_relation=False, simple_col=False):
++                     reuse_with_filtered_relation=False, simple_col=False,
++                     check_constraint=False):
+         """
+         Build a WhereNode for a single filter clause but don't add it
+         to this Query. Query.add_q() will then add this filter to the where
+@@ -1271,11 +1273,11 @@ class Query(BaseExpression):
+             if num_lookups > 1:
+                 raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))
+             if len(targets) == 1:
+-                col = _get_col(targets[0], join_info.final_field, alias, simple_col)
++                col = _get_col(targets[0], join_info.final_field, alias, simple_col, check_constraint)
+             else:
+                 col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)
+         else:
+-            col = _get_col(targets[0], join_info.final_field, alias, simple_col)
++            col = _get_col(targets[0], join_info.final_field, alias, simple_col, check_constraint)
+ 
+         condition = self.build_lookup(lookups, col, value)
+         lookup_type = condition.lookup_name
+@@ -1297,7 +1299,7 @@ class Query(BaseExpression):
+                 #   <=>
+                 # NOT (col IS NOT NULL AND col = someval).
+                 lookup_class = targets[0].get_lookup('isnull')
+-                col = _get_col(targets[0], join_info.targets[0], alias, simple_col)
++                col = _get_col(targets[0], join_info.targets[0], alias, simple_col, check_constraint)
+                 clause.add(lookup_class(col, False), AND)
+         return clause, used_joins if not require_outer else ()
+ 
+@@ -1322,11 +1324,13 @@ class Query(BaseExpression):
+         self.demote_joins(existing_inner)
+ 
+     def build_where(self, q_object):
+-        return self._add_q(q_object, used_aliases=set(), allow_joins=False, simple_col=True)[0]
++        # For check constraints, we want to use SimpleCol for all fields to avoid table name qualification
++        # This ensures consistent behavior between AND and OR clauses
++        return self._add_q(q_object, used_aliases=set(), allow_joins=False, simple_col=True, check_constraint=True)[0]
+ 
+     def _add_q(self, q_object, used_aliases, branch_negated=False,
+                current_negated=False, allow_joins=True, split_subq=True,
+-               simple_col=False):
++               simple_col=False, check_constraint=False):
+         """Add a Q-object to the current filter."""
+         connector = q_object.connector
+         current_negated = current_negated ^ q_object.negated
+@@ -1338,13 +1342,15 @@ class Query(BaseExpression):
+             if isinstance(child, Node):
+                 child_clause, needed_inner = self._add_q(
+                     child, used_aliases, branch_negated,
+-                    current_negated, allow_joins, split_subq)
++                    current_negated, allow_joins, split_subq,
++                    simple_col=simple_col, check_constraint=check_constraint)
+                 joinpromoter.add_votes(needed_inner)
+             else:
+                 child_clause, needed_inner = self.build_filter(
+                     child, can_reuse=used_aliases, branch_negated=branch_negated,
+                     current_negated=current_negated, allow_joins=allow_joins,
+                     split_subq=split_subq, simple_col=simple_col,
++                    check_constraint=check_constraint,
+                 )
+                 joinpromoter.add_votes(needed_inner)
+             if child_clause:
+@@ -1639,7 +1645,7 @@ class Query(BaseExpression):
+             join_info.transform_function(targets[0], final_alias)
+             if reuse is not None:
+                 reuse.update(join_list)
+-            col = _get_col(targets[0], join_info.targets[0], join_list[-1], simple_col)
++            col = _get_col(targets[0], join_info.targets[0], join_list[-1], simple_col, check_constraint)
+             return col
+ 
+     def split_exclude(self, filter_expr, can_reuse, names_with_path):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..3389ecee83
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,41 @@
+import os
+import django
+from django.conf import settings
+from django.db import models, migrations, connection
+from django.db.backends.sqlite3.schema import DatabaseSchemaEditor
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=False,
+    )
+    django.setup()
+
+# Define the model
+class TestConstraint(models.Model):
+    field_1 = models.IntegerField(blank=True, null=True)
+    flag = models.BooleanField(blank=False, null=False)
+
+    class Meta:
+        app_label = 'test_app'
+        constraints = [
+            models.CheckConstraint(
+                check=models.Q(flag__exact=True, field_1__isnull=False) | models.Q(flag__exact=False),
+                name='field_1_has_value_if_flag_set'
+            ),
+        ]
+
+# Create a schema editor instance
+schema_editor = DatabaseSchemaEditor(connection)
+
+# Get the SQL for the check constraint
+constraint = TestConstraint._meta.constraints[0]
+sql = schema_editor._check_sql(constraint.name, constraint.check)
+print("Generated SQL:", sql)
\ No newline at end of file
diff --git a/test_app.py b/test_app.py
new file mode 100644
index 0000000000..971d5b3d16
--- /dev/null
+++ b/test_app.py
@@ -0,0 +1,5 @@
+from django.apps import AppConfig
+
+class TestConfig(AppConfig):
+    name = 'test_app'
+    verbose_name = 'Test App'
\ No newline at end of file
