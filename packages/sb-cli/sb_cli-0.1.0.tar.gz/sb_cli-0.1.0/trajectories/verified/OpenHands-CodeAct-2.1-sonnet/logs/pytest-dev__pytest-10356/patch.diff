diff --git a/conftest.py b/conftest.py
new file mode 100644
index 000000000..972021879
--- /dev/null
+++ b/conftest.py
@@ -0,0 +1,3 @@
+def pytest_configure(config):
+    for marker in ["foo", "bar", "baz", "qux"]:
+        config.addinivalue_line("markers", f"{marker}: test marker")
\ No newline at end of file
diff --git a/reproduce_marker_issue.py b/reproduce_marker_issue.py
new file mode 100644
index 000000000..9c4894b70
--- /dev/null
+++ b/reproduce_marker_issue.py
@@ -0,0 +1,66 @@
+import itertools
+import pytest
+
+# Python 2/3 compatible metaclass
+def with_metaclass(meta, *bases):
+    class metaclass(meta):
+        def __new__(cls, name, this_bases, d):
+            return meta(name, bases, d)
+    return type.__new__(metaclass, 'temporary_class', (), {})
+
+class BaseMeta(type):
+    @property
+    def pytestmark(self):
+        return (
+            getattr(self, "_pytestmark", []) +
+            list(itertools.chain.from_iterable(getattr(x, "_pytestmark", []) for x in self.__mro__))
+        )
+
+    @pytestmark.setter
+    def pytestmark(self, value):
+        self._pytestmark = value
+
+class Base(with_metaclass(BaseMeta, object)):
+    pass
+
+@pytest.mark.foo
+class Foo(Base):
+    pass
+
+@pytest.mark.bar
+class Bar(Base):
+    pass
+
+@pytest.mark.baz
+class Baz(Base):
+    pass
+
+@pytest.mark.foo(reason="another foo")  # Different foo marker
+class FooBar(Foo):
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        # Test basic multiple inheritance
+        from _pytest.mark.structures import get_unpacked_marks
+        marks = [mark.name for mark in get_unpacked_marks(TestDings)]
+        assert 'foo' in marks, "foo marker not found"
+        assert 'bar' in marks, "bar marker not found"
+
+class TestDeepInheritance(FooBar, Baz):
+    def test_deep(self):
+        # Test deeper inheritance hierarchy and duplicate markers
+        from _pytest.mark.structures import get_unpacked_marks
+        marks = [mark.name for mark in get_unpacked_marks(TestDeepInheritance)]
+        assert marks.count('foo') == 2, "Expected 2 foo markers"
+        assert 'baz' in marks, "baz marker not found"
+
+@pytest.mark.qux
+def test_non_class():
+    # Test that non-class objects still work
+    from _pytest.mark.structures import get_unpacked_marks
+    marks = [mark.name for mark in get_unpacked_marks(test_non_class)]
+    assert 'qux' in marks, "qux marker not found"
+
+if __name__ == "__main__":
+    pytest.main([__file__, "-v"])
\ No newline at end of file
diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py
index 800a25c92..ba6d869f6 100644
--- a/src/_pytest/mark/structures.py
+++ b/src/_pytest/mark/structures.py
@@ -356,10 +356,35 @@ class MarkDecorator:
 
 
 def get_unpacked_marks(obj: object) -> Iterable[Mark]:
-    """Obtain the unpacked marks that are stored on an object."""
-    mark_list = getattr(obj, "pytestmark", [])
-    if not isinstance(mark_list, list):
-        mark_list = [mark_list]
+    """Obtain the unpacked marks that are stored on an object.
+    
+    For classes, this includes marks from all base classes following MRO order.
+    Marks are deduplicated based on their name, args, and kwargs."""
+    mark_list = []
+    seen = set()
+    
+    # If it's a class, collect marks from all base classes following MRO
+    if isinstance(obj, type):
+        for base in obj.__mro__:
+            base_marks = getattr(base, "pytestmark", [])
+            if not isinstance(base_marks, list):
+                base_marks = [base_marks]
+            for mark in base_marks:
+                # Create a unique key for the mark based on its attributes
+                mark_obj = getattr(mark, "mark", mark)
+                if not isinstance(mark_obj, Mark):
+                    continue
+                key = (mark_obj.name, mark_obj.args, tuple(sorted(mark_obj.kwargs.items())))
+                if key not in seen:
+                    seen.add(key)
+                    mark_list.append(mark)
+    else:
+        # For non-class objects, get marks directly
+        obj_marks = getattr(obj, "pytestmark", [])
+        if not isinstance(obj_marks, list):
+            obj_marks = [obj_marks]
+        mark_list.extend(obj_marks)
+    
     return normalize_mark_list(mark_list)
