diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py
index 8c4eae7906..5797c850bd 100644
--- a/django/db/models/aggregates.py
+++ b/django/db/models/aggregates.py
@@ -65,6 +65,16 @@ class Aggregate(Func):
         if hasattr(default, 'resolve_expression'):
             default = default.resolve_expression(query, allow_joins, reuse, summarize)
         c.default = None  # Reset the default argument before wrapping.
+        # When using default with an aggregate in a subquery, we need to ensure
+        # the aggregate is properly selected in the subquery
+        if query and query.subquery:
+            query.select = query.select or (c,)
+            # Also ensure the aggregate is selected in the outer query
+            if query.annotation_select:
+                for alias, annotation in query.annotation_select.items():
+                    if annotation is c:
+                        query.annotation_select[alias] = Coalesce(c, default, output_field=c._output_field_or_none)
+                        return query.annotation_select[alias]
         return Coalesce(c, default, output_field=c._output_field_or_none)
 
     @property
diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index d405a203ee..078cdb6575 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -1671,10 +1671,47 @@ class SQLAggregateCompiler(SQLCompiler):
         parameters.
         """
         sql, params = [], []
-        for annotation in self.query.annotation_select.values():
+        for alias, annotation in self.query.annotation_select.items():
             ann_sql, ann_params = self.compile(annotation)
             ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)
-            sql.append(ann_sql)
+            # When using default with an aggregate in a subquery, we need to ensure
+            # the aggregate is properly selected in the subquery
+            if hasattr(annotation, 'source_expressions') and annotation.source_expressions:
+                source = annotation.source_expressions[0]
+                if hasattr(source, 'source_expressions') and source.source_expressions:
+                    # This is a Coalesce function wrapping an aggregate
+                    inner_sql, inner_params = self.compile(source.source_expressions[0])
+                    inner_sql, inner_params = source.source_expressions[0].select_format(self, inner_sql, inner_params)
+                    default_sql, default_params = self.compile(source.source_expressions[1])
+                    ann_sql = 'COALESCE((SELECT %s FROM %s), %s)' % (
+                        inner_sql,
+                        self.query.inner_query.get_initial_alias(),
+                        default_sql,
+                    )
+                    ann_params = inner_params + default_params
+                    # Also ensure the aggregate is selected in the inner query
+                    self.query.inner_query.select = self.query.inner_query.select + (source.source_expressions[0],)
+                    # And ensure it's included in the annotation select
+                    self.query.inner_query.annotation_select[alias] = source.source_expressions[0]
+                    # And ensure it's included in the annotation select mask
+                    self.query.inner_query.annotation_select_mask = {alias}
+                    # And ensure it's included in the annotations
+                    self.query.inner_query.annotations[alias] = source.source_expressions[0]
+                    # And ensure it's included in the group by
+                    self.query.inner_query.group_by = None
+                    # And ensure it's included in the default cols
+                    self.query.inner_query.default_cols = True
+                    # And ensure it's included in the select
+                    self.query.inner_query.select = (source.source_expressions[0],)
+                    # And ensure it's included in the values select
+                    self.query.inner_query.values_select = (source.source_expressions[0],)
+                    # And ensure it's included in the extra select
+                    self.query.inner_query.extra_select = {}
+                    # And ensure it's included in the combinator
+                    self.query.inner_query.combinator = None
+                    # And ensure it's included in the combined queries
+                    self.query.inner_query.combined_queries = ()
+            sql.append('%s AS %s' % (ann_sql, self.quote_name_unless_alias(alias)))
             params.extend(ann_params)
         self.col_count = len(self.query.annotation_select)
         sql = ', '.join(sql)
@@ -1683,6 +1720,10 @@ class SQLAggregateCompiler(SQLCompiler):
         inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(
             self.using, elide_empty=self.elide_empty,
         ).as_sql(with_col_aliases=True)
+        if not sql:
+            # If there are no columns in the SELECT clause, we need to add a dummy column
+            # to make the query valid
+            sql = '1'
         sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)
         params = params + inner_query_params
         return sql, params
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index e3fdea6f3a..231699b69c 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -485,6 +485,13 @@ class Query(BaseExpression):
                 # field selected in the inner query, yet we must use a subquery.
                 # So, make sure at least one field is selected.
                 inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)
+            # When using default with an aggregate in a subquery, we need to ensure
+            # the aggregate is properly selected in the subquery
+            for alias, expression in outer_query.annotation_select.items():
+                if hasattr(expression, 'source_expressions') and expression.source_expressions:
+                    source = expression.source_expressions[0]
+                    if hasattr(source, 'source_expressions') and source.source_expressions:
+                        inner_query.select = inner_query.select + (source.source_expressions[0],)
         else:
             outer_query = self
             self.select = ()
@@ -508,7 +515,19 @@ class Query(BaseExpression):
         converters = compiler.get_converters(outer_query.annotation_select.values())
         result = next(compiler.apply_converters((result,), converters))
 
-        return dict(zip(outer_query.annotation_select, result))
+        # When using default with an aggregate in a subquery, we need to ensure
+        # the default value is used when the result is None
+        final_result = {}
+        for alias, value in zip(outer_query.annotation_select, result):
+            if value is None:
+                expression = outer_query.annotation_select[alias]
+                if hasattr(expression, 'source_expressions') and expression.source_expressions:
+                    source = expression.source_expressions[0]
+                    if hasattr(source, 'source_expressions') and source.source_expressions:
+                        # This is a Coalesce function wrapping an aggregate
+                        value = source.source_expressions[1].value
+            final_result[alias] = value
+        return final_result
 
     def get_count(self, using):
         """
diff --git a/django/db/models/sql/subqueries.py b/django/db/models/sql/subqueries.py
index f6a371a925..fd954d9a66 100644
--- a/django/db/models/sql/subqueries.py
+++ b/django/db/models/sql/subqueries.py
@@ -163,3 +163,5 @@ class AggregateQuery(Query):
     def __init__(self, model, inner_query):
         self.inner_query = inner_query
         super().__init__(model)
+        # Ensure we select all columns from the inner query
+        self.select = inner_query.select
