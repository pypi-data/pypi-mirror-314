diff --git a/django/db/backends/sqlite3/compiler.py b/django/db/backends/sqlite3/compiler.py
new file mode 100644
index 0000000000..93d3dd05ac
--- /dev/null
+++ b/django/db/backends/sqlite3/compiler.py
@@ -0,0 +1,23 @@
+from django.db.models.sql import compiler
+
+
+class SQLCompiler(compiler.SQLCompiler):
+    def as_sql(self, with_limits=True, with_col_aliases=False):
+        sql, params = super().as_sql(with_limits, with_col_aliases)
+        return self.connection.ops.compile_sql(self, sql, params)
+
+
+class SQLInsertCompiler(compiler.SQLInsertCompiler, SQLCompiler):
+    pass
+
+
+class SQLDeleteCompiler(compiler.SQLDeleteCompiler, SQLCompiler):
+    pass
+
+
+class SQLUpdateCompiler(compiler.SQLUpdateCompiler, SQLCompiler):
+    pass
+
+
+class SQLAggregateCompiler(compiler.SQLAggregateCompiler, SQLCompiler):
+    pass
\ No newline at end of file
diff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py
index 1f77b3109f..c5134e38ad 100644
--- a/django/db/backends/sqlite3/operations.py
+++ b/django/db/backends/sqlite3/operations.py
@@ -273,6 +273,43 @@ class DatabaseOperations(BaseDatabaseOperations):
             converters.append(self.convert_booleanfield_value)
         return converters
 
+    def window_frame_range_start_end(self, start=None, end=None):
+        # SQLite doesn't support RANGE frame types with value boundaries yet.
+        # Raise NotSupportedError because the emulation of value boundaries
+        # is not complete (#28333).
+        if (start and start != 'UNBOUNDED' and start != 'CURRENT ROW' or
+                end and end != 'UNBOUNDED' and end != 'CURRENT ROW'):
+            raise NotSupportedError(
+                'SQLite does not support RANGE with value specification.'
+            )
+        return super().window_frame_range_start_end(start, end)
+
+    def window_frame_rows_start_end(self, start=None, end=None):
+        # SQLite doesn't support expressions as frame boundaries.
+        if isinstance(start, int) or isinstance(end, int):
+            raise NotSupportedError(
+                'SQLite does not support expressions as window frame boundaries.'
+            )
+        return super().window_frame_rows_start_end(start, end)
+
+    def compile_sql(self, compiler, sql, params):
+        # SQLite doesn't support CAST around window function expressions.
+        # Move the CAST to be around the entire window expression.
+        if 'CAST(' in sql and ' OVER ' in sql:
+            cast_start = sql.find('CAST(')
+            cast_end = sql.find(' AS NUMERIC)', cast_start) + len(' AS NUMERIC)')
+            over_start = sql.find(' OVER ', cast_end)
+            if over_start != -1:
+                over_end = sql.find(')', over_start) + 1
+                sql = (
+                    'CAST(' +
+                    sql[cast_start + 5:cast_end - len(' AS NUMERIC')] +
+                    sql[over_start:over_end] +
+                    ' AS NUMERIC)' +
+                    sql[over_end:]
+                )
+        return sql, params
+
     def convert_datetimefield_value(self, value, expression, connection):
         if value is not None:
             if not isinstance(value, datetime.datetime):
diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index 90d90119d0..566dcffa3c 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -1262,6 +1262,37 @@ class Window(Expression):
     contains_over_clause = True
     filterable = False
 
+    def as_sqlite(self, compiler, connection, **extra_context):
+        # For SQLite, if the source expression has a DecimalField output,
+        # we need to cast the entire window function expression to NUMERIC
+        # and prevent double casting
+        if hasattr(self.source_expression, 'output_field') and self.source_expression.output_field.get_internal_type() == 'DecimalField':
+            # For DecimalField, we need to cast the entire window function to NUMERIC
+            expr_sql, params = compiler.compile(self.source_expression)
+            # Remove any existing CAST
+            if expr_sql.startswith('CAST('):
+                expr_sql = expr_sql[5:expr_sql.find(' AS NUMERIC)')]
+            window_sql = []
+            if self.partition_by is not None:
+                sql_expr, sql_params = self.partition_by.as_sql(
+                    compiler=compiler, connection=connection,
+                    template='PARTITION BY %(expressions)s',
+                )
+                window_sql.extend(sql_expr)
+                params.extend(sql_params)
+            if self.order_by is not None:
+                window_sql.append(' ORDER BY ')
+                order_sql, order_params = compiler.compile(self.order_by)
+                window_sql.extend(order_sql)
+                params.extend(order_params)
+            if self.frame:
+                frame_sql, frame_params = compiler.compile(self.frame)
+                window_sql.append(' ' + frame_sql)
+                params.extend(frame_params)
+            sql = 'CAST(%s OVER (%s) AS NUMERIC)' % (expr_sql, ''.join(window_sql).strip())
+            return sql, params
+        return self.as_sql(compiler, connection, **extra_context)
+
     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
         self.partition_by = partition_by
         self.order_by = order_by
