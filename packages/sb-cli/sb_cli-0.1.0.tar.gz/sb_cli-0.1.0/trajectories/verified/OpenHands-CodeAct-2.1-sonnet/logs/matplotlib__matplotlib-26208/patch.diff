diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py
index 5203e3232c..66da7dd9d7 100644
--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -2494,8 +2494,21 @@ class _AxesBase(martist.Artist):
         xys = np.asarray(xys)
         if not np.any(np.isfinite(xys)):
             return
-        self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
-                                         updatex=updatex, updatey=updatey)
+
+        # For twinned axes, don't update y limits if they would become infinite
+        if self._twinned_axes.get_siblings(self) and updatey:
+            # Save current y limits
+            y_interval = self.dataLim.intervaly
+            # Try updating with the new points
+            self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
+                                           updatex=updatex, updatey=updatey)
+            # If y limits became infinite, restore previous y limits
+            if not np.all(np.isfinite(self.dataLim.intervaly)):
+                self.dataLim.intervaly = y_interval
+        else:
+            # For non-twinned axes or x-axis updates, proceed normally
+            self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
+                                           updatex=updatex, updatey=updatey)
         self.ignore_existing_data_limits = False
 
     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
@@ -2847,10 +2860,13 @@ class _AxesBase(martist.Artist):
                     for ax in self._shared_axes["x"].get_siblings(self)
                     for artist in ax.get_children()]))
             if self._ymargin and scaley and self.get_autoscaley_on():
-                y_stickies = np.sort(np.concatenate([
-                    artist.sticky_edges.y
-                    for ax in self._shared_axes["y"].get_siblings(self)
-                    for artist in ax.get_children()]))
+                # For twinned axes, don't use sticky edges for y-axis
+                if not self._twinned_axes.get_siblings(self):
+                    y_stickies = np.sort(np.concatenate([
+                        artist.sticky_edges.y
+                        for ax in self._shared_axes["y"].get_siblings(self)
+                        for artist in ax.get_children()
+                        if not hasattr(artist, '_from_stackplot') or not artist._from_stackplot]))
         if self.get_xscale() == 'log':
             x_stickies = x_stickies[x_stickies > 0]
         if self.get_yscale() == 'log':
@@ -2883,6 +2899,10 @@ class _AxesBase(martist.Artist):
             minimum_minpos = min(
                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
 
+            # For twinned axes, don't use sticky edges for y-axis
+            if name == 'y' and self._twinned_axes.get_siblings(self):
+                stickies = np.array([])
+
             # Prevent margin addition from crossing a sticky value.  A small
             # tolerance must be added due to floating point issues with
             # streamplot; it is defined relative to x0, x1, x1-x0 but has
@@ -4410,6 +4430,100 @@ class _AxesBase(martist.Artist):
                     [0, 0, 1, 1], self.transAxes))
         self.set_adjustable('datalim')
         twin.set_adjustable('datalim')
+        # Initialize twin's data limits to avoid inheriting from self
+        twin.dataLim = mtransforms.Bbox.null()
+        # Store original update_datalim methods
+        twin._orig_update_datalim = twin.update_datalim
+        self._orig_update_datalim = self.update_datalim
+        # Override update_datalim to prevent cross-contamination
+        def twin_update_datalim(xys, updatex=True, updatey=True):
+            # Convert to array and check for infinite values
+            xys = np.asarray(xys)
+            if updatex and not np.all(np.isfinite(xys[:, 0])):
+                updatex = False
+            if updatey and not np.all(np.isfinite(xys[:, 1])):
+                updatey = False
+
+            # Save current y limits
+            y_interval = twin.dataLim.intervaly
+            # Update data limits
+            twin._orig_update_datalim(xys, updatex=updatex, updatey=updatey)
+            # Only share x limits for twinx
+            if updatex:
+                self.dataLim.intervalx = twin.dataLim.intervalx
+            # If y limits became infinite, restore previous y limits
+            if updatey and not np.all(np.isfinite(twin.dataLim.intervaly)):
+                twin.dataLim.intervaly = y_interval
+            # If y limits are still infinite, set them to the data range
+            if updatey and not np.all(np.isfinite(twin.dataLim.intervaly)):
+                finite_y = xys[np.isfinite(xys[:, 1]), 1]
+                if len(finite_y) > 0:
+                    twin.dataLim.intervaly = [np.min(finite_y), np.max(finite_y)]
+        def self_update_datalim(xys, updatex=True, updatey=True):
+            # Convert to array and check for infinite values
+            xys = np.asarray(xys)
+            if updatex and not np.all(np.isfinite(xys[:, 0])):
+                updatex = False
+            if updatey and not np.all(np.isfinite(xys[:, 1])):
+                updatey = False
+
+            # Save current y limits
+            y_interval = self.dataLim.intervaly
+            # Update data limits
+            self._orig_update_datalim(xys, updatex=updatex, updatey=updatey)
+            # Only share x limits for twinx
+            if updatex:
+                twin.dataLim.intervalx = self.dataLim.intervalx
+            # If y limits became infinite, restore previous y limits
+            if updatey and not np.all(np.isfinite(self.dataLim.intervaly)):
+                self.dataLim.intervaly = y_interval
+            # If y limits are still infinite, set them to the data range
+            if updatey and not np.all(np.isfinite(self.dataLim.intervaly)):
+                finite_y = xys[np.isfinite(xys[:, 1]), 1]
+                if len(finite_y) > 0:
+                    self.dataLim.intervaly = [np.min(finite_y), np.max(finite_y)]
+        twin.update_datalim = twin_update_datalim
+        self.update_datalim = self_update_datalim
+        # Store original autoscale_view methods
+        twin._orig_autoscale_view = twin.autoscale_view
+        self._orig_autoscale_view = self.autoscale_view
+        # Override autoscale_view to prevent sticky edges from affecting twinned axes
+        def twin_autoscale_view(scalex=True, scaley=True, **kwargs):
+            # Save current y limits
+            y_interval = twin.dataLim.intervaly
+            # Save sticky edges
+            sticky_edges = []
+            for artist in twin.get_children():
+                if hasattr(artist, 'sticky_edges'):
+                    sticky_edges.append((artist, artist.sticky_edges.y[:]))
+                    artist.sticky_edges.y[:] = []
+            # Update view limits
+            twin._orig_autoscale_view(scalex=scalex, scaley=scaley, **kwargs)
+            # Restore sticky edges
+            for artist, edges in sticky_edges:
+                artist.sticky_edges.y[:] = edges
+            # If y limits became infinite, restore previous y limits
+            if not np.all(np.isfinite(twin.dataLim.intervaly)):
+                twin.dataLim.intervaly = y_interval
+        def self_autoscale_view(scalex=True, scaley=True, **kwargs):
+            # Save current y limits
+            y_interval = self.dataLim.intervaly
+            # Save sticky edges
+            sticky_edges = []
+            for artist in self.get_children():
+                if hasattr(artist, 'sticky_edges'):
+                    sticky_edges.append((artist, artist.sticky_edges.y[:]))
+                    artist.sticky_edges.y[:] = []
+            # Update view limits
+            self._orig_autoscale_view(scalex=scalex, scaley=scaley, **kwargs)
+            # Restore sticky edges
+            for artist, edges in sticky_edges:
+                artist.sticky_edges.y[:] = edges
+            # If y limits became infinite, restore previous y limits
+            if not np.all(np.isfinite(self.dataLim.intervaly)):
+                self.dataLim.intervaly = y_interval
+        twin.autoscale_view = twin_autoscale_view
+        self.autoscale_view = self_autoscale_view
         self._twinned_axes.join(self, twin)
         return twin
 
diff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py
index c97a21e029..688028ac33 100644
--- a/lib/matplotlib/stackplot.py
+++ b/lib/matplotlib/stackplot.py
@@ -115,13 +115,23 @@ def stackplot(axes, x, *args,
     coll = axes.fill_between(x, first_line, stack[0, :],
                              facecolor=next(colors), label=next(labels, None),
                              **kwargs)
-    coll.sticky_edges.y[:] = [0]
+    # Mark this collection as coming from stackplot
+    coll._from_stackplot = True
+    # Only set sticky edges if this is not a twinned axis
+    if not hasattr(axes, '_twinned_axes') or not axes._twinned_axes.get_siblings(axes):
+        coll.sticky_edges.y[:] = [0]
     r = [coll]
 
     # Color between array i-1 and array i
     for i in range(len(y) - 1):
-        r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],
-                                   facecolor=next(colors),
-                                   label=next(labels, None),
-                                   **kwargs))
+        coll = axes.fill_between(x, stack[i, :], stack[i + 1, :],
+                                facecolor=next(colors),
+                                label=next(labels, None),
+                                **kwargs)
+        # Mark this collection as coming from stackplot
+        coll._from_stackplot = True
+        # Only set sticky edges if this is not a twinned axis
+        if not hasattr(axes, '_twinned_axes') or not axes._twinned_axes.get_siblings(axes):
+            coll.sticky_edges.y[:] = [0]
+        r.append(coll)
     return r
diff --git a/lib/matplotlib/transforms.py b/lib/matplotlib/transforms.py
index f2ffa09932..f45846e8e8 100644
--- a/lib/matplotlib/transforms.py
+++ b/lib/matplotlib/transforms.py
@@ -880,11 +880,15 @@ class Bbox(BboxBase):
         if changed:
             self.invalidate()
             if updatex:
-                self._points[:, 0] = points[:, 0]
-                self._minpos[0] = minpos[0]
+                # Only update x points if they are finite
+                if np.all(np.isfinite(points[:, 0])):
+                    self._points[:, 0] = points[:, 0]
+                    self._minpos[0] = minpos[0]
             if updatey:
-                self._points[:, 1] = points[:, 1]
-                self._minpos[1] = minpos[1]
+                # Only update y points if they are finite
+                if np.all(np.isfinite(points[:, 1])):
+                    self._points[:, 1] = points[:, 1]
+                    self._minpos[1] = minpos[1]
 
     def update_from_data_x(self, x, ignore=None):
         """
@@ -945,9 +949,18 @@ class Bbox(BboxBase):
         if len(xy) == 0:
             return
 
-        path = Path(xy)
-        self.update_from_path(path, ignore=ignore,
-                              updatex=updatex, updatey=updatey)
+        # Convert to array and check for infinite values
+        xy = np.asarray(xy)
+        if updatex and not np.all(np.isfinite(xy[:, 0])):
+            updatex = False
+        if updatey and not np.all(np.isfinite(xy[:, 1])):
+            updatey = False
+
+        # Only proceed if there are finite values to update
+        if updatex or updatey:
+            path = Path(xy)
+            self.update_from_path(path, ignore=ignore,
+                                updatex=updatex, updatey=updatey)
 
     @BboxBase.x0.setter
     def x0(self, val):
diff --git a/reproduce_bug.py b/reproduce_bug.py
new file mode 100644
index 0000000000..bb236b87bc
--- /dev/null
+++ b/reproduce_bug.py
@@ -0,0 +1,23 @@
+import matplotlib.pyplot as plt
+
+def print_datalim(*ax):
+    for ax_ in ax:
+        print(ax_.dataLim.intervaly, end=' / ')
+    print()
+
+df1_index = ['16 May', '17 May']  # == df2_index
+df1_values = [-22.717708333333402, 26.584999999999937]
+df2_values = [-0.08501399999999998, -2.9833019999999966]
+
+fig, ax1 = plt.subplots()
+
+ax1.stackplot(df1_index, df1_values)
+print_datalim(ax1)
+
+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
+print_datalim(ax1, ax2)
+
+ax2.plot(df1_index, df2_values)
+print_datalim(ax1, ax2)
+
+plt.show()
\ No newline at end of file
