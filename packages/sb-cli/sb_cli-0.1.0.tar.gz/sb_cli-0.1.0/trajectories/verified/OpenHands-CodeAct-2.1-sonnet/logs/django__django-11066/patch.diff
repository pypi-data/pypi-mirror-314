diff --git a/django/contrib/contenttypes/management/__init__.py b/django/contrib/contenttypes/management/__init__.py
index 2b5f688136..563cba2fdf 100644
--- a/django/contrib/contenttypes/management/__init__.py
+++ b/django/contrib/contenttypes/management/__init__.py
@@ -24,7 +24,7 @@ class RenameContentType(migrations.RunPython):
             content_type.model = new_model
             try:
                 with transaction.atomic(using=db):
-                    content_type.save(update_fields={'model'})
+                    content_type.save(using=db, update_fields={'model'})
             except IntegrityError:
                 # Gracefully fallback if a stale content type causes a
                 # conflict as remove_stale_contenttypes will take care of
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..16e60d6129
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,112 @@
+import os
+from django.conf import settings
+from django.db import connection, migrations, transaction
+from django.contrib.contenttypes.management import RenameContentType
+from django.apps import apps
+from django.db.models import Model
+from django.db import models
+
+# Create a dynamic router similar to django-dynamic-db-router
+class DynamicRouter:
+    def __init__(self):
+        self.db = 'other_db'
+
+    def db_for_read(self, model, **hints):
+        print(f"db_for_read called with model={model}, hints={hints}")
+        return self.db
+        
+    def db_for_write(self, model, **hints):
+        print(f"db_for_write called with model={model}, hints={hints}")
+        return self.db
+        
+    def allow_migrate(self, db, app_label, model_name=None, **hints):
+        print(f"allow_migrate called with db={db}, app_label={app_label}, model_name={model_name}, hints={hints}")
+        # Only allow migrations on other_db
+        return db == self.db
+
+# Configure minimal Django settings
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:'
+        },
+        'other_db': {
+            'ENGINE': 'django.db.backends.sqlite3', 
+            'NAME': ':memory:'
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+)
+
+# Initialize Django
+import django
+django.setup()
+
+# Register the router
+from django.db import router
+router.routers = [DynamicRouter()]
+
+# Create schema editors for both databases
+from django.db import connections
+connection = connections['other_db']
+default_connection = connections['default']
+
+# Create the contenttypes table in both databases
+from django.contrib.contenttypes.models import ContentType
+
+# Create tables in both databases
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(ContentType)
+
+with default_connection.schema_editor() as schema_editor:
+    schema_editor.create_model(ContentType)
+
+# Create a test content type in the other database
+ContentType.objects.using('other_db').create(
+    app_label='test_app',
+    model='old_model'
+)
+
+# Print initial state
+print("Initial state:")
+ct = ContentType.objects.using('other_db').get(app_label='test_app')
+print(f"Model name in other_db: {ct.model}")
+
+try:
+    ct = ContentType.objects.using('default').get(app_label='test_app')
+    print(f"Model name in default: {ct.model}")
+except ContentType.DoesNotExist:
+    print("No content type found in default database (expected)")
+
+# Try to rename it
+print("\nRenaming content type...")
+rename_op = RenameContentType('test_app', 'old_model', 'new_model')
+
+# Add debug output for save method
+from django.db.models import Model
+original_save = Model.save
+def debug_save(self, *args, **kwargs):
+    import traceback
+    print(f"Model.save called with args={args}, kwargs={kwargs}")
+    print("Stack trace:")
+    traceback.print_stack()
+    return original_save(self, *args, **kwargs)
+Model.save = debug_save
+
+# Run the rename operation with schema editor from other_db
+with connection.schema_editor() as schema_editor:
+    rename_op._rename(apps, schema_editor, 'old_model', 'new_model')
+
+# Verify the content type was renamed in the correct database
+print("\nFinal state:")
+ct = ContentType.objects.using('other_db').get(app_label='test_app')
+print(f"Model name in other_db: {ct.model}")
+
+try:
+    ct = ContentType.objects.using('default').get(app_label='test_app')
+    print(f"Model name in default: {ct.model}")
+except ContentType.DoesNotExist:
+    print("No content type found in default database (expected)")
\ No newline at end of file
