diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..925d735b7a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,25 @@
+from sympy import *
+from sympy.abc import x, y, z, n
+from sympy.solvers.solveset import solveset_real
+
+# Test case 1: solveset_real with subs
+print("Test case 1: solveset_real with subs")
+expr1 = solveset_real(Abs(x) - y, x)
+print(f"Original: {expr1}")
+print(f"After subs: {expr1.subs(y, Rational(1,3))}")
+print()
+
+# Test case 2: ImageSet with subs
+print("Test case 2: ImageSet with subs")
+expr2 = imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+print(f"Original: {expr2}")
+print(f"After subs: {expr2.subs(y, Rational(1,3))}")
+print()
+
+# Test case 3: ConditionSet with ImageSet and subs
+print("Test case 3: ConditionSet with ImageSet and subs")
+expr3 = ConditionSet(x, Contains(y, Interval(-1,1)), expr2)
+print(f"Original: {expr3}")
+print(f"After subs: {expr3.subs(y, Rational(1,3))}")
+print(f"After xreplace: {expr3.xreplace({y: Rational(1,3)})}")
+print(f"After subs with simultaneous=True: {expr3.subs({y: Rational(1,3)}, simultaneous=True)}")
\ No newline at end of file
diff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py
index 118eda6f77..6822e6ec8e 100644
--- a/sympy/sets/conditionset.py
+++ b/sympy/sets/conditionset.py
@@ -240,6 +240,17 @@ def _eval_subs(self, old, new):
             # the base set should be filtered and if new is not in
             # the base set then this substitution is ignored
             return self.func(sym, cond, base)
+        
+        # If we're substituting a variable that appears in both condition and base set,
+        # we need to be careful to maintain the relationship between them
+        if old in cond.free_symbols and old in base.free_symbols:
+            # First substitute in the base set
+            new_base = base.subs(old, new)
+            # Then substitute in the condition, but keep the dummy variable unchanged
+            new_cond = cond.subs(old, new)
+            return self.func(sym, new_cond, new_base)
+        
+        # Otherwise, proceed with normal substitution
         cond = self.condition.subs(old, new)
         base = self.base_set.subs(old, new)
         if cond is S.true:
