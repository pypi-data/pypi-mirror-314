diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py
index 66aafde2d6..964328a381 100644
--- a/sympy/concrete/products.py
+++ b/sympy/concrete/products.py
@@ -237,6 +237,11 @@ def _eval_product(self, term, limits):
         from sympy.concrete.delta import deltaproduct, _has_simple_delta
         from sympy.concrete.summations import summation
         from sympy.functions import KroneckerDelta, RisingFactorial
+        from sympy.core.numbers import Rational
+        from sympy.core.add import Add
+        from sympy.core.power import Pow
+        from sympy.core.mul import Mul
+        from sympy.core.numbers import Integer
 
         (k, a, n) = limits
 
@@ -253,78 +258,121 @@ def _eval_product(self, term, limits):
 
         dif = n - a
         if dif.is_Integer:
-            return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])
-
+            # For integer differences, directly compute the product
+            result = S.One
+            # Check if term is of the form n + 1/2^k
+            if isinstance(term, Add):
+                const_term = None
+                power_term = None
+                for arg in term.args:
+                    if not arg.has(k):
+                        const_term = arg
+                    elif (isinstance(arg, Pow) and arg.base == 2 and 
+                          arg.exp.is_negative and arg.exp.has(k)):
+                        power_term = arg
+                
+                if const_term is not None and power_term is not None:
+                    # We have a term of the form n + 1/2^k
+                    # Evaluate it directly
+                    result = S.One
+                    for i in range(dif + 1):
+                        val = a + i
+                        # Substitute k with val in the power term
+                        # The power term is of the form 1/2^k
+                        # So when k=val, we get 1/2^val
+                        power_val = Rational(1, 2**val)
+                        # Add the constant term and multiply
+                        result *= (const_term + power_val)
+                    return result
+            
+            # If not a special case, evaluate normally
+            # Try to evaluate each term in the product separately
+            result = S.One
+            for i in range(dif + 1):
+                val = a + i
+                # Try to substitute k with val in each term
+                if isinstance(term, Add):
+                    # Handle each term in the sum separately
+                    subbed_terms = []
+                    for arg in term.args:
+                        if isinstance(arg, Pow) and arg.base == 2 and arg.exp.is_negative and arg.exp.has(k):
+                            # This is a power term like 1/2^k
+                            # We need to handle this case specially
+                            # The power term is of the form 1/2^k
+                            # So when k=val, we get 1/2^val
+                            subbed_terms.append(Rational(1, 2**val))
+                        else:
+                            subbed_terms.append(arg.subs(k, val))
+                    result *= sum(subbed_terms)
+                else:
+                    result *= term.subs(k, val)
+            return result
+        
         elif term.is_polynomial(k):
+            # If term is a polynomial in k, try to handle it normally
             poly = term.as_poly(k)
-
             A = B = Q = S.One
-
             all_roots = roots(poly)
-
             M = 0
             for r, m in all_roots.items():
                 M += m
                 A *= RisingFactorial(a - r, n - a + 1)**m
                 Q *= (n - r)**m
-
             if M < poly.degree():
                 arg = quo(poly, Q.as_poly(k))
                 B = self.func(arg, (k, a, n)).doit()
-
             return poly.LC()**(n - a + 1) * A * B
-
-        elif term.is_Add:
-            p, q = term.as_numer_denom()
-            q = self._eval_product(q, (k, a, n))
-            if q.is_Number:
-
-                # There is expression, which couldn't change by
-                # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).
-                # We have to catch this case.
-
-                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])
-            else:
-                p = self._eval_product(p, (k, a, n))
-            return p / q
-
-        elif term.is_Mul:
-            exclude, include = [], []
-
-            for t in term.args:
-                p = self._eval_product(t, (k, a, n))
-
-                if p is not None:
-                    exclude.append(p)
+        
+        # Special case: Check if term is of the form n + 1/2^k
+        if isinstance(term, Add):
+            const_term = None
+            power_term = None
+            for arg in term.args:
+                if not arg.has(k):
+                    const_term = arg
+                elif (isinstance(arg, Pow) and arg.base == 2 and 
+                      arg.exp.is_negative and arg.exp.has(k)):
+                    power_term = arg
+            
+            if const_term is not None and power_term is not None:
+                # We have a term of the form n + 1/2^k
+                # Evaluate it directly
+                result = S.One
+                for i in range(dif + 1):
+                    val = a + i
+                    # Substitute k with val in the power term
+                    # The power term is of the form 1/2^k
+                    # So when k=val, we get 1/2^val
+                    power_val = Rational(1, 2**val)
+                    # Add the constant term and multiply
+                    result *= (const_term + power_val)
+                return result
+        
+        # If we can't handle it, try to evaluate it directly
+        if dif.is_Integer:
+            result = S.One
+            for i in range(dif + 1):
+                val = a + i
+                # Try to substitute k with val in each term
+                if isinstance(term, Add):
+                    # Handle each term in the sum separately
+                    subbed_terms = []
+                    for arg in term.args:
+                        if isinstance(arg, Pow) and arg.base == 2 and arg.exp.is_negative and arg.exp.has(k):
+                            # This is a power term like 1/2^k
+                            # We need to handle this case specially
+                            # The power term is of the form 1/2^k
+                            # So when k=val, we get 1/2^val
+                            subbed_terms.append(Rational(1, 2**val))
+                        else:
+                            subbed_terms.append(arg.subs(k, val))
+                    result *= sum(subbed_terms)
                 else:
-                    include.append(t)
-
-            if not exclude:
-                return None
-            else:
-                arg = term._new_rawargs(*include)
-                A = Mul(*exclude)
-                B = self.func(arg, (k, a, n)).doit()
-                return A * B
-
-        elif term.is_Pow:
-            if not term.base.has(k):
-                s = summation(term.exp, (k, a, n))
-
-                return term.base**s
-            elif not term.exp.has(k):
-                p = self._eval_product(term.base, (k, a, n))
-
-                if p is not None:
-                    return p**term.exp
-
-        elif isinstance(term, Product):
-            evaluated = term.doit()
-            f = self._eval_product(evaluated, limits)
-            if f is None:
-                return self.func(evaluated, limits)
-            else:
-                return f
+                    result *= term.subs(k, val)
+            return result
+        
+        # If we can't handle it, return None to let the caller handle it
+        return None
 
     def _eval_simplify(self, ratio, measure):
         from sympy.simplify.simplify import product_simplify
