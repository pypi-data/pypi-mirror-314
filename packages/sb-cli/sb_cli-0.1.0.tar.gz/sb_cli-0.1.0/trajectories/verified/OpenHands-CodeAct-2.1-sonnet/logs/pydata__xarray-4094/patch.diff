diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 00000000..a7578bce
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,22 @@
+import xarray as xr
+import numpy as np
+
+# Create test data
+arr = xr.DataArray(
+    np.arange(3),
+    coords=[("x", [0, 1, 2])],
+)
+data = xr.Dataset({"a": arr, "b": arr})
+
+# Try stacking and unstacking
+stacked = data.to_stacked_array('y', sample_dims=['x'])
+print("\nStacked array:")
+print(stacked)
+
+try:
+    unstacked = stacked.to_unstacked_dataset('y')
+    print("\nUnstacked dataset:")
+    print(unstacked)
+except Exception as e:
+    print("\nError during unstacking:")
+    print(e)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..1280e828
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,45 @@
+import xarray as xr
+import numpy as np
+
+def test_case(name, data):
+    print(f"\nTest case: {name}")
+    print("Input dataset:")
+    print(data)
+    
+    stacked = data.to_stacked_array('y', sample_dims=['x'])
+    print("\nStacked array:")
+    print(stacked)
+    
+    unstacked = stacked.to_unstacked_dataset('y')
+    print("\nUnstacked dataset:")
+    print(unstacked)
+    
+    print("\nRoundtrip successful:", data.equals(unstacked))
+
+# Test case 1: Original case
+arr = xr.DataArray(np.arange(3), coords=[("x", [0, 1, 2])])
+data1 = xr.Dataset({"a": arr, "b": arr})
+test_case("Original case", data1)
+
+# Test case 2: Different values
+arr2 = xr.DataArray(np.arange(3), coords=[("x", [0, 1, 2])])
+data2 = xr.Dataset({"a": arr2, "b": arr2 * 2})
+test_case("Different values", data2)
+
+# Test case 3: Mixed dimensions with shared sample dim
+arr3 = xr.DataArray(np.arange(3), coords=[("x", [0, 1, 2])])
+scalar = xr.DataArray([5, 6, 7], coords=[("x", [0, 1, 2])])
+data3 = xr.Dataset({"a": arr3, "b": scalar})
+test_case("Mixed dimensions with shared sample dim", data3)
+
+# Test case 4: Multiple coordinates
+arr4 = xr.DataArray(
+    np.arange(6).reshape(2, 3),
+    coords={
+        "x": [0, 1],
+        "y": ["a", "b", "c"],
+        "z": ("x", [10, 20])
+    }
+)
+data4 = xr.Dataset({"a": arr4, "b": arr4.isel(y=0)})
+test_case("Multiple coordinates", data4)
\ No newline at end of file
diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index b0df8749..0f5c95a2 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -1960,11 +1960,48 @@ class DataArray(AbstractArray, DataWithCoords):
 
         # pull variables out of datarray
         data_dict = {}
+        coords_dict = {}
+        
+        # Get the original non-stacked dimensions
+        orig_dims = set(self.dims) - {dim}
+        
+        # First pass: collect all coordinates except the stacked one
+        for coord_name, coord_var in self.coords.items():
+            if coord_name != dim and coord_name != variable_dim:
+                if set(coord_var.dims).issubset(orig_dims):
+                    coords_dict[coord_name] = coord_var
+
+        # Second pass: extract data while preserving coordinates
         for k in variables:
-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)
-
-        # unstacked dataset
-        return Dataset(data_dict)
+            # Get the data for this variable
+            indexer = {variable_dim: k}
+            selected = self.sel(indexer)
+            
+            # Get the non-stacked dimensions for this variable
+            var_dims = [d for d in selected.dims if d != dim]
+            
+            # If no dimensions left, use the first available dimension
+            if not var_dims and orig_dims:
+                var_dims = [list(orig_dims)[0]]
+                
+            # Create a new variable with proper dimensions
+            if var_dims:
+                # For array data, keep original dimensions
+                data = selected.squeeze().drop_vars([dim] if dim in selected.coords else [])
+                data_dict[k] = data
+            else:
+                # For scalar data, create a 0-dimensional array
+                data_dict[k] = selected.squeeze().drop_vars([dim] if dim in selected.coords else [])
+
+        # Create dataset with explicit coordinates to avoid conflicts
+        ds = Dataset(data_dict, coords=coords_dict)
+        
+        # Drop any remaining stacked coordinates
+        for v in ds.variables:
+            if dim in ds[v].coords:
+                ds[v] = ds[v].drop_vars(dim)
+                
+        return ds
 
     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> "DataArray":
         """Return a new DataArray object with transposed dimensions.
