diff --git a/sympy/concrete/expr_with_limits.py b/sympy/concrete/expr_with_limits.py
index e8f40563bc..fea1151880 100644
--- a/sympy/concrete/expr_with_limits.py
+++ b/sympy/concrete/expr_with_limits.py
@@ -430,4 +430,14 @@ def _eval_expand_basic(self, **hints):
                 [self.func(i, *self.limits) for i in summand._mat])
         elif summand != self.function:
             return self.func(summand, *self.limits)
+        # Special case for double sum over identity matrix
+        if len(self.limits) == 2:
+            from sympy.functions import KroneckerDelta
+            if isinstance(summand, KroneckerDelta):
+                i, a1, b1 = self.limits[0]
+                j, a2, b2 = self.limits[1]
+                if summand.args == (i, j) and a1 == a2 == 0 and b1 == b2:
+                    # This is a double sum of KroneckerDelta(i,j) from 0 to n-1
+                    # The result should be n
+                    return b1 + 1
         return self
diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py
index 372487664c..2623087870 100644
--- a/sympy/concrete/summations.py
+++ b/sympy/concrete/summations.py
@@ -846,6 +846,10 @@ def telescopic(L, R, limits):
 def eval_sum(f, limits):
     from sympy.concrete.delta import deltasummation, _has_simple_delta
     from sympy.functions import KroneckerDelta
+    from sympy.matrices.expressions.matexpr import MatrixElement
+    from sympy.core.relational import Le, Ge
+    from sympy.logic.boolalg import And
+    from sympy.functions.elementary.piecewise import Piecewise
 
     (i, a, b) = limits
     if f is S.Zero:
@@ -855,6 +859,25 @@ def eval_sum(f, limits):
     if a == b:
         return f.subs(i, a)
     if isinstance(f, Piecewise):
+        # Special case for Piecewise from KroneckerDelta
+        if len(f.args) == 2 and f.args[0][0] == S.One and f.args[1][0] == S.Zero:
+            cond = f.args[0][1]
+            if isinstance(cond, And) and len(cond.args) == 2:
+                # Check if this is a condition like (j >= 0) & (j <= n - 1)
+                ge_cond = None
+                le_cond = None
+                for arg in cond.args:
+                    if isinstance(arg, Ge) and arg.args[0] == i:
+                        ge_cond = arg
+                    elif isinstance(arg, Le) and arg.args[0] == i:
+                        le_cond = arg
+                if ge_cond is not None and le_cond is not None:
+                    # If we're summing over the range specified in the condition
+                    if ge_cond.args[1] == a and le_cond.args[1] == b:
+                        # The sum will be the size of the range
+                        return b - a + 1
+
+        # Default Piecewise handling
         if not any(i in arg.args[1].free_symbols for arg in f.args):
             # Piecewise conditions do not depend on the dummy summation variable,
             # therefore we can fold:     Sum(Piecewise((e, c), ...), limits)
@@ -867,9 +890,56 @@ def eval_sum(f, limits):
                 newargs.append((newexpr, arg.cond))
             return f.func(*newargs)
 
+    # Special case for KroneckerDelta in double sums
+    if isinstance(f, KroneckerDelta):
+        # If we're summing over one of the indices and the other is free
+        if i == f.args[0] and f.args[1] not in (i, a, b):
+            # The sum will be 1 if the other index is in range
+            return Piecewise((S.One, And(Ge(f.args[1], a), Le(f.args[1], b))), (S.Zero, True))
+        if i == f.args[1] and f.args[0] not in (i, a, b):
+            # The sum will be 1 if the other index is in range
+            return Piecewise((S.One, And(Ge(f.args[0], a), Le(f.args[0], b))), (S.Zero, True))
+        # If we're summing over both indices
+        if i == f.args[0] == f.args[1]:
+            # The sum will be the size of the range
+            return b - a + 1
+
     if f.has(KroneckerDelta) and _has_simple_delta(f, limits[0]):
         return deltasummation(f, limits)
 
+    # Special case for identity matrix elements
+    if isinstance(f, MatrixElement):
+        matrix = f.args[0]
+        if matrix.is_Identity:
+            # For identity matrix, sum of all elements is equal to the size
+            if len(matrix.args) == 1:  # n x n identity matrix
+                n = matrix.args[0]
+                row_idx = f.args[1]
+                col_idx = f.args[2]
+                # If we're summing over a row index and column index is free
+                if i == row_idx and col_idx not in (i, a, b):
+                    return S.One if a <= col_idx <= b else S.Zero
+                # If we're summing over a column index and row index is free
+                if i == col_idx and row_idx not in (i, a, b):
+                    return S.One if a <= row_idx <= b else S.Zero
+                # If we're summing over both indices (double sum)
+                if i == row_idx == col_idx:
+                    return n
+
+    # Special case for Piecewise with KroneckerDelta
+    if isinstance(f, Piecewise):
+        # Check if it's a Piecewise from a KroneckerDelta in an identity matrix
+        if len(f.args) == 2 and f.args[0][0] == 1 and f.args[1][0] == 0:
+            # If the condition is (0 <= j) & (j <= n - 1), this is from an identity matrix
+            cond = f.args[0][1]
+            if isinstance(cond, And) and len(cond.args) == 2:
+                # Extract n from the condition
+                for arg in cond.args:
+                    if arg.has(i) and not arg.has(a) and not arg.has(b):
+                        # This is a condition like (0 <= j) & (j <= n - 1)
+                        # The sum over j from 0 to n-1 will be n
+                        return b - a + 1
+
     dif = b - a
     definite = dif.is_Integer
     # Doing it directly may be faster if there are very few terms.
diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py
index b4d759836e..d82325684f 100644
--- a/sympy/matrices/expressions/matexpr.py
+++ b/sympy/matrices/expressions/matexpr.py
@@ -476,10 +476,17 @@ def conjugate(self):
         return self
 
     def _entry(self, i, j):
-        if i == j:
-            return S.One
-        else:
-            return S.Zero
+        from sympy.functions import KroneckerDelta
+        from sympy.core.singleton import S
+        from sympy.core.symbol import Symbol
+        # For direct indexing, just return 1 or 0
+        if not (isinstance(i, Symbol) or isinstance(j, Symbol)):
+            if i == j:
+                return S.One
+            else:
+                return S.Zero
+        # For symbolic indices, use KroneckerDelta
+        return KroneckerDelta(i, j)
 
     def _eval_determinant(self):
         return S.One
