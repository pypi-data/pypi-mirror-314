diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py
index b821c42845..c4e733a55d 100644
--- a/sympy/matrices/expressions/blockmatrix.py
+++ b/sympy/matrices/expressions/blockmatrix.py
@@ -233,18 +233,45 @@ def transpose(self):
         return self._eval_transpose()
 
     def _entry(self, i, j, **kwargs):
-        # Find row entry
-        for row_block, numrows in enumerate(self.rowblocksizes):
-            if (i < numrows) != False:
-                break
-            else:
-                i -= numrows
-        for col_block, numcols in enumerate(self.colblocksizes):
-            if (j < numcols) != False:
-                break
-            else:
-                j -= numcols
-        return self.blocks[row_block, col_block][i, j]
+        from sympy import Piecewise, And
+        
+        # For symbolic indices, we need to return a Piecewise expression
+        # that represents all possible blocks the index could be in
+        
+        # Calculate cumulative sums of block sizes
+        row_sums = [0]
+        for size in self.rowblocksizes:
+            row_sums.append(row_sums[-1] + size)
+        
+        col_sums = [0]
+        for size in self.colblocksizes:
+            col_sums.append(col_sums[-1] + size)
+        
+        # If indices are numeric, we can determine the exact block
+        if i.is_number and j.is_number:
+            # Find row block
+            for row_block, (start, end) in enumerate(zip(row_sums[:-1], row_sums[1:])):
+                if start <= i < end:
+                    break
+            # Find column block
+            for col_block, (start, end) in enumerate(zip(col_sums[:-1], col_sums[1:])):
+                if start <= j < end:
+                    break
+            # Adjust indices to be relative to the block
+            i, j = i - row_sums[row_block], j - col_sums[col_block]
+            return self.blocks[row_block, col_block][i, j]
+        
+        # For symbolic indices, return a Piecewise expression
+        pieces = []
+        for row_block, (row_start, row_end) in enumerate(zip(row_sums[:-1], row_sums[1:])):
+            for col_block, (col_start, col_end) in enumerate(zip(col_sums[:-1], col_sums[1:])):
+                # Condition for this block
+                cond = And(row_start <= i, i < row_end, col_start <= j, j < col_end)
+                # Adjust indices to be relative to the block
+                expr = self.blocks[row_block, col_block][i - row_start, j - col_start]
+                pieces.append((expr, cond))
+        
+        return Piecewise(*pieces)
 
     @property
     def is_Identity(self):
