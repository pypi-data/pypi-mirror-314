diff --git a/requests/models.py b/requests/models.py
index fbb3c7e6..ad71b0fb 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -658,7 +658,8 @@ class Response(object):
         returned as decoding can take place.
 
         If decode_unicode is True, content will be decoded using the best
-        available encoding based on the response.
+        available encoding based on the response. For JSON content, this will
+        always return unicode strings.
         """
 
         def generate():
@@ -666,7 +667,11 @@ class Response(object):
             if hasattr(self.raw, 'stream'):
                 try:
                     for chunk in self.raw.stream(chunk_size, decode_content=True):
-                        yield chunk
+                        if decode_unicode:
+                            encoding = self.encoding or get_encoding_from_headers(self.headers) or 'utf-8'
+                            yield chunk.decode(encoding)
+                        else:
+                            yield chunk
                 except ProtocolError as e:
                     raise ChunkedEncodingError(e)
                 except DecodeError as e:
@@ -679,7 +684,11 @@ class Response(object):
                     chunk = self.raw.read(chunk_size)
                     if not chunk:
                         break
-                    yield chunk
+                    if decode_unicode:
+                        encoding = self.encoding or get_encoding_from_headers(self.headers) or 'utf-8'
+                        yield chunk.decode(encoding)
+                    else:
+                        yield chunk
 
             self._content_consumed = True
 
@@ -695,7 +704,33 @@ class Response(object):
         chunks = reused_chunks if self._content_consumed else stream_chunks
 
         if decode_unicode:
-            chunks = stream_decode_response_unicode(chunks, self)
+            # Get encoding
+            encoding = self.encoding
+            if encoding is None:
+                encoding = get_encoding_from_headers(self.headers)
+                if encoding is None:
+                    # Default to UTF-8 for JSON, otherwise let Python detect it
+                    if self.headers.get('content-type', '').startswith('application/json'):
+                        encoding = 'utf-8'
+            
+            # For JSON content, decode the entire content at once
+            if self.headers.get('content-type', '').startswith('application/json'):
+                # Convert chunks to list to avoid consuming the iterator
+                chunks = list(chunks)
+                content = b''.join(chunks)
+                # Convert bytes to string
+                content = content.decode(encoding) if encoding else content.decode()
+                # Return as a single chunk since JSON should be treated as a whole
+                return iter([content])
+            else:
+                # For other content types, decode each chunk
+                def decode_chunks():
+                    for chunk in chunks:
+                        if encoding:
+                            yield chunk.decode(encoding)
+                        else:
+                            yield chunk.decode()
+                return decode_chunks()
 
         return chunks
 
diff --git a/requests/utils.py b/requests/utils.py
index 8d17b6b2..5bdc5a59 100644
--- a/requests/utils.py
+++ b/requests/utils.py
@@ -359,16 +359,46 @@ def get_encoding_from_headers(headers):
 def stream_decode_response_unicode(iterator, r):
     """Stream decodes a iterator."""
 
-    if r.encoding is None:
-        for item in iterator:
-            yield item
+    encoding = r.encoding
+    if encoding is None:
+        # If no encoding is specified, try to detect it from content-type
+        encoding = get_encoding_from_headers(r.headers)
+        if encoding is None:
+            # If still no encoding, use UTF-8 as a safe default for JSON
+            if r.headers.get('content-type', '').startswith('application/json'):
+                encoding = 'utf-8'
+            else:
+                # For other content types, pass through as bytes
+                for item in iterator:
+                    yield item
+                return
+
+    # For JSON content, decode the entire content at once to handle escape sequences
+    if r.headers.get('content-type', '').startswith('application/json'):
+        content = b''.join(iterator)
+        try:
+            # First try to decode the entire content
+            yield content.decode(encoding)
+        except UnicodeDecodeError:
+            # If that fails, try decoding each chunk
+            for chunk in iterator:
+                try:
+                    yield chunk.decode(encoding)
+                except UnicodeDecodeError:
+                    yield chunk
         return
 
-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')
+    # For other content types, use incremental decoder
+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')
     for chunk in iterator:
-        rv = decoder.decode(chunk)
-        if rv:
-            yield rv
+        try:
+            # First try to decode directly
+            yield chunk.decode(encoding)
+        except UnicodeDecodeError:
+            # If that fails, use the incremental decoder
+            rv = decoder.decode(chunk)
+            if rv:
+                yield rv
     rv = decoder.decode(b'', final=True)
     if rv:
         yield rv
