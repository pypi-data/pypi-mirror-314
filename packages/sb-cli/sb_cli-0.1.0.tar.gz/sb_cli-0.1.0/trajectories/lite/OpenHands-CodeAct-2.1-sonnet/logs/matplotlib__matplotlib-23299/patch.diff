diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py
index c268a56724..f1c6c8759b 100644
--- a/lib/matplotlib/__init__.py
+++ b/lib/matplotlib/__init__.py
@@ -673,8 +673,19 @@ class RcParams(MutableMapping, dict):
         elif key == "backend" and self is globals().get("rcParams"):
             val = dict.__getitem__(self, key)
             if val is rcsetup._auto_backend_sentinel:
-                from matplotlib import pyplot as plt
-                plt.switch_backend(rcsetup._auto_backend_sentinel)
+                # Only resolve the backend if we're not in a context manager
+                # or if we're not just getting the current backend
+                if not hasattr(self, '_context_is_temporary') and sys._getframe(1).f_code.co_name != 'get_backend':
+                    from matplotlib import pyplot as plt
+                    plt.switch_backend(rcsetup._auto_backend_sentinel)
+                else:
+                    # If we're in a context manager or just getting the current backend,
+                    # return the current backend without resolving
+                    from matplotlib import pyplot as plt
+                    if plt._backend_mod is not None:
+                        val = plt._backend_mod.__name__.rsplit(".", 1)[-1]
+                    else:
+                        val = 'agg'
 
         return dict.__getitem__(self, key)
 
@@ -1088,6 +1099,8 @@ def rc_context(rc=None, fname=None):
 
     """
     orig = rcParams.copy()
+    # Mark this as a temporary context
+    rcParams._context_is_temporary = True
     try:
         if fname:
             rc_file(fname)
@@ -1095,7 +1108,10 @@ def rc_context(rc=None, fname=None):
             rcParams.update(rc)
         yield
     finally:
-        dict.update(rcParams, orig)  # Revert to the original rcs.
+        dict.update(rcParams, orig)  # Revert to the original rcs
+        # Remove the temporary context flag
+        if hasattr(rcParams, '_context_is_temporary'):
+            del rcParams._context_is_temporary
 
 
 def use(backend, *, force=True):
@@ -1175,7 +1191,11 @@ def get_backend():
     --------
     matplotlib.use
     """
-    return rcParams['backend']
+    backend = rcParams._get_backend_or_none()
+    if backend is None:
+        # Only trigger resolution if we really need to
+        backend = rcParams['backend']
+    return backend
 
 
 def interactive(b):
diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py
index e3c66ea67c..c48e6c4f68 100644
--- a/lib/matplotlib/pyplot.py
+++ b/lib/matplotlib/pyplot.py
@@ -198,11 +198,22 @@ def _get_backend_mod():
 
     This is currently private, but may be made public in the future.
     """
+    global _backend_mod
     if _backend_mod is None:
         # Use __getitem__ here to avoid going through the fallback logic (which
         # will (re)import pyplot and then call switch_backend if we need to
         # resolve the auto sentinel)
-        switch_backend(dict.__getitem__(rcParams, "backend"))
+        backend = dict.__getitem__(rcParams, "backend")
+        if backend is rcsetup._auto_backend_sentinel:
+            # If we're in a context manager, don't trigger backend resolution
+            if hasattr(rcParams, '_context_is_temporary'):
+                # Just return the agg backend as a fallback
+                import matplotlib.backends.backend_agg as backend_mod
+                _backend_mod = backend_mod
+            else:
+                switch_backend(backend)
+        else:
+            switch_backend(backend)
     return _backend_mod
 
 
@@ -222,7 +233,19 @@ def switch_backend(newbackend):
     global _backend_mod
     # make sure the init is pulled up so we can assign to it later
     import matplotlib.backends
-    close("all")
+
+    # Store current figures if we're resolving the auto backend
+    if newbackend is rcsetup._auto_backend_sentinel:
+        # Store current figures
+        stored_figs = []
+        for num, manager in list(_pylab_helpers.Gcf.figs.items()):
+            fig = manager.canvas.figure
+            stored_figs.append((num, fig))
+            # Don't destroy the figure, just remove it from Gcf.figs
+            _pylab_helpers.Gcf.figs.pop(num)
+    else:
+        close("all")
+        stored_figs = []
 
     if newbackend is rcsetup._auto_backend_sentinel:
         current_framework = cbook._get_running_interactive_framework()
@@ -317,6 +340,12 @@ def switch_backend(newbackend):
     # See https://github.com/matplotlib/matplotlib/issues/6092
     matplotlib.backends.backend = newbackend
 
+    # Restore figures if we stored any
+    if stored_figs:
+        for num, fig in stored_figs:
+            new_manager = new_figure_manager_given_figure(num, fig)
+            _pylab_helpers.Gcf.set_active(new_manager)
+
     # make sure the repl display hook is installed in case we become
     # interactive
     install_repl_displayhook()
diff --git a/reproduce_bug.py b/reproduce_bug.py
new file mode 100644
index 0000000000..4a74c6747d
--- /dev/null
+++ b/reproduce_bug.py
@@ -0,0 +1,14 @@
+import matplotlib.pyplot as plt
+from matplotlib import get_backend, rc_context
+
+# fig1 = plt.figure()  # <- UNCOMMENT THIS LINE AND IT WILL WORK
+# plt.ion()            # <- ALTERNATIVELY, UNCOMMENT THIS LINE AND IT WILL ALSO WORK
+with rc_context():
+    fig2 = plt.figure()
+before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'
+get_backend()
+after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'
+
+print("Before:", before)
+print("After:", after)
+assert before == after, '\n' + before + '\n' + after
\ No newline at end of file
