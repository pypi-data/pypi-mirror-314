diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..671c7cdd3c
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,6 @@
+from sympy import sympify
+
+expr = sympify("cosh(acos(-i + acosh(-g + i)))")
+print("Expression:", expr)
+print("Checking is_zero...")
+print("is_zero =", expr.is_zero)
\ No newline at end of file
diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py
index 892e19cabb..8229d5f324 100644
--- a/sympy/functions/elementary/hyperbolic.py
+++ b/sympy/functions/elementary/hyperbolic.py
@@ -434,8 +434,35 @@ def _eval_is_real(self):
         # cosh(a+ib) = cos(b)*cosh(a) + i*sin(b)*sinh(a)
         # the imaginary part can be an expression like n*pi
         # if not, check if the imaginary part is a number
-        re, im = arg.as_real_imag()
-        return (im%pi).is_zero
+        try:
+            re, im = arg.as_real_imag()
+        except:
+            return None
+
+        # If im is complex (not real), we can't determine if it's a multiple of pi
+        if im.is_complex and not im.is_real:
+            return None
+
+        # If im is a number, check if it's a multiple of pi
+        if im.is_number:
+            try:
+                return (im % pi).is_zero
+            except:
+                return None
+
+        # For symbolic expressions, try to determine if it's a multiple of pi
+        # without using modulo operation
+        from sympy import pi
+        from sympy.core.mul import Mul
+        from sympy.core.numbers import Integer, Rational
+
+        # Check if im is of the form n*pi where n is an integer
+        if isinstance(im, Mul):
+            coeff, rest = im.as_coeff_Mul()
+            if rest == pi and (coeff.is_integer or isinstance(coeff, (Integer, Rational))):
+                return True
+
+        return None
 
     def _eval_is_positive(self):
         # cosh(x+I*y) = cos(y)*cosh(x) + I*sin(y)*sinh(x)
@@ -445,7 +472,16 @@ def _eval_is_positive(self):
         # Case 2 (x=0): cosh(z) = cos(y) -> positive when cos(y) is positive
         z = self.args[0]
 
+        # If the argument is not real or imaginary, we can't determine positivity
+        if not (z.is_real or z.is_imaginary):
+            return None
+
         x, y = z.as_real_imag()
+
+        # If y is complex, we can't determine positivity
+        if y.is_complex and not y.is_real:
+            return None
+
         ymod = y % (2*pi)
 
         yzero = ymod.is_zero
@@ -472,7 +508,16 @@ def _eval_is_positive(self):
     def _eval_is_nonnegative(self):
         z = self.args[0]
 
+        # If the argument is not real or imaginary, we can't determine nonnegativity
+        if not (z.is_real or z.is_imaginary):
+            return None
+
         x, y = z.as_real_imag()
+
+        # If y is complex (not real), we can't determine nonnegativity
+        if y.is_complex and not y.is_real:
+            return None
+
         ymod = y % (2*pi)
 
         yzero = ymod.is_zero
diff --git a/test_edge_case.py b/test_edge_case.py
new file mode 100644
index 0000000000..1ecf64291e
--- /dev/null
+++ b/test_edge_case.py
@@ -0,0 +1,22 @@
+from sympy import sympify, I, pi
+
+# Test a simpler case where we know the result
+expr1 = sympify("cosh(I*pi)")
+print("Expression 1:", expr1)
+print("is_zero =", expr1.is_zero)
+print("is_real =", expr1.is_real)
+print("is_positive =", expr1.is_positive)
+
+# Test a more complex case with nested functions
+expr2 = sympify("cosh(acos(I*pi))")
+print("\nExpression 2:", expr2)
+print("is_zero =", expr2.is_zero)
+print("is_real =", expr2.is_real)
+print("is_positive =", expr2.is_positive)
+
+# Test the original problematic case
+expr3 = sympify("cosh(acos(-i + acosh(-g + i)))")
+print("\nExpression 3:", expr3)
+print("is_zero =", expr3.is_zero)
+print("is_real =", expr3.is_real)
+print("is_positive =", expr3.is_positive)
\ No newline at end of file
