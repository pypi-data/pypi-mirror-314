diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py
index 7b17d7612..e6bec6260 100644
--- a/src/_pytest/_code/code.py
+++ b/src/_pytest/_code/code.py
@@ -57,7 +57,14 @@ class Code:
             rawcode = getrawcode(rawcode)
         if not isinstance(rawcode, CodeType):
             raise TypeError("not a code object: {!r}".format(rawcode))
-        self.filename = rawcode.co_filename
+        # Store absolute path for co_filename
+        if rawcode.co_filename:
+            try:
+                self.filename = str(py.path.local(rawcode.co_filename).realpath())
+            except OSError:
+                self.filename = rawcode.co_filename
+        else:
+            self.filename = rawcode.co_filename
         self.firstlineno = rawcode.co_firstlineno - 1
         self.name = rawcode.co_name
         self.raw = rawcode
@@ -789,14 +796,18 @@ class FormattedExcinfo:
             return ReprEntry(lines, None, None, None, style)
 
     def _makepath(self, path):
-        if not self.abspath:
-            try:
-                np = py.path.local().bestrelpath(path)
-            except OSError:
-                return path
-            if len(np) < len(str(path)):
-                path = np
-        return path
+        try:
+            # Always convert to absolute path first
+            abs_path = py.path.local(path).realpath()
+            if not self.abspath:
+                # Get relative path from current test directory
+                test_dir = py.path.local().realpath()
+                np = test_dir.bestrelpath(abs_path)
+                if len(np) < len(str(abs_path)):
+                    return np
+            return str(abs_path)
+        except OSError:
+            return path
 
     def repr_traceback(self, excinfo: ExceptionInfo) -> "ReprTraceback":
         traceback = excinfo.traceback
@@ -1115,7 +1126,20 @@ class ReprFileLocation(TerminalRepr):
         i = msg.find("\n")
         if i != -1:
             msg = msg[:i]
-        tw.write(self.path, bold=True, red=True)
+        
+        # Convert path to absolute first
+        try:
+            abs_path = py.path.local(self.path).realpath()
+            # Get relative path from test invocation directory
+            test_dir = py.path.local().realpath()
+            display_path = test_dir.bestrelpath(abs_path)
+            # Remove any leading ../ since we want paths relative to test dir
+            if display_path.startswith("../"):
+                display_path = display_path[3:]
+        except OSError:
+            display_path = self.path
+            
+        tw.write(display_path, bold=True, red=True)
         tw.line(":{}: {}".format(self.lineno, msg))
 
 
diff --git a/src/_pytest/config/__init__.py b/src/_pytest/config/__init__.py
index bb5034ab1..4cac23c9b 100644
--- a/src/_pytest/config/__init__.py
+++ b/src/_pytest/config/__init__.py
@@ -795,6 +795,7 @@ class Config:
         invocation_params: Optional[InvocationParams] = None
     ) -> None:
         from .argparsing import Parser, FILE_OR_DIR
+        self._original_cwd = py.path.local()
 
         if invocation_params is None:
             invocation_params = self.InvocationParams(
diff --git a/test_path_error.py b/test_path_error.py
new file mode 100644
index 000000000..a879dd6c0
--- /dev/null
+++ b/test_path_error.py
@@ -0,0 +1,29 @@
+import os
+import errno
+import shutil
+
+import pytest
+
+
+@pytest.fixture
+def private_dir():  # or (monkeypatch)
+    out_dir = 'ddd'
+
+    try:
+        shutil.rmtree(out_dir)
+    except OSError as ex:
+        if ex.errno != errno.ENOENT:
+            raise
+    os.mkdir(out_dir)
+
+    old_dir = os.getcwd()
+    os.chdir(out_dir)
+    yield out_dir
+    os.chdir(old_dir)
+
+    # Same issue if using:
+    # monkeypatch.chdir(out_dir)
+
+
+def test_show_wrong_path(private_dir):
+    assert False
\ No newline at end of file
