diff --git a/expr.pkl b/expr.pkl
new file mode 100644
index 0000000000..788045e03c
Binary files /dev/null and b/expr.pkl differ
diff --git a/generate_pickle.py b/generate_pickle.py
new file mode 100644
index 0000000000..da028d2b35
--- /dev/null
+++ b/generate_pickle.py
@@ -0,0 +1,12 @@
+import pickle
+import sympy
+
+x = sympy.symbols("x")
+expr = x + 1.0
+
+# Pickle it with protocol 2 (Python 2 compatible)
+pickled = pickle.dumps(expr, 2)
+
+# Write the pickled data to a file
+with open('expr.pkl', 'wb') as f:
+    f.write(pickled)
\ No newline at end of file
diff --git a/load_pickle.py b/load_pickle.py
new file mode 100644
index 0000000000..3ce4cc18f6
--- /dev/null
+++ b/load_pickle.py
@@ -0,0 +1,11 @@
+import pickle
+import sys
+
+# Load the pickled data
+with open('expr.pkl', 'rb') as f:
+    data = f.read()
+    try:
+        result = pickle.loads(data)
+        print("Successfully loaded:", result)
+    except Exception as e:
+        print("Error loading:", str(e))
\ No newline at end of file
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..3d732df3e4
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,23 @@
+import pickle
+import sympy
+import sys
+
+# Create a simple expression with a float
+x = sympy.symbols("x")
+expr = x + 1.0
+
+# Pickle it with protocol 2 (Python 2 compatible)
+pickled = pickle.dumps(expr, 2)
+
+# Write the pickled data to a file
+with open('expr.pkl', 'wb') as f:
+    f.write(pickled)
+
+# Now try to load it back
+with open('expr.pkl', 'rb') as f:
+    data = f.read()
+    try:
+        result = pickle.loads(data)
+        print("Successfully loaded:", result)
+    except Exception as e:
+        print("Error loading:", str(e))
\ No newline at end of file
diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py
index 7bc96e68eb..a8ed937e96 100644
--- a/sympy/core/numbers.py
+++ b/sympy/core/numbers.py
@@ -101,6 +101,13 @@ def mpf_norm(mpf, prec):
 
     # Necessary if mpmath is using the gmpy backend
     from mpmath.libmp.backend import MPZ
+    
+    # Handle Python 2 hex strings with 'L' suffix
+    if isinstance(man, str):
+        if man.endswith('L'):
+            man = man[:-1]
+        man = int(man, 16)
+    
     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
     return rv
 
@@ -1042,7 +1049,14 @@ def __new__(cls, num, dps=None, prec=None, precision=None):
                 # it's a hexadecimal (coming from a pickled object)
                 # assume that it is in standard form
                 num = list(num)
-                num[1] = long(num[1], 16)
+                # Handle Python 2 'L' suffix in hex string
+                hex_str = num[1]
+                if hex_str.endswith('L'):
+                    hex_str = hex_str[:-1]
+                try:
+                    num[1] = int(hex_str, 16)
+                except Exception as e:
+                    raise ValueError("invalid hex literal: %s" % hex_str)
                 _mpf_ = tuple(num)
             else:
                 if len(num) == 4:
