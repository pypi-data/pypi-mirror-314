diff --git a/reproduce_trig.py b/reproduce_trig.py
new file mode 100644
index 0000000000..4fcf3b017a
--- /dev/null
+++ b/reproduce_trig.py
@@ -0,0 +1,25 @@
+from sympy import Symbol, cos, sin, sqrt, simplify, trigsimp, I, pi
+from sympy.abc import x
+
+# Create symbols with different assumptions
+z = Symbol('z', complex=True)
+r = Symbol('r', real=True)
+i = Symbol('i', imaginary=True)
+
+# Test cases
+test_cases = [
+    (cos(z) + sqrt(sin(z)**2), "Complex z"),
+    (cos(r) + sqrt(sin(r)**2), "Real r"),
+    (cos(i) + sqrt(sin(i)**2), "Imaginary i"),
+    (cos(x) + sqrt(sin(x)**2), "Unspecified x"),
+    (cos(z + I) + sqrt(sin(z + I)**2), "Complex z + I"),
+    (cos(pi*z) + sqrt(sin(pi*z)**2), "Complex pi*z"),
+]
+
+# Run tests
+for expr, desc in test_cases:
+    result = trigsimp(expr)
+    print(f"\nTest case: {desc}")
+    print(f"Original expression: {expr}")
+    print(f"After trigsimp: {result}")
+    print(f"Changed: {expr != result}")
\ No newline at end of file
diff --git a/sympy/simplify/fu.py b/sympy/simplify/fu.py
index 612bc0bb69..8677520d76 100644
--- a/sympy/simplify/fu.py
+++ b/sympy/simplify/fu.py
@@ -503,6 +503,10 @@ def _f(rv):
         if not rv.exp.is_real:
             return rv
 
+        # Don't transform if the argument is complex or can't be proven real
+        if rv.base.args and rv.base.args[0].is_real is not True:
+            return rv
+
         if (rv.exp < 0) == True:
             return rv
         if (rv.exp > max) == True:
diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py
index 7ca05f0304..730a4058fe 100644
--- a/sympy/simplify/trigsimp.py
+++ b/sympy/simplify/trigsimp.py
@@ -1088,6 +1088,9 @@ def futrig(e, **kwargs):
     """
     from sympy.simplify.fu import hyper_as_trig
     from sympy.simplify.simplify import bottom_up
+    from sympy.core.function import expand
+    from sympy.functions.elementary.trigonometric import TrigonometricFunction
+    from sympy.core import S, Pow, Add, Mul
 
     e = sympify(e)
 
@@ -1097,6 +1100,34 @@ def futrig(e, **kwargs):
     if not e.args:
         return e
 
+    # Check if any part of the expression involves complex arguments
+    def has_complex_trig(expr):
+        if isinstance(expr, TrigonometricFunction):
+            if expr.args[0].is_real is not True:
+                return True
+        for arg in expr.args:
+            if has_complex_trig(arg):
+                return True
+        return False
+
+    # For complex arguments, don't apply transformations that assume real domain
+    if has_complex_trig(e):
+        # Only apply basic simplifications that are valid in complex domain
+        if isinstance(e, Add):
+            # Simplify each term individually but don't combine them
+            return Add(*[futrig(arg, **kwargs) for arg in e.args])
+        elif isinstance(e, Mul):
+            # Simplify factors individually but don't combine them
+            return Mul(*[futrig(arg, **kwargs) for arg in e.args])
+        elif e.func == Pow and e.exp == S.Half:  # sqrt
+            arg = e.args[0]
+            if isinstance(arg, Pow) and arg.exp == 2:  # squared term
+                base = arg.base
+                if isinstance(base, TrigonometricFunction):
+                    # Don't simplify sqrt(sin(x)**2) to sin(x) for complex x
+                    return e
+        return e
+
     old = e
     e = bottom_up(e, lambda x: _futrig(x, **kwargs))
