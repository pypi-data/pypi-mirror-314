diff --git a/django/contrib/sessions/backends/base.py b/django/contrib/sessions/backends/base.py
index 187e14b1b7..2695b7be3e 100644
--- a/django/contrib/sessions/backends/base.py
+++ b/django/contrib/sessions/backends/base.py
@@ -1,4 +1,5 @@
 import base64
+import binascii
 import logging
 import string
 import warnings
@@ -122,7 +123,14 @@ class SessionBase:
         # RemovedInDjango40Warning: when the deprecation ends, handle here
         # exceptions similar to what _legacy_decode() does now.
         except Exception:
-            return self._legacy_decode(session_data)
+            try:
+                return self._legacy_decode(session_data)
+            except (binascii.Error, ValueError, SuspiciousOperation) as e:
+                # Handle base64 decoding errors, value errors from split, and suspicious sessions
+                if isinstance(e, SuspiciousOperation):
+                    logger = logging.getLogger('django.security.%s' % e.__class__.__name__)
+                    logger.warning(str(e))
+                return {}
 
     def _legacy_encode(self, session_dict):
         # RemovedInDjango40Warning.
diff --git a/reproduce_session_error.py b/reproduce_session_error.py
new file mode 100644
index 0000000000..615ad7ad94
--- /dev/null
+++ b/reproduce_session_error.py
@@ -0,0 +1,34 @@
+from django.contrib.sessions.backends.db import SessionStore
+from django.conf import settings
+import django
+
+# Configure minimal Django settings
+settings.configure(
+    SECRET_KEY='dummy-key-for-test',
+    SESSION_SERIALIZER='django.contrib.sessions.serializers.JSONSerializer',
+    DEFAULT_HASHING_ALGORITHM='sha256',
+    INSTALLED_APPS=['django.contrib.sessions'],
+)
+
+django.setup()
+
+# Create a session store
+session = SessionStore()
+
+# Test various edge cases
+test_cases = [
+    "invalid-base64-data-with-no-padding",  # Invalid base64
+    "YTpiOnNvbWV0aGluZw==",  # Valid base64 but invalid session format
+    "",  # Empty string
+    "a" * 1000,  # Very long invalid string
+    "{}",  # Valid JSON but not a valid session
+    None,  # None value
+]
+
+for test_data in test_cases:
+    print(f"\nTesting: {test_data}")
+    try:
+        result = session.decode(test_data) if test_data is not None else session.decode("")
+        print(f"Result: {result}")  # Should print an empty dict in all cases
+    except Exception as e:
+        print(f"Error: {type(e).__name__}: {str(e)}")
\ No newline at end of file
