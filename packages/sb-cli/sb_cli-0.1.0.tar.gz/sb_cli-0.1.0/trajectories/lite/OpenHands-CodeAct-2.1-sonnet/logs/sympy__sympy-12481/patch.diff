diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..a0eee3a0a3
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,5 @@
+from sympy.combinatorics.permutations import Permutation
+
+# Try to create a permutation with non-disjoint cycles
+p = Permutation([[0,1], [0,1]])
+print(p)
\ No newline at end of file
diff --git a/reproduce2.py b/reproduce2.py
new file mode 100644
index 0000000000..62f5393fd6
--- /dev/null
+++ b/reproduce2.py
@@ -0,0 +1,7 @@
+from sympy.combinatorics.permutations import Cycle, Permutation
+
+# Try to create a permutation with non-disjoint cycles using Cycle
+c = Cycle(0, 1)(0, 1)
+print(c)
+p = Permutation(c)
+print(p)
\ No newline at end of file
diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 136ed5a478..844b6c9b0b 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -897,8 +897,11 @@ def __new__(cls, *args, **kwargs):
         temp = flatten(args)
         if has_dups(temp):
             if is_cycle:
-                raise ValueError('there were repeated elements; to resolve '
-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))
+                # Handle non-disjoint cycles by converting to Cycle
+                c = Cycle()
+                for cycle in args:
+                    c = c(*cycle)
+                return _af_new(c.list(size))
             else:
                 raise ValueError('there were repeated elements.')
         temp = set(temp)
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..8b9f424831
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,37 @@
+from sympy.combinatorics.permutations import Permutation
+
+# Test case from PR description
+p = Permutation([[0,1], [0,1]])
+print("Test case from PR description:")
+print(f"p = {p}")
+print(f"p.array_form = {p.array_form}")
+print(f"Is identity? {p.is_Identity}")
+
+# Additional test cases
+print("\nAdditional test cases:")
+
+# Multiple overlapping cycles
+p2 = Permutation([[0,1,2], [1,2,3]])
+print(f"\np2 = {p2}")
+print(f"p2.array_form = {p2.array_form}")
+
+# Cycles that share multiple elements
+p3 = Permutation([[0,1,2], [2,1,0]])
+print(f"\np3 = {p3}")
+print(f"p3.array_form = {p3.array_form}")
+
+# More than two overlapping cycles
+p4 = Permutation([[0,1], [1,2], [2,0]])
+print(f"\np4 = {p4}")
+print(f"p4.array_form = {p4.array_form}")
+
+# Cycles with different sizes
+p5 = Permutation([[0,1,2,3], [1,2]])
+print(f"\np5 = {p5}")
+print(f"p5.array_form = {p5.array_form}")
+
+# Identity permutation through cancellation
+p6 = Permutation([[0,1], [1,0]])
+print(f"\np6 = {p6}")
+print(f"p6.array_form = {p6.array_form}")
+print(f"Is identity? {p6.is_Identity}")
\ No newline at end of file
