diff --git a/db.sqlite3 b/db.sqlite3
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index b89b6b511b..6ecdc7517a 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -645,7 +645,24 @@ class AlterIndexTogether(AlterTogetherOptionOperation):
     option_name = "index_together"
 
     def __init__(self, name, index_together):
-        super().__init__(name, index_together)
+        from django.db.models import Index
+        # Convert index_together to indexes
+        self.indexes = []
+        if index_together:
+            for fields in index_together:
+                index_name = f"idx_{'_'.join(str(f) for f in fields)}"
+                self.indexes.append(Index(fields=list(fields), name=index_name))
+        super().__init__(name, [])
+
+    def database_forwards(self, app_label, schema_editor, from_state, to_state):
+        from django.db.migrations.operations.models import AddIndex
+        model = to_state.apps.get_model(app_label, self.name)
+        if self.indexes:
+            for index in self.indexes:
+                operation = AddIndex(self.name, index)
+                operation.state_forwards(app_label, to_state)
+                operation.database_forwards(app_label, schema_editor, from_state, to_state)
+        super().database_forwards(app_label, schema_editor, from_state, to_state)
 
 
 class AlterOrderWithRespectTo(ModelOptionOperation):
diff --git a/django/db/migrations/state.py b/django/db/migrations/state.py
index ae55967383..29d031b54a 100644
--- a/django/db/migrations/state.py
+++ b/django/db/migrations/state.py
@@ -10,7 +10,7 @@ from django.conf import settings
 from django.core.exceptions import FieldDoesNotExist
 from django.db import models
 from django.db.migrations.utils import field_is_referenced, get_references
-from django.db.models import NOT_PROVIDED
+from django.db.models import NOT_PROVIDED, Index
 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT
 from django.db.models.options import DEFAULT_NAMES, normalize_together
 from django.db.models.utils import make_model_tuple
@@ -724,7 +724,16 @@ class ModelState:
     ):
         self.app_label = app_label
         self.name = name
-        self.fields = dict(fields)
+        self.fields = {}
+        if isinstance(fields, dict):
+            self.fields = fields
+        else:
+            for field in fields:
+                if isinstance(field, (list, tuple)):
+                    if len(field) == 2 and not isinstance(field[1], str):
+                        self.fields[field[0]] = field[1]
+                elif hasattr(field, 'name') and hasattr(field, 'clone'):
+                    self.fields[field.name] = field.clone()
         self.options = options or {}
         self.options.setdefault("indexes", [])
         self.options.setdefault("constraints", [])
@@ -774,28 +783,72 @@ class ModelState:
                 continue
             if isinstance(field, models.OrderWrt):
                 continue
-            name = field.name
             try:
-                fields.append((name, field.clone()))
+                field_copy = field.clone()
+                field_copy.model = None
+                field_copy.concrete = True
+                if hasattr(field_copy, 'db_column') and not isinstance(getattr(field_copy.__class__, 'db_column', None), property):
+                    field_copy.db_column = None
+                if hasattr(field_copy, 'db_tablespace') and not isinstance(getattr(field_copy.__class__, 'db_tablespace', None), property):
+                    field_copy.db_tablespace = None
+                if hasattr(field_copy, 'db_index') and not isinstance(getattr(field_copy.__class__, 'db_index', None), property):
+                    field_copy.db_index = False
+                if hasattr(field_copy, '_unique') and not isinstance(getattr(field_copy.__class__, '_unique', None), property):
+                    field_copy._unique = False
+                if hasattr(field_copy, '_validators') and not isinstance(getattr(field_copy.__class__, '_validators', None), property):
+                    field_copy._validators = []
+                if hasattr(field_copy, '_error_messages') and not isinstance(getattr(field_copy.__class__, '_error_messages', None), property):
+                    field_copy._error_messages = {}
+                if hasattr(field_copy, '_choices') and not isinstance(getattr(field_copy.__class__, '_choices', None), property):
+                    field_copy._choices = []
+                if hasattr(field_copy, '_help_text') and not isinstance(getattr(field_copy.__class__, '_help_text', None), property):
+                    field_copy._help_text = ''
+                if hasattr(field_copy, '_verbose_name') and not isinstance(getattr(field_copy.__class__, '_verbose_name', None), property):
+                    field_copy._verbose_name = None
+                if hasattr(field_copy, '_default') and not isinstance(getattr(field_copy.__class__, '_default', None), property):
+                    field_copy._default = None
+                fields.append((field.name, field_copy))
             except TypeError as e:
                 raise TypeError(
                     "Couldn't reconstruct field %s on %s: %s"
                     % (
-                        name,
+                        field.name,
                         model._meta.label,
                         e,
                     )
                 )
         if not exclude_rels:
             for field in model._meta.local_many_to_many:
-                name = field.name
                 try:
-                    fields.append((name, field.clone()))
+                    field_copy = field.clone()
+                    field_copy.model = None
+                    field_copy.concrete = True
+                    if hasattr(field_copy, 'db_column') and not isinstance(getattr(field_copy.__class__, 'db_column', None), property):
+                        field_copy.db_column = None
+                    if hasattr(field_copy, 'db_tablespace') and not isinstance(getattr(field_copy.__class__, 'db_tablespace', None), property):
+                        field_copy.db_tablespace = None
+                    if hasattr(field_copy, 'db_index') and not isinstance(getattr(field_copy.__class__, 'db_index', None), property):
+                        field_copy.db_index = False
+                    if hasattr(field_copy, '_unique') and not isinstance(getattr(field_copy.__class__, '_unique', None), property):
+                        field_copy._unique = False
+                    if hasattr(field_copy, '_validators') and not isinstance(getattr(field_copy.__class__, '_validators', None), property):
+                        field_copy._validators = []
+                    if hasattr(field_copy, '_error_messages') and not isinstance(getattr(field_copy.__class__, '_error_messages', None), property):
+                        field_copy._error_messages = {}
+                    if hasattr(field_copy, '_choices') and not isinstance(getattr(field_copy.__class__, '_choices', None), property):
+                        field_copy._choices = []
+                    if hasattr(field_copy, '_help_text') and not isinstance(getattr(field_copy.__class__, '_help_text', None), property):
+                        field_copy._help_text = ''
+                    if hasattr(field_copy, '_verbose_name') and not isinstance(getattr(field_copy.__class__, '_verbose_name', None), property):
+                        field_copy._verbose_name = None
+                    if hasattr(field_copy, '_default') and not isinstance(getattr(field_copy.__class__, '_default', None), property):
+                        field_copy._default = None
+                    fields.append((field.name, field_copy))
                 except TypeError as e:
                     raise TypeError(
                         "Couldn't reconstruct m2m field %s on %s: %s"
                         % (
-                            name,
+                            field.name,
                             model._meta.object_name,
                             e,
                         )
@@ -812,6 +865,13 @@ class ModelState:
                     options[name] = set(normalize_together(ut))
                 elif name == "index_together":
                     it = model._meta.original_attrs["index_together"]
+                    # Convert index_together to indexes
+                    if it:
+                        if "indexes" not in options:
+                            options["indexes"] = []
+                        for fields in normalize_together(it):
+                            index_name = f"idx_{'_'.join(str(f) for f in fields)}"
+                            options["indexes"].append(Index(fields=list(fields), name=index_name))
                     options[name] = set(normalize_together(it))
                 elif name == "indexes":
                     indexes = [idx.clone() for idx in model._meta.indexes]
diff --git a/django/db/models/options.py b/django/db/models/options.py
index be3d68f390..a658d7b5e3 100644
--- a/django/db/models/options.py
+++ b/django/db/models/options.py
@@ -212,6 +212,12 @@ class Options:
                     f"{self.label!r} instead.",
                     RemovedInDjango51Warning,
                 )
+                # Convert index_together to indexes
+                from django.db.models import Index
+                for fields in self.index_together:
+                    index_name = f"idx_{'_'.join(str(f) for f in fields)}"
+                    self.indexes.append(Index(fields=list(fields), name=index_name))
+                self.index_together = []
             # App label/class name interpolation for names of constraints and
             # indexes.
             if not getattr(cls._meta, "abstract", False):
diff --git a/reproduce_warning.py b/reproduce_warning.py
new file mode 100644
index 0000000000..c57d6fd578
--- /dev/null
+++ b/reproduce_warning.py
@@ -0,0 +1,68 @@
+from django.db import models
+from django.core.management import execute_from_command_line
+import os
+import sys
+
+# Set up Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_project.settings')
+
+# Create a test project
+if not os.path.exists('test_project'):
+    os.makedirs('test_project')
+
+# Create settings.py
+settings_content = '''
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': 'db.sqlite3',
+    }
+}
+INSTALLED_APPS = [
+    'test_app',
+]
+SECRET_KEY = 'dummy'
+'''
+
+with open('test_project/settings.py', 'w') as f:
+    f.write(settings_content)
+
+# Create __init__.py
+with open('test_project/__init__.py', 'w') as f:
+    f.write('')
+
+# Create test app
+if not os.path.exists('test_app'):
+    os.makedirs('test_app')
+    os.makedirs('test_app/migrations')
+
+with open('test_app/__init__.py', 'w') as f:
+    f.write('')
+
+with open('test_app/migrations/__init__.py', 'w') as f:
+    f.write('')
+
+# Create models.py with index_together
+models_content = '''
+from django.db import models
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    age = models.IntegerField()
+
+    class Meta:
+        index_together = [
+            ('name', 'age'),
+        ]
+'''
+
+with open('test_app/models.py', 'w') as f:
+    f.write(models_content)
+
+if __name__ == '__main__':
+    # Add the current directory to Python path
+    sys.path.append(os.getcwd())
+    
+    # Make migrations to trigger the warning
+    argv = ['manage.py', 'makemigrations']
+    execute_from_command_line(argv)
\ No newline at end of file
diff --git a/test_app/__init__.py b/test_app/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/migrations/0001_initial.py b/test_app/migrations/0001_initial.py
new file mode 100644
index 0000000000..50b6346804
--- /dev/null
+++ b/test_app/migrations/0001_initial.py
@@ -0,0 +1,25 @@
+# Generated by Django 5.0.dev20230502044622 on 2024-10-25 16:58
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    initial = True
+
+    dependencies = []
+
+    operations = [
+        migrations.CreateModel(
+            name="TestModel",
+            fields=[],
+        ),
+        migrations.AddIndex(
+            model_name="testmodel",
+            index=models.Index(fields=["name", "age"], name="idx_name_age"),
+        ),
+        migrations.AlterIndexTogether(
+            name="testmodel",
+            index_together=[],
+        ),
+    ]
diff --git a/test_app/migrations/__init__.py b/test_app/migrations/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/models.py b/test_app/models.py
new file mode 100644
index 0000000000..4fb3fa295b
--- /dev/null
+++ b/test_app/models.py
@@ -0,0 +1,11 @@
+
+from django.db import models
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    age = models.IntegerField()
+
+    class Meta:
+        index_together = [
+            ('name', 'age'),
+        ]
diff --git a/test_project/__init__.py b/test_project/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_project/settings.py b/test_project/settings.py
new file mode 100644
index 0000000000..c29f99f79c
--- /dev/null
+++ b/test_project/settings.py
@@ -0,0 +1,11 @@
+
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': 'db.sqlite3',
+    }
+}
+INSTALLED_APPS = [
+    'test_app',
+]
+SECRET_KEY = 'dummy'
