diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index b0df8749..b7652687 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -1958,13 +1958,103 @@ class DataArray(AbstractArray, DataWithCoords):
         variables = idx.levels[level_number]
         variable_dim = idx.names[level_number]
 
-        # pull variables out of datarray
+        # Get the MultiIndex for the stacked dimension
+        multi_idx = self.get_index(dim)
+        
+        # Get the level values and their positions
+        level_values = multi_idx.get_level_values(level)
+        level_positions = multi_idx.codes[level_number]
+        
+        # Create a dictionary to store the unstacked data
         data_dict = {}
-        for k in variables:
-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)
-
-        # unstacked dataset
-        return Dataset(data_dict)
+        
+        # Get all non-stacked coordinates
+        coords_dict = {}
+        for name, coord in self.coords.items():
+            if name != dim and not (isinstance(coord, IndexVariable) and coord.name == variable_dim):
+                coords_dict[name] = coord
+        
+        # Get other level values for these positions
+        other_levels = [i for i in range(len(multi_idx.levels)) if i != level_number]
+        other_level_names = [multi_idx.names[i] for i in other_levels]
+        
+        # For each variable in the level
+        for var in variables:
+            # Find positions where this variable appears
+            var_positions = level_positions == multi_idx.levels[level_number].get_loc(var)
+            
+            # Get the data for these positions
+            var_data = self.isel({dim: var_positions})
+            
+            # Get the values for other levels at these positions
+            var_coords = {}
+            for level_idx, level_name in zip(other_levels, other_level_names):
+                if level_name is not None:  # Skip unnamed levels
+                    level_values = multi_idx.levels[level_idx]
+                    level_codes = multi_idx.codes[level_idx][var_positions]
+                    
+                    # Only include non-NA values
+                    valid = level_codes >= 0
+                    if valid.any():
+                        coord_values = level_values.take(level_codes[valid])
+                        if len(coord_values) == len(var_data):  # Only include if it matches the data length
+                            var_coords[level_name] = coord_values
+            
+            # Get the dimensions for this variable
+            var_dims = tuple(d for d in var_data.dims if d != dim)
+            
+            # Find the dimensions from the MultiIndex that are valid for this variable
+            valid_coords = {}
+            for level_idx, level_name in zip(other_levels, other_level_names):
+                if level_name is not None:  # Skip unnamed levels
+                    level_values = multi_idx.levels[level_idx]
+                    level_codes = multi_idx.codes[level_idx][var_positions]
+                    
+                    # Only include non-NA values
+                    valid = level_codes >= 0
+                    if valid.any():
+                        coord_values = level_values.take(level_codes[valid])
+                        if len(coord_values) == len(var_data):  # Only include if it matches the data length
+                            valid_coords[level_name] = coord_values
+            
+            # Get the values for this variable
+            values = var_data.values
+            
+            # Get the shape of each dimension
+            dim_sizes = {d: len(var_data[d]) for d in var_dims}
+            
+            # Add any dimensions from the MultiIndex that aren't already present
+            for coord_name, coord_values in valid_coords.items():
+                if coord_name not in var_dims:
+                    var_dims = var_dims + (coord_name,)
+                    dim_sizes[coord_name] = len(coord_values)
+            
+            # Reshape the values to match all dimensions
+            if values.ndim > len(var_dims):
+                # Get the first occurrence of each coordinate combination
+                values = values[..., 0]
+            elif values.ndim < len(var_dims):
+                # Add missing dimensions
+                for _ in range(len(var_dims) - values.ndim):
+                    values = values[..., None]
+            
+            # Create the variable with the correct dimensions and coordinates
+            var_coords = {d: var_data[d] for d in var_dims if d in var_data.dims}
+            var_coords.update(valid_coords)
+            data_dict[var] = Variable(var_dims, values)
+            
+            # Update coordinates with proper dimensions
+            for name, values in var_coords.items():
+                if name not in coords_dict:
+                    coords_dict[name] = Variable((name,), values)
+        
+        # Create the dataset with preserved coordinates
+        ds = Dataset(data_dict, coords=coords_dict)
+        
+        # Copy attributes
+        ds.attrs.update(self.attrs)
+        
+        return ds
 
     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> "DataArray":
         """Return a new DataArray object with transposed dimensions.
