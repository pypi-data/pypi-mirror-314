diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 000000000..00a37a0a2
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,46 @@
+import pandas as pd
+import numpy as np
+from sklearn.utils.multiclass import unique_labels
+
+def test_case(y_true, y_pred, case_name):
+    print(f"\nTesting {case_name}...")
+    print(f"y_true dtype: {y_true.dtype}")
+    print(f"y_pred dtype: {y_pred.dtype}")
+    try:
+        result = unique_labels(y_true, y_pred)
+        print(f"Success: {result}")
+    except ValueError as e:
+        print(f"Error: {str(e)}")
+
+# Test case 1: Basic nullable dtypes
+print("\n=== Basic nullable dtypes ===")
+for dtype in ["Int64", "Float64", "boolean"]:
+    y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)
+    y_pred = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype="int64")
+    test_case(y_true, y_pred, f"basic {dtype}")
+
+# Test case 2: Nullable dtypes with missing values
+print("\n=== Nullable dtypes with NA values ===")
+for dtype in ["Int64", "Float64", "boolean"]:
+    y_true = pd.Series([1, 0, None, 1, 0, 1, 1, 0, 1], dtype=dtype)
+    y_pred = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype="int64")
+    test_case(y_true, y_pred, f"{dtype} with NA")
+
+# Test case 3: Mixed types
+print("\n=== Mixed types ===")
+y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype="Int64")
+y_pred = pd.Series([True, False, True, True, False, True, True, True, True], dtype="boolean")
+test_case(y_true, y_pred, "Int64 with boolean")
+
+# Test case 4: Regular dtypes
+print("\n=== Regular dtypes ===")
+for dtype in ["int64", "float64", "bool"]:
+    y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)
+    y_pred = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype="int64")
+    test_case(y_true, y_pred, f"regular {dtype}")
+
+# Test case 5: Extreme values
+print("\n=== Extreme values ===")
+y_true = pd.Series([9223372036854775807, -9223372036854775808, 0], dtype="Int64")
+y_pred = pd.Series([9223372036854775807, -9223372036854775808, 0], dtype="int64")
+test_case(y_true, y_pred, "extreme values")
\ No newline at end of file
diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py
index 5eaef2fde..9add37c05 100644
--- a/sklearn/utils/multiclass.py
+++ b/sklearn/utils/multiclass.py
@@ -22,6 +22,20 @@ from ..utils._array_api import get_namespace
 
 def _unique_multiclass(y):
     xp, is_array_api = get_namespace(y)
+    
+    # Handle pandas nullable dtypes
+    if hasattr(y, "dtype") and str(y.dtype) in ["Int64", "Float64", "boolean"]:
+        # Convert to corresponding non-nullable dtype, replacing NA with a sentinel value
+        if str(y.dtype) == "boolean":
+            # For boolean, use False for NA values
+            y = y.fillna(False).astype(bool)
+        else:
+            # For Int64/Float64, use the corresponding non-nullable dtype
+            target_dtype = "int64" if str(y.dtype) == "Int64" else "float64"
+            # Fill NA with a sentinel value that's valid for the dtype
+            sentinel = 0 if target_dtype == "int64" else 0.0
+            y = y.fillna(sentinel).astype(target_dtype)
+    
     if hasattr(y, "__array__") or is_array_api:
         return xp.unique_values(xp.asarray(y))
     else:
@@ -298,6 +312,19 @@ def type_of_target(y, input_name=""):
     if is_multilabel(y):
         return "multilabel-indicator"
 
+    # Handle pandas nullable dtypes
+    if hasattr(y, "dtype") and str(y.dtype) in ["Int64", "Float64", "boolean"]:
+        # Convert to corresponding non-nullable dtype, replacing NA with a sentinel value
+        if str(y.dtype) == "boolean":
+            # For boolean, use False for NA values
+            y = y.fillna(False).astype(bool)
+        else:
+            # For Int64/Float64, use the corresponding non-nullable dtype
+            target_dtype = "int64" if str(y.dtype) == "Int64" else "float64"
+            # Fill NA with a sentinel value that's valid for the dtype
+            sentinel = 0 if target_dtype == "int64" else 0.0
+            y = y.fillna(sentinel).astype(target_dtype)
+
     # DeprecationWarning will be replaced by ValueError, see NEP 34
     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html
     # We therefore catch both deprecation (NumPy < 1.24) warning and
