diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py
index 397146a354..a327a0d71d 100644
--- a/django/db/models/fields/related.py
+++ b/django/db/models/fields/related.py
@@ -400,21 +400,12 @@ class RelatedField(FieldCacheMixin, Field):
 
     def formfield(self, **kwargs):
         """
-        Pass ``limit_choices_to`` to the field being constructed.
+        Pass field configuration to the field being constructed.
 
-        Only passes it if there is a type that supports related fields.
-        This is a similar strategy used to pass the ``queryset`` to the field
-        being constructed.
+        Note: limit_choices_to is handled during ModelForm initialization
+        to avoid applying it twice.
         """
         defaults = {}
-        if hasattr(self.remote_field, 'get_related_field'):
-            # If this is a callable, do not invoke it here. Just pass
-            # it in the defaults for when the form class will later be
-            # instantiated.
-            limit_choices_to = self.remote_field.limit_choices_to
-            defaults.update({
-                'limit_choices_to': limit_choices_to,
-            })
         defaults.update(kwargs)
         return super().formfield(**defaults)
 
@@ -986,13 +977,16 @@ class ForeignKey(ForeignObject):
             raise ValueError("Cannot create form field for %r yet, because "
                              "its related model %r has not been loaded yet" %
                              (self.name, self.remote_field.model))
-        return super().formfield(**{
+        # Pass limit_choices_to to the field constructor but don't apply it to the queryset yet
+        defaults = {
             'form_class': forms.ModelChoiceField,
             'queryset': self.remote_field.model._default_manager.using(using),
             'to_field_name': self.remote_field.field_name,
-            **kwargs,
+            'limit_choices_to': self.remote_field.limit_choices_to,
             'blank': self.blank,
-        })
+        }
+        defaults.update(kwargs)
+        return super().formfield(**defaults)
 
     def db_check(self, connection):
         return []
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..5d3468bb76
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,64 @@
+from django.conf import settings
+from django.db import models
+from django.forms import ModelForm
+from django.db.models import Q
+
+# Configure Django settings
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+        'test_app',
+    ],
+    MIDDLEWARE=[],
+    DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+)
+
+import django
+django.setup()
+
+# Define models
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'test_app'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    class Meta:
+        app_label = 'test_app'
+
+class Review(models.Model):
+    book = models.ForeignKey(
+        Book, 
+        on_delete=models.CASCADE,
+        limit_choices_to=Q(author__name__startswith='A')  # This will cause duplicates
+    )
+    text = models.TextField()
+    class Meta:
+        app_label = 'test_app'
+
+class ReviewForm(ModelForm):
+    class Meta:
+        model = Review
+        fields = ['book', 'text']
+
+# Create test data
+from django.core.management import call_command
+call_command('migrate', verbosity=0)
+
+author1 = Author.objects.create(name='Alice')
+book1 = Book.objects.create(title='Book 1', author=author1)
+book2 = Book.objects.create(title='Book 2', author=author1)
+
+# Create form and check choices
+form = ReviewForm()
+print("Number of choices:", len(list(form.fields['book'].choices)))
+print("Choices:", list(form.fields['book'].choices))
\ No newline at end of file
diff --git a/test_app/__init__.py b/test_app/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/migrations/0001_initial.py b/test_app/migrations/0001_initial.py
new file mode 100644
index 0000000000..53c742711f
--- /dev/null
+++ b/test_app/migrations/0001_initial.py
@@ -0,0 +1,38 @@
+# Generated by Django 3.2 on 2024-10-25 11:37
+
+from django.db import migrations, models
+import django.db.models.deletion
+
+
+class Migration(migrations.Migration):
+
+    initial = True
+
+    dependencies = [
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='Author',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('name', models.CharField(max_length=100)),
+            ],
+        ),
+        migrations.CreateModel(
+            name='Book',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('title', models.CharField(max_length=100)),
+                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='test_app.author')),
+            ],
+        ),
+        migrations.CreateModel(
+            name='Review',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('text', models.TextField()),
+                ('book', models.ForeignKey(limit_choices_to=models.Q(author__name__startswith='A'), on_delete=django.db.models.deletion.CASCADE, to='test_app.book')),
+            ],
+        ),
+    ]
diff --git a/test_app/migrations/__init__.py b/test_app/migrations/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_app/models.py b/test_app/models.py
new file mode 100644
index 0000000000..278a261e55
--- /dev/null
+++ b/test_app/models.py
@@ -0,0 +1,17 @@
+from django.db import models
+from django.db.models import Q
+
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+
+class Review(models.Model):
+    book = models.ForeignKey(
+        Book, 
+        on_delete=models.CASCADE,
+        limit_choices_to=Q(author__name__startswith='A')  # This will cause duplicates
+    )
+    text = models.TextField()
\ No newline at end of file
diff --git a/test_app/tests.py b/test_app/tests.py
new file mode 100644
index 0000000000..30f4d6823f
--- /dev/null
+++ b/test_app/tests.py
@@ -0,0 +1,88 @@
+from django.test import TestCase
+from django.forms import ModelForm
+from django.db import models
+from django.db.models import Q
+from .models import Author, Book, Review
+
+class ReviewForm(ModelForm):
+    class Meta:
+        model = Review
+        fields = ['book', 'text']
+
+class LimitChoicesToTest(TestCase):
+    def setUp(self):
+        self.author1 = Author.objects.create(name='Alice')
+        self.book1 = Book.objects.create(title='Book 1', author=self.author1)
+        self.book2 = Book.objects.create(title='Book 2', author=self.author1)
+
+    def test_no_duplicate_choices(self):
+        form = ReviewForm()
+        choices = list(form.fields['book'].choices)[1:]  # Skip empty choice
+        self.assertEqual(len(choices), 2)  # Should have 2 books
+        self.assertEqual(len(set(str(c[0]) for c in choices)), 2)  # Should have 2 unique values
+
+    def test_complex_q_object(self):
+        # Create more test data
+        author2 = Author.objects.create(name='Bob')
+        author3 = Author.objects.create(name='Alice Smith')
+        book3 = Book.objects.create(title='Book 3', author=author2)
+        book4 = Book.objects.create(title='Book 4', author=author3)
+
+        # Create a form with a more complex Q object
+        class ComplexReview(models.Model):
+            book = models.ForeignKey(
+                Book,
+                on_delete=models.CASCADE,
+                limit_choices_to=Q(author__name__startswith='A') | Q(author__name__endswith='Smith')
+            )
+            text = models.TextField()
+            class Meta:
+                app_label = 'test_app'
+
+        class ComplexReviewForm(ModelForm):
+            class Meta:
+                model = ComplexReview
+                fields = ['book', 'text']
+
+        form = ComplexReviewForm()
+        print("\nBooks:", [(b.id, b.title, b.author.name) for b in Book.objects.all()])
+        print("Authors:", [(a.id, a.name) for a in Author.objects.all()])
+        print("Limit choices to:", form.fields['book'].get_limit_choices_to())
+        choices = list(form.fields['book'].choices)[1:]  # Skip empty choice
+        print("Choices:", [(str(c[0]), c[1]) for c in choices])
+        # Should have 3 books (2 from Alice and 1 from Alice Smith)
+        self.assertEqual(len(choices), 3)
+        self.assertEqual(len(set(str(c[0]) for c in choices)), 3)  # Should have 3 unique values
+
+    def test_callable_limit_choices_to(self):
+        # Create more test data
+        author2 = Author.objects.create(name='Bob')
+        author3 = Author.objects.create(name='Alice Smith')
+        book3 = Book.objects.create(title='Book 3', author=author2)
+        book4 = Book.objects.create(title='Book 4', author=author3)
+
+        # Create a form with a callable limit_choices_to
+        class CallableReview(models.Model):
+            book = models.ForeignKey(
+                Book,
+                on_delete=models.CASCADE,
+                limit_choices_to=lambda: Q(author__name__startswith='A') | Q(author__name__endswith='Smith')
+            )
+            text = models.TextField()
+            class Meta:
+                app_label = 'test_app'
+
+        class CallableReviewForm(ModelForm):
+            class Meta:
+                model = CallableReview
+                fields = ['book', 'text']
+
+        form = CallableReviewForm()
+        print("\nBooks:", [(b.id, b.title, b.author.name) for b in Book.objects.all()])
+        print("Authors:", [(a.id, a.name) for a in Author.objects.all()])
+        print("Limit choices to:", form.fields['book'].get_limit_choices_to())
+        choices = list(form.fields['book'].choices)[1:]  # Skip empty choice
+        print("Choices:", [(str(c[0]), c[1]) for c in choices])
+        # Should have 3 books (2 from Alice and 1 from Alice Smith)
+        self.assertEqual(len(choices), 3)
+        self.assertEqual(len(set(str(c[0]) for c in choices)), 3)  # Should have 3 unique values
\ No newline at end of file
diff --git a/tests/apps.py b/tests/apps.py
new file mode 100644
index 0000000000..b369b0c194
--- /dev/null
+++ b/tests/apps.py
@@ -0,0 +1,6 @@
+from django.apps import AppConfig
+import os
+
+class TestConfig(AppConfig):
+    name = 'tests'
+    path = os.path.dirname(os.path.abspath(__file__))
\ No newline at end of file
diff --git a/tests/test_limit_choices_to.py b/tests/test_limit_choices_to.py
new file mode 100644
index 0000000000..820079eea7
--- /dev/null
+++ b/tests/test_limit_choices_to.py
@@ -0,0 +1,42 @@
+from django.db import models
+from django.forms import ModelForm
+from django.db.models import Q
+from django.test import TestCase
+
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'test_limit_choices_to'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    class Meta:
+        app_label = 'test_limit_choices_to'
+
+class Review(models.Model):
+    book = models.ForeignKey(
+        Book, 
+        on_delete=models.CASCADE,
+        limit_choices_to=Q(author__name__startswith='A')  # This will cause duplicates
+    )
+    text = models.TextField()
+    class Meta:
+        app_label = 'test_limit_choices_to'
+
+class ReviewForm(ModelForm):
+    class Meta:
+        model = Review
+        fields = ['book', 'text']
+
+class LimitChoicesToTest(TestCase):
+    def setUp(self):
+        self.author1 = Author.objects.create(name='Alice')
+        self.book1 = Book.objects.create(title='Book 1', author=self.author1)
+        self.book2 = Book.objects.create(title='Book 2', author=self.author1)
+
+    def test_no_duplicate_choices(self):
+        form = ReviewForm()
+        choices = list(form.fields['book'].choices)[1:]  # Skip empty choice
+        self.assertEqual(len(choices), 2)  # Should have 2 books
+        self.assertEqual(len(set(c[0] for c in choices)), 2)  # Should have 2 unique values
\ No newline at end of file
diff --git a/tests/test_settings.py b/tests/test_settings.py
new file mode 100644
index 0000000000..e6b65d103c
--- /dev/null
+++ b/tests/test_settings.py
@@ -0,0 +1,17 @@
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'django.contrib.auth',
+    'test_app',
+]
+
+SECRET_KEY = 'dummy'
+USE_TZ = False
+DEFAULT_AUTO_FIELD = 'django.db.models.AutoField'
+PASSWORD_HASHERS = ['django.contrib.auth.hashers.MD5PasswordHasher']
\ No newline at end of file
