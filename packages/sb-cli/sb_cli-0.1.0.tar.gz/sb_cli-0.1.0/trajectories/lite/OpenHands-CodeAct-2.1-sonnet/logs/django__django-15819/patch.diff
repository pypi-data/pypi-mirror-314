diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py
index f33bcbdccf..90009fcae8 100644
--- a/django/core/management/commands/inspectdb.py
+++ b/django/core/management/commands/inspectdb.py
@@ -182,6 +182,14 @@ class Command(BaseCommand):
                             if ref_db_table == table_name
                             else table2model(ref_db_table)
                         )
+                        
+                        # Always add related_name for foreign keys to avoid potential clashes
+                        if rel_type == "ForeignKey":
+                            extra_params["related_name"] = "%s_%s_set" % (
+                                table_name.lower(),
+                                att_name.replace("_id", ""),
+                            )
+                        
                         if rel_to in known_models:
                             field_type = "%s(%s" % (rel_type, rel_to)
                         else:
diff --git a/generated_models.py b/generated_models.py
new file mode 100644
index 0000000000..a576adeaa4
--- /dev/null
+++ b/generated_models.py
@@ -0,0 +1,27 @@
+# This is an auto-generated Django model module.
+# You'll have to do the following manually to clean this up:
+#   * Rearrange models' order
+#   * Make sure each model has one field with primary_key=True
+#   * Make sure each ForeignKey and OneToOneField has `on_delete` set to the desired behavior
+#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table
+# Feel free to rename the models, but don't rename db_table values or field names.
+from django.db import models
+
+
+class Child(models.Model):
+    parent1 = models.ForeignKey('Parent', models.DO_NOTHING, blank=True, null=True)
+    parent2 = models.ForeignKey('Parent', models.DO_NOTHING, blank=True, null=True)
+
+    class Meta:
+        app_label = "myapp"
+        managed = False
+        db_table = 'child'
+
+
+class Parent(models.Model):
+    name = models.TextField(blank=True, null=True)
+
+    class Meta:
+        app_label = "myapp"
+        managed = False
+        db_table = 'parent'
diff --git a/myapp/__init__.py b/myapp/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/myapp/apps.py b/myapp/apps.py
new file mode 100644
index 0000000000..b0cf5deea5
--- /dev/null
+++ b/myapp/apps.py
@@ -0,0 +1,4 @@
+from django.apps import AppConfig
+
+class MyAppConfig(AppConfig):
+    name = 'myapp'
\ No newline at end of file
diff --git a/myapp/models.py b/myapp/models.py
new file mode 100644
index 0000000000..8ea5b900c2
--- /dev/null
+++ b/myapp/models.py
@@ -0,0 +1,54 @@
+# This is an auto-generated Django model module.
+# You'll have to do the following manually to clean this up:
+#   * Rearrange models' order
+#   * Make sure each model has one field with primary_key=True
+#   * Make sure each ForeignKey and OneToOneField has `on_delete` set to the desired behavior
+#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table
+# Feel free to rename the models, but don't rename db_table values or field names.
+from django.db import models
+
+
+class Child(models.Model):
+    parent1 = models.ForeignKey('Parent', models.DO_NOTHING, related_name='child_parent1_set', blank=True, null=True)
+    parent2 = models.ForeignKey('Parent', models.DO_NOTHING, related_name='child_parent2_set', blank=True, null=True)
+
+    class Meta:
+        managed = False
+        db_table = 'child'
+
+
+class Employee(models.Model):
+    name = models.TextField(blank=True, null=True)
+    manager = models.ForeignKey('self', models.DO_NOTHING, related_name='employee_manager_set', blank=True, null=True)
+    supervisor = models.ForeignKey('self', models.DO_NOTHING, related_name='employee_supervisor_set', blank=True, null=True)
+
+    class Meta:
+        managed = False
+        db_table = 'employee'
+
+
+class Parent(models.Model):
+    name = models.TextField(blank=True, null=True)
+
+    class Meta:
+        managed = False
+        db_table = 'parent'
+
+
+class Profile(models.Model):
+    bio = models.TextField(blank=True, null=True)
+    user = models.OneToOneField(Parent, models.DO_NOTHING, blank=True, null=True)
+
+    class Meta:
+        managed = False
+        db_table = 'profile'
+
+
+class Student(models.Model):
+    name = models.TextField(blank=True, null=True)
+    advisor = models.ForeignKey(Parent, models.DO_NOTHING, related_name='student_advisor_set', blank=True, null=True)
+    mentor = models.ForeignKey(Employee, models.DO_NOTHING, related_name='student_mentor_set', blank=True, null=True)
+
+    class Meta:
+        managed = False
+        db_table = 'student'
diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..e3313034c0
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,109 @@
+import os
+import sqlite3
+import sys
+
+# Add Django to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Create test database file
+DB_FILE = 'test.db'
+if os.path.exists(DB_FILE):
+    os.remove(DB_FILE)
+
+conn = sqlite3.connect(DB_FILE)
+
+# Create a test app package
+import os
+if not os.path.exists('myapp'):
+    os.makedirs('myapp')
+with open('myapp/__init__.py', 'w') as f:
+    f.write('')
+
+# Set up Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': DB_FILE,
+            }
+        },
+        INSTALLED_APPS=['django.contrib.contenttypes', 'myapp'],
+        MIDDLEWARE=[],
+        SECRET_KEY='dummy',
+    )
+
+import django
+django.setup()
+cursor = conn.cursor()
+
+# Create test tables
+cursor.execute('''
+    CREATE TABLE parent (
+        id INTEGER PRIMARY KEY,
+        name TEXT
+    )
+''')
+
+cursor.execute('''
+    CREATE TABLE child (
+        id INTEGER PRIMARY KEY,
+        parent1_id INTEGER REFERENCES parent(id),
+        parent2_id INTEGER REFERENCES parent(id)
+    )
+''')
+
+cursor.execute('''
+    CREATE TABLE employee (
+        id INTEGER PRIMARY KEY,
+        name TEXT,
+        manager_id INTEGER REFERENCES employee(id),
+        supervisor_id INTEGER REFERENCES employee(id)
+    )
+''')
+
+cursor.execute('''
+    CREATE TABLE student (
+        id INTEGER PRIMARY KEY,
+        name TEXT,
+        advisor_id INTEGER REFERENCES parent(id),
+        mentor_id INTEGER REFERENCES employee(id)
+    )
+''')
+
+cursor.execute('''
+    CREATE TABLE profile (
+        id INTEGER PRIMARY KEY,
+        bio TEXT,
+        user_id INTEGER UNIQUE REFERENCES parent(id)
+    )
+''')
+
+# Commit changes
+conn.commit()
+
+# Run inspectdb and save output to a file
+from io import StringIO
+from django.core.management import call_command
+
+# Capture output
+output = StringIO()
+call_command('inspectdb', stdout=output)
+model_code = output.getvalue()
+print(model_code)
+
+# Save the generated models to models.py in our test app
+with open('myapp/models.py', 'w') as f:
+    f.write(model_code)
+
+# Import the models and try to use them
+from myapp.models import Parent, Child
+
+# Create some test objects
+parent = Parent.objects.create(name="Test Parent")
+child = Child.objects.create(parent1=parent, parent2=parent)
+
+# This should raise a Django system check error about the clashing accessors
+from django.core import management
+management.call_command('check')
\ No newline at end of file
diff --git a/test.db b/test.db
new file mode 100644
index 0000000000..d349156e70
Binary files /dev/null and b/test.db differ
