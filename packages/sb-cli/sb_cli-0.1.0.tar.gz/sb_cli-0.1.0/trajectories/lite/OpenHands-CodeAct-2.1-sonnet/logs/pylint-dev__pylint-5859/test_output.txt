+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   pylint/checkers/misc.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	test.py
	test_edge.py
	test_edge2.py

no changes added to commit (use "git add" and/or "git commit -a")
+ git show
commit 182cc539b8154c0710fcea7e522267e42eba8899
Author: Tim Martin <tim@asymptotic.co.uk>
Date:   Wed Mar 2 21:58:26 2022 +0000

    Use value directly instead of index in ``enumerate`` contexts (#5856)
    
    Refactoring to prevent warnings being issued on these lines from a new proposed
    checker.

diff --git a/pylint/checkers/__init__.py b/pylint/checkers/__init__.py
index a79a38194..ab23b6b59 100644
--- a/pylint/checkers/__init__.py
+++ b/pylint/checkers/__init__.py
@@ -124,8 +124,8 @@ def table_lines_from_stats(
                 ("error", "NC"),
             ]
 
-    for index, _ in enumerate(new):
-        new_value = new[index][1]
+    for index, value in enumerate(new):
+        new_value = value[1]
         old_value = old[index][1]
         diff_str = (
             diff_string(old_value, new_value)
@@ -134,7 +134,7 @@ def table_lines_from_stats(
         )
         new_str = f"{new_value:.3f}" if isinstance(new_value, float) else str(new_value)
         old_str = f"{old_value:.3f}" if isinstance(old_value, float) else str(old_value)
-        lines.extend((new[index][0].replace("_", " "), new_str, old_str, diff_str))
+        lines.extend((value[0].replace("_", " "), new_str, old_str, diff_str))
     return lines
 
 
diff --git a/pylint/checkers/refactoring/refactoring_checker.py b/pylint/checkers/refactoring/refactoring_checker.py
index 1bf75e77e..b727f1b63 100644
--- a/pylint/checkers/refactoring/refactoring_checker.py
+++ b/pylint/checkers/refactoring/refactoring_checker.py
@@ -578,12 +578,12 @@ class RefactoringChecker(checkers.BaseTokenChecker):
             token_string = token[1]
             if token_string == "elif":
                 # AST exists by the time process_tokens is called, so
-                # it's safe to assume tokens[index+1]
-                # exists. tokens[index+1][2] is the elif's position as
+                # it's safe to assume tokens[index+1] exists.
+                # tokens[index+1][2] is the elif's position as
                 # reported by CPython and PyPy,
-                # tokens[index][2] is the actual position and also is
+                # token[2] is the actual position and also is
                 # reported by IronPython.
-                self._elifs.extend([tokens[index][2], tokens[index + 1][2]])
+                self._elifs.extend([token[2], tokens[index + 1][2]])
             elif _is_trailing_comma(tokens, index):
                 if self.linter.is_message_enabled("trailing-comma-tuple"):
                     self.add_message("trailing-comma-tuple", line=token.start[0])
+ git diff 182cc539b8154c0710fcea7e522267e42eba8899
diff --git a/pylint/checkers/misc.py b/pylint/checkers/misc.py
index 69149e61a..79c7d2f60 100644
--- a/pylint/checkers/misc.py
+++ b/pylint/checkers/misc.py
@@ -28,6 +28,7 @@
 """Check source code is ascii only or has an encoding declaration (PEP 263)."""
 
 import re
+import string
 import tokenize
 from typing import TYPE_CHECKING, List, Optional
 
@@ -119,13 +120,64 @@ class EncodingChecker(BaseChecker):
     def open(self):
         super().open()
 
-        notes = "|".join(re.escape(note) for note in self.config.notes)
+        # Store original notes for later use
+        self._notes = [note.strip() for note in self.config.notes]
+        
+        # Split notes into punctuation-only and regular notes
+        punct_notes = []
+        regular_notes = []
+        for note in self.config.notes:
+            note = note.strip()
+            if all(c in string.punctuation for c in note):
+                punct_notes.append(note)
+            else:
+                regular_notes.append(note)
+                
+        # Create pattern parts
+        patterns = []
+        if punct_notes:
+            # Case-sensitive for punctuation-only notes
+            patterns.append("|".join(re.escape(note) for note in punct_notes))
+        if regular_notes:
+            # Case-insensitive for regular notes
+            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
+            
+        # Combine patterns
+        notes = "|".join(patterns)
         if self.config.notes_rgx:
-            regex_string = rf"#\s*({notes}|{self.config.notes_rgx})\b"
+            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
         else:
-            regex_string = rf"#\s*({notes})\b"
+            regex_string = rf"#\s*(?:{notes})\b"
 
-        self._fixme_pattern = re.compile(regex_string, re.I)
+        self._fixme_pattern = re.compile(regex_string)
+        
+        # Store note sets for later use
+        self._punct_notes = set(punct_notes)
+        self._regular_notes = set(regular_notes)
+        
+        # Debug info
+        print(f"Regex pattern: {regex_string}")
+        print(f"Punct notes: {punct_notes}")
+        print(f"Regular notes: {regular_notes}")
+        
+        # Create separate patterns for testing
+        if punct_notes:
+            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
+        else:
+            self._punct_pattern = None
+            
+        if regular_notes:
+            self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
+        else:
+            self._regular_pattern = None
+            
+        # Debug info
+        print(f"Punct pattern: {self._punct_pattern.pattern if self._punct_pattern else None}")
+        print(f"Regular pattern: {self._regular_pattern.pattern if self._regular_pattern else None}")
+        
+        # Store original notes for exact matching
+        self._punct_notes = set(punct_notes)
+        self._regular_notes = set(regular_notes)
 
     def _check_encoding(
         self, lineno: int, line: bytes, file_encoding: str
@@ -188,14 +240,29 @@ class EncodingChecker(BaseChecker):
                     continue
 
             # emit warnings if necessary
-            match = self._fixme_pattern.search("#" + comment_text.lower())
-            if match:
-                self.add_message(
-                    "fixme",
-                    col_offset=comment.start[1] + 1,
-                    args=comment_text,
-                    line=comment.start[0],
-                )
+            comment_with_hash = "#" + comment_text
+            
+            # Extract the note tag (part before colon)
+            note_tag = comment_text.split(':', 1)[0].strip()
+            
+            # For punctuation-only notes, try exact match
+            if all(c in string.punctuation for c in note_tag):
+                if note_tag in self._punct_notes:
+                    self.add_message(
+                        "fixme",
+                        col_offset=comment.start[1] + 1,
+                        args=comment_text,
+                        line=comment.start[0],
+                    )
+            # For regular notes, try case-insensitive match
+            else:
+                if note_tag.upper() in (n.upper() for n in self._regular_notes):
+                    self.add_message(
+                        "fixme",
+                        col_offset=comment.start[1] + 1,
+                        args=comment_text,
+                        line=comment.start[0],
+                    )
 
 
 def register(linter: "PyLinter") -> None:
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Preparing metadata (setup.py): started
  Preparing metadata (setup.py): finished with status 'done'
Requirement already satisfied: dill>=0.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pylint==2.13.0.dev0) (0.3.9)
Requirement already satisfied: platformdirs>=2.2.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pylint==2.13.0.dev0) (4.3.6)
Requirement already satisfied: astroid<=2.10.0-dev0,>=2.9.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pylint==2.13.0.dev0) (2.9.3)
Requirement already satisfied: isort<6,>=4.2.5 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pylint==2.13.0.dev0) (5.10.1)
Requirement already satisfied: mccabe<0.7,>=0.6 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pylint==2.13.0.dev0) (0.6.1)
Requirement already satisfied: toml>=0.9.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pylint==2.13.0.dev0) (0.10.2)
Requirement already satisfied: typing-extensions>=3.10.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pylint==2.13.0.dev0) (4.12.2)
Requirement already satisfied: lazy-object-proxy>=1.4.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from astroid<=2.10.0-dev0,>=2.9.2->pylint==2.13.0.dev0) (1.10.0)
Requirement already satisfied: wrapt<1.14,>=1.11 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from astroid<=2.10.0-dev0,>=2.9.2->pylint==2.13.0.dev0) (1.13.3)
Requirement already satisfied: setuptools>=20.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from astroid<=2.10.0-dev0,>=2.9.2->pylint==2.13.0.dev0) (75.1.0)
Installing collected packages: pylint
  Attempting uninstall: pylint
    Found existing installation: pylint 2.13.0.dev0
    Uninstalling pylint-2.13.0.dev0:
      Successfully uninstalled pylint-2.13.0.dev0
  DEPRECATION: Legacy editable install of pylint==2.13.0.dev0 from file:///testbed (setup.py develop) is deprecated. pip 25.0 will enforce this behaviour change. A possible replacement is to add a pyproject.toml or enable --use-pep517, and use setuptools >= 64. If the resulting installation is not behaving as expected, try using --config-settings editable_mode=compat. Please consult the setuptools documentation for more information. Discussion can be found at https://github.com/pypa/pip/issues/11457
  Running setup.py develop for pylint
Successfully installed pylint
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git checkout 182cc539b8154c0710fcea7e522267e42eba8899 tests/checkers/unittest_misc.py
Updated 0 paths from d012e00b3
+ git apply -v -
Checking patch tests/checkers/unittest_misc.py...
Applied patch tests/checkers/unittest_misc.py cleanly.
+ pytest -rA tests/checkers/unittest_misc.py
============================= test session starts ==============================
platform linux -- Python 3.9.20, pytest-7.4.4, pluggy-1.5.0
benchmark: 3.4.1 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /testbed
configfile: setup.cfg
plugins: forked-1.6.0, profiling-1.7.0, benchmark-3.4.1, cov-3.0.0, timeout-2.3.1, xdist-2.5.0
collected 11 items

tests/checkers/unittest_misc.py EEEEEEEEEEE                              [100%]

==================================== ERRORS ====================================
_____________ ERROR at setup of TestFixme.test_fixme_with_message ______________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385c40>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
____________ ERROR at setup of TestFixme.test_todo_without_message _____________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385fa0>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
______________ ERROR at setup of TestFixme.test_xxx_without_space ______________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385430>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
_________________ ERROR at setup of TestFixme.test_xxx_middle __________________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385160>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
_____________ ERROR at setup of TestFixme.test_without_space_fixme _____________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a533855e0>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
__________ ERROR at setup of TestFixme.test_non_alphanumeric_codetag ___________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385700>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
_______________ ERROR at setup of TestFixme.test_absent_codetag ________________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385550>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
____________ ERROR at setup of TestFixme.test_other_present_codetag ____________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385ac0>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
________ ERROR at setup of TestFixme.test_issue_2321_should_not_trigger ________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a533858b0>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
__________ ERROR at setup of TestFixme.test_issue_2321_should_trigger __________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53385880>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
___________ ERROR at setup of TestFixme.test_dont_trigger_on_todoist ___________

self = <checkers.unittest_misc.TestFixme object at 0x7f6a53394670>

    def setup_method(self):
        self.linter = UnittestLinter()
        self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
        for key, value in self.CONFIG.items():
            setattr(self.checker.config, key, value)
>       self.checker.open()

pylint/testutils/checker_test_case.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Checker 'miscellaneous' (responsible for 'W0511')

    def open(self):
        super().open()
    
        # Store original notes for later use
        self._notes = [note.strip() for note in self.config.notes]
    
        # Split notes into punctuation-only and regular notes
        punct_notes = []
        regular_notes = []
        for note in self.config.notes:
            note = note.strip()
            if all(c in string.punctuation for c in note):
                punct_notes.append(note)
            else:
                regular_notes.append(note)
    
        # Create pattern parts
        patterns = []
        if punct_notes:
            # Case-sensitive for punctuation-only notes
            patterns.append("|".join(re.escape(note) for note in punct_notes))
        if regular_notes:
            # Case-insensitive for regular notes
            patterns.append("(?i:" + "|".join(re.escape(note) for note in regular_notes) + ")")
    
        # Combine patterns
        notes = "|".join(patterns)
        if self.config.notes_rgx:
            regex_string = rf"#\s*(?:{notes}|{self.config.notes_rgx})\b"
        else:
            regex_string = rf"#\s*(?:{notes})\b"
    
        self._fixme_pattern = re.compile(regex_string)
    
        # Store note sets for later use
        self._punct_notes = set(punct_notes)
        self._regular_notes = set(regular_notes)
    
        # Debug info
        print(f"Regex pattern: {regex_string}")
        print(f"Punct notes: {punct_notes}")
        print(f"Regular notes: {regular_notes}")
    
        # Create separate patterns for testing
        if punct_notes:
            self._punct_pattern = re.compile(rf"#\s*({patterns[0]})\b")
        else:
            self._punct_pattern = None
    
        if regular_notes:
>           self._regular_pattern = re.compile(rf"#\s*({patterns[1]})\b", re.I)
E           IndexError: list index out of range

pylint/checkers/misc.py:170: IndexError
---------------------------- Captured stdout setup -----------------------------
Regex pattern: #\s*(?:(?i:FIXME|XXX|TODO))\b
Punct notes: []
Regular notes: ['FIXME', 'XXX', 'TODO']
=============================== warnings summary ===============================
../opt/miniconda3/envs/testbed/lib/python3.9/site-packages/astroid/interpreter/_import/util.py:7
  /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/astroid/interpreter/_import/util.py:7: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    import pkg_resources

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/checkers/unittest_misc.py::TestFixme::test_fixme_with_message - I...
ERROR tests/checkers/unittest_misc.py::TestFixme::test_todo_without_message
ERROR tests/checkers/unittest_misc.py::TestFixme::test_xxx_without_space - In...
ERROR tests/checkers/unittest_misc.py::TestFixme::test_xxx_middle - IndexErro...
ERROR tests/checkers/unittest_misc.py::TestFixme::test_without_space_fixme - ...
ERROR tests/checkers/unittest_misc.py::TestFixme::test_non_alphanumeric_codetag
ERROR tests/checkers/unittest_misc.py::TestFixme::test_absent_codetag - Index...
ERROR tests/checkers/unittest_misc.py::TestFixme::test_other_present_codetag
ERROR tests/checkers/unittest_misc.py::TestFixme::test_issue_2321_should_not_trigger
ERROR tests/checkers/unittest_misc.py::TestFixme::test_issue_2321_should_trigger
ERROR tests/checkers/unittest_misc.py::TestFixme::test_dont_trigger_on_todoist
======================== 1 warning, 11 errors in 0.21s =========================
+ git checkout 182cc539b8154c0710fcea7e522267e42eba8899 tests/checkers/unittest_misc.py
Updated 1 path from d012e00b3
