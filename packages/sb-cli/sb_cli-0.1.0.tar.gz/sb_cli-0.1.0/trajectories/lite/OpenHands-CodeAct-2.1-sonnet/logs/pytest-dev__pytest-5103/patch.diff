diff --git a/src/_pytest/assertion/all_any.py b/src/_pytest/assertion/all_any.py
new file mode 100644
index 000000000..14fab075a
--- /dev/null
+++ b/src/_pytest/assertion/all_any.py
@@ -0,0 +1,96 @@
+"""Assertion rewriting for all() and any() calls."""
+import ast
+import inspect
+
+def rewrite_all_any_assert(assert_node):
+    """Rewrite an assertion containing all() or any() to provide better error messages."""
+    if not isinstance(assert_node.test, ast.Call):
+        return None
+    if not isinstance(assert_node.test.func, ast.Name):
+        return None
+    if assert_node.test.func.id not in ('all', 'any'):
+        return None
+    if len(assert_node.test.args) != 1:
+        return None
+    
+    # Get the iterator argument
+    iter_arg = assert_node.test.args[0]
+    if not isinstance(iter_arg, ast.GeneratorExp):
+        return None
+    
+    # For generator expressions, materialize the list first
+    list_call = ast.Call(
+        func=ast.Name(id='list', ctx=ast.Load()),
+        args=[iter_arg],
+        keywords=[]
+    )
+    
+    # Create a variable to store the list
+    list_var = ast.Name(id='_pytest_all_any_list', ctx=ast.Store())
+    list_assign = ast.Assign(targets=[list_var], value=list_call)
+    
+    # Create a loop to check each item
+    loop_var = ast.Name(id='_pytest_all_any_item', ctx=ast.Store())
+    loop_body = []
+    
+    # Create the test condition based on whether it's all() or any()
+    is_all = assert_node.test.func.id == 'all'
+    if is_all:
+        # For all(), we want to fail on the first False
+        test = ast.If(
+            test=ast.UnaryOp(
+                op=ast.Not(),
+                operand=ast.Name(id='_pytest_all_any_item', ctx=ast.Load())
+            ),
+            body=[
+                ast.Raise(
+                    exc=ast.Call(
+                        func=ast.Name(id='AssertionError', ctx=ast.Load()),
+                        args=[
+                            ast.BinOp(
+                                left=ast.Str(s='assert all(...) - failed at item: '),
+                                op=ast.Add(),
+                                right=ast.Call(
+                                    func=ast.Name(id='str', ctx=ast.Load()),
+                                    args=[ast.Name(id='_pytest_all_any_item', ctx=ast.Load())],
+                                    keywords=[]
+                                )
+                            )
+                        ],
+                        keywords=[]
+                    ),
+                    cause=None
+                )
+            ],
+            orelse=[]
+        )
+    else:
+        # For any(), we want to succeed on the first True
+        test = ast.If(
+            test=ast.Name(id='_pytest_all_any_item', ctx=ast.Load()),
+            body=[ast.Return(value=None)],
+            orelse=[]
+        )
+    
+    loop_body.append(test)
+    loop = ast.For(
+        target=loop_var,
+        iter=ast.Name(id='_pytest_all_any_list', ctx=ast.Load()),
+        body=loop_body,
+        orelse=[]
+    )
+    
+    # For any(), if we get here it means no item was True
+    if not is_all:
+        loop.orelse = [
+            ast.Raise(
+                exc=ast.Call(
+                    func=ast.Name(id='AssertionError', ctx=ast.Load()),
+                    args=[ast.Str(s='assert any(...) - no items were true')],
+                    keywords=[]
+                ),
+                cause=None
+            )
+        ]
+    
+    return [list_assign, loop]
\ No newline at end of file
diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py
index 2903b8995..748bb3d9d 100644
--- a/src/_pytest/assertion/rewrite.py
+++ b/src/_pytest/assertion/rewrite.py
@@ -19,6 +19,8 @@ import atomicwrites
 import py
 import six
 
+from _pytest.assertion.all_any import rewrite_all_any_assert
+
 from _pytest._io.saferepr import saferepr
 from _pytest.assertion import util
 from _pytest.assertion.util import (  # noqa: F401
@@ -819,7 +821,91 @@ class AssertionRewriter(ast.NodeVisitor):
         raises an assertion error with a detailed explanation in case
         the expression is false.
 
+        Special handling is done for all() and any() calls to provide better error messages.
         """
+        # Special handling for all() and any() calls
+        if isinstance(assert_.test, ast.Call) and isinstance(assert_.test.func, ast.Name):
+            if assert_.test.func.id in ('all', 'any'):
+                if len(assert_.test.args) == 1:
+                    # Get the iterator argument
+                    iter_arg = assert_.test.args[0]
+                    if isinstance(iter_arg, ast.GeneratorExp):
+                        # For generator expressions, materialize the list first
+                        list_call = ast.Call(
+                            func=ast.Name(id='list', ctx=ast.Load()),
+                            args=[iter_arg],
+                            keywords=[]
+                        )
+                        list_var = self.variable()
+                        self.statements.append(
+                            ast.Assign([ast.Name(id=list_var, ctx=ast.Store())], list_call)
+                        )
+                        # Create a loop to check each item
+                        loop_var = self.variable()
+                        loop_body = []
+                        
+                        # Create the test condition based on whether it's all() or any()
+                        is_all = assert_.test.func.id == 'all'
+                        if is_all:
+                            # For all(), we want to fail on the first False
+                            test = ast.If(
+                                test=ast.UnaryOp(
+                                    op=ast.Not(),
+                                    operand=ast.Name(id=loop_var, ctx=ast.Load())
+                                ),
+                                body=[
+                                    ast.Raise(
+                                        exc=ast.Call(
+                                            func=ast.Name(id='AssertionError', ctx=ast.Load()),
+                                            args=[
+                                                ast.BinOp(
+                                                    left=ast.Str(s='assert all(...) - failed at item: '),
+                                                    op=ast.Add(),
+                                                    right=ast.Call(
+                                                        func=ast.Name(id='str', ctx=ast.Load()),
+                                                        args=[ast.Name(id=loop_var, ctx=ast.Load())],
+                                                        keywords=[]
+                                                    )
+                                                )
+                                            ],
+                                            keywords=[]
+                                        ),
+                                        cause=None
+                                    )
+                                ],
+                                orelse=[]
+                            )
+                        else:
+                            # For any(), we want to succeed on the first True
+                            test = ast.If(
+                                test=ast.Name(id=loop_var, ctx=ast.Load()),
+                                body=[ast.Return(value=None)],
+                                orelse=[]
+                            )
+
+                        loop_body.append(test)
+                        loop = ast.For(
+                            target=ast.Name(id=loop_var, ctx=ast.Store()),
+                            iter=ast.Name(id=list_var, ctx=ast.Load()),
+                            body=loop_body,
+                            orelse=[]
+                        )
+                        self.statements.append(loop)
+
+                        if not is_all:
+                            # For any(), if we get here it means no item was True
+                            self.statements.append(
+                                ast.Raise(
+                                    exc=ast.Call(
+                                        func=ast.Name(id='AssertionError', ctx=ast.Load()),
+                                        args=[ast.Str(s='assert any(...) - no items were true')],
+                                        keywords=[]
+                                    ),
+                                    cause=None
+                                )
+                            )
+
+                        return
         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
             from _pytest.warning_types import PytestAssertRewriteWarning
             import warnings
@@ -839,7 +925,94 @@ class AssertionRewriter(ast.NodeVisitor):
         self.stack = []
         self.on_failure = []
         self.push_format_context()
-        # Rewrite assert into a bunch of statements.
+        # Special handling for all() and any() calls
+        from _pytest.assertion.util import is_all_any_call
+        if is_all_any_call(assert_.test):
+            call = assert_.test
+            if len(call.args) != 1:
+                # Not a valid all/any call, fall back to normal handling
+                top_condition, explanation = self.visit(assert_.test)
+            else:
+                # Get the iterator argument
+                iter_arg = call.args[0]
+                if isinstance(iter_arg, ast.GeneratorExp):
+                    # For generator expressions, we need to create a list to avoid consuming it
+                    list_call = ast.Call(
+                        func=ast.Name(id='list', ctx=ast.Load()),
+                        args=[iter_arg],
+                        keywords=[]
+                    )
+                    iter_var = self.variable()
+                    self.statements.append(
+                        ast.Assign([ast.Name(id=iter_var, ctx=ast.Store())], list_call)
+                    )
+                else:
+                    # For other iterables (lists, etc.), use them directly
+                    iter_var = self.variable()
+                    self.statements.append(
+                        ast.Assign([ast.Name(id=iter_var, ctx=ast.Store())], iter_arg)
+                    )
+
+                # Create a loop to check each item
+                loop_var = self.variable()
+                loop_body = []
+
+                # Create the test condition based on whether it's all() or any()
+                is_all = call.func.id == 'all'
+                if is_all:
+                    # For all(), we want to fail on the first False
+                    test = ast.If(
+                        test=ast.UnaryOp(
+                            op=ast.Not(),
+                            operand=ast.Name(id=loop_var, ctx=ast.Load())
+                        ),
+                        body=[
+                            ast.Raise(
+                                exc=ast.Call(
+                                    func=ast.Name(id='AssertionError', ctx=ast.Load()),
+                                    args=[
+                                        ast.Str(s='assert all(...) - failed at item: {}'.format(loop_var))
+                                    ],
+                                    keywords=[]
+                                ),
+                                cause=None
+                            )
+                        ],
+                        orelse=[]
+                    )
+                else:
+                    # For any(), we want to succeed on the first True
+                    test = ast.If(
+                        test=ast.Name(id=loop_var, ctx=ast.Load()),
+                        body=[ast.Return(value=None)],
+                        orelse=[]
+                    )
+
+                loop_body.append(test)
+                loop = ast.For(
+                    target=ast.Name(id=loop_var, ctx=ast.Store()),
+                    iter=ast.Name(id=iter_var, ctx=ast.Load()),
+                    body=loop_body,
+                    orelse=[]
+                )
+                self.statements.append(loop)
+
+                if not is_all:
+                    # For any(), if we get here it means no item was True
+                    self.statements.append(
+                        ast.Raise(
+                            exc=ast.Call(
+                                func=ast.Name(id='AssertionError', ctx=ast.Load()),
+                                args=[ast.Str(s='assert any(...) - no items were true')],
+                                keywords=[]
+                            ),
+                            cause=None
+                        )
+                    )
+
+                return
+
+        # Normal assertion handling
         top_condition, explanation = self.visit(assert_.test)
         # If in a test module, check if directly asserting None, in order to warn [Issue #3191]
         if self.module_path is not None:
@@ -969,6 +1142,34 @@ warn_explicit(
         visit `ast.Call` nodes on Python3.5 and after
         """
         new_func, func_expl = self.visit(call.func)
+        
+        # Special handling for all() and any() calls
+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):
+            if len(call.args) == 1:
+                # Get the iterator argument
+                iter_arg = call.args[0]
+                if isinstance(iter_arg, ast.GeneratorExp):
+                    # For generator expressions, materialize the list first
+                    list_call = ast.Call(
+                        func=ast.Name(id='list', ctx=ast.Load()),
+                        args=[iter_arg],
+                        keywords=[]
+                    )
+                    list_var = self.assign(list_call)
+                    # Create a new call with the list instead of generator
+                    new_call = ast.Call(
+                        func=new_func,
+                        args=[ast.Name(id=list_var, ctx=ast.Load())],
+                        keywords=[]
+                    )
+                    res = self.assign(new_call)
+                    # Add the list contents to the explanation
+                    list_expl = self.explanation_param(self.display(ast.Name(id=list_var, ctx=ast.Load())))
+                    res_expl = self.explanation_param(self.display(res))
+                    outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, list_expl)
+                    return res, outer_expl
+
+        # Normal call handling
         arg_expls = []
         new_args = []
         new_kwargs = []
@@ -988,6 +1189,18 @@ warn_explicit(
         new_call = ast.Call(new_func, new_args, new_kwargs)
         res = self.assign(new_call)
         res_expl = self.explanation_param(self.display(res))
+        
+        # Special handling for all() and any() calls - add more detail to the explanation
+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):
+            if len(call.args) == 1:
+                # Get the iterator argument
+                iter_arg = call.args[0]
+                if isinstance(iter_arg, ast.GeneratorExp):
+                    # Add the list contents to the explanation
+                    list_expl = self.explanation_param(self.display(ast.Name(id=res, ctx=ast.Load())))
+                    outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, list_expl)
+                    return res, outer_expl
+        
         outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, expl)
         return res, outer_expl
 
@@ -1002,6 +1215,34 @@ warn_explicit(
         visit `ast.Call nodes on 3.4 and below`
         """
         new_func, func_expl = self.visit(call.func)
+        
+        # Special handling for all() and any() calls
+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):
+            if len(call.args) == 1:
+                # Get the iterator argument
+                iter_arg = call.args[0]
+                if isinstance(iter_arg, ast.GeneratorExp):
+                    # For generator expressions, materialize the list first
+                    list_call = ast.Call(
+                        func=ast.Name(id='list', ctx=ast.Load()),
+                        args=[iter_arg],
+                        keywords=[]
+                    )
+                    list_var = self.assign(list_call)
+                    # Create a new call with the list instead of generator
+                    new_call = ast.Call(
+                        func=new_func,
+                        args=[ast.Name(id=list_var, ctx=ast.Load())],
+                        keywords=[]
+                    )
+                    res = self.assign(new_call)
+                    # Add the list contents to the explanation
+                    list_expl = self.explanation_param(self.display(ast.Name(id=list_var, ctx=ast.Load())))
+                    res_expl = self.explanation_param(self.display(res))
+                    outer_expl = "%s\n{%s = %s(%s)\n}" % (res_expl, res_expl, func_expl, list_expl)
+                    return res, outer_expl
+
+        # Normal call handling
         arg_expls = []
         new_args = []
         new_kwargs = []
@@ -1024,6 +1265,27 @@ warn_explicit(
         new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)
         res = self.assign(new_call)
         res_expl = self.explanation_param(self.display(res))
+        
+        # Special handling for all() and any() calls - add more detail to the explanation
+        if isinstance(call.func, ast.Name) and call.func.id in ('all', 'any'):
+            if len(call.args) == 1:
+                # Get the iterator argument
+                iter_arg = call.args[0]
+                if isinstance(iter_arg, ast.GeneratorExp):
+                    # Add the list contents to the explanation
+                    list_expl = self.explanation_param(self.display(ast.Name(id=res, ctx=ast.Load())))
+                    outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, list_expl)
+                    return res, outer_expl
+        
+        outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, expl)
+        return res, outer_expl
+        if call.kwargs:
+            new_kwarg, expl = self.visit(call.kwargs)
+            arg_expls.append("**" + expl)
+        expl = "%s(%s)" % (func_expl, ", ".join(arg_expls))
+        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)
+        res = self.assign(new_call)
+        res_expl = self.explanation_param(self.display(res))
         outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, expl)
         return res, outer_expl
 
diff --git a/src/_pytest/assertion/util.py b/src/_pytest/assertion/util.py
index b53646859..5305a01c9 100644
--- a/src/_pytest/assertion/util.py
+++ b/src/_pytest/assertion/util.py
@@ -3,7 +3,9 @@ from __future__ import absolute_import
 from __future__ import division
 from __future__ import print_function
 
+import ast
 import pprint
+import sys
 
 import six
 
@@ -135,8 +137,49 @@ def isiterable(obj):
         return False
 
 
+def is_all_any_call(node):
+    """Return whether the AST node is a call to all() or any()."""
+    if not isinstance(node, ast.Call):
+        return False
+    if not isinstance(node.func, ast.Name):
+        return False
+    return node.func.id in ('all', 'any')
+
+
 def assertrepr_compare(config, op, left, right):
     """Return specialised explanations for some operators/operands"""
+    # Special handling for all() and any() calls
+    if op == "==" and isinstance(right, bool) and isinstance(left, bool):
+        # Check if this is from an all() or any() call
+        frame = sys._getframe(1)
+        while frame:
+            if frame.f_code.co_name == "visit_Assert":
+                # Found the assertion frame
+                test_expr = frame.f_locals.get("assert_", None)
+                if test_expr and hasattr(test_expr, "test"):
+                    test = test_expr.test
+                    if isinstance(test, ast.Call) and isinstance(test.func, ast.Name):
+                        if test.func.id in ("all", "any") and len(test.args) == 1:
+                            # This is an all() or any() call
+                            arg = test.args[0]
+                            if isinstance(arg, ast.GeneratorExp):
+                                # Convert generator to list for better error message
+                                gen = eval(compile(ast.Expression(arg), "<string>", "eval"), frame.f_globals, frame.f_locals)
+                                values = list(gen)
+                                if test.func.id == "all":
+                                    failed = [v for v in values if not v]
+                                    if failed:
+                                        return [
+                                            "assert all(...) - the following values were false:",
+                                            *[saferepr(v) for v in failed]
+                                        ]
+                                else:  # any()
+                                    if not any(values):
+                                        return [
+                                            "assert any(...) - all values were false:",
+                                            *[saferepr(v) for v in values]
+                                        ]
+            frame = frame.f_back
     width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op
     left_repr = saferepr(left, maxsize=int(width // 2))
     right_repr = saferepr(right, maxsize=width - len(left_repr))
diff --git a/test_all_any.py b/test_all_any.py
new file mode 100644
index 000000000..2e6e50548
--- /dev/null
+++ b/test_all_any.py
@@ -0,0 +1,10 @@
+def is_even(n):
+    return n % 2 == 0
+
+def test_all_even():
+    even_stevens = list(range(1,100,2))
+    assert all(is_even(number) for number in even_stevens)
+
+if __name__ == '__main__':
+    import pytest
+    pytest.main([__file__])
\ No newline at end of file
