diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..58d88fd618
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,38 @@
+from sympy import symbols
+from sympy.core.symbol import Symbol
+
+def test_substitution():
+    # Test case 1: Original case
+    a, b = symbols('a,b')
+    r = (1/(a+b) + 1/(a-b))/(1/(a+b) - 1/(a-b))
+    print("Test case 1:")
+    print("Original expression:", r)
+    print("After substitution b->a:", r.subs(b,a))
+    print("Limit as b->a:", r.limit(b,a))
+    print()
+
+    # Test case 2: More complex expression with same issue
+    r2 = (1/(a+b)**2 + 1/(a-b)**2)/(1/(a+b)**2 - 1/(a-b)**2)
+    print("Test case 2:")
+    print("Original expression:", r2)
+    print("After substitution b->a:", r2.subs(b,a))
+    print("Limit as b->a:", r2.limit(b,a))
+    print()
+
+    # Test case 3: Expression that should not be affected
+    r3 = (a + b)/(a - b)
+    print("Test case 3:")
+    print("Original expression:", r3)
+    print("After substitution b->2:", r3.subs(b,2))
+    print()
+
+    # Test case 4: Another undefined case
+    x, y = symbols('x,y')
+    r4 = (x**2 - y**2)/(x - y)
+    print("Test case 4:")
+    print("Original expression:", r4)
+    print("After substitution y->x:", r4.subs(y,x))
+    print("Limit as y->x:", r4.limit(y,x))
+
+if __name__ == "__main__":
+    test_substitution()
\ No newline at end of file
diff --git a/sympy/core/basic.py b/sympy/core/basic.py
index d4ca323e0d..cdaecbc34b 100644
--- a/sympy/core/basic.py
+++ b/sympy/core/basic.py
@@ -922,6 +922,29 @@ def subs(self, *args, **kwargs):
                     break
             return rv
 
+    def _is_potentially_undefined(self, old, new):
+        """Check if substituting old -> new would lead to an undefined expression.
+        
+        Returns True if the substitution would lead to a 0/0 form.
+        """
+        from sympy import Add, Mul, Pow, S
+        if not isinstance(self, (Add, Mul, Pow)):
+            return False
+            
+        # Get numerator and denominator
+        n, d = self.as_numer_denom()
+        
+        # Create a dict for substitution
+        subs_dict = {old: new}
+        
+        # Try to evaluate if numerator and denominator would be zero
+        try:
+            n_eval = n.subs(subs_dict)
+            d_eval = d.subs(subs_dict)
+            return n_eval.is_zero and d_eval.is_zero
+        except:
+            return False
+
     @cacheit
     def _subs(self, old, new, **hints):
         """Substitutes an expression old -> new.
@@ -932,6 +955,9 @@ def _subs(self, old, new, **hints):
         should be applied wherein a search for replacements is made
         amongst the arguments of self.
 
+        If the substitution would lead to an undefined expression (0/0),
+        returns the limit of the expression as old approaches new.
+
         >>> from sympy import Add
         >>> from sympy.abc import x, y, z
 
@@ -1029,6 +1055,17 @@ def fallback(self, old, new):
         if _aresame(self, old):
             return new
 
+        # Check if substitution would lead to undefined expression
+        if self._is_potentially_undefined(old, new):
+            from sympy import limit
+            # Calculate limit directly
+            try:
+                result = limit(self, old, new)
+                if result is not None:
+                    return result
+            except:
+                pass
+
         rv = self._eval_subs(old, new)
         if rv is None:
             rv = fallback(self, old, new)
