diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index dddf7c679c..a2b572db64 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -745,6 +745,10 @@ class AddIndex(IndexOperation):
                 "argument. %r doesn't have one." % index
             )
         self.index = index
+        
+    def references_order_with_respect_to(self):
+        """Check if this index references the _order field."""
+        return any(field_name == '_order' for field_name, _ in self.index.fields_orders)
 
     def state_forwards(self, app_label, state):
         model_state = state.models[app_label, self.model_name_lower]
diff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py
index ee20f62af2..8cc839634d 100644
--- a/django/db/migrations/optimizer.py
+++ b/django/db/migrations/optimizer.py
@@ -1,3 +1,5 @@
+from django.db.migrations.operations.models import AlterOrderWithRespectTo
+
 class MigrationOptimizer:
     """
     Power the optimization process, where you provide a list of Operations
@@ -42,6 +44,22 @@ class MigrationOptimizer:
         new_operations = []
         for i, operation in enumerate(operations):
             right = True  # Should we reduce on the right or on the left.
+            
+            # Special handling for AddIndex operations that reference _order field
+            if (hasattr(operation, 'references_order_with_respect_to') and 
+                operation.references_order_with_respect_to()):
+                # Look for AlterOrderWithRespectTo operations that should come before this index
+                found_alter = False
+                for j, other in enumerate(operations[i + 1:]):
+                    if (isinstance(other, AlterOrderWithRespectTo) and 
+                        other.name_lower == operation.model_name_lower):
+                        # Move the AlterOrderWithRespectTo before the AddIndex
+                        new_operations.extend(operations[i + 1:i + j + 1])
+                        new_operations.append(other)
+                        new_operations.append(operation)
+                        new_operations.extend(operations[i + j + 2:])
+                        return new_operations
+                
             # Compare it to each operation after it
             for j, other in enumerate(operations[i + 1:]):
                 result = operation.reduce(other, app_label)
