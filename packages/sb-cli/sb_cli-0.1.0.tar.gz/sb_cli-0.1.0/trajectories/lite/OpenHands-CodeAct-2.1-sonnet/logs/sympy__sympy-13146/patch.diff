diff --git a/edge_cases.py b/edge_cases.py
new file mode 100644
index 0000000000..47d96b356c
--- /dev/null
+++ b/edge_cases.py
@@ -0,0 +1,33 @@
+import sympy
+from sympy import *
+x = Symbol('x')
+
+# Test case 1: Negative base with floating-point exponent
+expr1 = (-x)**2.5
+expr2 = (-x)**(S(5)/2)
+res = expr1 - expr2
+print("Test 1:", simplify(res.evalf(5)))
+
+# Test case 2: Very large floating-point exponent
+expr1 = x**1000.0
+expr2 = x**1000
+res = expr1 - expr2
+print("Test 2:", simplify(res.evalf(5)))
+
+# Test case 3: Very small floating-point exponent
+expr1 = x**0.0001
+expr2 = x**(S(1)/10000)
+res = expr1 - expr2
+print("Test 3:", simplify(res.evalf(5)))
+
+# Test case 4: Complex base with floating-point exponent
+expr1 = (x + I)**2.5
+expr2 = (x + I)**(S(5)/2)
+res = expr1 - expr2
+print("Test 4:", simplify(res.evalf(5)))
+
+# Test case 5: Multiple terms with floating-point exponents
+expr1 = x**2.5 + x**3.5
+expr2 = x**(S(5)/2) + x**(S(7)/2)
+res = expr1 - expr2
+print("Test 5:", simplify(res.evalf(5)))
\ No newline at end of file
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..2fa705bd45
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,8 @@
+import sympy
+from sympy import *
+x = Symbol('x')
+expr1 = S(1)/2*x**2.5
+expr2 = S(1)*x**(S(5)/2)/2
+res = expr1-expr2
+res = simplify(res.evalf(5))
+print(res)  # Added parentheses for Python 3 compatibility
\ No newline at end of file
diff --git a/sympy/core/power.py b/sympy/core/power.py
index 82bc545f33..a2424378ff 100644
--- a/sympy/core/power.py
+++ b/sympy/core/power.py
@@ -197,6 +197,10 @@ def __new__(cls, b, e, evaluate=None):
                 return S.One
             elif e is S.One:
                 return b
+            # Convert floating-point exponents to rationals for better simplification
+            if e.is_Float:
+                from sympy.core.numbers import Rational
+                e = Rational(str(e))
             # Only perform autosimplification if exponent or base is a Symbol or number
             elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and\
                 e.is_integer and _coeff_isneg(b):
