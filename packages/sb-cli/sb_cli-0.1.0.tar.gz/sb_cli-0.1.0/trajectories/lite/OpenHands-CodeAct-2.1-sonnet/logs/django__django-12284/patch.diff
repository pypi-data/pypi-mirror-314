diff --git a/django/db/models/base.py b/django/db/models/base.py
index 8ea6c05ef9..efd0528f83 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -945,9 +945,19 @@ class Model(metaclass=ModelBase):
 
     def _get_FIELD_display(self, field):
         value = getattr(self, field.attname)
-        choices_dict = dict(make_hashable(field.flatchoices))
+        # Get all choices from parent classes in reverse MRO order
+        # This ensures child class choices override parent choices
+        choices = {}
+        for cls in reversed(self.__class__.__mro__):
+            if hasattr(cls, '_meta'):
+                try:
+                    parent_field = cls._meta.get_field(field.name)
+                    if parent_field.choices:
+                        choices.update(dict(parent_field.choices))
+                except:
+                    continue
         # force_str() to coerce lazy strings.
-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)
+        return force_str(choices.get(value, value), strings_only=True)
 
     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
         if not self.pk:
diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 1a55d3d417..c9d5eb1dc0 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -764,6 +764,25 @@ class Field(RegisterLookupMixin):
             if not getattr(cls, self.attname, None):
                 setattr(cls, self.attname, self.descriptor_class(self))
         if self.choices is not None:
+            # If this is a field with choices in a child class
+            if not cls._meta.abstract:
+                # Look for parent classes with the same field name
+                for base in cls.__bases__:
+                    if hasattr(base, '_meta') and hasattr(base, name):
+                        try:
+                            parent_field = base._meta.get_field(name)
+                            if parent_field.choices:
+                                # Merge parent choices with current choices
+                                parent_choices = dict(parent_field.choices)
+                                current_choices = dict(self.choices)
+                                # Update with current choices to allow overriding
+                                parent_choices.update(current_choices)
+                                # Convert back to list of tuples
+                                self.choices = list(parent_choices.items())
+                                break
+                        except:
+                            continue
+
             if not hasattr(cls, 'get_%s_display' % self.name):
                 setattr(
                     cls,
