diff --git a/django/db/models/options.py b/django/db/models/options.py
index 00735e0de1..62811035df 100644
--- a/django/db/models/options.py
+++ b/django/db/models/options.py
@@ -9,6 +9,7 @@ from django.conf import settings
 from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured
 from django.db import connections
 from django.db.models import AutoField, Manager, OrderWrt, UniqueConstraint
+from django.db.models.fields.related import OneToOneField
 from django.db.models.query_utils import PathInfo
 from django.utils.datastructures import ImmutableList, OrderedSet
 from django.utils.deprecation import RemovedInDjango51Warning
@@ -644,7 +645,7 @@ class Options:
     @cached_property
     def fields_map(self):
         res = {}
-        fields = self._get_fields(forward=False, include_hidden=True)
+        fields = self._get_fields(forward=True, reverse=True, include_hidden=True)
         for field in fields:
             res[field.name] = field
             # Due to the way Django's internals work, get_field() should also
@@ -654,6 +655,22 @@ class Options:
                 res[field.attname] = field
             except AttributeError:
                 pass
+
+        # Add reverse OneToOne relations
+        for model in self.apps.get_models(include_auto_created=True):
+            opts = model._meta
+            if opts.abstract:
+                continue
+            for f in opts._get_fields(reverse=False, include_parents=False):
+                if (f.is_relation and f.related_model is not None and 
+                    f.remote_field.model == self.model):
+                    related_name = getattr(f.remote_field, 'related_name', None)
+                    if related_name:
+                        res[related_name] = f.remote_field
+                    elif isinstance(f, OneToOneField):
+                        # For OneToOneField without related_name, use the model name in lowercase
+                        res[f.model._meta.model_name] = f.remote_field
+
         return res
 
     def get_field(self, field_name):
@@ -674,6 +691,24 @@ class Options:
                     "be available yet." % (self.object_name, field_name)
                 )
 
+        # Check if this is a reverse relation
+        for f in self._get_fields(forward=False, reverse=True, include_hidden=True):
+            if f.name == field_name:
+                return f
+
+        # Check if this is a reverse OneToOne relation
+        for model in self.apps.get_models(include_auto_created=True):
+            opts = model._meta
+            if opts.abstract:
+                continue
+            for f in opts._get_fields(reverse=False, include_parents=False):
+                if (f.is_relation and f.related_model is not None and 
+                    f.remote_field.model == self.model and 
+                    getattr(f.remote_field, 'related_name', None) == field_name):
+                    # Add the field to the fields_map cache
+                    self.fields_map[field_name] = f.remote_field
+                    return f.remote_field
+
         try:
             # Retrieve field instance by name from cached or just-computed
             # field map.
@@ -804,7 +839,7 @@ class Options:
             fields_with_relations = (
                 f
                 for f in opts._get_fields(reverse=False, include_parents=False)
-                if f.is_relation and f.related_model is not None
+                if (f.is_relation or isinstance(f, OneToOneField)) and f.related_model is not None
             )
             for f in fields_with_relations:
                 if not isinstance(f.remote_field.model, str):
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 781dfd5499..f5933932dd 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -778,12 +778,22 @@ class Query(BaseExpression):
         select_mask[opts.pk] = {}
         # Only include fields mentioned in the mask.
         for field_name, field_mask in mask.items():
-            field = opts.get_field(field_name)
+            try:
+                field = opts.get_field(field_name)
+            except FieldDoesNotExist:
+                # Check if this is a reverse relation
+                for f in opts._get_fields(forward=False, reverse=True, include_hidden=True):
+                    if f.name == field_name:
+                        field = f
+                        break
+                else:
+                    raise
             field_select_mask = select_mask.setdefault(field, {})
             if field_mask:
-                if not field.is_relation:
+                if not field.is_relation and not hasattr(field, 'related_model'):
                     raise FieldError(next(iter(field_mask)))
-                related_model = field.remote_field.model._meta.concrete_model
+                related_model = (field.remote_field.model if hasattr(field, 'remote_field') 
+                               else field.related_model)._meta.concrete_model
                 self._get_only_select_mask(
                     related_model._meta, field_mask, field_select_mask
                 )
