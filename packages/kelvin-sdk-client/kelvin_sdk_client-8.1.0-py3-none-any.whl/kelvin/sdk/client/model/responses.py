# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2024-02-05T18:54:09+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, Iterator, List, Mapping, Optional, Sequence, Union
from uuid import UUID

from pydantic.v1 import Field
from typing_extensions import Literal

from kelvin.sdk.client.data_model import DataModelBase, PaginatorDataModel
from kelvin.sdk.client.utils import instance_classmethod

from . import domain, errors, kerrors, models, pagination, paginator, parameterschema, requests


class AppIO(DataModelBase):
    """
    AppIO object.

    Parameters
    ----------
    control_change: Optional[bool]
    data_type_name: Optional[str]
    name: Optional[str]
    primitive_type_name: Optional[str]
    semantic_type_name: Optional[str]
    unit_name: Optional[str]

    """

    control_change: Optional[bool] = None
    data_type_name: Optional[str] = None
    name: Optional[str] = None
    primitive_type_name: Optional[str] = None
    semantic_type_name: Optional[str] = None
    unit_name: Optional[str] = None


class AppParameterValues(DataModelBase):
    """
    AppParameterValues object.

    Parameters
    ----------
    app_parameter_values: Optional[Dict[str, Dict[str, List[Dict[str, Any]]]]]

    """

    app_parameter_values: Optional[Dict[str, Dict[str, List[Dict[str, Any]]]]] = None

    @classmethod
    def get_parameter_values(
        cls,
        data: Optional[Union[requests.ParameterValuesGet, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> AppParameterValues:
        """
        Get Parameter Values

        Returns a list of all unique values for each parameter grouped by app.

        **Permission Required:** `kelvin.permission.parameter.read`.

        ``getParameterValues``: ``POST`` ``/api/v4/parameters/values/get``

        Parameters
        ----------
        data: requests.ParameterValuesGet, optional
        **kwargs:
            Extra parameters for requests.ParameterValuesGet
              - app_parameters: list
              - primitive_types: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/parameters/values/get",
            {},
            {},
            {},
            {},
            data,
            "requests.ParameterValuesGet",
            False,
            {
                "200": AppParameterValues,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class AppVersion(DataModelBase):
    """
    AppVersion object.

    Parameters
    ----------
    created: Optional[datetime]
    id: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]
    version: Optional[str]

    """

    created: Optional[datetime] = None
    id: Optional[str] = None
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None
    version: Optional[str] = None

    @classmethod
    def delete_app_version(
        cls, app_name: str, app_version: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete App Version

        **Note:** This operation also deletes the associated Docker Image

        **Permission Required:** `kelvin.permission.appregistry.delete`.

        ``deleteAppVersion``: ``POST`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/delete``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/delete",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_app_version(
        cls, app_name: str, app_version: str, _dry_run: bool = False, _client: Any = None
    ) -> AppVersion:
        """
        Get App Version

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getAppVersion``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/get",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersion, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class AssetInsightsItem(DataModelBase):
    """
    AssetInsightsItem object.

    Parameters
    ----------
    asset_type_name: Optional[str]
    asset_type_title: Optional[str]
    extra_fields: Optional[Dict[str, Any]]
    last_seen: Optional[datetime]
    name: Optional[str]
    pinned: Optional[bool]
    state: Optional[str]
    title: Optional[str]

    """

    asset_type_name: Optional[str] = Field(
        None,
        description='Unique identifier name of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> linked to this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
    )
    asset_type_title: Optional[str] = Field(
        None,
        description='Display name (title) of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> linked to this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
    )
    extra_fields: Optional[Dict[str, Any]] = Field(
        None,
        description="A dictionary of all requested data from the `extra_fields` key in the request.</p> The key names for each column of data are the same from the request.",
    )
    last_seen: Optional[datetime] = Field(None, description="Last the time the asset was online")
    name: Optional[str] = Field(
        None,
        description='Unique identifier name of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
    )
    pinned: Optional[bool] = Field(
        None,
        description="Pinned status of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a>.</p> The pinned <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Assets</a> have been defined in an array from the request in the key `PinnedAssets`.",
    )
    state: Optional[str] = Field(
        None,
        description="Current asset state ['online', 'offline', 'partially_online', ''unknown']",
    )
    title: Optional[str] = Field(
        None,
        description='Display name (title) of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
    )

    @classmethod
    def get_assets_insights(
        cls,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        data: Optional[Union[requests.GetAssetsInsights, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[AssetInsightsItem], AssetInsightsPaginated]:
        """
        Advanced <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a> search and filter.

        There are not only standard options for searching and filtering <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Assets</a> but also advanced options such as pinning selected <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Assets</a> to page 1, creating extra fields with date range computational calculations on <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metrics</a> and retrieving custom fields from <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Assets</a>.

        **Pagination Sortable Columns:** `name`, `title`, `asset_type_name`, `asset_type_title`, `state`

        **Permission Required:** `kelvin.permission.asset_insights.read`.

        ``getAssetsInsights``: ``POST`` ``/api/v4/asset-insights/get``

        Parameters
        ----------
        page_size : :obj:`int`
            Number of <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a> objects to be returned. Page size can be between 1 and 1000
            objects.</p> The default is 20 <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a>
            objects.
        page : :obj:`int`
            Return the list of <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin
            Asset</a> objects on requested page using the `page_size` as a
            calculation reference.
        data: requests.GetAssetsInsights, optional
        **kwargs:
            Extra parameters for requests.GetAssetsInsights
              - asset_names: list
              - asset_states: list
              - asset_types: list
              - extra_fields: str
              - force_parameters_refresh: bool
              - pinned_assets: list
              - search: list
              - sort_by: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/asset-insights/get",
            {},
            {"page_size": page_size, "page": page},
            {},
            {},
            data,
            "requests.GetAssetsInsights",
            False,
            {"200": AssetInsightsPaginated, "400": errors.ErrorMessage, "424": errors.ErrorMessage},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/asset-insights/get", "POST") if fetch and not _dry_run else result
        )


class AssetInsightsPaginated(PaginatorDataModel[AssetInsightsItem]):
    """
    AssetInsightsPaginated object.

    Parameters
    ----------
    data: Optional[List[AssetInsightsItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[AssetInsightsItem]] = Field(
        None,
        description="A dictionary which contains an array of up to `page_size` <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets#asset-type-metadata' target='_blank'>Kelvin Asset Type Metadata</a> objects. If a bookmark has been used, then the array will start or end based on the `starting_after` or `ending_before` parameters.",
    )
    pagination: Optional[paginator.PaginationInfo] = None


class AssetProperty(DataModelBase):
    """
    AssetProperty object.

    Parameters
    ----------
    name: Optional[str]
    title: Optional[str]
    value: Optional[Any]

    """

    name: Optional[str] = Field(
        None,
        description='Unique identifier name for this property in the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset" target="_blank">Kelvin Asset</a>.</p> This must contain only lowercase alphanumeric characters. The `.`, `_` and `-` characters are also allowed to separate words instead of a space BUT can not be at the beginning or end of the name.',
        max_length=64,
    )
    title: Optional[str] = Field(
        None,
        description='Display name (title) for this property in the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset" target="_blank">Kelvin Asset</a>. This is a friendly name displayed in lists and in references within asset details.</p> You can use any character, numeric, space and special character in this parameter.',
        max_length=64,
    )
    value: Optional[Any] = Field(None, description="Value for this property.")


class AssetStatusCount(DataModelBase):
    """
    AssetStatusCount object.

    Parameters
    ----------
    offline: Optional[int]
    online: Optional[int]
    partially_online: Optional[int]
    total: Optional[int]
    unknown: Optional[int]

    """

    offline: Optional[int] = Field(
        None,
        description="Count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> that have all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> inactive and not receiving data.",
    )
    online: Optional[int] = Field(
        None,
        description="Count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> that have all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> receiving active data.",
    )
    partially_online: Optional[int] = Field(
        None,
        description="Count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> that have at least one <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> receiving active data. </p> If the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> only has <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a>, then it will be classed at Online, not partially online.",
    )
    total: Optional[int] = Field(
        None,
        description="Count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.",
    )
    unknown: Optional[int] = Field(
        None,
        description="Count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> that has no associated <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metrics</a> or the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> has never received data. i.e. It has not been established if this connection is a valid address.",
    )

    @classmethod
    def get_asset_status_count(
        cls, _dry_run: bool = False, _client: Any = None
    ) -> AssetStatusCount:
        """
        Get Asset Status Count

        Summary total count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> into four statuses.

        There are four status (state) values that can be returned; `online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all online and receiving information, `offline` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all offline, `partially_online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and some assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are online and receiving information and `unknown` where the status (state) has never received any data to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> and/or is not declared on any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> as a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetStatusCount``: ``GET`` ``/api/v4/assets/status/count/get``

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/status/count/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetStatusCount,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result


class AssetStatusItem(DataModelBase):
    """
    AssetStatusItem object.

    Parameters
    ----------
    last_seen: Optional[datetime]
    state: Optional[str]

    """

    last_seen: Optional[datetime] = Field(
        None,
        description='Time when the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> was last seen in ISO 8601 UTC date/time format. Example; "2022-07-08T08:41:01.657916Z".',
    )
    state: Optional[str] = Field(
        None,
        description="Current status (state) of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>. There are four status options; `online`, `offline`, `partially_online` and `unknown`.",
    )


class AssetType(DataModelBase):
    """
    AssetType object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = Field(
        None,
        description='Time of creation of this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> in ISO 8601 UTC date/time format. Example; "2022-07-08T08:41:01.657916Z".',
    )
    name: Optional[str] = Field(
        None,
        description='Unique identifier name of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.',
        max_length=64,
    )
    title: Optional[str] = Field(
        None,
        description='Display name (title) of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.',
        max_length=64,
    )
    updated: Optional[datetime] = Field(
        None,
        description='Time of modifying any variable of this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> in ISO 8601 UTC date/time format. Example; "2022-07-08T08:41:01.657916Z".',
    )

    @instance_classmethod
    @DataModelBase.translate()
    def create_asset_type(
        self_or_cls,
        data: Optional[Union[requests.AssetTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> AssetType:
        """
        Create Asset Type

        To create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> you first need to create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>. A <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> is directly linked to a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>. There can be many <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a> linked to one <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.create`.

        ``createAssetType``: ``POST`` ``/api/v4/assets/types/create``

        Parameters
        ----------
        data: requests.AssetTypeCreate, optional
        **kwargs:
            Extra parameters for requests.AssetTypeCreate
              - name: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetTypeCreate",
            False,
            {"201": AssetType, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def delete_bulk_asset_type(
        cls,
        data: Optional[Union[requests.AssetTypeDeleteBulk, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Bulk Asset Type

        Permanently delete a list of existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a>. This cannot be undone once the API request has been submitted.

        This command can not delete <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a> that are currently linked to any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and will return an error 403.

        **Permission Required:** `kelvin.permission.asset_type.delete`.

        ``deleteBulkAssetType``: ``POST`` ``/api/v4/assets/types/delete``

        Parameters
        ----------
        data: requests.AssetTypeDeleteBulk, optional
        **kwargs:
            Extra parameters for requests.AssetTypeDeleteBulk
              - names: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/delete",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetTypeDeleteBulk",
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_asset_type(
        cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[AssetType], AssetTypeListPaginated]:
        """
        List Asset Type

        Returns a filtered dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects on the Kelvin Platform that meet the criteria of any parameters passed with the API request.

        If no query parameters are given with the API request, then the defaults will be used to return the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> list.

        The defaults are the first 20 <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects returned in alphabetical order by the unique identifier name.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``listAssetType``: ``GET`` ``/api/v4/assets/types/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter on the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset-type'
            target='_blank'>Kelvin Asset Type</a> parameter `name`. This is given
            as an array, for example `[pump,fan]`.</p> The filter is done on the
            full name only according to unique identifier name rules (Must contain
            only lowercase alphanumeric characters. The `.`, `_` and `-`
            characters are also allowed to separate words instead of a space but
            not at the beginning or end).</p> For example a search with
            `[pump,fan]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> with the name `pump` but not with the names `pumps` or
            `centrifugal-fan`.
        search : :obj:`Sequence[str]`
            Search and filter the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> list. Both the Display Name and the Name will be included in
            the search field criteria. This is given as an array, for example
            `[pump,fan]`.</p> The search is case insensitive and will find partial
            matches as well. For example if a Kelvin Asset Type name is
            `centrifugal_pump`, then a match will be made if the search string is
            `pum` or `FUGaL`.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `created`, `updated`.</p> The default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/types/list",
            {},
            {
                "names": names,
                "search": search,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AssetTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/assets/types/list", "GET") if fetch and not _dry_run else result
        )

    @classmethod
    def list_asset_type_advanced(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.AssetTypeList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[AssetType], AssetTypeListPaginated]:
        """
        List Asset Type Advanced

        Returns a filtered dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects on the Kelvin Platform that meet the criteria of any parameters passed with the API request.

        If no query parameters are given with the API request, then the defaults will be used to return the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> list.

        The defaults are the first 20 <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects returned in alphabetical order by the unique identifier name.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``listAssetTypeAdvanced``: ``POST`` ``/api/v4/assets/types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `created`, `updated`.</p> The default is `name`
        data: requests.AssetTypeList, optional
        **kwargs:
            Extra parameters for requests.AssetTypeList
              - names: list
              - search: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.AssetTypeList",
            False,
            {"200": AssetTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/assets/types/list", "POST") if fetch and not _dry_run else result
        )

    @instance_classmethod
    @DataModelBase.translate({"asset_type_name": "name"})
    def delete_asset_type(
        self_or_cls, asset_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Asset Type

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a>. This cannot be undone once the API request has been submitted.

        This command can not delete <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a> that are currently linked to any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and will return an error 403.

        **Permission Required:** `kelvin.permission.asset_type.delete`.

        ``deleteAssetType``: ``POST`` ``/api/v4/assets/types/{asset_type_name}/delete``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to delete.</p> This is the unique identifier name and
            not the display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/{asset_type_name}/delete",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_type_name": "name"})
    def get_asset_type(
        self_or_cls, asset_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> AssetType:
        """
        Get Asset Type

        Retrieves the properties of a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``getAssetType``: ``GET`` ``/api/v4/assets/types/{asset_type_name}/get``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to retrieve.</p> This is the unique identifier name and
            not the display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/assets/types/{asset_type_name}/get",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AssetType, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_type_name": "name"})
    def update_asset_type(
        self_or_cls,
        asset_type_name: str,
        data: Optional[Union[requests.AssetTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> AssetType:
        """
        Update Asset Type

        Updates an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> with any new values passed through the body parameters.</p> All body parameters are optional and if not provided will remain unchanged.</p> Only the unique identifier name can not be changed. If you need to change this parameter, then you will need to make a new <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> and relink all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> to the new <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.update`.

        ``updateAssetType``: ``POST`` ``/api/v4/assets/types/{asset_type_name}/update``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to retrieve.</p> This is the unique identifier name and
            not the display name of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.
        data: requests.AssetTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.AssetTypeUpdate
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/{asset_type_name}/update",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            data,
            "requests.AssetTypeUpdate",
            False,
            {
                "200": AssetType,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "403": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class AssetTypeListPaginated(PaginatorDataModel[AssetType]):
    """
    AssetTypeListPaginated object.

    Parameters
    ----------
    data: Optional[List[AssetType]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[AssetType]] = Field(
        None,
        description="A dictionary which contains an array of up to `page_size` <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a>. If a bookmark has been used, then the array will start or end based on the `starting_after` or `ending_before` parameters.",
    )
    pagination: Optional[paginator.PaginationInfo] = None


class Attachment(DataModelBase):
    """
    Attachment object.

    Parameters
    ----------
    extension: Optional[str]
    filename: Optional[str]
    size: Optional[int]
    url: Optional[str]

    """

    extension: Optional[str] = None
    filename: Optional[str] = None
    size: Optional[int] = None
    url: Optional[str] = None


class AuditLogger(DataModelBase):
    """
    AuditLogger object.

    Parameters
    ----------
    action: Optional[str]
    created: Optional[datetime]
    id: Optional[int]
    identifier: Optional[str]
    meta: Optional[Dict[str, Any]]
    namespace: Optional[str]
    request_id: Optional[str]
    user_id: Optional[str]
    username: Optional[str]

    """

    action: Optional[str] = None
    created: Optional[datetime] = None
    id: Optional[int] = None
    identifier: Optional[str] = None
    meta: Optional[Dict[str, Any]] = None
    namespace: Optional[str] = None
    request_id: Optional[str] = None
    user_id: Optional[str] = None
    username: Optional[str] = None

    @classmethod
    def list_audit_log(
        cls,
        action: Optional[Sequence[str]] = None,
        user_id: Optional[Sequence[str]] = None,
        namespace: Optional[Sequence[str]] = None,
        identifier: Optional[Sequence[str]] = None,
        username: Optional[Sequence[str]] = None,
        request_id: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        from_date_time: Optional[datetime] = None,
        to_date_time: Optional[datetime] = None,
        page_size: Optional[int] = 10000,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_asc: Optional[bool] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[AuditLogger], AuditLoggerListPaginated]:
        """
        List Audit Log

        **Pagination Sortable Columns:** `audit_log.id`, `audit_log.action`, `audit_log.username`, `audit_log.created`, `request_uri`

        **Note:** Both `from_date_time` and `to_date_time` support RFC3339 format with microseconds

        **Permission Required:** `kelvin.permission.audit_log.read`.

        ``listAuditLog``: ``GET`` ``/api/v4/instance/auditlog/list``

        Parameters
        ----------
        action : :obj:`Sequence[str]`
            Filter by action
        user_id : :obj:`Sequence[str]`
            Filter by user_id
        namespace : :obj:`Sequence[str]`
            Filter by namespace
        identifier : :obj:`Sequence[str]`
            Filter by identifier
        username : :obj:`Sequence[str]`
            Filter by username
        request_id : :obj:`Sequence[str]`
            Filter by request_id
        search : :obj:`Sequence[str]`
            Search Audit Log by action, username or namespace
        from_date_time : :obj:`datetime`
            Filter actions occurred at or after this date-time
        to_date_time : :obj:`datetime`
            Filter actions occurred until or at this date-time
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 1000. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination
        sort_by : :obj:`str`
            Parameter to sort by. Must be one of the sortable columns
        sort_asc : :obj:`bool`
            Order of sorting is Ascending. Possible Values: true/false. Default:
            false

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/instance/auditlog/list",
            {},
            {
                "action": action,
                "user_id": user_id,
                "namespace": namespace,
                "identifier": identifier,
                "username": username,
                "request_id": request_id,
                "search": search,
                "from_date_time": from_date_time,
                "to_date_time": to_date_time,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "sort_by": sort_by,
                "sort_asc": sort_asc,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AuditLoggerListPaginated, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/instance/auditlog/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"audit_logger_id": "id"})
    def get_audit_log(
        self_or_cls, audit_logger_id: str, _dry_run: bool = False, _client: Any = None
    ) -> AuditLogger:
        """
        Get Audit Log

        **Permission Required:** `kelvin.permission.audit_log.read`.

        ``getAuditLog``: ``GET`` ``/api/v4/instance/auditlog/{audit_logger_id}/get``

        Parameters
        ----------
        audit_logger_id : :obj:`str`, optional
            Audit Logger ID

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/instance/auditlog/{audit_logger_id}/get",
            {"audit_logger_id": audit_logger_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AuditLogger, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return result


class AuditLoggerListPaginated(PaginatorDataModel[AuditLogger]):
    """
    AuditLoggerListPaginated object.

    Parameters
    ----------
    data: Optional[List[AuditLogger]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[AuditLogger]] = None
    pagination: Optional[pagination.Pagination] = None


class CSVPosition(DataModelBase):
    """
    CSVPosition object.

    Parameters
    ----------
    column: Optional[int]
    field_description: Optional[str]
    field_solution: Optional[str]
    row: Optional[int]

    """

    column: Optional[int] = Field(None, description="The column where the error has been detected.")
    field_description: Optional[str] = Field(
        None, description="A detailed description of what is the error at this location."
    )
    field_solution: Optional[str] = Field(None, description="Possible solutions to fix this error.")
    row: Optional[int] = Field(None, description="The row where the error has been detected.")


class ClusterManifestImageItem(DataModelBase):
    """
    ClusterManifestImageItem object.

    Parameters
    ----------
    args: Optional[str]
    path: Optional[str]

    """

    args: Optional[str] = None
    path: Optional[str] = None


class ClusterManifestItem(DataModelBase):
    """
    ClusterManifestItem object.

    Parameters
    ----------
    content: Optional[str]
    file_name: Optional[str]

    """

    content: Optional[str] = None
    file_name: Optional[str] = None


class ClusterManifestUpgrade(DataModelBase):
    """
    ClusterManifestUpgrade object.

    Parameters
    ----------
    download_type: Optional[str]
    upgrade_type: Optional[str]

    """

    download_type: Optional[str] = None
    upgrade_type: Optional[str] = None


class ClusterUpdateStatus(DataModelBase):
    """
    ClusterUpdateStatus object.

    Parameters
    ----------
    message: Optional[str]
    state: Optional[str]

    """

    message: Optional[str] = None
    state: Optional[str] = None


class ClusterVersions(DataModelBase):
    """
    ClusterVersions object.

    Parameters
    ----------
    k8s_version: Optional[str]
    kelvin_version: Optional[str]

    """

    k8s_version: Optional[str] = None
    kelvin_version: Optional[str] = None


class ComponentStatus(DataModelBase):
    """
    ComponentStatus object.

    Parameters
    ----------
    name: Optional[str]
    status: Optional[bool]

    """

    name: Optional[str] = None
    status: Optional[bool] = None


class Context(DataModelBase):
    """
    Context object.

    Parameters
    ----------
    created: Optional[datetime]
    resource: Optional[str]
    source: Optional[str]
    updated: Optional[datetime]
    writable: Optional[bool]

    """

    created: Optional[datetime] = None
    resource: Optional[str] = None
    source: Optional[str] = None
    updated: Optional[datetime] = None
    writable: Optional[bool] = None


class ControlChange(DataModelBase):
    """
    ControlChange object.

    Parameters
    ----------
    created_by: Optional[str]
    created_type: Optional[str]
    id: str
    last_state: Optional[str]
    payload: Optional[Any]
    resource: Optional[str]
    source: Optional[str]
    timestamp: Optional[datetime]
    trace_id: str

    """

    created_by: Optional[str] = Field(
        None,
        description="Who created the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a>.</p> For a `user` this will normally be a user name or user email address and for a `workload` it will be the workload's unique name.",
    )
    created_type: Optional[str] = Field(
        None,
        description="Type of process that created the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a>.</p> There are two types; `user` which is a normal user registered on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> or `workload` which is an automated process like a Kelvin Rule or from a program in a  <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-apps/' target='_blank'>Kelvin App</a>.",
    )
    id: str = Field(
        ...,
        description="Unique identifier id for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request.",
    )
    last_state: Optional[str] = Field(
        None,
        description="The current payload value of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair before the new payload is delivered.",
    )
    payload: Optional[Any] = Field(
        None,
        description="The new value payload to send to the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.",
    )
    resource: Optional[str] = Field(None, description="An internal Kelvin parameter")
    source: Optional[str] = Field(None, description="An internal Kelvin parameter")
    timestamp: Optional[datetime] = Field(
        None,
        description="Time when `created_by` sent the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request to the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>. The date-time is in ISO 8601 UTC date/time format. Example; \"2022-08-22T08:41:01.657916Z\".",
    )
    trace_id: str = Field(
        ..., description="This is for internal purposes and is the same as the `id`."
    )

    @instance_classmethod
    @DataModelBase.translate()
    def create_control_change(
        self_or_cls,
        data: Optional[Union[requests.ControlChangeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> ControlChange:
        """
        Create Control Change

        Send a new value to be written to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        The <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> Manager will automatically find whichKelvin Cluster hosts the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> with the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.control_change.create`.

        ``createControlChange``: ``POST`` ``/api/v4/control-changes/create``

        Parameters
        ----------
        data: requests.ControlChangeCreate, optional
        **kwargs:
            Extra parameters for requests.ControlChangeCreate
              - expiration_date: datetime
              - payload: str
              - resource: str
              - retry: int
              - timeout: int

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/create",
            {},
            {},
            {},
            {},
            data,
            "requests.ControlChangeCreate",
            False,
            {"201": ControlChange, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_last_control_change(
        cls,
        status_limit: Optional[int] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ControlChangeLast, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ControlChangeGet], ControlChangeGetPaginated]:
        """
        Get Last Control Change

        Returns a list of the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pairs for each of the body parameters in the array `resources`.

        The list will include <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Changes</a> that succeeded, failed or are pending.

        Each object will not only give the `status` and `payload` of the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> but also the `status_log` containing the information of when the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> was created, sent to bridge and confirmed with a read.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getLastControlChange``: ``POST`` ``/api/v4/control-changes/last/get``

        Parameters
        ----------
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `id`, `resource`, `last_state`,
            `created`, `updated`, `timestamp`.</p> The default is `id`
        data: requests.ControlChangeLast, optional
        **kwargs:
            Extra parameters for requests.ControlChangeLast
              - resources: list
              - sources: list
              - states: list
              - status_limit: int

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/last/get",
            {},
            {
                "status_limit": status_limit,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ControlChangeLast",
            False,
            {"200": ControlChangeGetPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/control-changes/last/get", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def list_control_change(
        cls,
        status_limit: Optional[int] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ControlChangeList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ControlChangeGet], ControlChangeGetPaginated]:
        """
        List Control Change lists the Control Changes for each resource.

        Returns a list of the history of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> requests for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pairs for each of the body parameters in the array `resources`.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``listControlChange``: ``POST`` ``/api/v4/control-changes/list``

        Parameters
        ----------
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `id`, `resource`, `last_state`,
            `created`, `updated`, `timestamp`.</p> The default is `id`
        data: requests.ControlChangeList, optional
        **kwargs:
            Extra parameters for requests.ControlChangeList
              - ids: list
              - resources: list
              - sources: list
              - states: list
              - status_limit: int

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/list",
            {},
            {
                "status_limit": status_limit,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ControlChangeList",
            False,
            {"200": ControlChangeGetPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/control-changes/list", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def get_range_control_change(
        cls,
        status_limit: Optional[int] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ControlChangeRange, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ControlChangeGet], ControlChangeGetPaginated]:
        """
        Get Range Control Change.

        Returns a list of the history of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> status changes that have happened within a date range for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pairs for each of the body parameters in the array `resources`.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getRangeControlChange``: ``POST`` ``/api/v4/control-changes/range/get``

        Parameters
        ----------
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `id`, `resource`, `last_state`,
            `created`, `updated`, `timestamp`.</p> The default is `id`
        data: requests.ControlChangeRange, optional
        **kwargs:
            Extra parameters for requests.ControlChangeRange
              - end_date: datetime
              - resources: list
              - sources: list
              - start_date: datetime
              - states: list
              - status_limit: int

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/range/get",
            {},
            {
                "status_limit": status_limit,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ControlChangeRange",
            False,
            {"200": ControlChangeGetPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/control-changes/range/get", "POST")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"control_change_id": "id"})
    def get_control_change(
        self_or_cls,
        control_change_id: str,
        status_limit: Optional[int] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> ControlChangeGet:
        """
        Get Control Change

        Returns the properties of a single <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request via its unique ID.

        Returned object will not only give the `status` and `payload` of the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> but also the `status_log` containing the information of when the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> was created, sent to bridge and confirmed with a read.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getControlChange``: ``GET`` ``/api/v4/control-changes/{control_change_id}/get``

        Parameters
        ----------
        control_change_id : :obj:`str`, optional
            Unique identifier id for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a>.</p> This must contain only lowercase alphanumeric
            characters and the `-` character only. For example
            `764168a8-0e1e-33aa-adc7-14dfbb78dfad`
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/control-changes/{control_change_id}/get",
            {"control_change_id": control_change_id},
            {"status_limit": status_limit},
            {},
            {},
            None,
            None,
            False,
            {"200": ControlChangeGet, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class ControlChangeClustering(DataModelBase):
    """
    ControlChangeClustering object.

    Parameters
    ----------
    control_change_ids: Optional[List[str]]
    count: Optional[int]
    time_bucket_start: Optional[datetime]

    """

    control_change_ids: Optional[List[str]] = Field(
        None,
        description="Array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> ID's with the time frame of the current time bucket.",
    )
    count: Optional[int] = Field(
        None,
        description="The number of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Changes</a> that occurred within the time frame of the current time bucket.",
    )
    time_bucket_start: Optional[datetime] = Field(
        None,
        description='The start time of the current time bucket. The date-time is in ISO 8601 UTC date/time format. Example; "2022-08-22T08:41:01.657916Z".',
    )

    @classmethod
    def get_control_change_clustering(
        cls,
        data: Optional[Union[requests.ControlChangeClustering, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> List[ControlChangeClustering]:
        """
        Get Control Change Clustering

        Groups and counts the occurrence of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Changes</a> within a defined time bucket.

        The grouping can also be filtered to only include <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Changes</a> for certain <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>, <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metrics</a> or current <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> statuses.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getControlChangeClustering``: ``POST`` ``/api/v4/control-changes/clustering/get``

        Parameters
        ----------
        data: requests.ControlChangeClustering, optional
        **kwargs:
            Extra parameters for requests.ControlChangeClustering
              - end_date: datetime
              - resources: list
              - sources: list
              - start_date: datetime
              - states: list
              - time_bucket: str

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/clustering/get",
            {},
            {},
            {},
            {},
            data,
            "requests.ControlChangeClustering",
            False,
            {
                "200": List[ControlChangeClustering],
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class ControlChangeGetStatus(DataModelBase):
    """
    ControlChangeGetStatus object.

    Parameters
    ----------
    message: Optional[str]
    payload: Optional[Any]
    state: str
    timestamp: Optional[datetime]

    """

    message: Optional[str] = Field(
        None,
        description="A message about the change in status. This will only appear if there is a message attached.",
    )
    payload: Optional[Any] = Field(
        None,
        description="`pending` status will show a blank dictionary. `sent`, `applied` and `failed` will show the current value of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.",
    )
    state: str = Field(
        ...,
        description="<a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> updated state.</p> There are four states available; `pending`, `sent`, `applied` and `failed`.",
    )
    timestamp: Optional[datetime] = Field(
        None,
        description="Time when the new status for <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request is recorded. The date-time is in ISO 8601 UTC date/time format. Example; \"2022-08-22T08:41:01.657916Z\".",
    )


class DSContext(DataModelBase):
    """
    DSContext object.

    Parameters
    ----------
    resource: Optional[str]
    writable: Optional[bool]

    """

    resource: Optional[str] = None
    writable: Optional[bool] = None


class Data(DataModelBase):
    """
    Data object.

    Parameters
    ----------
    payload: Optional[Any]
    resource: Optional[str]
    timestamp: Optional[str]

    """

    payload: Optional[Any] = None
    resource: Optional[str] = None
    timestamp: Optional[str] = None

    @classmethod
    def download_range_timeseries_data(
        cls,
        data: Optional[Union[requests.TimeseriesGetRange, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Iterator[None]:
        """
        Download Range Timeseries Data

        Returns a **CSV file** with time series data within a for a given time range and given list of resources in the parameter `selectors`.

        **Permission Required:** `kelvin.permission.storage.read`.

        ``downloadRangeTimeseriesData``: ``POST`` ``/api/v4/timeseries/range/download``

        Parameters
        ----------
        data: requests.TimeseriesGetRange, optional
        **kwargs:
            Extra parameters for requests.TimeseriesGetRange
              - agg: str
              - end_time: datetime
              - fill: str
              - group_by_selector: bool
              - order: str
              - selectors: list
              - start_time: datetime
              - time_bucket: str
              - time_shift: str

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/timeseries/range/download",
            {},
            {},
            {},
            {},
            data,
            "requests.TimeseriesGetRange",
            False,
            {"200": None, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            True,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_range_timeseries_data(
        cls,
        data: Optional[Union[requests.TimeseriesGetRange, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Iterator[Data]:
        """
        Get Range Timeseries Data


        **Permission Required:** `kelvin.permission.storage.read`.

        ``getRangeTimeseriesData``: ``POST`` ``/api/v4/timeseries/range/get``

        Parameters
        ----------
        data: requests.TimeseriesGetRange, optional
        **kwargs:
            Extra parameters for requests.TimeseriesGetRange
              - agg: str
              - end_time: datetime
              - fill: str
              - group_by_selector: bool
              - order: str
              - selectors: list
              - start_time: datetime
              - time_bucket: str
              - time_shift: str

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/timeseries/range/get",
            {},
            {},
            {},
            {},
            data,
            "requests.TimeseriesGetRange",
            False,
            {"200": Data, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            True,
            _dry_run,
            kwargs,
        )
        return result


class Type(Enum):
    computed = "computed"
    measurement = "measurement"


class DataStream(DataModelBase):
    """
    DataStream object.

    Parameters
    ----------
    created: Optional[datetime]
    data_type_name: Optional[str]
    description: Optional[str]
    name: Optional[str]
    primitive_type_name: Optional[str]
    semantic_type_name: Optional[str]
    title: Optional[str]
    type: Optional[Type]
    unit_name: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    data_type_name: Optional[str] = None
    description: Optional[str] = None
    name: Optional[str] = None
    primitive_type_name: Optional[str] = None
    semantic_type_name: Optional[str] = None
    title: Optional[str] = None
    type: Optional[Type] = None
    unit_name: Optional[str] = None
    updated: Optional[datetime] = None

    @classmethod
    def list_data_stream_contexts(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.DataStreamContextList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[DataStreamContext], DataStreamContextPaginated]:
        """
        List Data Stream Contexts

        **Pagination Sortable Columns:** `data_stream_name`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listDataStreamContexts``: ``POST`` ``/api/v4/datastreams/context/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `data_stream_name`.</p> The default is
            `data_stream_name`
        data: requests.DataStreamContextList, optional
        **kwargs:
            Extra parameters for requests.DataStreamContextList
              - datastream_names: list
              - resources: list
              - sources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/context/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.DataStreamContextList",
            False,
            {
                "200": DataStreamContextPaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/datastreams/context/list", "POST")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def create_data_stream(
        self_or_cls,
        data: Optional[Union[requests.DataStreamCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> DataStream:
        """
        Create Data Stream

        Create a datastream

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``createDataStream``: ``POST`` ``/api/v4/datastreams/create``

        Parameters
        ----------
        data: requests.DataStreamCreate, optional
        **kwargs:
            Extra parameters for requests.DataStreamCreate
              - data_type_name: str
              - description: str
              - name: str
              - primitive_type_name: str
              - semantic_type_name: str
              - title: str
              - type: str
              - unit_name: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/create",
            {},
            {},
            {},
            {},
            data,
            "requests.DataStreamCreate",
            False,
            {
                "201": DataStream,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_data_type(
        self_or_cls,
        data: Optional[Union[requests.DataTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> DataType:
        """
        Create Data Type

        Create a data type

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``createDataType``: ``POST`` ``/api/v4/datastreams/data-types/create``

        Parameters
        ----------
        data: requests.DataTypeCreate, optional
        **kwargs:
            Extra parameters for requests.DataTypeCreate
              - name: str
              - schema: dict
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/data-types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.DataTypeCreate",
            False,
            {
                "201": DataType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_data_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[DataType], DataTypesPaginated]:
        """
        List Data Types

        **Pagination Sortable Columns:** `name`, `title`, `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listDataTypes``: ``GET`` ``/api/v4/datastreams/data-types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search data types by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/data-types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": DataTypesPaginated, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/data-types/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def delete_data_type(
        self_or_cls, data_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Data Type

        Delete a data type

        **Permission Required:** `kelvin.permission.datastreams.delete`.

        ``deleteDataType``: ``POST`` ``/api/v4/datastreams/data-types/{data_type_name}/delete``

        Parameters
        ----------
        data_type_name : :obj:`str`, optional
            Data Type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/data-types/{data_type_name}/delete",
            {"data_type_name": data_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_data_type(
        self_or_cls, data_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> DataType:
        """
        Get Data Type

        Get a data type

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getDataType``: ``GET`` ``/api/v4/datastreams/data-types/{data_type_name}/get``

        Parameters
        ----------
        data_type_name : :obj:`str`, optional
            Data Type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/data-types/{data_type_name}/get",
            {"data_type_name": data_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": DataType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_data_type(
        self_or_cls,
        data_type_name: str,
        data: Optional[Union[requests.DataTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> DataType:
        """
        Update Data Type

        Update a data type

        **Permission Required:** `kelvin.permission.datastreams.update`.

        ``updateDataType``: ``POST`` ``/api/v4/datastreams/data-types/{data_type_name}/update``

        Parameters
        ----------
        data_type_name : :obj:`str`, optional
            Data Type name
        data: requests.DataTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.DataTypeUpdate
              - schema: dict
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/data-types/{data_type_name}/update",
            {"data_type_name": data_type_name},
            {},
            {},
            {},
            data,
            "requests.DataTypeUpdate",
            False,
            {
                "200": DataType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_data_streams(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.DataStreamList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[DataStream], DataStreamsPaginated]:
        """
        List Data Streams

        **Pagination Sortable Columns:** `name`, `title`, `primitive_type_name`, `data_type_name`, `unit_name`, `semantic_type_name` `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listDataStreams``: ``POST`` ``/api/v4/datastreams/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`primitive_type_name`,`data_type_name`, `unit_name`,
            `semantic_type_name`, `created`, `updated`.</p> The default is `name`
        data: requests.DataStreamList, optional
        **kwargs:
            Extra parameters for requests.DataStreamList
              - data_type_names: list
              - names: list
              - primitive_type_names: list
              - search: list
              - semantic_type_names: list
              - unit_names: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.DataStreamList",
            False,
            {"200": DataStreamsPaginated, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/datastreams/list", "POST") if fetch and not _dry_run else result
        )

    @classmethod
    def list_primitive_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[PrimitiveType], PrimitiveTypesPaginated]:
        """
        List Primitive Types

        **Pagination Sortable Columns:** `name`, `title`, `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listPrimitiveTypes``: ``GET`` ``/api/v4/datastreams/primitive-types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search primitive types by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/primitive-types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": PrimitiveTypesPaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/primitive-types/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def create_semantic_type(
        self_or_cls,
        data: Optional[Union[requests.SemanticTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> SemanticType:
        """
        Create Semantic Type

        Create a semantic type

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``createSemanticType``: ``POST`` ``/api/v4/datastreams/semantic-types/create``

        Parameters
        ----------
        data: requests.SemanticTypeCreate, optional
        **kwargs:
            Extra parameters for requests.SemanticTypeCreate
              - data_type_name: str
              - name: str
              - primitive_type_name: str
              - title: str
              - unit_names: list

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/semantic-types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.SemanticTypeCreate",
            False,
            {
                "201": SemanticType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_semantic_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[SemanticType], SemanticTypesPaginated]:
        """
        List Semantic Types

        **Pagination Sortable Columns:** `name`, `title`, `primitive_type_name`, `data_type_name` `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listSemanticTypes``: ``GET`` ``/api/v4/datastreams/semantic-types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`, `title`,`primitive_type_name`,
            `data_type_name`, `created`, `updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search semantic types by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/semantic-types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": SemanticTypesPaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/semantic-types/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def delete_semantic_type(
        self_or_cls, semantic_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Semantic Type

        Delete a semantic type

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``deleteSemanticType``: ``POST`` ``/api/v4/datastreams/semantic-types/{semantic_type_name}/delete``

        Parameters
        ----------
        semantic_type_name : :obj:`str`, optional
            Semantic type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/semantic-types/{semantic_type_name}/delete",
            {"semantic_type_name": semantic_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_semantic_type(
        self_or_cls, semantic_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> SemanticType:
        """
        Get Semantic Type

        Get a semantic type

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getSemanticType``: ``GET`` ``/api/v4/datastreams/semantic-types/{semantic_type_name}/get``

        Parameters
        ----------
        semantic_type_name : :obj:`str`, optional
            Semantic type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/semantic-types/{semantic_type_name}/get",
            {"semantic_type_name": semantic_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": SemanticType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_semantic_type(
        self_or_cls,
        semantic_type_name: str,
        data: Optional[Union[requests.SemanticTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> SemanticType:
        """
        Update Semantic Type

        Update a semantic type

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``updateSemanticType``: ``POST`` ``/api/v4/datastreams/semantic-types/{semantic_type_name}/update``

        Parameters
        ----------
        semantic_type_name : :obj:`str`, optional
            Semantic type name
        data: requests.SemanticTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.SemanticTypeUpdate
              - title: str
              - unit_names: list

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/semantic-types/{semantic_type_name}/update",
            {"semantic_type_name": semantic_type_name},
            {},
            {},
            {},
            data,
            "requests.SemanticTypeUpdate",
            False,
            {
                "201": SemanticType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_unit(
        self_or_cls,
        data: Optional[Union[requests.UnitCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Unit:
        """
        Create Unit

        Create a unit

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``createUnit``: ``POST`` ``/api/v4/datastreams/units/create``

        Parameters
        ----------
        data: requests.UnitCreate, optional
        **kwargs:
            Extra parameters for requests.UnitCreate
              - name: str
              - symbol: str
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/units/create",
            {},
            {},
            {},
            {},
            data,
            "requests.UnitCreate",
            False,
            {
                "201": Unit,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_units(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[Unit], UnitsPaginated]:
        """
        List Units

        **Pagination Sortable Columns:** `name`, `title`, `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listUnits``: ``GET`` ``/api/v4/datastreams/units/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search units by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/units/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UnitsPaginated, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/units/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def delete_unit(
        self_or_cls, unit_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Unit

        Delete a unit

        **Permission Required:** `kelvin.permission.datastreams.delete`.

        ``deleteUnit``: ``POST`` ``/api/v4/datastreams/units/{unit_name}/delete``

        Parameters
        ----------
        unit_name : :obj:`str`, optional
            Unit name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/units/{unit_name}/delete",
            {"unit_name": unit_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_unit(self_or_cls, unit_name: str, _dry_run: bool = False, _client: Any = None) -> Unit:
        """
        Get Unit

        Get a unit

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getUnit``: ``GET`` ``/api/v4/datastreams/units/{unit_name}/get``

        Parameters
        ----------
        unit_name : :obj:`str`, optional
            Unit name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/units/{unit_name}/get",
            {"unit_name": unit_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": Unit,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_unit(
        self_or_cls,
        unit_name: str,
        data: Optional[Union[requests.UnitUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Unit:
        """
        Update Unit

        Update a unit

        **Permission Required:** `kelvin.permission.datastreams.update`.

        ``updateUnit``: ``POST`` ``/api/v4/datastreams/units/{unit_name}/update``

        Parameters
        ----------
        unit_name : :obj:`str`, optional
            Unit name
        data: requests.UnitUpdate, optional
        **kwargs:
            Extra parameters for requests.UnitUpdate
              - symbol: str
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/units/{unit_name}/update",
            {"unit_name": unit_name},
            {},
            {},
            {},
            data,
            "requests.UnitUpdate",
            False,
            {
                "200": Unit,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_stream_name": "name"})
    def get_data_stream_context(
        self_or_cls, data_stream_name: str, _dry_run: bool = False, _client: Any = None
    ) -> DataStreamContext:
        """
        Get Data Stream Context

        Get a datastream context

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getDataStreamContext``: ``GET`` ``/api/v4/datastreams/{data_stream_name}/context/get``

        Parameters
        ----------
        data_stream_name : :obj:`str`, optional
            Data Stream name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/{data_stream_name}/context/get",
            {"data_stream_name": data_stream_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": DataStreamContext,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_stream_name": "name"})
    def delete_data_stream(
        self_or_cls, data_stream_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Data Stream

        Delete a datastream

        **Permission Required:** `kelvin.permission.datastreams.delete`.

        ``deleteDataStream``: ``POST`` ``/api/v4/datastreams/{data_stream_name}/delete``

        Parameters
        ----------
        data_stream_name : :obj:`str`, optional
            Data Stream name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/{data_stream_name}/delete",
            {"data_stream_name": data_stream_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_stream_name": "name"})
    def get_data_stream(
        self_or_cls, data_stream_name: str, _dry_run: bool = False, _client: Any = None
    ) -> DataStream:
        """
        Get Data Stream

        Get a datastream

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getDataStream``: ``GET`` ``/api/v4/datastreams/{data_stream_name}/get``

        Parameters
        ----------
        data_stream_name : :obj:`str`, optional
            Data Stream name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/{data_stream_name}/get",
            {"data_stream_name": data_stream_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": DataStream,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_stream_name": "name"})
    def update_data_stream(
        self_or_cls,
        data_stream_name: str,
        data: Optional[Union[requests.DataStreamUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> DataStream:
        """
        Update Data Stream

        Update a datastream

        **Permission Required:** `kelvin.permission.datastreams.update`.

        ``updateDataStream``: ``POST`` ``/api/v4/datastreams/{data_stream_name}/update``

        Parameters
        ----------
        data_stream_name : :obj:`str`, optional
            Data Stream name
        data: requests.DataStreamUpdate, optional
        **kwargs:
            Extra parameters for requests.DataStreamUpdate
              - description: str
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/{data_stream_name}/update",
            {"data_stream_name": data_stream_name},
            {},
            {},
            {},
            data,
            "requests.DataStreamUpdate",
            False,
            {
                "200": DataStream,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class DataStreamContext(DataModelBase):
    """
    DataStreamContext object.

    Parameters
    ----------
    context: Optional[List[Context]]
    created: Optional[datetime]
    datastream_name: Optional[str]
    updated: Optional[datetime]

    """

    context: Optional[List[Context]] = None
    created: Optional[datetime] = None
    datastream_name: Optional[str] = None
    updated: Optional[datetime] = None

    @classmethod
    def list_data_stream_contexts(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.DataStreamContextList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[DataStreamContext], DataStreamContextPaginated]:
        """
        List Data Stream Contexts

        **Pagination Sortable Columns:** `data_stream_name`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listDataStreamContexts``: ``POST`` ``/api/v4/datastreams/context/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `data_stream_name`.</p> The default is
            `data_stream_name`
        data: requests.DataStreamContextList, optional
        **kwargs:
            Extra parameters for requests.DataStreamContextList
              - datastream_names: list
              - resources: list
              - sources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/context/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.DataStreamContextList",
            False,
            {
                "200": DataStreamContextPaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/datastreams/context/list", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def get_data_stream_context(
        cls, data_stream_name: str, _dry_run: bool = False, _client: Any = None
    ) -> DataStreamContext:
        """
        Get Data Stream Context

        Get a datastream context

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getDataStreamContext``: ``GET`` ``/api/v4/datastreams/{data_stream_name}/context/get``

        Parameters
        ----------
        data_stream_name : :obj:`str`, optional
            Data Stream name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/{data_stream_name}/context/get",
            {"data_stream_name": data_stream_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": DataStreamContext,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result


class DataStreamContextPaginated(PaginatorDataModel[DataStreamContext]):
    """
    DataStreamContextPaginated object.

    Parameters
    ----------
    data: Optional[List[DataStreamContext]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[DataStreamContext]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class DataStreamsPaginated(PaginatorDataModel[DataStream]):
    """
    DataStreamsPaginated object.

    Parameters
    ----------
    data: Optional[List[DataStream]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[DataStream]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class DataType(DataModelBase):
    """
    DataType object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    schema_: Optional[Dict[str, Any]]
    title: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    name: Optional[str] = None
    schema_: Optional[Dict[str, Any]] = Field(None, alias="schema")
    title: Optional[str] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_data_type(
        self_or_cls,
        data: Optional[Union[requests.DataTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> DataType:
        """
        Create Data Type

        Create a data type

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``createDataType``: ``POST`` ``/api/v4/datastreams/data-types/create``

        Parameters
        ----------
        data: requests.DataTypeCreate, optional
        **kwargs:
            Extra parameters for requests.DataTypeCreate
              - name: str
              - schema: dict
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/data-types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.DataTypeCreate",
            False,
            {
                "201": DataType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_data_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[DataType], DataTypesPaginated]:
        """
        List Data Types

        **Pagination Sortable Columns:** `name`, `title`, `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listDataTypes``: ``GET`` ``/api/v4/datastreams/data-types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search data types by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/data-types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": DataTypesPaginated, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/data-types/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"data_type_name": "name"})
    def delete_data_type(
        self_or_cls, data_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Data Type

        Delete a data type

        **Permission Required:** `kelvin.permission.datastreams.delete`.

        ``deleteDataType``: ``POST`` ``/api/v4/datastreams/data-types/{data_type_name}/delete``

        Parameters
        ----------
        data_type_name : :obj:`str`, optional
            Data Type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/data-types/{data_type_name}/delete",
            {"data_type_name": data_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_type_name": "name"})
    def get_data_type(
        self_or_cls, data_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> DataType:
        """
        Get Data Type

        Get a data type

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getDataType``: ``GET`` ``/api/v4/datastreams/data-types/{data_type_name}/get``

        Parameters
        ----------
        data_type_name : :obj:`str`, optional
            Data Type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/data-types/{data_type_name}/get",
            {"data_type_name": data_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": DataType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_type_name": "name"})
    def update_data_type(
        self_or_cls,
        data_type_name: str,
        data: Optional[Union[requests.DataTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> DataType:
        """
        Update Data Type

        Update a data type

        **Permission Required:** `kelvin.permission.datastreams.update`.

        ``updateDataType``: ``POST`` ``/api/v4/datastreams/data-types/{data_type_name}/update``

        Parameters
        ----------
        data_type_name : :obj:`str`, optional
            Data Type name
        data: requests.DataTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.DataTypeUpdate
              - schema: dict
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/data-types/{data_type_name}/update",
            {"data_type_name": data_type_name},
            {},
            {},
            {},
            data,
            "requests.DataTypeUpdate",
            False,
            {
                "200": DataType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class DataTypesPaginated(PaginatorDataModel[DataType]):
    """
    DataTypesPaginated object.

    Parameters
    ----------
    data: Optional[List[DataType]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[DataType]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class ErrorMessage(DataModelBase):
    """
    ErrorMessage object.

    Parameters
    ----------
    error_code: Optional[int]
    http_status_code: Optional[int]
    message: Optional[List[str]]

    """

    error_code: Optional[int] = Field(
        None, description="Internal Kelvin error code (used for internal purposes)."
    )
    http_status_code: Optional[int] = Field(
        None, description="HTTP status error code.", example=400
    )
    message: Optional[List[str]] = Field(None, description="Detailed description of the error.")


class ErrorMessages(DataModelBase):
    """
    ErrorMessages object.

    Parameters
    ----------
    errors: Optional[List[ErrorMessage]]

    """

    errors: Optional[List[ErrorMessage]] = Field(
        None,
        description="Array of dictionary objects detailing all errors that were found in the request data.",
    )


class IODataStreamContext(DataModelBase):
    """
    IODataStreamContext object.

    Parameters
    ----------
    context: Optional[List[DSContext]]
    datastream_name: Optional[str]

    """

    context: Optional[List[DSContext]] = None
    datastream_name: Optional[str] = None


class InstanceHealthStatus(DataModelBase):
    """
    InstanceHealthStatus object.

    Parameters
    ----------
    components: Optional[List[ComponentStatus]]
    status: Optional[bool]

    """

    components: Optional[List[ComponentStatus]] = None
    status: Optional[bool] = None

    @classmethod
    def get_instance_health_status(
        cls, _dry_run: bool = False, _client: Any = None
    ) -> InstanceHealthStatus:
        """
        Get Instance Health Status

        **Permission Required:** `n/a`.

        ``getInstanceHealthStatus``: ``GET`` ``/api/v4/instance/status/get``

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/instance/status/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"201": InstanceHealthStatus, "400": ErrorMessages, "503": InstanceHealthStatus},
            False,
            _dry_run,
        )
        return result


class InstanceSettingItem(DataModelBase):
    """
    InstanceSettingItem object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    name: Optional[str] = Field(None, max_length=64)
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None

    @classmethod
    def get_app_manager_cluster_rules_instance_setting(
        cls, _dry_run: bool = False, _client: Any = None
    ) -> InstanceSettingItem:
        """
        Get App Manager Cluster Rules Instance Setting

        **Permission Required:** `kelvin.permission.instance.read`.

        ``getAppManagerClusterRulesInstanceSetting``: ``GET`` ``/api/v4/instance/settings/app-manager-planner-rules/get``

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/instance/settings/app-manager-planner-rules/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": InstanceSettingItem, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_app_manager_cluster_rules_instance_setting(
        self_or_cls,
        data: Optional[
            Union[requests.AppManagerClusterRuleInstanceSettingUpdate, Mapping[str, Any]]
        ] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> InstanceSettingItem:
        """
        Update App Manager Cluster Rules Instance Setting

        **Permission Required:** `kelvin.permission.instance.update`.

        ``updateAppManagerClusterRulesInstanceSetting``: ``POST`` ``/api/v4/instance/settings/app-manager-planner-rules/update``

        Parameters
        ----------
        data: requests.AppManagerClusterRuleInstanceSettingUpdate, optional
        **kwargs:
            Extra parameters for requests.AppManagerClusterRuleInstanceSettingUpdate
              - payload: str

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/instance/settings/app-manager-planner-rules/update",
            {},
            {},
            {},
            {},
            data,
            "requests.AppManagerClusterRuleInstanceSettingUpdate",
            False,
            {
                "200": InstanceSettingItem,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_kelvin_cluster_instance_setting(
        cls, _dry_run: bool = False, _client: Any = None
    ) -> InstanceSettingItem:
        """
        Get Kelvin Cluster Instance Setting

        **Permission Required:** `kelvin.permission.instance.read`.

        ``getKelvinClusterInstanceSetting``: ``GET`` ``/api/v4/instance/settings/kelvin-cluster/get``

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/instance/settings/kelvin-cluster/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": InstanceSettingItem, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_kelvin_cluster_instance_setting(
        self_or_cls,
        data: Optional[
            Union[requests.KelvinClusterInstanceSettingUpdate, Mapping[str, Any]]
        ] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> InstanceSettingItem:
        """
        Update Kelvin Cluster Instance Setting

        **Permission Required:** `kelvin.permission.instance.update`.

        ``updateKelvinClusterInstanceSetting``: ``POST`` ``/api/v4/instance/settings/kelvin-cluster/update``

        Parameters
        ----------
        data: requests.KelvinClusterInstanceSettingUpdate, optional
        **kwargs:
            Extra parameters for requests.KelvinClusterInstanceSettingUpdate
              - payload: str

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/instance/settings/kelvin-cluster/update",
            {},
            {},
            {},
            {},
            data,
            "requests.KelvinClusterInstanceSettingUpdate",
            False,
            {
                "200": InstanceSettingItem,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_instance_settings(
        cls,
        search: Optional[Sequence[str]] = None,
        names: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[InstanceSettingItem], InstanceSettingListPaginated]:
        """
        List Instance Settings

        **Permission Required:** `kelvin.permission.instance.read`.

        ``listInstanceSettings``: ``GET`` ``/api/v4/instance/settings/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search Instance Setting by name
        names : :obj:`Sequence[str]`
            Filter User Setting by setting_name
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the instance setting parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `created`,
            `updated`.</p> The default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/instance/settings/list",
            {},
            {
                "search": search,
                "names": names,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": InstanceSettingListPaginated, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/instance/settings/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def delete_instance_setting(
        cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Instance Setting

        **Permission Required:** `kelvin.permission.instance.delete`.

        ``deleteInstanceSetting``: ``POST`` ``/api/v4/instance/settings/{setting_name}/delete``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/instance/settings/{setting_name}/delete",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessage,
                "401": ErrorMessage,
                "403": ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_instance_setting(
        cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> InstanceSettingItem:
        """
        Get Instance Setting

        **Permission Required:** `kelvin.permission.instance.read`.

        ``getInstanceSetting``: ``GET`` ``/api/v4/instance/settings/{setting_name}/get``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/instance/settings/{setting_name}/get",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": InstanceSettingItem, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_instance_setting(
        self_or_cls,
        setting_name: str,
        data: Optional[Union[requests.InstanceSettingUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> InstanceSettingItem:
        """
        Update Instance Setting

        **Permission Required:** `kelvin.permission.instance.update`.

        ``updateInstanceSetting``: ``POST`` ``/api/v4/instance/settings/{setting_name}/update``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name
        data: requests.InstanceSettingUpdate, optional
        **kwargs:
            Extra parameters for requests.InstanceSettingUpdate
              - payload: dict

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/instance/settings/{setting_name}/update",
            {"setting_name": setting_name},
            {},
            {},
            {},
            data,
            "requests.InstanceSettingUpdate",
            False,
            {
                "200": InstanceSettingItem,
                "400": ErrorMessage,
                "401": ErrorMessage,
                "403": ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class InstanceSettingListPaginated(PaginatorDataModel[InstanceSettingItem]):
    """
    InstanceSettingListPaginated object.

    Parameters
    ----------
    data: Optional[List[InstanceSettingItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[InstanceSettingItem]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class ListAppVersionResumedPaginatedResponse(
    PaginatorDataModel[models.AppVersionResumedProjection]
):
    """
    ListAppVersionResumedPaginatedResponse object.

    Parameters
    ----------
    data: Optional[List[models.AppVersionResumedProjection]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[models.AppVersionResumedProjection]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class MappingItem(DataModelBase):
    """
    MappingItem object.

    Parameters
    ----------
    app: Optional[str]
    datastream: Optional[str]

    """

    app: Optional[str] = None
    datastream: Optional[str] = None


class Mappings(DataModelBase):
    """
    Mappings object.

    Parameters
    ----------
    inputs: Optional[List[MappingItem]]
    outputs: Optional[List[MappingItem]]

    """

    inputs: Optional[List[MappingItem]] = None
    outputs: Optional[List[MappingItem]] = None


class NetworkingAddressItem(DataModelBase):
    """
    NetworkingAddressItem object.

    Parameters
    ----------
    address: Optional[str]
    interface: Optional[str]
    port: Optional[int]

    """

    address: Optional[str] = None
    interface: Optional[str] = None
    port: Optional[int] = None


class NetworkingItem(DataModelBase):
    """
    NetworkingItem object.

    Parameters
    ----------
    addresses: Optional[List[NetworkingAddressItem]]
    name: Optional[str]
    protocol: Optional[str]

    """

    addresses: Optional[List[NetworkingAddressItem]] = None
    name: Optional[str] = None
    protocol: Optional[str] = None


class NodeConditionItem(DataModelBase):
    """
    NodeConditionItem object.

    Parameters
    ----------
    lastHeartbeatTime: Optional[str]
    lastTransitionTime: Optional[str]
    message: Optional[str]
    name: Optional[str]
    reason: Optional[str]
    status: Optional[str]
    status_message: Optional[str]
    type: Optional[str]

    """

    lastHeartbeatTime: Optional[str] = None
    lastTransitionTime: Optional[str] = None
    message: Optional[str] = None
    name: Optional[str] = None
    reason: Optional[str] = None
    status: Optional[str] = None
    status_message: Optional[str] = None
    type: Optional[str] = None


class NodeSystemInfo(DataModelBase):
    """
    NodeSystemInfo object.

    Parameters
    ----------
    architecture: Optional[str]
    boot_id: Optional[str]
    container_runtime_version: Optional[str]
    host_name: Optional[str]
    kernel_version: Optional[str]
    kube_proxy_version: Optional[str]
    kubelet_version: Optional[str]
    machine_id: Optional[str]
    operating_system: Optional[str]
    os_image: Optional[str]
    system_uuid: Optional[str]

    """

    architecture: Optional[str] = None
    boot_id: Optional[str] = None
    container_runtime_version: Optional[str] = None
    host_name: Optional[str] = None
    kernel_version: Optional[str] = None
    kube_proxy_version: Optional[str] = None
    kubelet_version: Optional[str] = None
    machine_id: Optional[str] = None
    operating_system: Optional[str] = None
    os_image: Optional[str] = None
    system_uuid: Optional[str] = None


class ParameterDefinitionItem(DataModelBase):
    """
    ParameterDefinitionItem object.

    Parameters
    ----------
    app_name: Optional[str]
    created: Optional[datetime]
    last_title: Optional[str]
    name: Optional[str]
    primitive_type: Optional[str]
    updated: Optional[datetime]

    """

    app_name: Optional[str] = Field(None, max_length=64)
    created: Optional[datetime] = None
    last_title: Optional[str] = Field(None, max_length=64)
    name: Optional[str] = Field(None, max_length=64)
    primitive_type: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None

    @classmethod
    def list_parameter_definitions(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ParameterDefinitionList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ParameterDefinitionItem], ParameterDefinitionListPaginated]:
        """
        List Parameter Definitions

        Lists all the parameter definitions.

        **Permission Required:** `kelvin.permission.parameter.read`.

        ``listParameterDefinitions``: ``POST`` ``/api/v4/parameters/definitions/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `name`, `app_name`,
            `primitive_type`, `last_title`, `created`, `updated`.</p> The default
            is `name`
        data: requests.ParameterDefinitionList, optional
        **kwargs:
            Extra parameters for requests.ParameterDefinitionList
              - app_names: list
              - names: list
              - primitive_types: list
              - search: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/parameters/definitions/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ParameterDefinitionList",
            False,
            {
                "200": ParameterDefinitionListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/parameters/definitions/list", "POST")
            if fetch and not _dry_run
            else result
        )


class ParameterDefinitionListPaginated(PaginatorDataModel[ParameterDefinitionItem]):
    """
    ParameterDefinitionListPaginated object.

    Parameters
    ----------
    data: Optional[List[ParameterDefinitionItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[ParameterDefinitionItem]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class ParameterGetSchema(DataModelBase):
    """
    ParameterGetSchema object.

    Parameters
    ----------
    additionalProperties: Optional[bool]
    properties: Optional[Dict[str, parameterschema.ParameterJSONSchemaProperties]]
    required: Optional[List[str]]
    type: Optional[str]

    """

    additionalProperties: Optional[bool] = None
    properties: Optional[Dict[str, parameterschema.ParameterJSONSchemaProperties]] = None
    required: Optional[List[str]] = None
    type: Optional[str] = Field(None, max_length=64)

    @classmethod
    def get_schema(
        cls, app_name: str, version: str, _dry_run: bool = False, _client: Any = None
    ) -> ParameterGetSchema:
        """
        Get Schema

        **Permission Required:** `kelvin.permission.parameter.read`.

        ``getSchema``: ``GET`` ``/api/v4/parameters/app/{app_name}/versions/{version}/schema/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/parameters/app/{app_name}/versions/{version}/schema/get",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ParameterGetSchema,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result


class ParameterValueItem(DataModelBase):
    """
    ParameterValueItem object.

    Parameters
    ----------
    app_name: Optional[str]
    app_version: Optional[str]
    comment: Optional[str]
    created: Optional[datetime]
    parameter_name: Optional[str]
    resource: Optional[str]
    source: Optional[str]
    updated: Optional[datetime]
    value: Optional[Any]

    """

    app_name: Optional[str] = Field(None, max_length=64)
    app_version: Optional[str] = Field(None, max_length=64)
    comment: Optional[str] = Field(None, max_length=200)
    created: Optional[datetime] = None
    parameter_name: Optional[str] = Field(None, max_length=64)
    resource: Optional[str] = Field(None, max_length=256)
    source: Optional[str] = Field(None, max_length=256)
    updated: Optional[datetime] = None
    value: Optional[Any] = None

    @classmethod
    def list_asset_app_version_parameters(
        cls,
        app_name: str,
        version: str,
        asset_name: str,
        search: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[ParameterValueItem], ResourceParameterListPaginated]:
        """
        List Asset App Version Parameters lists the app version asset parameters.

        **Permission Required:** `kelvin.permission.parameter.read`.

        ``listAssetAppVersionParameters``: ``GET`` ``/api/v4/parameters/app/{app_name}/versions/{version}/assets/{asset_name}/list``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        asset_name : :obj:`str`, optional
            Asset name
        search : :obj:`Sequence[str]`
            Search by parameter_name
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `parameter_name`, `app_name`,
            `app_version`, `resource`, `source`, `comment`, `created`,
            `updated`.</p> The default is `parameter_name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/parameters/app/{app_name}/versions/{version}/assets/{asset_name}/list",
            {"app_name": app_name, "version": version, "asset_name": asset_name},
            {
                "search": search,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": ResourceParameterListPaginated,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return (
            result.fetch(
                "/api/v4/parameters/app/{app_name}/versions/{version}/assets/{asset_name}/list",
                "GET",
            )
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def update_parameters(
        self_or_cls,
        app_name: str,
        version: str,
        asset_name: str,
        data: Optional[Union[requests.ParameterUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Update Parameters for given app Version asset.

        **Permission Required:** `kelvin.permission.parameter.update`.

        ``updateParameters``: ``POST`` ``/api/v4/parameters/app/{app_name}/versions/{version}/assets/{asset_name}/update``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        asset_name : :obj:`str`, optional
            Asset name
        data: requests.ParameterUpdate, optional
        **kwargs:
            Extra parameters for requests.ParameterUpdate
              - parameters: list
              - source: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/parameters/app/{app_name}/versions/{version}/assets/{asset_name}/update",
            {"app_name": app_name, "version": version, "asset_name": asset_name},
            {},
            {},
            {},
            data,
            "requests.ParameterUpdate",
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_bulk_parameters(
        self_or_cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.BulkParameterUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Update Bulk Parameters for given app version and list of assets.

        **Permission Required:** `kelvin.permission.parameter.update`.

        ``updateBulkParameters``: ``POST`` ``/api/v4/parameters/app/{app_name}/versions/{version}/update``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.BulkParameterUpdate, optional
        **kwargs:
            Extra parameters for requests.BulkParameterUpdate
              - resource_parameters: list
              - source: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/parameters/app/{app_name}/versions/{version}/update",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.BulkParameterUpdate",
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_resource_parameters(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ResourceParameterList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ParameterValueItem], ResourceParameterListPaginated]:
        """
        List Resource Parameters

        Returns the current parameters values for resources.

        **Permission Required:** `kelvin.permission.parameter.read`.

        ``listResourceParameters``: ``POST`` ``/api/v4/parameters/resources/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `parameter_name`, `app_name`,
            `app_version_name`, `resource`, `source`, `comment`, `created`,
            `updated`.</p> The default is `parameter_name`
        data: requests.ResourceParameterList, optional
        **kwargs:
            Extra parameters for requests.ResourceParameterList
              - apps: list
              - resources: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/parameters/resources/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ResourceParameterList",
            False,
            {
                "200": ResourceParameterListPaginated,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/parameters/resources/list", "POST")
            if fetch and not _dry_run
            else result
        )


class PlannerRulesResponse(DataModelBase):
    """
    PlannerRulesResponse object.

    Parameters
    ----------
    cluster: Optional[str]
    max_resources: Optional[int]

    """

    cluster: Optional[str] = None
    max_resources: Optional[int] = None

    @classmethod
    def get_app_planner_rules(
        cls, app_name: str, _dry_run: bool = False, _client: Any = None
    ) -> PlannerRulesResponse:
        """
        Get App Planner Rules

        **Permission Required:** `kelvin.permission.appmanager.read`.

        ``getAppPlannerRules``: ``GET`` ``/api/v4/app-manager/app/{app_name}/planner-rules/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/app-manager/app/{app_name}/planner-rules/get",
            {"app_name": app_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": PlannerRulesResponse,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_app_planner_rules(
        self_or_cls,
        app_name: str,
        data: Optional[Union[requests.PlannerRulesUpdateRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> PlannerRulesResponse:
        """
        Update App Planner Rules

        **Permission Required:** `kelvin.permission.appmanager.update`.

        ``updateAppPlannerRules``: ``POST`` ``/api/v4/app-manager/app/{app_name}/planner-rules/update``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        data: requests.PlannerRulesUpdateRequest, optional
        **kwargs:
            Extra parameters for requests.PlannerRulesUpdateRequest
              - cluster: str
              - max_resources: int

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/planner-rules/update",
            {"app_name": app_name},
            {},
            {},
            {},
            data,
            "requests.PlannerRulesUpdateRequest",
            False,
            {
                "200": PlannerRulesResponse,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class PrimitiveType(DataModelBase):
    """
    PrimitiveType object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    name: Optional[str] = None
    title: Optional[str] = None
    updated: Optional[datetime] = None

    @classmethod
    def list_primitive_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[PrimitiveType], PrimitiveTypesPaginated]:
        """
        List Primitive Types

        **Pagination Sortable Columns:** `name`, `title`, `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listPrimitiveTypes``: ``GET`` ``/api/v4/datastreams/primitive-types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search primitive types by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/primitive-types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": PrimitiveTypesPaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/primitive-types/list", "GET")
            if fetch and not _dry_run
            else result
        )


class PrimitiveTypesPaginated(PaginatorDataModel[PrimitiveType]):
    """
    PrimitiveTypesPaginated object.

    Parameters
    ----------
    data: Optional[List[PrimitiveType]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[PrimitiveType]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class PropertiesValues(DataModelBase):
    """
    PropertiesValues object.

    Parameters
    ----------
    properties: Optional[Dict[str, List[Dict[str, Any]]]]

    """

    properties: Optional[Dict[str, List[Dict[str, Any]]]] = None

    @classmethod
    def get_asset_properties_values(
        cls,
        data: Optional[Union[requests.PropertiesValuesGet, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> PropertiesValues:
        """
        Get Asset Properties Values

        Get a list of all unique values for each property.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetPropertiesValues``: ``POST`` ``/api/v4/assets/properties/values/get``

        Parameters
        ----------
        data: requests.PropertiesValuesGet, optional
        **kwargs:
            Extra parameters for requests.PropertiesValuesGet
              - primitive_types: list
              - property_names: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/properties/values/get",
            {},
            {},
            {},
            {},
            data,
            "requests.PropertiesValuesGet",
            False,
            {
                "200": PropertiesValues,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class Property(DataModelBase):
    """
    Property object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    primitive_type: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    name: Optional[str] = Field(None, max_length=64)
    primitive_type: Optional[str] = None
    title: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None

    @classmethod
    def list_asset_property_definitions(
        cls,
        all: Optional[bool] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.PropertyDefinitionList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[Property], PropertyListPaginated]:
        """
        List Asset Property Definitions

        **Permission Required:** `kelvin.permission.asset.read`.

        ``listAssetPropertyDefinitions``: ``POST`` ``/api/v4/assets/properties/definitions/list``

        Parameters
        ----------
        all : :obj:`bool`
            Parameter to define whether all properties will be returned or only
            those with values. Default is false.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`, `title`, `primitive_type`,
            `created`, `updated`.</p> The default is `name`
        data: requests.PropertyDefinitionList, optional
        **kwargs:
            Extra parameters for requests.PropertyDefinitionList
              - names: list
              - primitive_types: list
              - search: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/properties/definitions/list",
            {},
            {
                "all": all,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.PropertyDefinitionList",
            False,
            {
                "200": PropertyListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/assets/properties/definitions/list", "POST")
            if fetch and not _dry_run
            else result
        )


class PropertyListPaginated(PaginatorDataModel[Property]):
    """
    PropertyListPaginated object.

    Parameters
    ----------
    data: Optional[List[Property]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[Property]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class RecommendationClustering(DataModelBase):
    """
    RecommendationClustering object.

    Parameters
    ----------
    count: Optional[int]
    recommendations_ids: Optional[List[str]]
    time_bucket_start: Optional[datetime]

    """

    count: Optional[int] = Field(
        None,
        description="Number of occurrences of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> that meet the `dates`, `resources`, `state` and `type` stipulations within the time frame of one bucket starting from `time_bucket_start`.",
    )
    recommendations_ids: Optional[List[str]] = Field(
        None,
        description="An array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `id`s.</p> An `id` is made from a Universally Unique Identifier (UUID) and must be made only of hexadecimal numbers and the `-` character.</p> It is a unique identifier for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> and is a 128-bit identifier generated using random or pseudo-random numbers consisting of 32 hexadecimal digits separated by hyphens into five groups of varying lengths: 8-4-4-4-12.",
    )
    time_bucket_start: Optional[datetime] = Field(
        None,
        description='Time of the start of the bucket in ISO 8601 UTC date/time format. Example; "2023-07-08T08:41:01.657916Z".',
    )

    @classmethod
    def get_recommendation_clustering(
        cls,
        data: Optional[Union[requests.RecommendationClustering, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> List[RecommendationClustering]:
        """
        Get Recommendation Clustering

        Counts the number of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> matching an array of `resources` between two dates in buckets and also returns a list of all the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `id`s.

        Optionally a filter on the `types` and `states` can be applied.

        A bucket is defined as a unit of time such as seconds, minutes or hours. For example; <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> count could be grouped in hourly buckets between 12am and 12pm on a certain date.

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getRecommendationClustering``: ``POST`` ``/api/v4/recommendations/clustering/get``

        Parameters
        ----------
        data: requests.RecommendationClustering, optional
        **kwargs:
            Extra parameters for requests.RecommendationClustering
              - end_date: datetime
              - resource_names: list
              - sources: list
              - start_date: datetime
              - states: list
              - time_bucket: str
              - types: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/clustering/get",
            {},
            {},
            {},
            {},
            data,
            "requests.RecommendationClustering",
            False,
            {
                "200": List[RecommendationClustering],
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class RecommendationControlChange(DataModelBase):
    """
    RecommendationControlChange object.

    Parameters
    ----------
    control_change_id: Optional[str]
    expiration_date: Optional[str]
    payload: Optional[Any]
    resource: Optional[str]
    retry: Optional[int]
    timeout: Optional[int]
    trace_id: Optional[str]

    """

    control_change_id: Optional[str] = Field(
        None,
        description="Unique identifier id for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request.</p> This will only be returned when the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> state is `applied` where the actions have been created and an id registered in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.`",
    )
    expiration_date: Optional[str] = Field(
        None,
        description="Date/time when the Control Change request will fail and return a `failed` status if it has not been `applied` yet.</p> Values for a given point in time must be given in RFC3339 format. e.g. `2022-08-12T00:00:00.000000Z`.</p> The default value is calculated by the formulae <strong>Now + (`timeout` * ( `retry` + 1 ))</strong>.",
    )
    payload: Optional[Any] = Field(
        None,
        description="<a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> data to write to the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> pair.</p> Normally this is an object `{ \"value\": 88}`.",
    )
    resource: Optional[str] = Field(
        None,
        description="krn:am of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>// <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> pair.</p> This must contain only lowercase alphanumeric characters. The `.`, `_` and `-` characters are also allowed to separate words instead of a space BUT can not be at the beginning or end of the name.",
    )
    retry: Optional[int] = Field(
        None,
        description="How many times the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> Manager will try and send the same <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request to the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> before the change is tagged `failed` and no further attempts will be made.</p> The default value is 0.</p> If the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> sends a `processed` acknowledgment, then the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> Manager will stop any further retries and wait for an `applied` response.",
    )
    timeout: Optional[int] = Field(
        None,
        description="How long the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> Manager will wait in seconds for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> to send an `processed` acknowledgement before a retry will be attempted. If the total number of retries has reach its `retry` limit, then the change is tagged `failed` and no further attempts will be made.</p> The default is 300 seconds.",
    )
    trace_id: Optional[str] = Field(
        None,
        description="A Universally Unique Identifier (UUID) for this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a>.</p>It is a 128-bit identifier generated using random or pseudo-random numbers and consists of 32 hexadecimal digits separated by hyphens into five groups of varying lengths: 8-4-4-4-12.",
    )


class RecommendationLog(DataModelBase):
    """
    RecommendationLog object.

    Parameters
    ----------
    created_at: Optional[str]
    email_list: Optional[List[str]]
    message: Optional[str]
    source: Optional[str]
    state: Optional[str]

    """

    created_at: Optional[str] = Field(
        None,
        description="Time of creation of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )
    email_list: Optional[List[str]] = Field(None, description="Future feature")
    message: Optional[str] = Field(None, description="Log message")
    source: Optional[str] = Field(
        None,
        description="The user or workload that created this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> Log.<p> This string always starts with `krn:`, then has either `user:` or `api:` followed by the user name, email or api id.</p> For example `krn:user:my.name@company.com` or `krn:user:api:app-recommendation:4.0.0`.",
    )
    state: Optional[str] = Field(
        None,
        description="The state reported by the last status update for this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.</p> Possible options are; `pending`, `accepted`, `rejected`, `applied`, `expired` and `error`.",
    )


class RecommendationResponsePayload(DataModelBase):
    """
    RecommendationResponsePayload object.

    Parameters
    ----------
    message: Optional[str]
    success: Optional[bool]

    """

    message: Optional[str] = Field(
        None,
        description="If `success` is `true`, this contains a message of the action that has been performed.</p> If `success` is `false`, this contains information why it failed.",
    )
    success: Optional[bool] = Field(
        None,
        description="A boolean response to signify if the action was completed successfully.</p> `true` means the action succeeded and `false` means the action failed.",
    )

    @instance_classmethod
    @DataModelBase.translate()
    def update_accept_recommendation(
        self_or_cls,
        recommendation_id: str,
        data: Optional[Union[requests.RecommendationAccept, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationResponsePayload:
        """
        Update Accept Recommendation

        Update a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `state` to `accepted`.

        This will trigger the `actions` for the `control change` in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> to be created on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``updateAcceptRecommendation``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/accept/update``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.
        data: requests.RecommendationAccept, optional
        **kwargs:
            Extra parameters for requests.RecommendationAccept
              - confidence: int
              - message: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/accept/update",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            data,
            "requests.RecommendationAccept",
            False,
            {"200": RecommendationResponsePayload, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def delete_recommendation(
        cls, recommendation_id: str, _dry_run: bool = False, _client: Any = None
    ) -> RecommendationResponsePayload:
        """
        Delete Recommendation

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>. This cannot be undone once the API request has been submitted.

        <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> that have have a `state` value of `accepted`, `applied` or have `error` can not be deleted.

        **Permission Required:** `kelvin.permission.recommendation.delete`.

        ``deleteRecommendation``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/delete``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/delete",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": RecommendationResponsePayload, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_recommendation(
        cls, recommendation_id: str, _dry_run: bool = False, _client: Any = None
    ) -> Recommendation:
        """
        Get Recommendation

        Retrieves the properties, status and all associated actions of a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getRecommendation``: ``GET`` ``/api/v4/recommendations/{recommendation_id}/get``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/recommendations/{recommendation_id}/get",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Recommendation, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_log(
        self_or_cls,
        recommendation_id: str,
        data: Optional[Union[requests.RecommendationCreateLog, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Log

        Create a new log entry for a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>. An unlimited number of logs can be attached to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.

        This has no effect on the `state` of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``createLog``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/log/create``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.
        data: requests.RecommendationCreateLog, optional
        **kwargs:
            Extra parameters for requests.RecommendationCreateLog
              - message: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/log/create",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            data,
            "requests.RecommendationCreateLog",
            False,
            {"201": None, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_reject_recommendation(
        self_or_cls,
        recommendation_id: str,
        data: Optional[Union[requests.RecommendationReject, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationResponsePayload:
        """
        Update Reject Recommendation

        Update a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `state` to `rejected`.

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``updateRejectRecommendation``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/reject/update``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.
        data: requests.RecommendationReject, optional
        **kwargs:
            Extra parameters for requests.RecommendationReject
              - confidence: int
              - message: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/reject/update",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            data,
            "requests.RecommendationReject",
            False,
            {"200": RecommendationResponsePayload, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result


class RecommendationType(DataModelBase):
    """
    RecommendationType object.

    Parameters
    ----------
    created_at: Optional[str]
    description: Optional[str]
    name: Optional[str]
    title: Optional[str]
    updated_at: Optional[str]

    """

    created_at: Optional[str] = Field(
        None,
        description="Time of creation of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )
    description: Optional[str] = Field(
        None,
        description="Full description of the purpose for this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a>.",
    )
    name: Optional[str] = Field(
        None,
        description="Unique identifier name of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a>.",
    )
    title: Optional[str] = Field(
        None,
        description="Display name (title) of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a>.",
    )
    updated_at: Optional[str] = Field(
        None,
        description="Time of modifying any variable of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )

    @instance_classmethod
    @DataModelBase.translate()
    def create_recommendation_type(
        self_or_cls,
        data: Optional[Union[requests.RecommendationTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationType:
        """
        Create Recommendation Type

        Create a new Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.create`.

        ``createRecommendationType``: ``POST`` ``/api/v4/recommendations/types/create``

        Parameters
        ----------
        data: requests.RecommendationTypeCreate, optional
        **kwargs:
            Extra parameters for requests.RecommendationTypeCreate
              - description: str
              - name: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.RecommendationTypeCreate",
            False,
            {"201": RecommendationType, "400": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_recommendation_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[RecommendationType], RecommendationTypePaginated]:
        """
        List Recommendation Types

        Returns a dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a> objects on the Kelvin Platform.

        **Pagination Sortable Columns:** `name`, `title`, `description`, `created`, `updated`

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``listRecommendationTypes``: ``GET`` ``/api/v4/recommendations/types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search recommendation types by name or title

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/recommendations/types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": RecommendationTypePaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/recommendations/types/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def delete_recommendation_type(
        self_or_cls, name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Recommendation Type

        Delete a Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.delete`.

        ``deleteRecommendationType``: ``POST`` ``/api/v4/recommendations/types/{name}/delete``

        Parameters
        ----------
        name : :obj:`str`, optional
            Recommendation Type name

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/types/{name}/delete",
            {"name": name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "404": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_recommendation_type(
        self_or_cls, name: str, _dry_run: bool = False, _client: Any = None
    ) -> RecommendationType:
        """
        Get Recommendation Type

        Get a Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getRecommendationType``: ``GET`` ``/api/v4/recommendations/types/{name}/get``

        Parameters
        ----------
        name : :obj:`str`, optional
            Recommendation Type name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/recommendations/types/{name}/get",
            {"name": name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": RecommendationType, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_recommendation_type(
        self_or_cls,
        name: str,
        data: Optional[Union[requests.RecommendationTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationType:
        """
        Update Recommendation Type

        Update a Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``updateRecommendationType``: ``POST`` ``/api/v4/recommendations/types/{name}/update``

        Parameters
        ----------
        name : :obj:`str`, optional
            Recommendation Type name
        data: requests.RecommendationTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.RecommendationTypeUpdate
              - description: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/types/{name}/update",
            {"name": name},
            {},
            {},
            {},
            data,
            "requests.RecommendationTypeUpdate",
            False,
            {"200": RecommendationType, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result


class RecommendationTypePaginated(PaginatorDataModel[RecommendationType]):
    """
    RecommendationTypePaginated object.

    Parameters
    ----------
    data: Optional[List[RecommendationType]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[RecommendationType]] = Field(
        None,
        description="A dictionary which contains an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Types</a>.",
    )
    pagination: Optional[paginator.PaginationInfo] = None


class Resource(DataModelBase):
    """
    Resource object.

    Parameters
    ----------
    created: Optional[str]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[str]

    """

    created: Optional[str] = None
    name: Optional[str] = None
    title: Optional[str] = None
    updated: Optional[str] = None


class ResourceApp(DataModelBase):
    """
    ResourceApp object.

    Parameters
    ----------
    name: Optional[str]
    version: Optional[str]

    """

    name: Optional[str] = None
    version: Optional[str] = None


class ResourceAppStatus(DataModelBase):
    """
    ResourceAppStatus object.

    Parameters
    ----------
    last_seen: Optional[str]
    status: Optional[str]
    updated: Optional[str]
    updated_by: Optional[str]

    """

    last_seen: Optional[str] = None
    status: Optional[str] = None
    updated: Optional[str] = None
    updated_by: Optional[str] = None


class ResourceAppWorkload(DataModelBase):
    """
    ResourceAppWorkload object.

    Parameters
    ----------
    cluster: Optional[str]
    name: Optional[str]
    warnings: Optional[List[str]]

    """

    cluster: Optional[str] = None
    name: Optional[str] = None
    warnings: Optional[List[str]] = None


class ResourceParameterListPaginated(PaginatorDataModel[ParameterValueItem]):
    """
    ResourceParameterListPaginated object.

    Parameters
    ----------
    data: Optional[List[ParameterValueItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[ParameterValueItem]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class Secret(DataModelBase):
    """
    Secret object.

    Parameters
    ----------
    name: Optional[str]

    """

    name: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_secret(
        self_or_cls,
        data: Optional[Union[requests.SecretCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Secret:
        """
        Create Secret

        **Permission Required:** `kelvin.permission.secret.create`.

        ``createSecret``: ``POST`` ``/api/v4/secrets/create``

        Parameters
        ----------
        data: requests.SecretCreate, optional
        **kwargs:
            Extra parameters for requests.SecretCreate
              - name: str
              - value: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/secrets/create",
            {},
            {},
            {},
            {},
            data,
            "requests.SecretCreate",
            False,
            {"201": Secret, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_secret(
        cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = 10000,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        sort_asc: Optional[bool] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[Secret], SecretListPaginated]:
        """
        List Secret

        **Permission Required:** `kelvin.permission.secret.read`.

        ``listSecret``: ``GET`` ``/api/v4/secrets/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search secrets by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 1000. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination
        sort_asc : :obj:`bool`
            Order of sorting is Ascending. Possible Values: true/false. Default:
            true

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/secrets/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "sort_asc": sort_asc,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": SecretListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/secrets/list", "GET") if fetch and not _dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"secret_name": "name"})
    def delete_secret(
        self_or_cls, secret_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Secret

        **Permission Required:** `kelvin.permission.secret.delete`.

        ``deleteSecret``: ``POST`` ``/api/v4/secrets/{secret_name}/delete``

        Parameters
        ----------
        secret_name : :obj:`str`, optional
            Secret name

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/secrets/{secret_name}/delete",
            {"secret_name": secret_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class SecretListPaginated(PaginatorDataModel[Secret]):
    """
    SecretListPaginated object.

    Parameters
    ----------
    data: Optional[List[Secret]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[Secret]] = None
    pagination: Optional[pagination.Pagination] = None


class SemanticType(DataModelBase):
    """
    SemanticType object.

    Parameters
    ----------
    created: Optional[datetime]
    data_type_name: Optional[str]
    name: Optional[str]
    primitive_type_name: Optional[str]
    title: Optional[str]
    unit_names: Optional[List[str]]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    data_type_name: Optional[str] = None
    name: Optional[str] = None
    primitive_type_name: Optional[str] = None
    title: Optional[str] = None
    unit_names: Optional[List[str]] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_semantic_type(
        self_or_cls,
        data: Optional[Union[requests.SemanticTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> SemanticType:
        """
        Create Semantic Type

        Create a semantic type

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``createSemanticType``: ``POST`` ``/api/v4/datastreams/semantic-types/create``

        Parameters
        ----------
        data: requests.SemanticTypeCreate, optional
        **kwargs:
            Extra parameters for requests.SemanticTypeCreate
              - data_type_name: str
              - name: str
              - primitive_type_name: str
              - title: str
              - unit_names: list

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/semantic-types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.SemanticTypeCreate",
            False,
            {
                "201": SemanticType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_semantic_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[SemanticType], SemanticTypesPaginated]:
        """
        List Semantic Types

        **Pagination Sortable Columns:** `name`, `title`, `primitive_type_name`, `data_type_name` `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listSemanticTypes``: ``GET`` ``/api/v4/datastreams/semantic-types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`, `title`,`primitive_type_name`,
            `data_type_name`, `created`, `updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search semantic types by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/semantic-types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": SemanticTypesPaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/semantic-types/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"semantic_type_name": "name"})
    def delete_semantic_type(
        self_or_cls, semantic_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Semantic Type

        Delete a semantic type

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``deleteSemanticType``: ``POST`` ``/api/v4/datastreams/semantic-types/{semantic_type_name}/delete``

        Parameters
        ----------
        semantic_type_name : :obj:`str`, optional
            Semantic type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/semantic-types/{semantic_type_name}/delete",
            {"semantic_type_name": semantic_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"semantic_type_name": "name"})
    def get_semantic_type(
        self_or_cls, semantic_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> SemanticType:
        """
        Get Semantic Type

        Get a semantic type

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getSemanticType``: ``GET`` ``/api/v4/datastreams/semantic-types/{semantic_type_name}/get``

        Parameters
        ----------
        semantic_type_name : :obj:`str`, optional
            Semantic type name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/semantic-types/{semantic_type_name}/get",
            {"semantic_type_name": semantic_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": SemanticType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"semantic_type_name": "name"})
    def update_semantic_type(
        self_or_cls,
        semantic_type_name: str,
        data: Optional[Union[requests.SemanticTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> SemanticType:
        """
        Update Semantic Type

        Update a semantic type

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``updateSemanticType``: ``POST`` ``/api/v4/datastreams/semantic-types/{semantic_type_name}/update``

        Parameters
        ----------
        semantic_type_name : :obj:`str`, optional
            Semantic type name
        data: requests.SemanticTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.SemanticTypeUpdate
              - title: str
              - unit_names: list

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/semantic-types/{semantic_type_name}/update",
            {"semantic_type_name": semantic_type_name},
            {},
            {},
            {},
            data,
            "requests.SemanticTypeUpdate",
            False,
            {
                "201": SemanticType,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class SemanticTypesPaginated(PaginatorDataModel[SemanticType]):
    """
    SemanticTypesPaginated object.

    Parameters
    ----------
    data: Optional[List[SemanticType]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[SemanticType]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class ServiceItem(DataModelBase):
    """
    ServiceItem object.

    Parameters
    ----------
    address: Optional[str]
    created: Optional[datetime]
    name: Optional[str]
    network_interface: Optional[str]
    service_type: Optional[str]
    updated: Optional[datetime]
    workload_name: Optional[str]

    """

    address: Optional[str] = None
    created: Optional[datetime] = None
    name: Optional[str] = None
    network_interface: Optional[str] = None
    service_type: Optional[str] = None
    updated: Optional[datetime] = None
    workload_name: Optional[str] = None

    @classmethod
    def list_service(
        cls,
        cluster_name: str,
        search: Optional[Sequence[str]] = None,
        workload_name: Optional[Sequence[str]] = None,
        service_type: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[ServiceItem], ServiceListPaginated]:
        """
        List Service

        **Pagination Sortable Columns:** `name`, `workload_name`, `network_interface`, `service_type`, `address`, `created`, `updated`

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``listService``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/services/list``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster Name
        search : :obj:`Sequence[str]`
            Search Service by any field
        workload_name : :obj:`Sequence[str]`
            Filter Service by workload name
        service_type : :obj:`Sequence[str]`
            Filter Service by type: Possible values: `cluster_ip, node_port,
            host_port`
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of service objects to be returned. Page size can be between 1
            and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of services in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of services in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the service parameters. Only one parameter
            can be selected.</p> Allowed options: `name`, `workload_name`,
            `network_interface`, `service_type`, `address`, `created`,
            `updated`.</p> The default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/services/list",
            {"cluster_name": cluster_name},
            {
                "search": search,
                "workload_name": workload_name,
                "service_type": service_type,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ServiceListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/orchestration/clusters/{cluster_name}/services/list", "GET")
            if fetch and not _dry_run
            else result
        )


class ServiceListPaginated(PaginatorDataModel[ServiceItem]):
    """
    ServiceListPaginated object.

    Parameters
    ----------
    data: Optional[List[ServiceItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[ServiceItem]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class SimpleAsset(DataModelBase):
    """
    SimpleAsset object.

    Parameters
    ----------
    name: Optional[str]
    state: Optional[str]

    """

    name: Optional[str] = Field(
        None,
        description='Unique identifier name for this property in the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a>.</p> This must contain only lowercase alphanumeric characters. The `.`, `_` and `-` characters are also allowed to separate words instead of a space BUT can not be at the beginning or end of the name.',
    )
    state: Optional[str] = Field(
        None,
        description="Current status (state) of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>. There are four status options; `online`, `offline`, `partially_online` and `unknown`.",
    )


class TimeseriesPaginatedResponse(PaginatorDataModel[domain.TimeseriesProjection]):
    """
    TimeseriesPaginatedResponse object.

    Parameters
    ----------
    data: Optional[List[domain.TimeseriesProjection]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[domain.TimeseriesProjection]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class Unit(DataModelBase):
    """
    Unit object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    symbol: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    name: Optional[str] = None
    symbol: Optional[str] = None
    title: Optional[str] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_unit(
        self_or_cls,
        data: Optional[Union[requests.UnitCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Unit:
        """
        Create Unit

        Create a unit

        **Permission Required:** `kelvin.permission.datastreams.create`.

        ``createUnit``: ``POST`` ``/api/v4/datastreams/units/create``

        Parameters
        ----------
        data: requests.UnitCreate, optional
        **kwargs:
            Extra parameters for requests.UnitCreate
              - name: str
              - symbol: str
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/units/create",
            {},
            {},
            {},
            {},
            data,
            "requests.UnitCreate",
            False,
            {
                "201": Unit,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "409": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_units(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[Unit], UnitsPaginated]:
        """
        List Units

        **Pagination Sortable Columns:** `name`, `title`, `created`, `updated`

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``listUnits``: ``GET`` ``/api/v4/datastreams/units/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search units by name

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/units/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UnitsPaginated, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/datastreams/units/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"unit_name": "name"})
    def delete_unit(
        self_or_cls, unit_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Unit

        Delete a unit

        **Permission Required:** `kelvin.permission.datastreams.delete`.

        ``deleteUnit``: ``POST`` ``/api/v4/datastreams/units/{unit_name}/delete``

        Parameters
        ----------
        unit_name : :obj:`str`, optional
            Unit name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/units/{unit_name}/delete",
            {"unit_name": unit_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"unit_name": "name"})
    def get_unit(self_or_cls, unit_name: str, _dry_run: bool = False, _client: Any = None) -> Unit:
        """
        Get Unit

        Get a unit

        **Permission Required:** `kelvin.permission.datastreams.read`.

        ``getUnit``: ``GET`` ``/api/v4/datastreams/units/{unit_name}/get``

        Parameters
        ----------
        unit_name : :obj:`str`, optional
            Unit name

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/datastreams/units/{unit_name}/get",
            {"unit_name": unit_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": Unit,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"unit_name": "name"})
    def update_unit(
        self_or_cls,
        unit_name: str,
        data: Optional[Union[requests.UnitUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Unit:
        """
        Update Unit

        Update a unit

        **Permission Required:** `kelvin.permission.datastreams.update`.

        ``updateUnit``: ``POST`` ``/api/v4/datastreams/units/{unit_name}/update``

        Parameters
        ----------
        unit_name : :obj:`str`, optional
            Unit name
        data: requests.UnitUpdate, optional
        **kwargs:
            Extra parameters for requests.UnitUpdate
              - symbol: str
              - title: str

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/datastreams/units/{unit_name}/update",
            {"unit_name": unit_name},
            {},
            {},
            {},
            data,
            "requests.UnitUpdate",
            False,
            {
                "200": Unit,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
                "404": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class UnitsPaginated(PaginatorDataModel[Unit]):
    """
    UnitsPaginated object.

    Parameters
    ----------
    data: Optional[List[Unit]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[Unit]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class User(DataModelBase):
    """
    User object.

    Parameters
    ----------
    created: Optional[datetime]
    email: Optional[str]
    first_name: Optional[str]
    id: Optional[UUID]
    last_name: Optional[str]
    username: Optional[str]

    """

    created: Optional[datetime] = None
    email: Optional[str] = None
    first_name: Optional[str] = Field(None, max_length=64)
    id: Optional[UUID] = None
    last_name: Optional[str] = Field(None, max_length=64)
    username: Optional[str] = None

    @classmethod
    def list_user(
        cls,
        username: Optional[Sequence[str]] = None,
        email: Optional[Sequence[str]] = None,
        name: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = 10000,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_asc: Optional[bool] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[User], UserListPaginated]:
        """
        List User

        **Pagination Sortable Columns:** `user_entity.id`, `user_entity.username`, `user_entity.first_name`, `user_entity.last_name`, `user_entity.email`

        **Permission Required:** `kelvin.permission.users.read`.

        ``listUser``: ``GET`` ``/api/v4/users/list``

        Parameters
        ----------
        username : :obj:`Sequence[str]`
            User's username
        email : :obj:`Sequence[str]`
            User's email
        name : :obj:`Sequence[str]`
            User's name
        search : :obj:`Sequence[str]`
            Search Users by name or email
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 1000. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination
        sort_by : :obj:`str`
            Parameter to sort by. Must be one of the sortable columns
        sort_asc : :obj:`bool`
            Order of sorting is Ascending. Possible Values: true/false. Default:
            true

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/list",
            {},
            {
                "username": username,
                "email": email,
                "name": name,
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "sort_by": sort_by,
                "sort_asc": sort_asc,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UserListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/users/list", "GET") if fetch and not _dry_run else result

    @classmethod
    def get_current_user(cls, _dry_run: bool = False, _client: Any = None) -> UserWithPermissions:
        """
        Get Current User

        **Permission Required:** `n/a`.

        ``getCurrentUser``: ``GET`` ``/api/v4/users/me``

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/me",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": UserWithPermissions, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def list_user_settings(
        cls,
        search: Optional[Sequence[str]] = None,
        names: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[UserSettingItem], UserSettingsListPaginated]:
        """
        List User Settings

        **Permission Required:** `kelvin.permission.users.read`.

        ``listUserSettings``: ``GET`` ``/api/v4/users/settings/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search User Setting by setting_name
        names : :obj:`Sequence[str]`
            Filter User Setting by setting_name
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the user setting parameters. Only one
            parameter can be selected.</p> Allowed options: `setting_name`,
            `created`, `updated`.</p> The default is `setting_name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/settings/list",
            {},
            {
                "search": search,
                "names": names,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UserSettingsListPaginated, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/users/settings/list", "GET") if fetch and not _dry_run else result
        )

    @classmethod
    def delete_user_setting(
        cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete User Setting

        **Permission Required:** `kelvin.permission.users.delete`.

        ``deleteUserSetting``: ``POST`` ``/api/v4/users/settings/{setting_name}/delete``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/users/settings/{setting_name}/delete",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_user_setting(
        cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> UserSettingItem:
        """
        Get User Setting

        **Permission Required:** `kelvin.permission.users.read`.

        ``getUserSetting``: ``GET`` ``/api/v4/users/settings/{setting_name}/get``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/settings/{setting_name}/get",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": UserSettingItem, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def update_user_setting(
        cls,
        setting_name: str,
        data: Optional[Union[requests.UserSettingUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> UserSettingItem:
        """
        Update User Setting

        **Permission Required:** `kelvin.permission.users.update`.

        ``updateUserSetting``: ``POST`` ``/api/v4/users/settings/{setting_name}/update``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name
        data: requests.UserSettingUpdate, optional
        **kwargs:
            Extra parameters for requests.UserSettingUpdate
              - payload: dict

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/users/settings/{setting_name}/update",
            {"setting_name": setting_name},
            {},
            {},
            {},
            data,
            "requests.UserSettingUpdate",
            False,
            {
                "200": UserSettingItem,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"user_id": "id"})
    def get_user(self_or_cls, user_id: str, _dry_run: bool = False, _client: Any = None) -> User:
        """
        Get User

        **Permission Required:** `kelvin.permission.user.read`.

        ``getUser``: ``GET`` ``/api/v4/users/{user_id}/get``

        Parameters
        ----------
        user_id : :obj:`str`, optional
            User ID

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/users/{user_id}/get",
            {"user_id": user_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": User, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class UserFollow(DataModelBase):
    """
    UserFollow object.

    Parameters
    ----------
    mute: Optional[bool]
    seen: Optional[bool]

    """

    mute: Optional[bool] = None
    seen: Optional[bool] = None


class UserListPaginated(PaginatorDataModel[User]):
    """
    UserListPaginated object.

    Parameters
    ----------
    data: Optional[List[User]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[User]] = None
    pagination: Optional[pagination.Pagination] = None


class UserSettingItem(DataModelBase):
    """
    UserSettingItem object.

    Parameters
    ----------
    created: Optional[datetime]
    payload: Optional[Dict[str, Any]]
    setting_name: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    payload: Optional[Dict[str, Any]] = None
    setting_name: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None

    @classmethod
    def list_user_settings(
        cls,
        search: Optional[Sequence[str]] = None,
        names: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[UserSettingItem], UserSettingsListPaginated]:
        """
        List User Settings

        **Permission Required:** `kelvin.permission.users.read`.

        ``listUserSettings``: ``GET`` ``/api/v4/users/settings/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search User Setting by setting_name
        names : :obj:`Sequence[str]`
            Filter User Setting by setting_name
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the user setting parameters. Only one
            parameter can be selected.</p> Allowed options: `setting_name`,
            `created`, `updated`.</p> The default is `setting_name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/settings/list",
            {},
            {
                "search": search,
                "names": names,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UserSettingsListPaginated, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/users/settings/list", "GET") if fetch and not _dry_run else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def delete_user_setting(
        self_or_cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete User Setting

        **Permission Required:** `kelvin.permission.users.delete`.

        ``deleteUserSetting``: ``POST`` ``/api/v4/users/settings/{setting_name}/delete``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/users/settings/{setting_name}/delete",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_user_setting(
        self_or_cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> UserSettingItem:
        """
        Get User Setting

        **Permission Required:** `kelvin.permission.users.read`.

        ``getUserSetting``: ``GET`` ``/api/v4/users/settings/{setting_name}/get``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/users/settings/{setting_name}/get",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": UserSettingItem, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_user_setting(
        self_or_cls,
        setting_name: str,
        data: Optional[Union[requests.UserSettingUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> UserSettingItem:
        """
        Update User Setting

        **Permission Required:** `kelvin.permission.users.update`.

        ``updateUserSetting``: ``POST`` ``/api/v4/users/settings/{setting_name}/update``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name
        data: requests.UserSettingUpdate, optional
        **kwargs:
            Extra parameters for requests.UserSettingUpdate
              - payload: dict

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/users/settings/{setting_name}/update",
            {"setting_name": setting_name},
            {},
            {},
            {},
            data,
            "requests.UserSettingUpdate",
            False,
            {
                "200": UserSettingItem,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class UserSettingsListPaginated(PaginatorDataModel[UserSettingItem]):
    """
    UserSettingsListPaginated object.

    Parameters
    ----------
    data: Optional[List[UserSettingItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[UserSettingItem]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class UserWithPermissions(DataModelBase):
    """
    UserWithPermissions object.

    Parameters
    ----------
    created: Optional[datetime]
    email: Optional[str]
    first_name: Optional[str]
    id: Optional[UUID]
    last_name: Optional[str]
    permissions: Optional[List[str]]
    username: Optional[str]

    """

    created: Optional[datetime] = None
    email: Optional[str] = None
    first_name: Optional[str] = Field(None, max_length=64)
    id: Optional[UUID] = None
    last_name: Optional[str] = Field(None, max_length=64)
    permissions: Optional[List[str]] = None
    username: Optional[str] = None

    @classmethod
    def list_user(
        cls,
        username: Optional[Sequence[str]] = None,
        email: Optional[Sequence[str]] = None,
        name: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = 10000,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_asc: Optional[bool] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[User], UserListPaginated]:
        """
        List User

        **Pagination Sortable Columns:** `user_entity.id`, `user_entity.username`, `user_entity.first_name`, `user_entity.last_name`, `user_entity.email`

        **Permission Required:** `kelvin.permission.users.read`.

        ``listUser``: ``GET`` ``/api/v4/users/list``

        Parameters
        ----------
        username : :obj:`Sequence[str]`
            User's username
        email : :obj:`Sequence[str]`
            User's email
        name : :obj:`Sequence[str]`
            User's name
        search : :obj:`Sequence[str]`
            Search Users by name or email
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 1000. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination
        sort_by : :obj:`str`
            Parameter to sort by. Must be one of the sortable columns
        sort_asc : :obj:`bool`
            Order of sorting is Ascending. Possible Values: true/false. Default:
            true

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/list",
            {},
            {
                "username": username,
                "email": email,
                "name": name,
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "sort_by": sort_by,
                "sort_asc": sort_asc,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UserListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/users/list", "GET") if fetch and not _dry_run else result

    @classmethod
    def get_current_user(cls, _dry_run: bool = False, _client: Any = None) -> UserWithPermissions:
        """
        Get Current User

        **Permission Required:** `n/a`.

        ``getCurrentUser``: ``GET`` ``/api/v4/users/me``

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/me",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": UserWithPermissions, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def list_user_settings(
        cls,
        search: Optional[Sequence[str]] = None,
        names: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[UserSettingItem], UserSettingsListPaginated]:
        """
        List User Settings

        **Permission Required:** `kelvin.permission.users.read`.

        ``listUserSettings``: ``GET`` ``/api/v4/users/settings/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search User Setting by setting_name
        names : :obj:`Sequence[str]`
            Filter User Setting by setting_name
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the user setting parameters. Only one
            parameter can be selected.</p> Allowed options: `setting_name`,
            `created`, `updated`.</p> The default is `setting_name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/settings/list",
            {},
            {
                "search": search,
                "names": names,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UserSettingsListPaginated, "400": ErrorMessage, "401": ErrorMessage},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/users/settings/list", "GET") if fetch and not _dry_run else result
        )

    @classmethod
    def delete_user_setting(
        cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete User Setting

        **Permission Required:** `kelvin.permission.users.delete`.

        ``deleteUserSetting``: ``POST`` ``/api/v4/users/settings/{setting_name}/delete``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/users/settings/{setting_name}/delete",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_user_setting(
        cls, setting_name: str, _dry_run: bool = False, _client: Any = None
    ) -> UserSettingItem:
        """
        Get User Setting

        **Permission Required:** `kelvin.permission.users.read`.

        ``getUserSetting``: ``GET`` ``/api/v4/users/settings/{setting_name}/get``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/settings/{setting_name}/get",
            {"setting_name": setting_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": UserSettingItem, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def update_user_setting(
        cls,
        setting_name: str,
        data: Optional[Union[requests.UserSettingUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> UserSettingItem:
        """
        Update User Setting

        **Permission Required:** `kelvin.permission.users.update`.

        ``updateUserSetting``: ``POST`` ``/api/v4/users/settings/{setting_name}/update``

        Parameters
        ----------
        setting_name : :obj:`str`, optional
            Setting Name
        data: requests.UserSettingUpdate, optional
        **kwargs:
            Extra parameters for requests.UserSettingUpdate
              - payload: dict

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/users/settings/{setting_name}/update",
            {"setting_name": setting_name},
            {},
            {},
            {},
            data,
            "requests.UserSettingUpdate",
            False,
            {
                "200": UserSettingItem,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_user(cls, user_id: str, _dry_run: bool = False, _client: Any = None) -> User:
        """
        Get User

        **Permission Required:** `kelvin.permission.user.read`.

        ``getUser``: ``GET`` ``/api/v4/users/{user_id}/get``

        Parameters
        ----------
        user_id : :obj:`str`, optional
            User ID

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/users/{user_id}/get",
            {"user_id": user_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": User, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class WorkloadLogs(DataModelBase):
    """
    WorkloadLogs object.

    Parameters
    ----------
    logs: Optional[Dict[str, List[str]]]

    """

    logs: Optional[Dict[str, List[str]]] = None

    @classmethod
    def get_workload_logs(
        cls,
        workload_name: str,
        tail_lines: Optional[str] = None,
        since_time: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> WorkloadLogs:
        """
        Get Workload Logs

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadLogs``: ``GET`` ``/api/v4/workloads/{workload_name}/logs/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name
        tail_lines : :obj:`str`
            The number of lines from the end of the logs to show
        since_time : :obj:`str`
            A timestamp from which to show logs

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/{workload_name}/logs/get",
            {"workload_name": workload_name},
            {"tail_lines": tail_lines, "since_time": since_time},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WorkloadLogs,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "500": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result


class WorkloadStatus(DataModelBase):
    """
    WorkloadStatus object.

    Parameters
    ----------
    last_seen: Optional[datetime]
    message: Optional[str]
    state: Optional[str]
    warnings: Optional[List[str]]

    """

    last_seen: Optional[datetime] = None
    message: Optional[str] = None
    state: Optional[str] = None
    warnings: Optional[List[str]] = None


class App(DataModelBase):
    """
    App object.

    Parameters
    ----------
    created: Optional[datetime]
    description: Optional[str]
    latest_version: Optional[str]
    name: Optional[str]
    title: Optional[str]
    type: Optional[str]
    updated: Optional[datetime]
    versions: Optional[List[AppVersion]]

    """

    created: Optional[datetime] = None
    description: Optional[str] = None
    latest_version: Optional[str] = None
    name: Optional[str] = Field(None, max_length=64)
    title: Optional[str] = Field(None, max_length=64)
    type: Optional[str] = None
    updated: Optional[datetime] = None
    versions: Optional[List[AppVersion]] = None

    @classmethod
    def create_app(
        cls,
        data: Optional[Union[requests.AppCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> App:
        """
        Create App

        **Note:** If the App already exists, the App Version will be appended to the existing App

        **Permission Required:** `kelvin.permission.appregistry.create`.

        ``createApp``: ``POST`` ``/api/v4/appregistry/create``

        Parameters
        ----------
        data: requests.AppCreate, optional
        **kwargs:
            Extra parameters for requests.AppCreate
              - manifest: dict
              - payload: dict

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/appregistry/create",
            {},
            {},
            {},
            {},
            data,
            "requests.AppCreate",
            False,
            {"201": App, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_apps(
        cls,
        type: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[App], AppListPaginated]:
        """
        List Apps

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``listApps``: ``GET`` ``/api/v4/appregistry/list``

        Parameters
        ----------
        type : :obj:`Sequence[str]`
            Match the type field
        search : :obj:`Sequence[str]`
            Search Apps by name and title
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `name`, `title`, `type`,
            `latest_version`, `created`, `updated`.</p> The default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/appregistry/list",
            {},
            {
                "type": type,
                "search": search,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AppListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/appregistry/list", "GET") if fetch and not _dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def delete_app(self_or_cls, app_name: str, _dry_run: bool = False, _client: Any = None) -> None:
        """
        Delete App

        **Note:** Deleting an App will also delete all App Versions

        **Permission Required:** `kelvin.permission.appregistry.delete`.

        ``deleteApp``: ``POST`` ``/api/v4/appregistry/{app_name}/delete``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/appregistry/{app_name}/delete",
            {"app_name": app_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "412": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def get_app(self_or_cls, app_name: str, _dry_run: bool = False, _client: Any = None) -> App:
        """
        Get App

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getApp``: ``GET`` ``/api/v4/appregistry/{app_name}/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/appregistry/{app_name}/get",
            {"app_name": app_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": App, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def update_app(
        self_or_cls,
        app_name: str,
        data: Optional[Union[requests.AppUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> App:
        """
        Update App

        **Permission Required:** `kelvin.permission.appregistry.update`.

        ``updateApp``: ``POST`` ``/api/v4/appregistry/{app_name}/update``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        data: requests.AppUpdate, optional
        **kwargs:
            Extra parameters for requests.AppUpdate
              - description: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/appregistry/{app_name}/update",
            {"app_name": app_name},
            {},
            {},
            {},
            data,
            "requests.AppUpdate",
            False,
            {"200": App, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def delete_app_version(
        self_or_cls, app_name: str, app_version: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete App Version

        **Note:** This operation also deletes the associated Docker Image

        **Permission Required:** `kelvin.permission.appregistry.delete`.

        ``deleteAppVersion``: ``POST`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/delete``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/delete",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def get_app_version(
        self_or_cls, app_name: str, app_version: str, _dry_run: bool = False, _client: Any = None
    ) -> AppVersion:
        """
        Get App Version

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getAppVersion``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/get",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersion, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class AppListPaginated(PaginatorDataModel[App]):
    """
    AppListPaginated object.

    Parameters
    ----------
    data: Optional[List[App]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[App]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class Asset(DataModelBase):
    """
    Asset object.

    Parameters
    ----------
    asset_type_name: Optional[str]
    asset_type_title: Optional[str]
    created: Optional[datetime]
    name: Optional[str]
    properties: Optional[List[AssetProperty]]
    status: Optional[AssetStatusItem]
    title: Optional[str]
    updated: Optional[datetime]

    """

    asset_type_name: Optional[str] = Field(
        None,
        description='Unique identifier name of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> linked to this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
        max_length=64,
    )
    asset_type_title: Optional[str] = Field(
        None,
        description='Display name (title) of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> linked to this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
    )
    created: Optional[datetime] = Field(
        None,
        description='Time of creation of this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> in ISO 8601 UTC date/time format. Example; "2022-07-08T08:41:01.657916Z".',
    )
    name: Optional[str] = Field(
        None,
        description='Unique identifier name of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
        max_length=64,
    )
    properties: Optional[List[AssetProperty]] = Field(
        None,
        description='List of any custom properties for this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
    )
    status: Optional[AssetStatusItem] = None
    title: Optional[str] = Field(
        None,
        description='Display name (title) of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
        max_length=64,
    )
    updated: Optional[datetime] = Field(
        None,
        description='Time of modifying any variable of this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> in ISO 8601 UTC date/time format. Example; "2022-07-08T08:41:01.657916Z".',
    )

    @classmethod
    def create_bulk_asset(
        cls,
        dry_run: Optional[bool] = None,
        data: Optional[Union[requests.AssetCreateBulk, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Bulk Assets

        Create <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a>.

        To create any <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> you first need to create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset.create`.

        ``createBulkAsset``: ``POST`` ``/api/v4/assets/bulk/create``

        Parameters
        ----------
        dry_run : :obj:`bool`
            Dry run to check if the request is valid
        data: requests.AssetCreateBulk, optional
        **kwargs:
            Extra parameters for requests.AssetCreateBulk
              - assets: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/bulk/create",
            {},
            {"dry_run": dry_run},
            {},
            {},
            data,
            "requests.AssetCreateBulk",
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_asset(
        self_or_cls,
        data: Optional[Union[requests.AssetCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Asset:
        """
        Create Asset

        Create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.

        To create any <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> you first need to create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset.create`.

        ``createAsset``: ``POST`` ``/api/v4/assets/create``

        Parameters
        ----------
        data: requests.AssetCreate, optional
        **kwargs:
            Extra parameters for requests.AssetCreate
              - asset_type_name: str
              - name: str
              - properties: list
              - title: str

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/create",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetCreate",
            False,
            {
                "201": Asset,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def upload_assets(cls, file: str, _dry_run: bool = False, _client: Any = None) -> None:
        """
        Upload Assets

        Upload a csv (comma-separated values) file with up to 20,000 assets to add as <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> into the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>. Each row represents one <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>.

        The first row of the csv file needs to be the header of the columns. `NAME,DISPLAY NAME,ASSET TYPE`.

        Details of the options for each column are explained in this <a href='https://docs.kelvininc.com/latest/documentation/kelvin-platform/kelvin-manager-ui/management/assets/assets/#importing-assets-in-bulk' target='_blank'>Kelvin Documentation</a> link.

        The file needs to be saved in UTF-8 format with a comma separating each field. Do not use other separation options available in Microsoft Excel or Google Sheets such as semi-colons or colons. Strings in the csv file can be with or without quotation marks.

        **Permission Required:** `kelvin.permission.asset.create`.

        ``uploadAssets``: ``POST`` ``/api/v4/assets/create/upload``

        Parameters
        ----------
        file : :obj:`str`, optional
            Path and name of the CSV File to upload to the <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/overview/#kelvin-platform' target='_blank'>Kelvin
            Platform</a>.</p> You can download a blank copy of the template from
            the <a href='https://docs.kelvininc.com/latest/documentation/kelvin-
            platform/kelvin-manager-ui/control-manager-ui-overview/'
            target='_blank'>Kelvin Manager UI</a>. Instructions can be found in
            the <a href='https://docs.kelvininc.com/latest/documentation/kelvin-
            platform/kelvin-manager-ui/management/metrics/metrics/#1-download-the-
            assets-csv-template' target='_blank'>Kelvin Documentation</a>.

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/create/upload",
            {},
            {},
            {"file": file},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "412": CSVErrorMessage},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def delete_bulk_asset(
        cls,
        data: Optional[Union[requests.AssetDeleteBulk, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Bulk Asset

        Permanently delete a list of existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>. This cannot be undone once the API request has been submitted.

        **Permission Required:** `kelvin.permission.asset.delete`.

        ``deleteBulkAsset``: ``POST`` ``/api/v4/assets/delete``

        Parameters
        ----------
        data: requests.AssetDeleteBulk, optional
        **kwargs:
            Extra parameters for requests.AssetDeleteBulk
              - names: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/delete",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetDeleteBulk",
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_asset(
        cls,
        search: Optional[Sequence[str]] = None,
        names: Optional[Sequence[str]] = None,
        asset_type_name: Optional[Sequence[str]] = None,
        status_state: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[AssetItem], AssetListPaginated]:
        """
        List Asset

        Returns a dictionary with a data property containing a filtered array of all <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a> objects on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``listAsset``: ``GET`` ``/api/v4/assets/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search and filter the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> list. Both
            the Display Name and the Name will be included in the search field
            criteria. This is given as an array, for example `[pump,fan]`.</p> The
            search is case insensitive and will find partial matches as well. For
            example if a <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin
            Asset</a> name or display name is `centrifugal_pump`, then a match
            will be made if the search string is `pum` or `FUGaL`.
        names : :obj:`Sequence[str]`
            Filter on the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a> parameter `name`. This is given as an array, for example
            `[pump,fan]`.</p> The filter is done on the full name only according
            to unique identifier name rules (Must contain only lowercase
            alphanumeric characters. The `.`, `_` and `-` characters are also
            allowed to separate words instead of a space but not at the beginning
            or end).</p> For example a search with `[pump,fan]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> with the
            name `pump` but not with the names `pumps` or `centrifugal-fan`.
        asset_type_name : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> by its name. This is given as an array, for example
            `[pump,fan]`.</p> The filter is done on the full name only according
            to unique identifier name rules (Must contain only lowercase
            alphanumeric characters. The `.`, `_` and `-` characters are also
            allowed to separate words instead of a space but not at the beginning
            or end).</p> For example a filter with `[pump,fan]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> with the name `pump` but not with the names `pumps` or
            `centrifugal-fan`.
        status_state : :obj:`Sequence[str]`
            Filter <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a> by its current status. Multiple parameters can be given in
            an array, for example `[online,partially_online]` and will be filtered
            as `OR`.</p> There are four parameter options; `online`, `offline`,
            `partially_online` and `unknown`.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `asset_type_name`, `asset_type_title`, `status_state`,
            `status_last_seen`, `created`, `updated`.</p> The default is `name`

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/list",
            {},
            {
                "search": search,
                "names": names,
                "asset_type_name": asset_type_name,
                "status_state": status_state,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/assets/list", "GET") if fetch and not _dry_run else result

    @classmethod
    def list_asset_advanced(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.AssetList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[AssetItem], AssetListPaginated]:
        """
        List Asset Advanced

        Returns a dictionary with a data property containing a filtered array of all <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a> objects on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``listAssetAdvanced``: ``POST`` ``/api/v4/assets/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `asset_type_name`, `asset_type_title`, `status_state`,
            `status_last_seen`, `created`, `updated`.</p> The default is `name`
        data: requests.AssetList, optional
        **kwargs:
            Extra parameters for requests.AssetList
              - asset_type_name: list
              - names: list
              - search: list
              - status_state: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.AssetList",
            False,
            {
                "200": AssetListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result.fetch("/api/v4/assets/list", "POST") if fetch and not _dry_run else result

    @classmethod
    def list_asset_property_definitions(
        cls,
        all: Optional[bool] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.PropertyDefinitionList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[Property], PropertyListPaginated]:
        """
        List Asset Property Definitions

        **Permission Required:** `kelvin.permission.asset.read`.

        ``listAssetPropertyDefinitions``: ``POST`` ``/api/v4/assets/properties/definitions/list``

        Parameters
        ----------
        all : :obj:`bool`
            Parameter to define whether all properties will be returned or only
            those with values. Default is false.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`, `title`, `primitive_type`,
            `created`, `updated`.</p> The default is `name`
        data: requests.PropertyDefinitionList, optional
        **kwargs:
            Extra parameters for requests.PropertyDefinitionList
              - names: list
              - primitive_types: list
              - search: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/properties/definitions/list",
            {},
            {
                "all": all,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.PropertyDefinitionList",
            False,
            {
                "200": PropertyListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/assets/properties/definitions/list", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def get_asset_properties_values(
        cls,
        data: Optional[Union[requests.PropertiesValuesGet, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> PropertiesValues:
        """
        Get Asset Properties Values

        Get a list of all unique values for each property.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetPropertiesValues``: ``POST`` ``/api/v4/assets/properties/values/get``

        Parameters
        ----------
        data: requests.PropertiesValuesGet, optional
        **kwargs:
            Extra parameters for requests.PropertiesValuesGet
              - primitive_types: list
              - property_names: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/properties/values/get",
            {},
            {},
            {},
            {},
            data,
            "requests.PropertiesValuesGet",
            False,
            {
                "200": PropertiesValues,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_asset_status_count(
        cls, _dry_run: bool = False, _client: Any = None
    ) -> AssetStatusCount:
        """
        Get Asset Status Count

        Summary total count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> into four statuses.

        There are four status (state) values that can be returned; `online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all online and receiving information, `offline` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all offline, `partially_online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and some assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are online and receiving information and `unknown` where the status (state) has never received any data to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> and/or is not declared on any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> as a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetStatusCount``: ``GET`` ``/api/v4/assets/status/count/get``

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/status/count/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetStatusCount,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_asset_statuses(cls, _dry_run: bool = False, _client: Any = None) -> AssetStatus:
        """
        Get Asset Statuses

        Returns a list of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and the current status (state).

        There are four status (state) values that can be returned; `online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all online and receiving information, `offline` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all offline, `partially_online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and some assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are online and receiving information and `unknown` where the status (state) has never received any data to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> and/or is not declared on any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> as a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetStatuses``: ``GET`` ``/api/v4/assets/status/current/get``

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/status/current/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetStatus,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_asset_type(
        self_or_cls,
        data: Optional[Union[requests.AssetTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> AssetType:
        """
        Create Asset Type

        To create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> you first need to create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>. A <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> is directly linked to a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>. There can be many <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a> linked to one <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.create`.

        ``createAssetType``: ``POST`` ``/api/v4/assets/types/create``

        Parameters
        ----------
        data: requests.AssetTypeCreate, optional
        **kwargs:
            Extra parameters for requests.AssetTypeCreate
              - name: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetTypeCreate",
            False,
            {"201": AssetType, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def delete_bulk_asset_type(
        cls,
        data: Optional[Union[requests.AssetTypeDeleteBulk, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Bulk Asset Type

        Permanently delete a list of existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a>. This cannot be undone once the API request has been submitted.

        This command can not delete <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a> that are currently linked to any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and will return an error 403.

        **Permission Required:** `kelvin.permission.asset_type.delete`.

        ``deleteBulkAssetType``: ``POST`` ``/api/v4/assets/types/delete``

        Parameters
        ----------
        data: requests.AssetTypeDeleteBulk, optional
        **kwargs:
            Extra parameters for requests.AssetTypeDeleteBulk
              - names: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/delete",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetTypeDeleteBulk",
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_asset_type(
        cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[AssetType], AssetTypeListPaginated]:
        """
        List Asset Type

        Returns a filtered dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects on the Kelvin Platform that meet the criteria of any parameters passed with the API request.

        If no query parameters are given with the API request, then the defaults will be used to return the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> list.

        The defaults are the first 20 <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects returned in alphabetical order by the unique identifier name.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``listAssetType``: ``GET`` ``/api/v4/assets/types/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter on the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset-type'
            target='_blank'>Kelvin Asset Type</a> parameter `name`. This is given
            as an array, for example `[pump,fan]`.</p> The filter is done on the
            full name only according to unique identifier name rules (Must contain
            only lowercase alphanumeric characters. The `.`, `_` and `-`
            characters are also allowed to separate words instead of a space but
            not at the beginning or end).</p> For example a search with
            `[pump,fan]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> with the name `pump` but not with the names `pumps` or
            `centrifugal-fan`.
        search : :obj:`Sequence[str]`
            Search and filter the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> list. Both the Display Name and the Name will be included in
            the search field criteria. This is given as an array, for example
            `[pump,fan]`.</p> The search is case insensitive and will find partial
            matches as well. For example if a Kelvin Asset Type name is
            `centrifugal_pump`, then a match will be made if the search string is
            `pum` or `FUGaL`.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `created`, `updated`.</p> The default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/types/list",
            {},
            {
                "names": names,
                "search": search,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AssetTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/assets/types/list", "GET") if fetch and not _dry_run else result
        )

    @classmethod
    def list_asset_type_advanced(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.AssetTypeList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[AssetType], AssetTypeListPaginated]:
        """
        List Asset Type Advanced

        Returns a filtered dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects on the Kelvin Platform that meet the criteria of any parameters passed with the API request.

        If no query parameters are given with the API request, then the defaults will be used to return the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> list.

        The defaults are the first 20 <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects returned in alphabetical order by the unique identifier name.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``listAssetTypeAdvanced``: ``POST`` ``/api/v4/assets/types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `created`, `updated`.</p> The default is `name`
        data: requests.AssetTypeList, optional
        **kwargs:
            Extra parameters for requests.AssetTypeList
              - names: list
              - search: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.AssetTypeList",
            False,
            {"200": AssetTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/assets/types/list", "POST") if fetch and not _dry_run else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def delete_asset_type(
        self_or_cls, asset_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Asset Type

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a>. This cannot be undone once the API request has been submitted.

        This command can not delete <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a> that are currently linked to any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and will return an error 403.

        **Permission Required:** `kelvin.permission.asset_type.delete`.

        ``deleteAssetType``: ``POST`` ``/api/v4/assets/types/{asset_type_name}/delete``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to delete.</p> This is the unique identifier name and
            not the display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/{asset_type_name}/delete",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_asset_type(
        self_or_cls, asset_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> AssetType:
        """
        Get Asset Type

        Retrieves the properties of a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``getAssetType``: ``GET`` ``/api/v4/assets/types/{asset_type_name}/get``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to retrieve.</p> This is the unique identifier name and
            not the display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/assets/types/{asset_type_name}/get",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AssetType, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_asset_type(
        self_or_cls,
        asset_type_name: str,
        data: Optional[Union[requests.AssetTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> AssetType:
        """
        Update Asset Type

        Updates an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> with any new values passed through the body parameters.</p> All body parameters are optional and if not provided will remain unchanged.</p> Only the unique identifier name can not be changed. If you need to change this parameter, then you will need to make a new <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> and relink all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> to the new <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.update`.

        ``updateAssetType``: ``POST`` ``/api/v4/assets/types/{asset_type_name}/update``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to retrieve.</p> This is the unique identifier name and
            not the display name of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.
        data: requests.AssetTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.AssetTypeUpdate
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/{asset_type_name}/update",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            data,
            "requests.AssetTypeUpdate",
            False,
            {
                "200": AssetType,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "403": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_name": "name"})
    def delete_asset(
        self_or_cls, asset_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Asset

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>. This cannot be undone once the API request has been submitted.

        **Permission Required:** `kelvin.permission.asset.delete`.

        ``deleteAsset``: ``POST`` ``/api/v4/assets/{asset_name}/delete``

        Parameters
        ----------
        asset_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> name to
            delete.</p> This is the unique identifier name and not the display
            name (title) of the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/{asset_name}/delete",
            {"asset_name": asset_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_name": "name"})
    def get_asset(
        self_or_cls, asset_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Asset:
        """
        Get Asset

        Retrieve the properties of a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAsset``: ``GET`` ``/api/v4/assets/{asset_name}/get``

        Parameters
        ----------
        asset_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> name to
            retrieve.</p> This is the unique identifier name and not the display
            name (title) of the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/assets/{asset_name}/get",
            {"asset_name": asset_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": Asset,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_name": "name"})
    def update_asset(
        self_or_cls,
        asset_name: str,
        data: Optional[Union[requests.AssetUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Asset:
        """
        Update Asset

        Update an existing <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> with any new values passed through the body parameters.

        The minimum required in the body parameters is `title`. If this body parameter does not need to be changed, it should still have the original Display Name (title) given. Any other body parameters that are not required and not provided will remain unchanged.

        **Permission Required:** `kelvin.permission.asset.update`.

        ``updateAsset``: ``POST`` ``/api/v4/assets/{asset_name}/update``

        Parameters
        ----------
        asset_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-groups' target='_blank'>Kelvin Asset
            Group</a> or a <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin
            Asset</a> name at the top of the hierarchy. Even if the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a> is
            below the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset-groups'
            target='_blank'>Kelvin Asset Group</a>, the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a> name
            be used here.</p> This is the unique identifier name and not the
            display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>.
        data: requests.AssetUpdate, optional
        **kwargs:
            Extra parameters for requests.AssetUpdate
              - asset_type_name: str
              - properties: list
              - title: str

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/{asset_name}/update",
            {"asset_name": asset_name},
            {},
            {},
            {},
            data,
            "requests.AssetUpdate",
            False,
            {
                "200": Asset,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class AssetItem(DataModelBase):
    """
    AssetItem object.

    Parameters
    ----------
    asset_type_name: Optional[str]
    asset_type_title: Optional[str]
    created: Optional[datetime]
    name: Optional[str]
    properties: Optional[List[AssetProperty]]
    status: Optional[AssetStatusItem]
    title: Optional[str]
    updated: Optional[datetime]

    """

    asset_type_name: Optional[str] = Field(
        None,
        description='Unique identifier name of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> linked to this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
        max_length=64,
    )
    asset_type_title: Optional[str] = Field(
        None,
        description='Display name (title) of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a> linked to this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
    )
    created: Optional[datetime] = Field(
        None,
        description='Time of creation of this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> in ISO 8601 UTC date/time format. Example; "2022-07-08T08:41:01.657916Z".',
    )
    name: Optional[str] = Field(
        None,
        description='Unique identifier name of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
        max_length=64,
    )
    properties: Optional[List[AssetProperty]] = Field(
        None,
        description="Array of custom properties. These properties are not used by the Kelvin Platform and are for end-user use only.",
    )
    status: Optional[AssetStatusItem] = None
    title: Optional[str] = Field(
        None,
        description='Display name (title) of the <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.',
        max_length=64,
    )
    updated: Optional[datetime] = Field(
        None,
        description='Time of modifying any variable of this <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> in ISO 8601 UTC date/time format. Example; "2022-07-08T08:41:01.657916Z".',
    )

    @classmethod
    def create_bulk_asset(
        cls,
        dry_run: Optional[bool] = None,
        data: Optional[Union[requests.AssetCreateBulk, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Bulk Assets

        Create <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a>.

        To create any <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> you first need to create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset.create`.

        ``createBulkAsset``: ``POST`` ``/api/v4/assets/bulk/create``

        Parameters
        ----------
        dry_run : :obj:`bool`
            Dry run to check if the request is valid
        data: requests.AssetCreateBulk, optional
        **kwargs:
            Extra parameters for requests.AssetCreateBulk
              - assets: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/bulk/create",
            {},
            {"dry_run": dry_run},
            {},
            {},
            data,
            "requests.AssetCreateBulk",
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_asset(
        self_or_cls,
        data: Optional[Union[requests.AssetCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Asset:
        """
        Create Asset

        Create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a>.

        To create any <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> you first need to create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset.create`.

        ``createAsset``: ``POST`` ``/api/v4/assets/create``

        Parameters
        ----------
        data: requests.AssetCreate, optional
        **kwargs:
            Extra parameters for requests.AssetCreate
              - asset_type_name: str
              - name: str
              - properties: list
              - title: str

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/create",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetCreate",
            False,
            {
                "201": Asset,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def upload_assets(cls, file: str, _dry_run: bool = False, _client: Any = None) -> None:
        """
        Upload Assets

        Upload a csv (comma-separated values) file with up to 20,000 assets to add as <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> into the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>. Each row represents one <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>.

        The first row of the csv file needs to be the header of the columns. `NAME,DISPLAY NAME,ASSET TYPE`.

        Details of the options for each column are explained in this <a href='https://docs.kelvininc.com/latest/documentation/kelvin-platform/kelvin-manager-ui/management/assets/assets/#importing-assets-in-bulk' target='_blank'>Kelvin Documentation</a> link.

        The file needs to be saved in UTF-8 format with a comma separating each field. Do not use other separation options available in Microsoft Excel or Google Sheets such as semi-colons or colons. Strings in the csv file can be with or without quotation marks.

        **Permission Required:** `kelvin.permission.asset.create`.

        ``uploadAssets``: ``POST`` ``/api/v4/assets/create/upload``

        Parameters
        ----------
        file : :obj:`str`, optional
            Path and name of the CSV File to upload to the <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/overview/#kelvin-platform' target='_blank'>Kelvin
            Platform</a>.</p> You can download a blank copy of the template from
            the <a href='https://docs.kelvininc.com/latest/documentation/kelvin-
            platform/kelvin-manager-ui/control-manager-ui-overview/'
            target='_blank'>Kelvin Manager UI</a>. Instructions can be found in
            the <a href='https://docs.kelvininc.com/latest/documentation/kelvin-
            platform/kelvin-manager-ui/management/metrics/metrics/#1-download-the-
            assets-csv-template' target='_blank'>Kelvin Documentation</a>.

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/create/upload",
            {},
            {},
            {"file": file},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "412": CSVErrorMessage},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def delete_bulk_asset(
        cls,
        data: Optional[Union[requests.AssetDeleteBulk, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Bulk Asset

        Permanently delete a list of existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>. This cannot be undone once the API request has been submitted.

        **Permission Required:** `kelvin.permission.asset.delete`.

        ``deleteBulkAsset``: ``POST`` ``/api/v4/assets/delete``

        Parameters
        ----------
        data: requests.AssetDeleteBulk, optional
        **kwargs:
            Extra parameters for requests.AssetDeleteBulk
              - names: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/delete",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetDeleteBulk",
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_asset(
        cls,
        search: Optional[Sequence[str]] = None,
        names: Optional[Sequence[str]] = None,
        asset_type_name: Optional[Sequence[str]] = None,
        status_state: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[AssetItem], AssetListPaginated]:
        """
        List Asset

        Returns a dictionary with a data property containing a filtered array of all <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a> objects on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``listAsset``: ``GET`` ``/api/v4/assets/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search and filter the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> list. Both
            the Display Name and the Name will be included in the search field
            criteria. This is given as an array, for example `[pump,fan]`.</p> The
            search is case insensitive and will find partial matches as well. For
            example if a <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin
            Asset</a> name or display name is `centrifugal_pump`, then a match
            will be made if the search string is `pum` or `FUGaL`.
        names : :obj:`Sequence[str]`
            Filter on the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a> parameter `name`. This is given as an array, for example
            `[pump,fan]`.</p> The filter is done on the full name only according
            to unique identifier name rules (Must contain only lowercase
            alphanumeric characters. The `.`, `_` and `-` characters are also
            allowed to separate words instead of a space but not at the beginning
            or end).</p> For example a search with `[pump,fan]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> with the
            name `pump` but not with the names `pumps` or `centrifugal-fan`.
        asset_type_name : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> by its name. This is given as an array, for example
            `[pump,fan]`.</p> The filter is done on the full name only according
            to unique identifier name rules (Must contain only lowercase
            alphanumeric characters. The `.`, `_` and `-` characters are also
            allowed to separate words instead of a space but not at the beginning
            or end).</p> For example a filter with `[pump,fan]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> with the name `pump` but not with the names `pumps` or
            `centrifugal-fan`.
        status_state : :obj:`Sequence[str]`
            Filter <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a> by its current status. Multiple parameters can be given in
            an array, for example `[online,partially_online]` and will be filtered
            as `OR`.</p> There are four parameter options; `online`, `offline`,
            `partially_online` and `unknown`.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `asset_type_name`, `asset_type_title`, `status_state`,
            `status_last_seen`, `created`, `updated`.</p> The default is `name`

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/list",
            {},
            {
                "search": search,
                "names": names,
                "asset_type_name": asset_type_name,
                "status_state": status_state,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/assets/list", "GET") if fetch and not _dry_run else result

    @classmethod
    def list_asset_advanced(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.AssetList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[AssetItem], AssetListPaginated]:
        """
        List Asset Advanced

        Returns a dictionary with a data property containing a filtered array of all <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a> objects on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``listAssetAdvanced``: ``POST`` ``/api/v4/assets/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `asset_type_name`, `asset_type_title`, `status_state`,
            `status_last_seen`, `created`, `updated`.</p> The default is `name`
        data: requests.AssetList, optional
        **kwargs:
            Extra parameters for requests.AssetList
              - asset_type_name: list
              - names: list
              - search: list
              - status_state: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.AssetList",
            False,
            {
                "200": AssetListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result.fetch("/api/v4/assets/list", "POST") if fetch and not _dry_run else result

    @classmethod
    def list_asset_property_definitions(
        cls,
        all: Optional[bool] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.PropertyDefinitionList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[Property], PropertyListPaginated]:
        """
        List Asset Property Definitions

        **Permission Required:** `kelvin.permission.asset.read`.

        ``listAssetPropertyDefinitions``: ``POST`` ``/api/v4/assets/properties/definitions/list``

        Parameters
        ----------
        all : :obj:`bool`
            Parameter to define whether all properties will be returned or only
            those with values. Default is false.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`, `title`, `primitive_type`,
            `created`, `updated`.</p> The default is `name`
        data: requests.PropertyDefinitionList, optional
        **kwargs:
            Extra parameters for requests.PropertyDefinitionList
              - names: list
              - primitive_types: list
              - search: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/properties/definitions/list",
            {},
            {
                "all": all,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.PropertyDefinitionList",
            False,
            {
                "200": PropertyListPaginated,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/assets/properties/definitions/list", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def get_asset_properties_values(
        cls,
        data: Optional[Union[requests.PropertiesValuesGet, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> PropertiesValues:
        """
        Get Asset Properties Values

        Get a list of all unique values for each property.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetPropertiesValues``: ``POST`` ``/api/v4/assets/properties/values/get``

        Parameters
        ----------
        data: requests.PropertiesValuesGet, optional
        **kwargs:
            Extra parameters for requests.PropertiesValuesGet
              - primitive_types: list
              - property_names: list

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/properties/values/get",
            {},
            {},
            {},
            {},
            data,
            "requests.PropertiesValuesGet",
            False,
            {
                "200": PropertiesValues,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_asset_status_count(
        cls, _dry_run: bool = False, _client: Any = None
    ) -> AssetStatusCount:
        """
        Get Asset Status Count

        Summary total count of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> into four statuses.

        There are four status (state) values that can be returned; `online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all online and receiving information, `offline` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all offline, `partially_online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and some assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are online and receiving information and `unknown` where the status (state) has never received any data to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> and/or is not declared on any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> as a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetStatusCount``: ``GET`` ``/api/v4/assets/status/count/get``

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/status/count/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetStatusCount,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_asset_statuses(cls, _dry_run: bool = False, _client: Any = None) -> AssetStatus:
        """
        Get Asset Statuses

        Returns a list of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and the current status (state).

        There are four status (state) values that can be returned; `online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all online and receiving information, `offline` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all offline, `partially_online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and some assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are online and receiving information and `unknown` where the status (state) has never received any data to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> and/or is not declared on any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> as a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetStatuses``: ``GET`` ``/api/v4/assets/status/current/get``

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/status/current/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetStatus,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_asset_type(
        self_or_cls,
        data: Optional[Union[requests.AssetTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> AssetType:
        """
        Create Asset Type

        To create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> you first need to create a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>. A <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> is directly linked to a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>. There can be many <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Assets</a> linked to one <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.create`.

        ``createAssetType``: ``POST`` ``/api/v4/assets/types/create``

        Parameters
        ----------
        data: requests.AssetTypeCreate, optional
        **kwargs:
            Extra parameters for requests.AssetTypeCreate
              - name: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetTypeCreate",
            False,
            {"201": AssetType, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def delete_bulk_asset_type(
        cls,
        data: Optional[Union[requests.AssetTypeDeleteBulk, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Bulk Asset Type

        Permanently delete a list of existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a>. This cannot be undone once the API request has been submitted.

        This command can not delete <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a> that are currently linked to any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and will return an error 403.

        **Permission Required:** `kelvin.permission.asset_type.delete`.

        ``deleteBulkAssetType``: ``POST`` ``/api/v4/assets/types/delete``

        Parameters
        ----------
        data: requests.AssetTypeDeleteBulk, optional
        **kwargs:
            Extra parameters for requests.AssetTypeDeleteBulk
              - names: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/delete",
            {},
            {},
            {},
            {},
            data,
            "requests.AssetTypeDeleteBulk",
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_asset_type(
        cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[AssetType], AssetTypeListPaginated]:
        """
        List Asset Type

        Returns a filtered dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects on the Kelvin Platform that meet the criteria of any parameters passed with the API request.

        If no query parameters are given with the API request, then the defaults will be used to return the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> list.

        The defaults are the first 20 <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects returned in alphabetical order by the unique identifier name.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``listAssetType``: ``GET`` ``/api/v4/assets/types/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter on the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset-type'
            target='_blank'>Kelvin Asset Type</a> parameter `name`. This is given
            as an array, for example `[pump,fan]`.</p> The filter is done on the
            full name only according to unique identifier name rules (Must contain
            only lowercase alphanumeric characters. The `.`, `_` and `-`
            characters are also allowed to separate words instead of a space but
            not at the beginning or end).</p> For example a search with
            `[pump,fan]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> with the name `pump` but not with the names `pumps` or
            `centrifugal-fan`.
        search : :obj:`Sequence[str]`
            Search and filter the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> list. Both the Display Name and the Name will be included in
            the search field criteria. This is given as an array, for example
            `[pump,fan]`.</p> The search is case insensitive and will find partial
            matches as well. For example if a Kelvin Asset Type name is
            `centrifugal_pump`, then a match will be made if the search string is
            `pum` or `FUGaL`.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `created`, `updated`.</p> The default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/types/list",
            {},
            {
                "names": names,
                "search": search,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AssetTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/assets/types/list", "GET") if fetch and not _dry_run else result
        )

    @classmethod
    def list_asset_type_advanced(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.AssetTypeList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[AssetType], AssetTypeListPaginated]:
        """
        List Asset Type Advanced

        Returns a filtered dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects on the Kelvin Platform that meet the criteria of any parameters passed with the API request.

        If no query parameters are given with the API request, then the defaults will be used to return the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> list.

        The defaults are the first 20 <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> objects returned in alphabetical order by the unique identifier name.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``listAssetTypeAdvanced``: ``POST`` ``/api/v4/assets/types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the asset type parameters. Only one
            parameter can be selected.</p> Allowed options: `name`, `title`,
            `created`, `updated`.</p> The default is `name`
        data: requests.AssetTypeList, optional
        **kwargs:
            Extra parameters for requests.AssetTypeList
              - names: list
              - search: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.AssetTypeList",
            False,
            {"200": AssetTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/assets/types/list", "POST") if fetch and not _dry_run else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def delete_asset_type(
        self_or_cls, asset_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Asset Type

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a>. This cannot be undone once the API request has been submitted.

        This command can not delete <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Types</a> that are currently linked to any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and will return an error 403.

        **Permission Required:** `kelvin.permission.asset_type.delete`.

        ``deleteAssetType``: ``POST`` ``/api/v4/assets/types/{asset_type_name}/delete``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to delete.</p> This is the unique identifier name and
            not the display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/{asset_type_name}/delete",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_asset_type(
        self_or_cls, asset_type_name: str, _dry_run: bool = False, _client: Any = None
    ) -> AssetType:
        """
        Get Asset Type

        Retrieves the properties of a <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type" target="_blank">Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.read`.

        ``getAssetType``: ``GET`` ``/api/v4/assets/types/{asset_type_name}/get``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to retrieve.</p> This is the unique identifier name and
            not the display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/assets/types/{asset_type_name}/get",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AssetType, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_asset_type(
        self_or_cls,
        asset_type_name: str,
        data: Optional[Union[requests.AssetTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> AssetType:
        """
        Update Asset Type

        Updates an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> with any new values passed through the body parameters.</p> All body parameters are optional and if not provided will remain unchanged.</p> Only the unique identifier name can not be changed. If you need to change this parameter, then you will need to make a new <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a> and relink all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> to the new <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset Type</a>.

        **Permission Required:** `kelvin.permission.asset_type.update`.

        ``updateAssetType``: ``POST`` ``/api/v4/assets/types/{asset_type_name}/update``

        Parameters
        ----------
        asset_type_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a> name to retrieve.</p> This is the unique identifier name and
            not the display name of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-type' target='_blank'>Kelvin Asset
            Type</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.
        data: requests.AssetTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.AssetTypeUpdate
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/types/{asset_type_name}/update",
            {"asset_type_name": asset_type_name},
            {},
            {},
            {},
            data,
            "requests.AssetTypeUpdate",
            False,
            {
                "200": AssetType,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "403": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_name": "name"})
    def delete_asset(
        self_or_cls, asset_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Asset

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>. This cannot be undone once the API request has been submitted.

        **Permission Required:** `kelvin.permission.asset.delete`.

        ``deleteAsset``: ``POST`` ``/api/v4/assets/{asset_name}/delete``

        Parameters
        ----------
        asset_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> name to
            delete.</p> This is the unique identifier name and not the display
            name (title) of the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/{asset_name}/delete",
            {"asset_name": asset_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_name": "name"})
    def get_asset(
        self_or_cls, asset_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Asset:
        """
        Get Asset

        Retrieve the properties of a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAsset``: ``GET`` ``/api/v4/assets/{asset_name}/get``

        Parameters
        ----------
        asset_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> name to
            retrieve.</p> This is the unique identifier name and not the display
            name (title) of the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Asset</a>.</p> This must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space BUT can not be at the beginning or
            end of the name.

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/assets/{asset_name}/get",
            {"asset_name": asset_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": Asset,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"asset_name": "name"})
    def update_asset(
        self_or_cls,
        asset_name: str,
        data: Optional[Union[requests.AssetUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Asset:
        """
        Update Asset

        Update an existing <a href="https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/" target="_blank">Kelvin Asset</a> with any new values passed through the body parameters.

        The minimum required in the body parameters is `title`. If this body parameter does not need to be changed, it should still have the original Display Name (title) given. Any other body parameters that are not required and not provided will remain unchanged.

        **Permission Required:** `kelvin.permission.asset.update`.

        ``updateAsset``: ``POST`` ``/api/v4/assets/{asset_name}/update``

        Parameters
        ----------
        asset_name : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset-groups' target='_blank'>Kelvin Asset
            Group</a> or a <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin
            Asset</a> name at the top of the hierarchy. Even if the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a> is
            below the <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/#asset-groups'
            target='_blank'>Kelvin Asset Group</a>, the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a> name
            be used here.</p> This is the unique identifier name and not the
            display name (title) of the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Asset</a>.
        data: requests.AssetUpdate, optional
        **kwargs:
            Extra parameters for requests.AssetUpdate
              - asset_type_name: str
              - properties: list
              - title: str

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/assets/{asset_name}/update",
            {"asset_name": asset_name},
            {},
            {},
            {},
            data,
            "requests.AssetUpdate",
            False,
            {
                "200": Asset,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
                "412": errors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class AssetListPaginated(PaginatorDataModel[AssetItem]):
    """
    AssetListPaginated object.

    Parameters
    ----------
    data: Optional[List[AssetItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[AssetItem]] = Field(
        None,
        description="A dictionary which contains an array of up to `page_size` <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>. If a bookmark has been used, then the array will start or end based on the `starting_after` or `ending_before` parameters.",
    )
    pagination: Optional[paginator.PaginationInfo] = None


class AssetStatus(DataModelBase):
    """
    AssetStatus object.

    Parameters
    ----------
    data: Optional[List[SimpleAsset]]

    """

    data: Optional[List[SimpleAsset]] = Field(
        None,
        description="Array of dictionary objects of the status of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.",
    )

    @classmethod
    def get_asset_statuses(cls, _dry_run: bool = False, _client: Any = None) -> AssetStatus:
        """
        Get Asset Statuses

        Returns a list of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and the current status (state).

        There are four status (state) values that can be returned; `online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all online and receiving information, `offline` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and all assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are all offline, `partially_online` where the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> and some assets below in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset-hierarchy' target='_blank'>hierarchy</a> (if applicable) are online and receiving information and `unknown` where the status (state) has never received any data to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> and/or is not declared on any <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> as a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.asset.read`.

        ``getAssetStatuses``: ``GET`` ``/api/v4/assets/status/current/get``

        """

        from . import errors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/assets/status/current/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": AssetStatus,
                "400": errors.ErrorMessage,
                "401": errors.ErrorMessage,
                "404": errors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return result


class Bridge(DataModelBase):
    """
    Bridge object.

    Parameters
    ----------
    cluster_name: Optional[str]
    created: Optional[datetime]
    enabled: Optional[bool]
    name: Optional[str]
    node_name: Optional[str]
    payload: Optional[Dict[str, Any]]
    protocol: Optional[str]
    status: Optional[WorkloadStatus]
    title: Optional[str]
    updated: Optional[datetime]
    workload_name: Optional[str]

    """

    cluster_name: Optional[str] = Field(
        None,
        description="Unique identifier name of the cluster_name ( This is a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a> ) linked to this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.",
    )
    created: Optional[datetime] = Field(
        None,
        description="Time of creation of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )
    enabled: Optional[bool] = None
    name: Optional[str] = Field(
        None,
        description="Unique identifier name for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This contains only lowercase alphanumeric characters. The `.`, `_` and `-` characters are also allowed to separate words instead of a space BUT can not be at the beginning or end of the name.",
    )
    node_name: Optional[str] = None
    payload: Optional[Dict[str, Any]] = Field(
        None,
        description="Contains the configuration dictionary, metrics_map dictionary and logging_level parameter of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> The configuration dictionary contains all the information required to connect to the assets. The information supplied will depend on which type of protocol the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> uses. There are four protocols; `modbus`, `opc-ua`, `mqtt`, `roc`.</p> The metrics_map dictionary contains a list of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> pairs on this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> and their configuration details.",
    )
    protocol: Optional[str] = Field(
        None,
        description="Type of protocol used by the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> there are 4 types of protocol type options; `opc-ua`, `mqtt`, `modbus`, `roc`.",
    )
    status: Optional[WorkloadStatus] = None
    title: Optional[str] = Field(
        None,
        description="Display name (title) for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> . This is the friendly name displayed.</p> It can use any character, numeric, space and special character in this parameter.",
    )
    updated: Optional[datetime] = Field(
        None,
        description="Time of modifying any variable of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )
    workload_name: Optional[str] = Field(
        None,
        description="Unique identifier name of the workload_name ( This is a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-apps/' target='_blank'>Kelvin App</a>, which is in this case is a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> ) linked to this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.",
    )

    @instance_classmethod
    @DataModelBase.translate()
    def deploy_bridge(
        self_or_cls,
        data: Optional[Union[requests.BridgeDeploy, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Bridge:
        """
        Deploy Bridge App

        Deploy a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> to a selected <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>.

        The Kelvin Bridge will handle all the communications and data transfer between external equipment and the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> using one of four communication protocols; OPC UA, MQTT, Modbus TCP / RTU or Emerson ROC.

        Each protocol will require a different type of payload structure that defines the exact address specifications for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> // <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> pairs.

        **Permission Required:** `kelvin.permission.bridge.create`.

        ``deployBridge``: ``POST`` ``/api/v4/bridges/deploy``

        Parameters
        ----------
        data: requests.BridgeDeploy, optional
        **kwargs:
            Extra parameters for requests.BridgeDeploy
              - app_version: str
              - cluster_name: str
              - name: str
              - payload: dict
              - protocol: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/bridges/deploy",
            {},
            {},
            {},
            {},
            data,
            "requests.BridgeDeploy",
            False,
            {
                "201": Bridge,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
                "424": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_bridge(
        cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        cluster_name: Optional[Sequence[str]] = None,
        protocol: Optional[Sequence[str]] = None,
        workload_name: Optional[Sequence[str]] = None,
        status_state: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[BridgeItem], BridgeListPaginated]:
        """
        List Bridge

        Returns a dictionary with a data property containing a list of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridges</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.bridge.read`.

        ``listBridge``: ``GET`` ``/api/v4/bridges/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> by its
            name. This is given as an array, for example `[extruder-bridge,tank-
            bridge]`.</p> The filter is done on the full name only according to
            unique identifier name rules (Must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space but not at the beginning or
            end).</p> For example a filter with `[extruder-bridge,tank-bridge]`
            will return <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin
            Bridge</a> with the name `extruder-bridge` but not with the names
            `demo-extruder-bridge` or `tank-bridge-one`.
        search : :obj:`Sequence[str]`
            Search and filter the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> list. Both
            the Display Name and the Name will be included in the search field
            criteria. This is given as an array, for example `[demo,bridge]`.</p>
            The search is case insensitive and will find partial matches as well.
            For example if a <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin
            Bridge</a> name or display name is `extruder-bridge`, then a match
            will be made if the search string is `ext` or `rIDge`.
        cluster_name : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>'s
            cluster_name (This is a <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>). This is
            given as an array, for example `[demo-node-1,extruder-node]`.</p> The
            filter is done on the full name only according to unique identifier
            name rules (Must contain only lowercase alphanumeric characters. The
            `.`, `_` and `-` characters are also allowed to separate words instead
            of a space but not at the beginning or end).</p> For example a filter
            with `[demo-node-1,extruder-node]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> with the
            parameter cluster_name `extruder-node` but not with the names `demo-
            extruder-node` or `extruder-node-one`.
        protocol : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>
            `protocol`. This is the communication protocol used by the bridge.
            This is given as an array, for example `[modbus,mqtt]`.</p> There are
            four options available; `modbus`, `opc-ua`, `mqtt`, `roc`.
        workload_name : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>
            `workload_name`. This is given as an array, for example
            `[extruder,tank]`.</p> The filter is done on the full workload_name
            only according to unique identifier name rules (Must contain only
            lowercase alphanumeric characters. The `.`, `_` and `-` characters are
            also allowed to separate words instead of a space but not at the
            beginning or end).</p> For example a filter with `[extruder,tank]`
            will return <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin
            Bridge</a> with the parameter workload_name `extruder` but not with
            the workload_name `demo-extruder-bridge` or `bridge-tank`.
        status_state : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>
            `status_state`. This is the communication protocol used by the bridge.
            This is given as an array, for example `[failed,stopped]`.</p> There
            are five options available; `running`, `stopped`, `failed`,
            `deploying`, `unreachable`.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `name`, `title`, `protocol`,
            `cluster_name`, `workload_name`, `node_name`, `enabled`,
            `status_state`, `status_last_seen`, `created`, `updated`.</p> The
            default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/list",
            {},
            {
                "names": names,
                "search": search,
                "cluster_name": cluster_name,
                "protocol": protocol,
                "workload_name": workload_name,
                "status_state": status_state,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": BridgeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/bridges/list", "GET") if fetch and not _dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def delete_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Bridge application

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>. This cannot be undone once the API request has been submitted.

        <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridges</a> can be deleted even if the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a> is unreachable. In this case, the information will be immediately deleted on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> and the commands to delete on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a> will be sent when it next comes online.

        **Permission Required:** `kelvin.permission.bridge.delete`.

        ``deleteBridge``: ``POST`` ``/api/v4/bridges/{bridge_name}/delete``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/bridges/{bridge_name}/delete",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def get_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Bridge:
        """
        Get Bridge

        Retrieve the properties of a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.

        **Permission Required:** `kelvin.permission.bridge.read`.

        ``getBridge``: ``GET`` ``/api/v4/bridges/{bridge_name}/get``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/{bridge_name}/get",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Bridge, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def start_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Start Bridge application

        Start a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.

        The <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> must already be deployed to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>.

        **Permission Required:** `kelvin.permission.bridge.update`.

        ``startBridge``: ``GET`` ``/api/v4/bridges/{bridge_name}/start``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/{bridge_name}/start",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def stop_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Stop Bridge application

        Stop a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.

        The <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> must already be deployed to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>.

        **Permission Required:** `kelvin.permission.bridge.update`.

        ``stopBridge``: ``GET`` ``/api/v4/bridges/{bridge_name}/stop``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/{bridge_name}/stop",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class BridgeItem(DataModelBase):
    """
    BridgeItem object.

    Parameters
    ----------
    cluster_name: Optional[str]
    created: Optional[datetime]
    enabled: Optional[bool]
    name: Optional[str]
    node_name: Optional[str]
    protocol: Optional[str]
    status: Optional[WorkloadStatus]
    title: Optional[str]
    updated: Optional[datetime]
    workload_name: Optional[str]

    """

    cluster_name: Optional[str] = Field(
        None,
        description="Unique identifier name of the cluster_name ( This is a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a> ) linked to this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.",
    )
    created: Optional[datetime] = Field(
        None,
        description="Time of creation of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )
    enabled: Optional[bool] = None
    name: Optional[str] = Field(
        None,
        description="Unique identifier name for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This contains only lowercase alphanumeric characters. The `.`, `_` and `-` characters are also allowed to separate words instead of a space BUT can not be at the beginning or end of the name.",
    )
    node_name: Optional[str] = None
    protocol: Optional[str] = Field(
        None,
        description="Type of protocol used by the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> there are 4 types of protocol type options; `modbus`, `opc-ua`, `mqtt`, `roc`.",
    )
    status: Optional[WorkloadStatus] = None
    title: Optional[str] = Field(
        None,
        description="Display name (title) for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> . This is the friendly name displayed.</p> It can use any character, numeric, space and special character in this parameter.",
    )
    updated: Optional[datetime] = Field(
        None,
        description="Time of modifying any variable of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )
    workload_name: Optional[str] = Field(
        None,
        description="Unique identifier name of the workload_name ( This is a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-apps/' target='_blank'>Kelvin App</a>, which is in this case is a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> ) linked to this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.",
    )

    @instance_classmethod
    @DataModelBase.translate()
    def deploy_bridge(
        self_or_cls,
        data: Optional[Union[requests.BridgeDeploy, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Bridge:
        """
        Deploy Bridge App

        Deploy a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> to a selected <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>.

        The Kelvin Bridge will handle all the communications and data transfer between external equipment and the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> using one of four communication protocols; OPC UA, MQTT, Modbus TCP / RTU or Emerson ROC.

        Each protocol will require a different type of payload structure that defines the exact address specifications for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> // <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metric</a> pairs.

        **Permission Required:** `kelvin.permission.bridge.create`.

        ``deployBridge``: ``POST`` ``/api/v4/bridges/deploy``

        Parameters
        ----------
        data: requests.BridgeDeploy, optional
        **kwargs:
            Extra parameters for requests.BridgeDeploy
              - app_version: str
              - cluster_name: str
              - name: str
              - payload: dict
              - protocol: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/bridges/deploy",
            {},
            {},
            {},
            {},
            data,
            "requests.BridgeDeploy",
            False,
            {
                "201": Bridge,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
                "424": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_bridge(
        cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        cluster_name: Optional[Sequence[str]] = None,
        protocol: Optional[Sequence[str]] = None,
        workload_name: Optional[Sequence[str]] = None,
        status_state: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[BridgeItem], BridgeListPaginated]:
        """
        List Bridge

        Returns a dictionary with a data property containing a list of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridges</a> on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.bridge.read`.

        ``listBridge``: ``GET`` ``/api/v4/bridges/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> by its
            name. This is given as an array, for example `[extruder-bridge,tank-
            bridge]`.</p> The filter is done on the full name only according to
            unique identifier name rules (Must contain only lowercase alphanumeric
            characters. The `.`, `_` and `-` characters are also allowed to
            separate words instead of a space but not at the beginning or
            end).</p> For example a filter with `[extruder-bridge,tank-bridge]`
            will return <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin
            Bridge</a> with the name `extruder-bridge` but not with the names
            `demo-extruder-bridge` or `tank-bridge-one`.
        search : :obj:`Sequence[str]`
            Search and filter the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> list. Both
            the Display Name and the Name will be included in the search field
            criteria. This is given as an array, for example `[demo,bridge]`.</p>
            The search is case insensitive and will find partial matches as well.
            For example if a <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin
            Bridge</a> name or display name is `extruder-bridge`, then a match
            will be made if the search string is `ext` or `rIDge`.
        cluster_name : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>'s
            cluster_name (This is a <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>). This is
            given as an array, for example `[demo-node-1,extruder-node]`.</p> The
            filter is done on the full name only according to unique identifier
            name rules (Must contain only lowercase alphanumeric characters. The
            `.`, `_` and `-` characters are also allowed to separate words instead
            of a space but not at the beginning or end).</p> For example a filter
            with `[demo-node-1,extruder-node]` will return <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> with the
            parameter cluster_name `extruder-node` but not with the names `demo-
            extruder-node` or `extruder-node-one`.
        protocol : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>
            `protocol`. This is the communication protocol used by the bridge.
            This is given as an array, for example `[modbus,mqtt]`.</p> There are
            four options available; `modbus`, `opc-ua`, `mqtt`, `roc`.
        workload_name : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>
            `workload_name`. This is given as an array, for example
            `[extruder,tank]`.</p> The filter is done on the full workload_name
            only according to unique identifier name rules (Must contain only
            lowercase alphanumeric characters. The `.`, `_` and `-` characters are
            also allowed to separate words instead of a space but not at the
            beginning or end).</p> For example a filter with `[extruder,tank]`
            will return <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin
            Bridge</a> with the parameter workload_name `extruder` but not with
            the workload_name `demo-extruder-bridge` or `bridge-tank`.
        status_state : :obj:`Sequence[str]`
            Filter on the parameter <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>
            `status_state`. This is the communication protocol used by the bridge.
            This is given as an array, for example `[failed,stopped]`.</p> There
            are five options available; `running`, `stopped`, `failed`,
            `deploying`, `unreachable`.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `name`, `title`, `protocol`,
            `cluster_name`, `workload_name`, `node_name`, `enabled`,
            `status_state`, `status_last_seen`, `created`, `updated`.</p> The
            default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/list",
            {},
            {
                "names": names,
                "search": search,
                "cluster_name": cluster_name,
                "protocol": protocol,
                "workload_name": workload_name,
                "status_state": status_state,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": BridgeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/bridges/list", "GET") if fetch and not _dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def delete_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Bridge application

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>. This cannot be undone once the API request has been submitted.

        <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridges</a> can be deleted even if the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a> is unreachable. In this case, the information will be immediately deleted on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> and the commands to delete on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a> will be sent when it next comes online.

        **Permission Required:** `kelvin.permission.bridge.delete`.

        ``deleteBridge``: ``POST`` ``/api/v4/bridges/{bridge_name}/delete``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/bridges/{bridge_name}/delete",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def get_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Bridge:
        """
        Get Bridge

        Retrieve the properties of a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.

        **Permission Required:** `kelvin.permission.bridge.read`.

        ``getBridge``: ``GET`` ``/api/v4/bridges/{bridge_name}/get``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/{bridge_name}/get",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Bridge, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def start_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Start Bridge application

        Start a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.

        The <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> must already be deployed to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>.

        **Permission Required:** `kelvin.permission.bridge.update`.

        ``startBridge``: ``GET`` ``/api/v4/bridges/{bridge_name}/start``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/{bridge_name}/start",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"bridge_name": "name"})
    def stop_bridge(
        self_or_cls, bridge_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Stop Bridge application

        Stop a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.

        The <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> must already be deployed to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-nodes/' target='_blank'>Kelvin Node</a>.

        **Permission Required:** `kelvin.permission.bridge.update`.

        ``stopBridge``: ``GET`` ``/api/v4/bridges/{bridge_name}/stop``

        Parameters
        ----------
        bridge_name : :obj:`str`, optional
            Unique identifier name for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a>.</p> This
            must contain only lowercase alphanumeric characters. The `.`, `_` and
            `-` characters are also allowed to separate words instead of a space
            BUT can not be at the beginning or end of the name.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/bridges/{bridge_name}/stop",
            {"bridge_name": bridge_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class BridgeListPaginated(PaginatorDataModel[BridgeItem]):
    """
    BridgeListPaginated object.

    Parameters
    ----------
    data: Optional[List[BridgeItem]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[BridgeItem]] = Field(
        None,
        description="A dictionary which contains an array of up to `page_size` <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> objects. If a bookmark has been used, then the array will start or end based on the `starting_after` or `ending_before` parameters.",
    )
    pagination: Optional[paginator.PaginationInfo] = None


class CSVError(DataModelBase):
    """
    CSVError object.

    Parameters
    ----------
    description: Optional[str]
    name: Optional[str]
    positions: Optional[List[CSVPosition]]
    solution: Optional[str]
    title: Optional[str]
    type: Optional[str]

    """

    description: Optional[str] = Field(
        None, description="A detailed description of the type of error encountered."
    )
    name: Optional[str] = Field(None, description="Unique name of the error message")
    positions: Optional[List[CSVPosition]] = Field(
        None, description="A dictionary of each error encountered and it's position in the file."
    )
    solution: Optional[str] = Field(None, description="Possible solutions to fix the errors.")
    title: Optional[str] = Field(None, description="Display Name (title) of the error message")
    type: Optional[str] = Field(
        None,
        description="Type of error detected. There are two types of errors.</p> `structural` errors means that there is something wrong with the csv file. For example; this can be wrong number of columns, all rows don't have the right number of columns, the header does not contain the right column names, etc.</p> `content` errors means that the information given fails the validation tests. For example; the latitude or longitude has invalid numbers or characters, the name contains invalid characters,etc.",
    )


class CSVErrorMessage(DataModelBase):
    """
    CSVErrorMessage object.

    Parameters
    ----------
    errors: Optional[List[CSVError]]

    """

    errors: Optional[List[CSVError]] = Field(
        None, description="An array of all errors detected during the validation of the csv file."
    )


class Cluster(DataModelBase):
    """
    Cluster object.

    Parameters
    ----------
    created: Optional[datetime]
    forward_logs_buffer_size: Optional[int]
    forward_logs_enabled: Optional[bool]
    join_script: Optional[str]
    last_seen: Optional[datetime]
    manifests_scrape_enabled: Optional[bool]
    manifests_scrape_interval: Optional[int]
    name: Optional[str]
    provision_script: Optional[str]
    ready: Optional[bool]
    service_account_token: Optional[str]
    status: Optional[str]
    sync_scrape_interval: Optional[int]
    telemetry_buffer_size: Optional[int]
    telemetry_enabled: Optional[bool]
    telemetry_scrape_interval: Optional[int]
    title: Optional[str]
    type: Optional[str]
    updated: Optional[datetime]
    upgrade_instantly_apply: Optional[bool]
    upgrade_pre_download: Optional[bool]
    upgrade_status: Optional[ClusterUpdateStatus]
    version: Optional[ClusterVersions]

    """

    created: Optional[datetime] = None
    forward_logs_buffer_size: Optional[int] = None
    forward_logs_enabled: Optional[bool] = None
    join_script: Optional[str] = None
    last_seen: Optional[datetime] = None
    manifests_scrape_enabled: Optional[bool] = None
    manifests_scrape_interval: Optional[int] = None
    name: Optional[str] = None
    provision_script: Optional[str] = None
    ready: Optional[bool] = None
    service_account_token: Optional[str] = None
    status: Optional[str] = None
    sync_scrape_interval: Optional[int] = None
    telemetry_buffer_size: Optional[int] = None
    telemetry_enabled: Optional[bool] = None
    telemetry_scrape_interval: Optional[int] = None
    title: Optional[str] = None
    type: Optional[str] = None
    updated: Optional[datetime] = None
    upgrade_instantly_apply: Optional[bool] = None
    upgrade_pre_download: Optional[bool] = None
    upgrade_status: Optional[ClusterUpdateStatus] = None
    version: Optional[ClusterVersions] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_cluster(
        self_or_cls,
        data: Optional[Union[requests.ClusterCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Cluster:
        """
        Create Cluster

        **Permission Required:** `kelvin.permission.cluster.create`.

        ``createCluster``: ``POST`` ``/api/v4/orchestration/clusters/create``

        Parameters
        ----------
        data: requests.ClusterCreate, optional
        **kwargs:
            Extra parameters for requests.ClusterCreate
              - name: str
              - title: str
              - type: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/orchestration/clusters/create",
            {},
            {},
            {},
            {},
            data,
            "requests.ClusterCreate",
            False,
            {
                "201": Cluster,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_cluster(
        cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        type: Optional[Sequence[str]] = None,
        ready: Optional[bool] = None,
        status: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[Cluster], ClusterListPaginated]:
        """
        List Cluster

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``listCluster``: ``GET`` ``/api/v4/orchestration/clusters/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter Clusters by name
        search : :obj:`Sequence[str]`
            Search Cluster by name
        type : :obj:`Sequence[str]`
            Filter Cluster by type. Allowed values: k3s, kubernetes
        ready : :obj:`bool`
            Filter by ready state. Possible Values: true/false. Default: none
        status : :obj:`Sequence[str]`
            Filter Cluster by status. Allowed values: pending, online,
            unreachable, requires_attention
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of cluster objects to be returned. Page size can be between 1
            and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of clusters in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of clusters in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the cluster parameters. Only one parameter
            can be selected.</p> Allowed options: `name`, `title`, `ready`,
            `type`, `status`, `last_seen`, `created`, `updated`.</p> The default
            is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/list",
            {},
            {
                "names": names,
                "search": search,
                "type": type,
                "ready": ready,
                "status": status,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ClusterListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/orchestration/clusters/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def download_cluster_provision_binary(
        cls, _dry_run: bool = False, _client: Any = None
    ) -> Iterator[bytes]:
        """
        Download Cluster Provision Binary

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``downloadClusterProvisionBinary``: ``GET`` ``/api/v4/orchestration/clusters/provision/bin/download``

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/provision/bin/download",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": bytes, "400": ErrorMessages, "401": ErrorMessages},
            True,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def delete_cluster(
        self_or_cls, cluster_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Cluster

        Permanently delete an existing cluster

        **Permission Required:** `kelvin.permission.cluster.delete`.

        ``deleteCluster``: ``POST`` ``/api/v4/orchestration/clusters/{cluster_name}/delete``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Unique identifier name for the cluster

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/orchestration/clusters/{cluster_name}/delete",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def apply_cluster_upgrade(
        self_or_cls, cluster_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Apply Cluster Upgrade

        Triggers the cluster to apply the upgrade. The cluster must be online and waiting for the trigger.

        **Permission Required:** `kelvin.permission.cluster.update`.

        ``applyClusterUpgrade``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/edge-apps/version/apply``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/edge-apps/version/apply",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "406": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def force_update_cluster_edge_app_version(
        self_or_cls,
        cluster_name: str,
        persist: Optional[bool] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> None:
        """
        Force Update Cluster Edge App Version

        **Permission Required:** `kelvin.permission.cluster.update`.

        ``forceUpdateClusterEdgeAppVersion``: ``POST`` ``/api/v4/orchestration/clusters/{cluster_name}/edge-apps/version/force-update``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name
        persist : :obj:`bool`
            If set to true, and the cluster is unreachable or auto-update is
            disabled, it will force the update next time the cluster is online.

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/orchestration/clusters/{cluster_name}/edge-apps/version/force-update",
            {"cluster_name": cluster_name},
            {"persist": persist},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "202": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def get_cluster(
        self_or_cls, cluster_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Cluster:
        """
        Get Cluster

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``getCluster``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/get",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Cluster, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def get_cluster_manifests(
        self_or_cls,
        cluster_name: str,
        version: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> ClusterManifestList:
        """
        Get Cluster Manifests

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``getClusterManifests``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/manifests/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name
        version : :obj:`str`
            Current Version

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/manifests/get",
            {"cluster_name": cluster_name},
            {"version": version},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ClusterManifestList,
                "204": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def list_node(
        self_or_cls,
        cluster_name: str,
        search: Optional[Sequence[str]] = None,
        status: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[Node], NodeListPaginated]:
        """
        List Node

        **Pagination Sortable Columns:** `id`, `name`, `status`, `last_seen`, `created`, `updated`

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``listNode``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/nodes/list``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster Name
        search : :obj:`Sequence[str]`
            Search Node by name
        status : :obj:`Sequence[str]`
            Filter by status. Allowed values: unreachable, online, not_ready
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of node objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of nodes in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of nodes in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the node parameters. Only one parameter can
            be selected.</p> Allowed options: `name`, `status`, `last_seen`,
            `created`, `updated`.</p> The default is `name`

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/nodes/list",
            {"cluster_name": cluster_name},
            {
                "search": search,
                "status": status,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": NodeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/orchestration/clusters/{cluster_name}/nodes/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def get_node(
        self_or_cls, cluster_name: str, node_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Node:
        """
        Get Node

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``getNode``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/nodes/{node_name}/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster Name
        node_name : :obj:`str`, optional
            Node Name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/nodes/{node_name}/get",
            {"cluster_name": cluster_name, "node_name": node_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Node, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def get_cluster_provision_yaml_spec(
        self_or_cls, cluster_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Iterator[bytes]:
        """
        Get Cluster Provision YAML Spec

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``getClusterProvisionYAMLSpec``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/provision/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/provision/get",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": bytes, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            True,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def list_service(
        self_or_cls,
        cluster_name: str,
        search: Optional[Sequence[str]] = None,
        workload_name: Optional[Sequence[str]] = None,
        service_type: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[ServiceItem], ServiceListPaginated]:
        """
        List Service

        **Pagination Sortable Columns:** `name`, `workload_name`, `network_interface`, `service_type`, `address`, `created`, `updated`

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``listService``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/services/list``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster Name
        search : :obj:`Sequence[str]`
            Search Service by any field
        workload_name : :obj:`Sequence[str]`
            Filter Service by workload name
        service_type : :obj:`Sequence[str]`
            Filter Service by type: Possible values: `cluster_ip, node_port,
            host_port`
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of service objects to be returned. Page size can be between 1
            and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of services in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of services in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the service parameters. Only one parameter
            can be selected.</p> Allowed options: `name`, `workload_name`,
            `network_interface`, `service_type`, `address`, `created`,
            `updated`.</p> The default is `name`

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/services/list",
            {"cluster_name": cluster_name},
            {
                "search": search,
                "workload_name": workload_name,
                "service_type": service_type,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ServiceListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/orchestration/clusters/{cluster_name}/services/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def update_cluster(
        self_or_cls,
        cluster_name: str,
        data: Optional[Union[requests.ClusterUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Cluster:
        """
        Update Cluster

        **Permission Required:** `kelvin.permission.cluster.update`.

        ``updateCluster``: ``POST`` ``/api/v4/orchestration/clusters/{cluster_name}/update``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name
        data: requests.ClusterUpdate, optional
        **kwargs:
            Extra parameters for requests.ClusterUpdate
              - forward_logs_buffer_size: int
              - forward_logs_enabled: bool
              - manifests_scrape_enabled: bool
              - manifests_scrape_interval: int
              - ready: bool
              - sync_scrape_interval: int
              - telemetry_buffer_size: int
              - telemetry_enabled: bool
              - telemetry_scrape_interval: int
              - title: str
              - upgrade: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/orchestration/clusters/{cluster_name}/update",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            data,
            "requests.ClusterUpdate",
            False,
            {
                "200": Cluster,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessage,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class ClusterListPaginated(PaginatorDataModel[Cluster]):
    """
    ClusterListPaginated object.

    Parameters
    ----------
    data: Optional[List[Cluster]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[Cluster]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class ClusterManifestList(DataModelBase):
    """
    ClusterManifestList object.

    Parameters
    ----------
    images: Optional[List[ClusterManifestImageItem]]
    manifests: Optional[List[ClusterManifestItem]]
    revision: Optional[str]
    upgrade: Optional[ClusterManifestUpgrade]

    """

    images: Optional[List[ClusterManifestImageItem]] = None
    manifests: Optional[List[ClusterManifestItem]] = None
    revision: Optional[str] = None
    upgrade: Optional[ClusterManifestUpgrade] = None

    @classmethod
    def get_cluster_manifests(
        cls,
        cluster_name: str,
        version: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> ClusterManifestList:
        """
        Get Cluster Manifests

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``getClusterManifests``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/manifests/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name
        version : :obj:`str`
            Current Version

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/manifests/get",
            {"cluster_name": cluster_name},
            {"version": version},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ClusterManifestList,
                "204": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result


class ControlChangeGet(DataModelBase):
    """
    ControlChangeGet object.

    Parameters
    ----------
    created: Optional[datetime]
    created_by: Optional[str]
    created_type: Optional[str]
    id: str
    last_message: Optional[str]
    last_state: Optional[str]
    old_payload: Optional[Any]
    payload: Optional[Any]
    resource: str
    status_log: Optional[List[ControlChangeGetStatus]]
    timestamp: Optional[datetime]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = Field(
        None,
        description="Time of creation of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> in ISO 8601 UTC date/time format. Example; \"2022-08-22T08:41:01.657916Z\".",
    )
    created_by: Optional[str] = Field(
        None,
        description="Who created the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a>.</p> For a `user` this will normally be a user name or user email address and for a `workload` it will be the workload's unique name.",
    )
    created_type: Optional[str] = Field(
        None,
        description="Type of process that created the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a>.</p> There are two types; `user` which is a normal user registered on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a> or `workload` which is an automated process like a Kelvin Rule or from a program in a  <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-apps/' target='_blank'>Kelvin App</a>.",
    )
    id: str = Field(
        ...,
        description="Unique identifier id for the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a>.",
    )
    last_message: Optional[str] = Field(
        None,
        description="Last message received from the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> Manager.</p> For example some messages received could be `The system considers the Managed Control Change to be successfully applied.` or `The Control Change was sent to the Bridge. At this stage, the system is monitoring according to the Acceptance Criteria parameters and the retry logic.`.",
    )
    last_state: Optional[str] = Field(
        None,
        description="Current state of the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a>.</p> Available states are; `pending`, `sent`, `applied` and `failed`. check out <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/#from-api-to-applied' target='_blank'>Kelvin Control Change Statuses</a> in the Kelvin Documentation for more details about each status.",
    )
    old_payload: Optional[Any] = Field(
        None, description="The original value payload before the change was applied"
    )
    payload: Optional[Any] = Field(None, description="The new value payload to be applied.")
    resource: str
    status_log: Optional[List[ControlChangeGetStatus]] = Field(
        None,
        description="Array of dictionary objects with the details of each status change including the `timestamp`, `state`, `message` and `payload value`.",
    )
    timestamp: Optional[datetime] = Field(
        None,
        description="Time when `created_by` sent the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request to the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>. The date-time is in ISO 8601 UTC date/time format. Example; \"2022-08-22T08:41:01.657916Z\".",
    )
    updated: Optional[datetime] = Field(
        None,
        description="Time of last state change of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> in ISO 8601 UTC date/time format. Example; \"2022-08-22T08:41:01.657916Z\".",
    )

    @classmethod
    def get_control_change_clustering(
        cls,
        data: Optional[Union[requests.ControlChangeClustering, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> List[ControlChangeClustering]:
        """
        Get Control Change Clustering

        Groups and counts the occurrence of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Changes</a> within a defined time bucket.

        The grouping can also be filtered to only include <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Changes</a> for certain <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Assets</a>, <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics/' target='_blank'>Kelvin Metrics</a> or current <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> statuses.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getControlChangeClustering``: ``POST`` ``/api/v4/control-changes/clustering/get``

        Parameters
        ----------
        data: requests.ControlChangeClustering, optional
        **kwargs:
            Extra parameters for requests.ControlChangeClustering
              - end_date: datetime
              - resources: list
              - sources: list
              - start_date: datetime
              - states: list
              - time_bucket: str

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/clustering/get",
            {},
            {},
            {},
            {},
            data,
            "requests.ControlChangeClustering",
            False,
            {
                "200": List[ControlChangeClustering],
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_control_change(
        self_or_cls,
        data: Optional[Union[requests.ControlChangeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> ControlChange:
        """
        Create Control Change

        Send a new value to be written to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        The <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> Manager will automatically find whichKelvin Cluster hosts the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-bridges/' target='_blank'>Kelvin Bridge</a> with the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pair.

        **Permission Required:** `kelvin.permission.control_change.create`.

        ``createControlChange``: ``POST`` ``/api/v4/control-changes/create``

        Parameters
        ----------
        data: requests.ControlChangeCreate, optional
        **kwargs:
            Extra parameters for requests.ControlChangeCreate
              - expiration_date: datetime
              - payload: str
              - resource: str
              - retry: int
              - timeout: int

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/create",
            {},
            {},
            {},
            {},
            data,
            "requests.ControlChangeCreate",
            False,
            {"201": ControlChange, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_last_control_change(
        cls,
        status_limit: Optional[int] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ControlChangeLast, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ControlChangeGet], ControlChangeGetPaginated]:
        """
        Get Last Control Change

        Returns a list of the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pairs for each of the body parameters in the array `resources`.

        The list will include <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Changes</a> that succeeded, failed or are pending.

        Each object will not only give the `status` and `payload` of the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> but also the `status_log` containing the information of when the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> was created, sent to bridge and confirmed with a read.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getLastControlChange``: ``POST`` ``/api/v4/control-changes/last/get``

        Parameters
        ----------
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `id`, `resource`, `last_state`,
            `created`, `updated`, `timestamp`.</p> The default is `id`
        data: requests.ControlChangeLast, optional
        **kwargs:
            Extra parameters for requests.ControlChangeLast
              - resources: list
              - sources: list
              - states: list
              - status_limit: int

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/last/get",
            {},
            {
                "status_limit": status_limit,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ControlChangeLast",
            False,
            {"200": ControlChangeGetPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/control-changes/last/get", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def list_control_change(
        cls,
        status_limit: Optional[int] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ControlChangeList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ControlChangeGet], ControlChangeGetPaginated]:
        """
        List Control Change lists the Control Changes for each resource.

        Returns a list of the history of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> requests for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pairs for each of the body parameters in the array `resources`.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``listControlChange``: ``POST`` ``/api/v4/control-changes/list``

        Parameters
        ----------
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `id`, `resource`, `last_state`,
            `created`, `updated`, `timestamp`.</p> The default is `id`
        data: requests.ControlChangeList, optional
        **kwargs:
            Extra parameters for requests.ControlChangeList
              - ids: list
              - resources: list
              - sources: list
              - states: list
              - status_limit: int

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/list",
            {},
            {
                "status_limit": status_limit,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ControlChangeList",
            False,
            {"200": ControlChangeGetPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/control-changes/list", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def get_range_control_change(
        cls,
        status_limit: Optional[int] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ControlChangeRange, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ControlChangeGet], ControlChangeGetPaginated]:
        """
        Get Range Control Change.

        Returns a list of the history of all <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> status changes that have happened within a date range for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin Asset</a> / <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-metrics' target='_blank'>Kelvin Metric</a> pairs for each of the body parameters in the array `resources`.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getRangeControlChange``: ``POST`` ``/api/v4/control-changes/range/get``

        Parameters
        ----------
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of app objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of apps in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the app parameters. Only one parameter can
            be selected.</p> Allowed options: `id`, `resource`, `last_state`,
            `created`, `updated`, `timestamp`.</p> The default is `id`
        data: requests.ControlChangeRange, optional
        **kwargs:
            Extra parameters for requests.ControlChangeRange
              - end_date: datetime
              - resources: list
              - sources: list
              - start_date: datetime
              - states: list
              - status_limit: int

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/control-changes/range/get",
            {},
            {
                "status_limit": status_limit,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ControlChangeRange",
            False,
            {"200": ControlChangeGetPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/control-changes/range/get", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def get_control_change(
        cls,
        control_change_id: str,
        status_limit: Optional[int] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> ControlChangeGet:
        """
        Get Control Change

        Returns the properties of a single <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> request via its unique ID.

        Returned object will not only give the `status` and `payload` of the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> but also the `status_log` containing the information of when the <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> was created, sent to bridge and confirmed with a read.

        **Permission Required:** `kelvin.permission.control_change.read`.

        ``getControlChange``: ``GET`` ``/api/v4/control-changes/{control_change_id}/get``

        Parameters
        ----------
        control_change_id : :obj:`str`, optional
            Unique identifier id for the <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a>.</p> This must contain only lowercase alphanumeric
            characters and the `-` character only. For example
            `764168a8-0e1e-33aa-adc7-14dfbb78dfad`
        status_limit : :obj:`int`
            Number of statuses per <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-control-change/' target='_blank'>Kelvin Control
            Change</a> objects to be returned. Page size can be between 1 and 300
            objects.</p> Default value is 20.

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/control-changes/{control_change_id}/get",
            {"control_change_id": control_change_id},
            {"status_limit": status_limit},
            {},
            {},
            None,
            None,
            False,
            {"200": ControlChangeGet, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class ControlChangeGetPaginated(PaginatorDataModel[ControlChangeGet]):
    """
    ControlChangeGetPaginated object.

    Parameters
    ----------
    data: Optional[List[ControlChangeGet]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[ControlChangeGet]] = Field(
        None,
        description="A dictionary which contains an array of up to `page_size` <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> objects. If a bookmark has been used, then the array will start or end based on the `starting_after` or `ending_before` parameters.",
    )
    pagination: Optional[paginator.PaginationInfo] = None


class DataMappingIO(DataModelBase):
    """
    DataMappingIO object.

    Parameters
    ----------
    app: Optional[List[AppIO]]
    datastream_context: Optional[List[IODataStreamContext]]

    """

    app: Optional[List[AppIO]] = None
    datastream_context: Optional[List[IODataStreamContext]] = None


class DataMappingsResponse(DataModelBase):
    """
    DataMappingsResponse object.

    Parameters
    ----------
    inputs: Optional[DataMappingIO]
    mappings: Optional[Dict[str, Any]]
    outputs: Optional[DataMappingIO]

    """

    inputs: Optional[DataMappingIO] = None
    mappings: Optional[Dict[str, Any]] = Field(None, description="empty for now")
    outputs: Optional[DataMappingIO] = None

    @classmethod
    def get_data_mapping(
        cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.DataMappingsRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> DataMappingsResponse:
        """
        Get Data Mapping

        **Permission Required:** `kelvin.permission.appmanager.read`.

        ``getDataMapping``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/data-mapping``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.DataMappingsRequest, optional
        **kwargs:
            Extra parameters for requests.DataMappingsRequest
              - resources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/data-mapping",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.DataMappingsRequest",
            False,
            {"200": DataMappingsResponse, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def start_app_manager_app_version(
        cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.ExecuteActionRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Start App Manager App Version Workloads

        **Permission Required:** `kelvin.permission.appmanager.update`.

        ``startAppManagerAppVersion``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/start``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.ExecuteActionRequest, optional
        **kwargs:
            Extra parameters for requests.ExecuteActionRequest
              - resources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/start",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.ExecuteActionRequest",
            False,
            {
                "200": None,
                "207": kerrors.ErrorMessage,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def stop_app_manager_app_version(
        cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.ExecuteActionRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Stop App Manager App Version Workloads

        **Permission Required:** `kelvin.permission.appmanager.update`.

        ``stopAppManagerAppVersion``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/stop``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.ExecuteActionRequest, optional
        **kwargs:
            Extra parameters for requests.ExecuteActionRequest
              - resources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/stop",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.ExecuteActionRequest",
            False,
            {
                "200": None,
                "207": kerrors.ErrorMessage,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def undeploy_app_manager_app_version(
        cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.ExecuteActionRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Undeploy App Manager App Version Workloads

        **Permission Required:** `kelvin.permission.appmanager.delete`.

        ``undeployAppManagerAppVersion``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/undeploy``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.ExecuteActionRequest, optional
        **kwargs:
            Extra parameters for requests.ExecuteActionRequest
              - resources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/undeploy",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.ExecuteActionRequest",
            False,
            {
                "200": None,
                "207": kerrors.ErrorMessage,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class Deployment(DataModelBase):
    """
    Deployment object.

    Parameters
    ----------
    actions: Optional[List[Dict[str, Any]]]
    mappings: Optional[Mappings]
    success: Optional[bool]

    """

    actions: Optional[List[Dict[str, Any]]] = None
    mappings: Optional[Mappings] = None
    success: Optional[bool] = None

    @instance_classmethod
    @DataModelBase.translate()
    def deploy_app_manager_app_version(
        self_or_cls,
        app_name: str,
        version: str,
        dry_run: Optional[bool] = None,
        data: Optional[Union[requests.ExecuteDeploymentRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Deployment:
        """
        Deploy App Manager App Version Workloads

        **Permission Required:** `kelvin.permission.appmanager.create`.

        ``deployAppManagerAppVersion``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/deploy``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        dry_run : :obj:`bool`
            Dry Run
        data: requests.ExecuteDeploymentRequest, optional
        **kwargs:
            Extra parameters for requests.ExecuteDeploymentRequest
              - mappings: str
              - resources: list

        """

        from . import kerrors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/deploy",
            {"app_name": app_name, "version": version},
            {"dry_run": dry_run},
            {},
            {},
            data,
            "requests.ExecuteDeploymentRequest",
            False,
            {
                "201": Deployment,
                "207": Deployment,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def start_app_manager_app_version(
        cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.ExecuteActionRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Start App Manager App Version Workloads

        **Permission Required:** `kelvin.permission.appmanager.update`.

        ``startAppManagerAppVersion``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/start``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.ExecuteActionRequest, optional
        **kwargs:
            Extra parameters for requests.ExecuteActionRequest
              - resources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/start",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.ExecuteActionRequest",
            False,
            {
                "200": None,
                "207": kerrors.ErrorMessage,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def stop_app_manager_app_version(
        cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.ExecuteActionRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Stop App Manager App Version Workloads

        **Permission Required:** `kelvin.permission.appmanager.update`.

        ``stopAppManagerAppVersion``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/stop``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.ExecuteActionRequest, optional
        **kwargs:
            Extra parameters for requests.ExecuteActionRequest
              - resources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/stop",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.ExecuteActionRequest",
            False,
            {
                "200": None,
                "207": kerrors.ErrorMessage,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def undeploy_app_manager_app_version(
        cls,
        app_name: str,
        version: str,
        data: Optional[Union[requests.ExecuteActionRequest, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Undeploy App Manager App Version Workloads

        **Permission Required:** `kelvin.permission.appmanager.delete`.

        ``undeployAppManagerAppVersion``: ``POST`` ``/api/v4/app-manager/app/{app_name}/v/{version}/undeploy``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        version : :obj:`str`, optional
            App version
        data: requests.ExecuteActionRequest, optional
        **kwargs:
            Extra parameters for requests.ExecuteActionRequest
              - resources: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/v/{version}/undeploy",
            {"app_name": app_name, "version": version},
            {},
            {},
            {},
            data,
            "requests.ExecuteActionRequest",
            False,
            {
                "200": None,
                "207": kerrors.ErrorMessage,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result


class Node(DataModelBase):
    """
    Node object.

    Parameters
    ----------
    capacity: Optional[Dict[str, Any]]
    conditions: Optional[List[NodeConditionItem]]
    created: Optional[datetime]
    hostname: Optional[str]
    internal_ip: Optional[str]
    k8s_version: Optional[str]
    labels: Optional[Dict[str, Any]]
    last_seen: Optional[datetime]
    main: Optional[bool]
    name: Optional[str]
    network_info: Optional[Dict[str, Any]]
    status: Optional[str]
    system_info: Optional[NodeSystemInfo]
    updated: Optional[datetime]
    warnings: Optional[Dict[str, Any]]

    """

    capacity: Optional[Dict[str, Any]] = None
    conditions: Optional[List[NodeConditionItem]] = None
    created: Optional[datetime] = None
    hostname: Optional[str] = None
    internal_ip: Optional[str] = None
    k8s_version: Optional[str] = None
    labels: Optional[Dict[str, Any]] = None
    last_seen: Optional[datetime] = None
    main: Optional[bool] = None
    name: Optional[str] = None
    network_info: Optional[Dict[str, Any]] = None
    status: Optional[str] = None
    system_info: Optional[NodeSystemInfo] = None
    updated: Optional[datetime] = None
    warnings: Optional[Dict[str, Any]] = None

    @classmethod
    def list_node(
        cls,
        cluster_name: str,
        search: Optional[Sequence[str]] = None,
        status: Optional[Sequence[str]] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[Node], NodeListPaginated]:
        """
        List Node

        **Pagination Sortable Columns:** `id`, `name`, `status`, `last_seen`, `created`, `updated`

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``listNode``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/nodes/list``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster Name
        search : :obj:`Sequence[str]`
            Search Node by name
        status : :obj:`Sequence[str]`
            Filter by status. Allowed values: unreachable, online, not_ready
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of node objects to be returned. Page size can be between 1 and
            1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of nodes in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of nodes in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the node parameters. Only one parameter can
            be selected.</p> Allowed options: `name`, `status`, `last_seen`,
            `created`, `updated`.</p> The default is `name`

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/nodes/list",
            {"cluster_name": cluster_name},
            {
                "search": search,
                "status": status,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": NodeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/orchestration/clusters/{cluster_name}/nodes/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate({"node_name": "name"})
    def get_node(
        self_or_cls, cluster_name: str, node_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Node:
        """
        Get Node

        **Permission Required:** `kelvin.permission.cluster.read`.

        ``getNode``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/nodes/{node_name}/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster Name
        node_name : :obj:`str`, optional
            Node Name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/nodes/{node_name}/get",
            {"cluster_name": cluster_name, "node_name": node_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Node, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class NodeListPaginated(PaginatorDataModel[Node]):
    """
    NodeListPaginated object.

    Parameters
    ----------
    data: Optional[List[Node]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[Node]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class RecommendationActions(DataModelBase):
    """
    RecommendationActions object.

    Parameters
    ----------
    control_changes: Optional[List[RecommendationControlChange]]

    """

    control_changes: Optional[List[RecommendationControlChange]] = Field(
        None,
        description="An array of objects with either <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> creation information if the Recommendation is `pending` or <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> status if the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> is `accepted` or `applied`.</p> Each <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-control-change/' target='_blank'>Kelvin Control Change</a> does not need to be related to the `resource` of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.",
    )


class ResourceAppProjection(DataModelBase):
    """
    ResourceAppProjection object.

    Parameters
    ----------
    app: Optional[ResourceApp]
    enabled: Optional[bool]
    resource: Optional[Resource]
    status: Optional[ResourceAppStatus]
    workload: Optional[ResourceAppWorkload]

    """

    app: Optional[ResourceApp] = None
    enabled: Optional[bool] = None
    resource: Optional[Resource] = None
    status: Optional[ResourceAppStatus] = None
    workload: Optional[ResourceAppWorkload] = None

    @classmethod
    def list_app_manager_app_resources(
        cls,
        app_name: str,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.ListResourcesRequest, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[ResourceAppProjection], ListResourcesPaginatedResponse]:
        """
        List App Manager App Resources
        **Pagination Sortable Columns:** `name`, `title`, `status`, `created`, `updated`

        **Permission Required:** `kelvin.permission.appmanager.read`.

        ``listAppManagerAppResources``: ``POST`` ``/api/v4/app-manager/app/{app_name}/resources/list``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page“
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size“ and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/kelvin-platform/kelvin-assets/' target='_blank'>Kelvin
            Assets</a> failure statistic objects to be returned. Page size can be
            between 1 and 1000 objects.</p> The default is 20 <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> failure
            statistic objects.
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size“ and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> failure
            statistics in the list.</p> The alphanumeric string which are the
            bookmarks for the beginning and end of the current list is given in
            the previous JSON response value under the key pagination ->
            previous_page and pagination -> next_page respectively.</p> The
            pagination -> next_page alphanumeric string should be used here to
            show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of <a
            href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-
            platform/kelvin-assets/' target='_blank'>Kelvin Assets</a> failure
            statistics in the list.</p> The alphanumeric string which are the
            bookmarks for the beginning and end of the current list is given in
            the previous JSON response value under the key pagination ->
            previous_page and pagination -> next_page respectively.</p> The
            pagination -> previous_page alphanumeric string should be used here to
            show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the following options; `workload_name`,
            `workload_cluster`, `app_name`, `app_title`, `app_description`,
            `app_version`, `resource_name`, `resource_title`, `resource_created`,
            `resource_updated`, `status`, `status_last_seen`, `status_updated` and
            `status_updated_by`.</p> The default is `workload_name`
        data: requests.ListResourcesRequest, optional
        **kwargs:
            Extra parameters for requests.ListResourcesRequest
              - app_versions: list
              - enabled_states: list
              - resources: list
              - statuses: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/app-manager/app/{app_name}/resources/list",
            {"app_name": app_name},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.ListResourcesRequest",
            False,
            {
                "200": ListResourcesPaginatedResponse,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/app-manager/app/{app_name}/resources/list", "POST")
            if fetch and not _dry_run
            else result
        )


class Workload(DataModelBase):
    """
    Workload object.

    Parameters
    ----------
    acp_name: Optional[str]
    app_name: Optional[str]
    app_version: Optional[str]
    cluster_name: Optional[str]
    created: Optional[datetime]
    download_status: Optional[str]
    enabled: Optional[bool]
    instantly_apply: Optional[bool]
    name: Optional[str]
    networking: Optional[List[NetworkingItem]]
    node_name: Optional[str]
    payload: Optional[Dict[str, Any]]
    pre_download: Optional[bool]
    status: Optional[WorkloadStatus]
    title: Optional[str]
    updated: Optional[datetime]

    """

    acp_name: Optional[str] = None
    app_name: Optional[str] = None
    app_version: Optional[str] = None
    cluster_name: Optional[str] = None
    created: Optional[datetime] = None
    download_status: Optional[str] = None
    enabled: Optional[bool] = None
    instantly_apply: Optional[bool] = None
    name: Optional[str] = None
    networking: Optional[List[NetworkingItem]] = None
    node_name: Optional[str] = None
    payload: Optional[Dict[str, Any]] = None
    pre_download: Optional[bool] = None
    status: Optional[WorkloadStatus] = None
    title: Optional[str] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def deploy_workload(
        self_or_cls,
        data: Optional[Union[requests.WorkloadDeploy, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Workload:
        """
        Deploy Workload

        **Permission Required:** `kelvin.permission.workload.update`

        **Note:** `acp_name` is deprecated. If `cluster_name` is set, it will override `acp_name`.

        ``deployWorkload``: ``POST`` ``/api/v4/workloads/deploy``

        Parameters
        ----------
        data: requests.WorkloadDeploy, optional
        **kwargs:
            Extra parameters for requests.WorkloadDeploy
              - acp_name: str
              - app_name: str
              - app_version: str
              - cluster_name: str
              - instantly_apply: bool
              - name: str
              - payload: dict
              - pre_download: bool
              - source: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/workloads/deploy",
            {},
            {},
            {},
            {},
            data,
            "requests.WorkloadDeploy",
            False,
            {
                "201": Workload,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def list_workload(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        app_name: Optional[Sequence[str]] = None,
        app_version: Optional[Sequence[str]] = None,
        acp_name: Optional[Sequence[str]] = None,
        cluster_name: Optional[Sequence[str]] = None,
        node_name: Optional[Sequence[str]] = None,
        workload_name: Optional[Sequence[str]] = None,
        enabled: Optional[bool] = None,
        asset_name: Optional[str] = None,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[Workload], WorkloadListPaginated]:
        """
        List Workload

        **Pagination Sortable Columns:** `name`, `title`, `cluster_name`, `node_name`, `enabled`, `created`, `updated`

        **Permission Required:** `kelvin.permission.workload.read`.

        ``listWorkload``: ``GET`` ``/api/v4/workloads/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search workloads by name, title, App name, Cluster name and Node name
        app_name : :obj:`Sequence[str]`
            App Name
        app_version : :obj:`Sequence[str]`
            App Version
        acp_name : :obj:`Sequence[str]`
            ACP Name **`[Deprecated]`**
        cluster_name : :obj:`Sequence[str]`
            Cluster Name. `If set, it will override acp_name`
        node_name : :obj:`Sequence[str]`
            Node Name
        workload_name : :obj:`Sequence[str]`
            Workload Name
        enabled : :obj:`bool`
            Filter workloads by enabled status
        asset_name : :obj:`str`
            Filter workloads with given asset
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available:</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of workload objects to be returned. Page size can be between 1
            and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of workloads in the
            list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            next_page` alphanumeric string should be used here to show a list of
            the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of workloads in
            the list.</p> The alphanumeric string which are the bookmarks for the
            beginning and end of the current list is given in the previous JSON
            response value under the key `pagination -> previous_page` and
            `pagination -> next_page` respectively.</p> The `pagination ->
            previous_page` alphanumeric string should be used here to show a list
            of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the workload parameters. Only one parameter
            can be selected.</p> Allowed options: `name`, `title`, `cluster_name`,
            `node_name`, `enabled`, `created`, `updated`.</p> The default is
            `name`

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/list",
            {},
            {
                "search": search,
                "app_name": app_name,
                "app_version": app_version,
                "acp_name": acp_name,
                "cluster_name": cluster_name,
                "node_name": node_name,
                "workload_name": workload_name,
                "enabled": enabled,
                "asset_name": asset_name,
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            _dry_run,
        )
        return result.fetch("/api/v4/workloads/list", "GET") if fetch and not _dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def apply_workload(
        self_or_cls, workload_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Apply Workload

        **Permission Required:** `kelvin.permission.workload.update`.

        ``applyWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/apply``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/{workload_name}/apply",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "406": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def download_workload_package_file(
        self_or_cls, workload_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Iterator[bytes]:
        """
        Download Workload Package File

        **Permission Required:** `kelvin.permission.workload.read`.

        ``downloadWorkloadPackageFile``: ``GET`` ``/api/v4/workloads/{workload_name}/download``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/{workload_name}/download",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": bytes,
                "202": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "412": None,
            },
            True,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def get_workload(
        self_or_cls, workload_name: str, _dry_run: bool = False, _client: Any = None
    ) -> Workload:
        """
        Get Workload

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/{workload_name}/get",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Workload, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def get_workload_logs(
        self_or_cls,
        workload_name: str,
        tail_lines: Optional[str] = None,
        since_time: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> WorkloadLogs:
        """
        Get Workload Logs

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadLogs``: ``GET`` ``/api/v4/workloads/{workload_name}/logs/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name
        tail_lines : :obj:`str`
            The number of lines from the end of the logs to show
        since_time : :obj:`str`
            A timestamp from which to show logs

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/{workload_name}/logs/get",
            {"workload_name": workload_name},
            {"tail_lines": tail_lines, "since_time": since_time},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WorkloadLogs,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "500": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def start_workload(
        self_or_cls, workload_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Start Workload

        **Permission Required:** `kelvin.permission.workload.update`.

        ``startWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/start``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/{workload_name}/start",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def stop_workload(
        self_or_cls, workload_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Stop Workload

        **Permission Required:** `kelvin.permission.workload.update`.

        ``stopWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/stop``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/workloads/{workload_name}/stop",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def undeploy_workload(
        self_or_cls, workload_name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Undeploy Workload

        **Permission Required:** `kelvin.permission.workload.delete`.

        ``undeployWorkload``: ``POST`` ``/api/v4/workloads/{workload_name}/undeploy``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/workloads/{workload_name}/undeploy",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result


class WorkloadListPaginated(PaginatorDataModel[Workload]):
    """
    WorkloadListPaginated object.

    Parameters
    ----------
    data: Optional[List[Workload]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[Workload]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class ListAppsPaginatedResponse(PaginatorDataModel[models.AppProjection]):
    """
    ListAppsPaginatedResponse object.

    Parameters
    ----------
    data: Optional[List[models.AppProjection]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[models.AppProjection]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class ListResourcesPaginatedResponse(PaginatorDataModel[ResourceAppProjection]):
    """
    ListResourcesPaginatedResponse object.

    Parameters
    ----------
    data: Optional[List[ResourceAppProjection]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[ResourceAppProjection]] = None
    pagination: Optional[paginator.PaginationInfo] = None


class Recommendation(DataModelBase):
    """
    Recommendation object.

    Parameters
    ----------
    actions: Optional[RecommendationActions]
    confidence: Optional[int]
    created: Optional[str]
    custom_identifier: Optional[str]
    description: Optional[str]
    expiration_date: Optional[str]
    id: Optional[str]
    logs: Optional[List[RecommendationLog]]
    metadata: Optional[Dict[str, Any]]
    resource: Optional[str]
    resource_parameters: Optional[Dict[str, Any]]
    source: Optional[str]
    state: Optional[str]
    type: Optional[str]
    type_title: Optional[str]
    updated: Optional[str]

    """

    actions: Optional[RecommendationActions] = None
    confidence: Optional[int] = Field(
        None,
        description="Confidence level of the Recommendation.</p> This is a 32-bit signed integer from -2,147,483,648 to 2,147,483,647.</p> This is usually related to any machine learning model results that triggered this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.",
    )
    created: Optional[str] = Field(
        None,
        description="Time of creation of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )
    custom_identifier: Optional[str] = Field(None, description="An optional identifier.")
    description: Optional[str] = Field(
        None,
        description="Detailed description of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.",
    )
    expiration_date: Optional[str] = Field(
        None,
        description="Time of expiry of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".</p> After the defined time, the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> will no longer accept any update accept or update reject API requests.</p> If no date is given, then the Recommendation will never expire.",
    )
    id: Optional[str] = Field(
        None,
        description="A <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `id`.</p> An `id` is made from a Universally Unique Identifier (UUID) and must be made only of hexadecimal numbers and the `-` character.</p> It is a unique identifier for each <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> and is a 128-bit identifier generated using random or pseudo-random numbers consisting of 32 hexadecimal digits separated by hyphens into five groups of varying lengths: 8-4-4-4-12.",
    )
    logs: Optional[List[RecommendationLog]] = Field(
        None,
        description="An ordered list of the updates related to this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="Custom dictionary keys/values for use by clients for anything useful and related to the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.",
    )
    resource: Optional[str] = Field(
        None,
        description="The asset or API that this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> is related to.</p> This string always starts with `krn:`, then has `asset:`, then the name of the Kelvin Asset.</p> Even though there are other `krn` options it needs to be `asset:` so that it is associated with a <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-platform/kelvin-assets/#asset' target='_blank'>Kelvin Asset</a> and the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> will be seen in the Asset List of <a href='https://docs.kelvininc.com/latest/kelvin-overview/kelvin-maps/kelvin-maps-overview/' target='_blank'>Kelvin Maps</a>.</p> For example `krn:asset:demo-asset`",
    )
    resource_parameters: Optional[Dict[str, Any]] = None
    source: Optional[str] = Field(
        None,
        description="The user or workload that created this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.<p> This string always starts with `krn:`, then has either `user:` or `api:` followed by the user name, email or api id.</p> For example `krn:user:my.name@company.com` or `krn:user:api:app-recommendation:4.0.0`.",
    )
    state: Optional[str] = Field(
        None,
        description="The state reported by the last status update for this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.</p> Possible options are; `pending`, `accepted`, `rejected`, `applied`, `expired` and `error`.",
    )
    type: Optional[str] = Field(
        None,
        description="Unique identifier name of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a>.",
    )
    type_title: Optional[str] = Field(
        None,
        description="Display name (title) of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a>.",
    )
    updated: Optional[str] = Field(
        None,
        description="Time of modifying any variable of this <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> in ISO 8601 UTC date/time format. Example; \"2022-07-08T08:41:01.657916Z\".",
    )

    @classmethod
    def get_recommendation_clustering(
        cls,
        data: Optional[Union[requests.RecommendationClustering, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> List[RecommendationClustering]:
        """
        Get Recommendation Clustering

        Counts the number of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> matching an array of `resources` between two dates in buckets and also returns a list of all the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `id`s.

        Optionally a filter on the `types` and `states` can be applied.

        A bucket is defined as a unit of time such as seconds, minutes or hours. For example; <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> count could be grouped in hourly buckets between 12am and 12pm on a certain date.

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getRecommendationClustering``: ``POST`` ``/api/v4/recommendations/clustering/get``

        Parameters
        ----------
        data: requests.RecommendationClustering, optional
        **kwargs:
            Extra parameters for requests.RecommendationClustering
              - end_date: datetime
              - resource_names: list
              - sources: list
              - start_date: datetime
              - states: list
              - time_bucket: str
              - types: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/clustering/get",
            {},
            {},
            {},
            {},
            data,
            "requests.RecommendationClustering",
            False,
            {
                "200": List[RecommendationClustering],
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_recommendation(
        self_or_cls,
        data: Optional[Union[requests.RecommendationCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Recommendation:
        """
        Create Recommendation

        Create a new <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.</p> The new recommendation will automatically inherit the state `pending`.

        **Permission Required:** `kelvin.permission.recommendation.create`.

        ``createRecommendation``: ``POST`` ``/api/v4/recommendations/create``

        Parameters
        ----------
        data: requests.RecommendationCreate, optional
        **kwargs:
            Extra parameters for requests.RecommendationCreate
              - actions: str
              - confidence: int
              - custom_identifier: str
              - description: str
              - expiration_date: str
              - metadata: dict
              - resource: str
              - resource_parameters: dict
              - source: str
              - state: str
              - type: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/create",
            {},
            {},
            {},
            {},
            data,
            "requests.RecommendationCreate",
            False,
            {"201": Recommendation, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_last_recommendation(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.RecommendationLast, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[Recommendation], RecommendationPaginated]:
        """
        Get Last Recommendation

        Returns a dictionary with a data property containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a>.

        This will only return the last <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> for each of the `resources` in the `resources` array that match the filter options `states` and `types`.

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getLastRecommendation``: ``POST`` ``/api/v4/recommendations/last/get``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects to be returned. Page size
            can be between 1 and 1000 objects.</p> The default is 20 <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects.
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> parameters. Only one parameter can
            be selected.</p> There are eleven parameter options; `id`,
            `custom_identifier`, `source`, `resource`, `description`,
            `confidence`, `expiration_date`, `created_at`, `updated_at`, `state`,
            `type`.</p> The default is `id`
        data: requests.RecommendationLast, optional
        **kwargs:
            Extra parameters for requests.RecommendationLast
              - resources: list
              - sources: list
              - states: list
              - types: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/last/get",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.RecommendationLast",
            False,
            {"200": RecommendationPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/recommendations/last/get", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def list_recommendation(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.RecommendationList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[Recommendation], RecommendationPaginated]:
        """
        List Recommendation

        Returns a dictionary with a data property containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a>.

        This will return all <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> for the `id` or `resources` in the respective array that match the filter options `states` and `types`.

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``listRecommendation``: ``POST`` ``/api/v4/recommendations/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects to be returned. Page size
            can be between 1 and 1000 objects.</p> The default is 20 <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects.
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> parameters. Only one parameter can
            be selected.</p> There are eleven parameter options; `id`,
            `custom_identifier`, `source`, `resource`, `description`,
            `confidence`, `expiration_date`, `created_at`, `updated_at`, `state`,
            `type`.</p> The default is `id`
        data: requests.RecommendationList, optional
        **kwargs:
            Extra parameters for requests.RecommendationList
              - ids: list
              - resources: list
              - sources: list
              - states: list
              - types: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.RecommendationList",
            False,
            {"200": RecommendationPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/recommendations/list", "POST")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def get_range_recommendation(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.RecommendationRange, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[Recommendation], RecommendationPaginated]:
        """
        Get Range Recommendations

        Returns a dictionary with a data property containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a>.

        This will only return any <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> within a specified time range for all of the `resources` in the `resources` array that match the filter options `states` and `types`.

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getRangeRecommendation``: ``POST`` ``/api/v4/recommendations/range/get``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects to be returned. Page size
            can be between 1 and 1000 objects.</p> The default is 20 <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects.
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page of <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page of <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> objects in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> parameters. Only one parameter can
            be selected.</p> There are eleven parameter options; `id`,
            `custom_identifier`, `source`, `resource`, `description`,
            `confidence`, `expiration_date`, `created_at`, `updated_at`, `state`,
            `type`.</p> The default is `id`
        data: requests.RecommendationRange, optional
        **kwargs:
            Extra parameters for requests.RecommendationRange
              - end_date: datetime
              - resources: list
              - sources: list
              - start_date: datetime
              - states: list
              - types: list

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/range/get",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.RecommendationRange",
            False,
            {"200": RecommendationPaginated, "400": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return (
            result.fetch("/api/v4/recommendations/range/get", "POST")
            if fetch and not _dry_run
            else result
        )

    @instance_classmethod
    @DataModelBase.translate()
    def create_recommendation_type(
        self_or_cls,
        data: Optional[Union[requests.RecommendationTypeCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationType:
        """
        Create Recommendation Type

        Create a new Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.create`.

        ``createRecommendationType``: ``POST`` ``/api/v4/recommendations/types/create``

        Parameters
        ----------
        data: requests.RecommendationTypeCreate, optional
        **kwargs:
            Extra parameters for requests.RecommendationTypeCreate
              - description: str
              - name: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/types/create",
            {},
            {},
            {},
            {},
            data,
            "requests.RecommendationTypeCreate",
            False,
            {"201": RecommendationType, "400": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_recommendation_types(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> Union[List[RecommendationType], RecommendationTypePaginated]:
        """
        List Recommendation Types

        Returns a dictionary with a data object containing an array of <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation Type</a> objects on the Kelvin Platform.

        **Pagination Sortable Columns:** `name`, `title`, `description`, `created`, `updated`

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``listRecommendationTypes``: ``GET`` ``/api/v4/recommendations/types/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the parameters. Only one parameter can be
            selected.</p> Allowed options: `name`,
            `title`,`created`,`updated`.</p> The default is `name`
        search : :obj:`Sequence[str]`
            Search recommendation types by name or title

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/recommendations/types/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {
                "200": RecommendationTypePaginated,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
        )
        return (
            result.fetch("/api/v4/recommendations/types/list", "GET")
            if fetch and not _dry_run
            else result
        )

    @classmethod
    def delete_recommendation_type(
        cls, name: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Recommendation Type

        Delete a Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.delete`.

        ``deleteRecommendationType``: ``POST`` ``/api/v4/recommendations/types/{name}/delete``

        Parameters
        ----------
        name : :obj:`str`, optional
            Recommendation Type name

        """

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/types/{name}/delete",
            {"name": name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "404": ErrorMessages, "409": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @classmethod
    def get_recommendation_type(
        cls, name: str, _dry_run: bool = False, _client: Any = None
    ) -> RecommendationType:
        """
        Get Recommendation Type

        Get a Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getRecommendationType``: ``GET`` ``/api/v4/recommendations/types/{name}/get``

        Parameters
        ----------
        name : :obj:`str`, optional
            Recommendation Type name

        """

        result = cls._make_request(
            _client,
            "get",
            "/api/v4/recommendations/types/{name}/get",
            {"name": name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": RecommendationType, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_recommendation_type(
        self_or_cls,
        name: str,
        data: Optional[Union[requests.RecommendationTypeUpdate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationType:
        """
        Update Recommendation Type

        Update a Recommendation Type

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``updateRecommendationType``: ``POST`` ``/api/v4/recommendations/types/{name}/update``

        Parameters
        ----------
        name : :obj:`str`, optional
            Recommendation Type name
        data: requests.RecommendationTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.RecommendationTypeUpdate
              - description: str
              - title: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/types/{name}/update",
            {"name": name},
            {},
            {},
            {},
            data,
            "requests.RecommendationTypeUpdate",
            False,
            {"200": RecommendationType, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"recommendation_id": "id"})
    def update_accept_recommendation(
        self_or_cls,
        recommendation_id: str,
        data: Optional[Union[requests.RecommendationAccept, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationResponsePayload:
        """
        Update Accept Recommendation

        Update a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `state` to `accepted`.

        This will trigger the `actions` for the `control change` in the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> to be created on the <a href='https://docs.kelvininc.com/latest/kelvin-overview/overview/#kelvin-platform' target='_blank'>Kelvin Platform</a>.

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``updateAcceptRecommendation``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/accept/update``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.
        data: requests.RecommendationAccept, optional
        **kwargs:
            Extra parameters for requests.RecommendationAccept
              - confidence: int
              - message: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/accept/update",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            data,
            "requests.RecommendationAccept",
            False,
            {"200": RecommendationResponsePayload, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"recommendation_id": "id"})
    def delete_recommendation(
        self_or_cls, recommendation_id: str, _dry_run: bool = False, _client: Any = None
    ) -> RecommendationResponsePayload:
        """
        Delete Recommendation

        Permanently delete an existing <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>. This cannot be undone once the API request has been submitted.

        <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a> that have have a `state` value of `accepted`, `applied` or have `error` can not be deleted.

        **Permission Required:** `kelvin.permission.recommendation.delete`.

        ``deleteRecommendation``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/delete``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/delete",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": RecommendationResponsePayload, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"recommendation_id": "id"})
    def get_recommendation(
        self_or_cls, recommendation_id: str, _dry_run: bool = False, _client: Any = None
    ) -> Recommendation:
        """
        Get Recommendation

        Retrieves the properties, status and all associated actions of a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.

        **Permission Required:** `kelvin.permission.recommendation.read`.

        ``getRecommendation``: ``GET`` ``/api/v4/recommendations/{recommendation_id}/get``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.

        """

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/recommendations/{recommendation_id}/get",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Recommendation, "404": ErrorMessages},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"recommendation_id": "id"})
    def create_log(
        self_or_cls,
        recommendation_id: str,
        data: Optional[Union[requests.RecommendationCreateLog, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Log

        Create a new log entry for a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>. An unlimited number of logs can be attached to a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.

        This has no effect on the `state` of the <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a>.

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``createLog``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/log/create``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.
        data: requests.RecommendationCreateLog, optional
        **kwargs:
            Extra parameters for requests.RecommendationCreateLog
              - message: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/log/create",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            data,
            "requests.RecommendationCreateLog",
            False,
            {"201": None, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"recommendation_id": "id"})
    def update_reject_recommendation(
        self_or_cls,
        recommendation_id: str,
        data: Optional[Union[requests.RecommendationReject, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> RecommendationResponsePayload:
        """
        Update Reject Recommendation

        Update a <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendation</a> `state` to `rejected`.

        **Permission Required:** `kelvin.permission.recommendation.update`.

        ``updateRejectRecommendation``: ``POST`` ``/api/v4/recommendations/{recommendation_id}/reject/update``

        Parameters
        ----------
        recommendation_id : :obj:`str`, optional
            <a href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a> `id`.</p> An `id` must be made only
            of hexadecimal numbers and the `-` character.</p> It is a Universally
            Unique Identifier (UUID) to identify each <a
            href='https://docs.kelvininc.com/latest/kelvin-
            overview/technologies/recommendations/'
            target='_blank'>Recommendation</a>.</p>It is a 128-bit identifier
            generated using random or pseudo-random numbers and consists of 32
            hexadecimal digits separated by hyphens into five groups of varying
            lengths: 8-4-4-4-12.
        data: requests.RecommendationReject, optional
        **kwargs:
            Extra parameters for requests.RecommendationReject
              - confidence: int
              - message: str

        """

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/recommendations/{recommendation_id}/reject/update",
            {"recommendation_id": recommendation_id},
            {},
            {},
            {},
            data,
            "requests.RecommendationReject",
            False,
            {"200": RecommendationResponsePayload, "400": ErrorMessages, "404": ErrorMessages},
            False,
            _dry_run,
            kwargs,
        )
        return result


class RecommendationPaginated(PaginatorDataModel[Recommendation]):
    """
    RecommendationPaginated object.

    Parameters
    ----------
    data: Optional[List[Recommendation]]
    pagination: Optional[paginator.PaginationInfo]

    """

    data: Optional[List[Recommendation]] = Field(
        None,
        description="A dictionary which contains an array of up to `page_size` <a href='https://docs.kelvininc.com/latest/kelvin-overview/technologies/recommendations/' target='_blank'>Recommendations</a>. Depending on the type of `pagination_type` declared, if a bookmark has been used, then the array will start or end based on the `starting_after` or `ending_before` parameters.",
    )
    pagination: Optional[paginator.PaginationInfo] = None


class Reply(DataModelBase):
    """
    Reply object.

    Parameters
    ----------
    content: Optional[ThreadContent]
    created: Optional[datetime]
    id: Optional[str]
    updated: Optional[datetime]
    user_id: Optional[str]

    """

    content: Optional[ThreadContent] = None
    created: Optional[datetime] = None
    id: Optional[str] = None
    updated: Optional[datetime] = None
    user_id: Optional[str] = None


class Thread(DataModelBase):
    """
    Thread object.

    Parameters
    ----------
    content: Optional[ThreadContent]
    created: Optional[datetime]
    follows: Optional[Dict[str, UserFollow]]
    id: Optional[str]
    related_to: Optional[str]
    type: Optional[str]
    updated: Optional[datetime]
    user_id: Optional[str]

    """

    content: Optional[ThreadContent] = None
    created: Optional[datetime] = None
    follows: Optional[Dict[str, UserFollow]] = None
    id: Optional[str] = None
    related_to: Optional[str] = None
    type: Optional[str] = None
    updated: Optional[datetime] = None
    user_id: Optional[str] = None

    @classmethod
    def create_thread(
        cls, body: str, file: Optional[str] = None, _dry_run: bool = False, _client: Any = None
    ) -> List[Thread]:
        """
        Create Thread

        **Permission Required:** `kelvin.permission.thread.create`.

        ``createThread``: ``POST`` ``/api/v4/threads/create``

        Parameters
        ----------
        body : :obj:`str`, optional
            requests.ThreadCreate schema
        file : :obj:`str`
            Attachment

        """

        from . import errors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/threads/create",
            {},
            {},
            {"body": body, "file": file},
            {},
            None,
            None,
            False,
            {"201": List[Thread], "400": errors.ErrorMessage, "401": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_threads(
        self_or_cls,
        type: Optional[str] = None,
        related_to: Optional[str] = None,
        user_id: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> List[Thread]:
        """
        List Threads

        **Pagination Sortable Columns:** `thread.id`

        **Permission Required:** `kelvin.permission.thread.read`.

        ``listThreads``: ``GET`` ``/api/v4/threads/list``

        Parameters
        ----------
        type : :obj:`str`
            Filter threads by type
        related_to : :obj:`str`
            Filter threads by related_to
        user_id : :obj:`str`
            Filter threads by user_id

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/threads/list",
            {},
            {"type": type, "related_to": related_to, "user_id": user_id},
            {},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "400": errors.ErrorMessage, "401": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def delete_thread(
        self_or_cls, thread_id: str, _dry_run: bool = False, _client: Any = None
    ) -> None:
        """
        Delete Thread

        **Permission Required:** `kelvin.permission.thread.delete`.

        ``deleteThread``: ``POST`` ``/api/v4/threads/{thread_id}/delete``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/threads/{thread_id}/delete",
            {"thread_id": thread_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": errors.ErrorMessage, "403": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def update_thread_follow(
        self_or_cls,
        thread_id: str,
        follow: Optional[bool] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> List[Thread]:
        """
        Update Thread Follow

        **Permission Required:** `kelvin.permission.thread.read`.

        ``updateThreadFollow``: ``POST`` ``/api/v4/threads/{thread_id}/follow/update``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID
        follow : :obj:`bool`
            Set user follow value to true or false

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/threads/{thread_id}/follow/update",
            {"thread_id": thread_id},
            {"follow": follow},
            {},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "404": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def get_thread(
        self_or_cls, thread_id: str, _dry_run: bool = False, _client: Any = None
    ) -> List[Thread]:
        """
        Get Thread

        **Permission Required:** `kelvin.permission.thread.read`.

        ``getThread``: ``GET`` ``/api/v4/threads/{thread_id}/get``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "get",
            "/api/v4/threads/{thread_id}/get",
            {"thread_id": thread_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "404": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def create_thread_reply(
        self_or_cls,
        thread_id: str,
        body: str,
        reply_id: Optional[str] = None,
        file: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> List[Thread]:
        """
        Create Thread Reply

        **Permission Required:** `kelvin.permission.thread.create`.

        ``createThreadReply``: ``POST`` ``/api/v4/threads/{thread_id}/replies/create``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID
        body : :obj:`str`, optional
            requests.ThreadReplyCreate schema
        reply_id : :obj:`str`
            Reply ID
        file : :obj:`str`
            Attachment

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/threads/{thread_id}/replies/create",
            {"thread_id": thread_id},
            {"reply_id": reply_id},
            {"body": body, "file": file},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "400": errors.ErrorMessage, "401": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def delete_thread_reply(
        self_or_cls, thread_id: str, reply_id: str, _dry_run: bool = False, _client: Any = None
    ) -> List[Thread]:
        """
        Delete Thread Reply

        **Permission Required:** `kelvin.permission.thread.delete`.

        ``deleteThreadReply``: ``POST`` ``/api/v4/threads/{thread_id}/replies/{reply_id}/delete``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID
        reply_id : :obj:`str`, optional
            Reply ID

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/threads/{thread_id}/replies/{reply_id}/delete",
            {"thread_id": thread_id, "reply_id": reply_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "400": errors.ErrorMessage, "401": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def update_thread_reply(
        self_or_cls,
        thread_id: str,
        reply_id: str,
        body: str,
        file: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> List[Thread]:
        """
        Update Thread Reply

        **Permission Required:** `kelvin.permission.thread.update`.

        ``updateThreadReply``: ``POST`` ``/api/v4/threads/{thread_id}/replies/{reply_id}/update``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID
        reply_id : :obj:`str`, optional
            Reply ID
        body : :obj:`str`, optional
            requests.ThreadReplyUpdate schema
        file : :obj:`str`
            Attachment

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/threads/{thread_id}/replies/{reply_id}/update",
            {"thread_id": thread_id, "reply_id": reply_id},
            {},
            {"body": body, "file": file},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "400": errors.ErrorMessage, "401": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def update_thread_seen(
        self_or_cls,
        thread_id: str,
        seen: Optional[bool] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> List[Thread]:
        """
        Update Thread Seen

        **Permission Required:** `kelvin.permission.thread.read`.

        ``updateThreadSeen``: ``POST`` ``/api/v4/threads/{thread_id}/seen/update``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID
        seen : :obj:`bool`
            Set user seen value to true or false

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/threads/{thread_id}/seen/update",
            {"thread_id": thread_id},
            {"seen": seen},
            {},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "404": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"thread_id": "id"})
    def update_thread(
        self_or_cls,
        thread_id: str,
        body: str,
        file: Optional[str] = None,
        _dry_run: bool = False,
        _client: Any = None,
    ) -> List[Thread]:
        """
        Update Thread

        **Permission Required:** `kelvin.permission.thread.update`.

        ``updateThread``: ``POST`` ``/api/v4/threads/{thread_id}/update``

        Parameters
        ----------
        thread_id : :obj:`str`, optional
            Thread ID
        body : :obj:`str`, optional
            requests.ThreadUpdate schema
        file : :obj:`str`
            Attachment

        """

        from . import errors

        result = self_or_cls._make_request(
            _client,
            "post",
            "/api/v4/threads/{thread_id}/update",
            {"thread_id": thread_id},
            {},
            {"body": body, "file": file},
            {},
            None,
            None,
            False,
            {"200": List[Thread], "400": errors.ErrorMessage, "401": errors.ErrorMessage},
            False,
            _dry_run,
        )
        return result


class ThreadContent(DataModelBase):
    """
    ThreadContent object.

    Parameters
    ----------
    attachments: Optional[List[Attachment]]
    mentions: Optional[List[str]]
    replies: Optional[List[Reply]]
    text: Optional[str]

    """

    attachments: Optional[List[Attachment]] = None
    mentions: Optional[List[str]] = None
    replies: Optional[List[Reply]] = None
    text: Optional[str] = None


Reply.update_forward_refs()
Thread.update_forward_refs()
