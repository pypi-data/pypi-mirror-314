# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2024-02-05T18:54:09+00:00

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Iterator, List, Mapping, Optional, Sequence, Union

from typing_extensions import Literal

from kelvin.sdk.client.data_model import DataModelBase
from kelvin.sdk.client.utils import instance_classmethod

if TYPE_CHECKING:
    from . import kerrors, requests, responses


class TimeseriesProjection(DataModelBase):
    """
    TimeseriesProjection object.

    Parameters
    ----------
    created: Optional[str]
    data_type: Optional[str]
    fields: Optional[List[str]]
    last_timestamp: Optional[str]
    last_value: Optional[Any]
    resource: Optional[str]
    source: Optional[str]
    updated: Optional[str]

    """

    created: Optional[str] = None
    data_type: Optional[str] = None
    fields: Optional[List[str]] = None
    last_timestamp: Optional[str] = None
    last_value: Optional[Any] = None
    resource: Optional[str] = None
    source: Optional[str] = None
    updated: Optional[str] = None

    @classmethod
    def create_timeseries_data(
        cls,
        data: Optional[Union[requests.TimeseriesBulkCreate, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Timeseries Data


        <span style="color: #ff0000;font-weight: bold;">WARNING</span> : If a value already exists at the defined time, then it will be overwritten with the new payload value. The old value will be lost and is not recoverable !

        **Permission Required:** `kelvin.permission.storage.create`.

        ``createTimeseriesData``: ``POST`` ``/api/v4/timeseries/create``

        Parameters
        ----------
        data: requests.TimeseriesBulkCreate, optional
        **kwargs:
            Extra parameters for requests.TimeseriesBulkCreate
              - data: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/timeseries/create",
            {},
            {},
            {},
            {},
            data,
            "requests.TimeseriesBulkCreate",
            False,
            {
                "201": None,
                "207": kerrors.ErrorMessage,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_last_timeseries_data(
        cls,
        data: Optional[Union[requests.TimeseriesGetLast, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> List[TimeseriesProjection]:
        """
        Get Last Timeseries Data


        **Permission Required:** `kelvin.permission.storage.read`.

        ``getLastTimeseriesData``: ``POST`` ``/api/v4/timeseries/last/get``

        Parameters
        ----------
        data: requests.TimeseriesGetLast, optional
        **kwargs:
            Extra parameters for requests.TimeseriesGetLast
              - selectors: list

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/timeseries/last/get",
            {},
            {},
            {},
            {},
            data,
            "requests.TimeseriesGetLast",
            False,
            {
                "200": List[TimeseriesProjection],
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def list_timeseries_data(
        cls,
        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
        page_size: Optional[int] = 10000,
        page: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        direction: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Sequence[str]] = None,
        data: Optional[Union[requests.TimeseriesList, Mapping[str, Any]]] = None,
        fetch: bool = True,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Union[List[TimeseriesProjection], responses.TimeseriesPaginatedResponse]:
        """
        List Timeseries Data

        **Pagination Sortable Columns:** `resource`, `data_type`,`last_timestamp`,`created`, `updated`

        **Permission Required:** `kelvin.permission.storage.read`.

        ``listTimeseriesData``: ``POST`` ``/api/v4/timeseries/list``

        Parameters
        ----------
        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
            Method of handling pages in the returned data. There are three options
            available;</p> limits: This is used with the query parameters `page`
            to select which page of data to return. The start of the data returned
            will be calculated using the `page_size` and `page` query parameters
            for the location to start and the query parameters `sort_by` and
            `direction` will determine the order of the data.</p> cursor: This is
            used with the query parameters `next` and `previous` which uses a
            string as the start or end location reference. The string to use is
            returned in the previous query json response in the keys `next_page`
            and `previous_page`.</p> stream: This will return all the data in one
            response. (limits, cursor, stream)
        page_size : :obj:`int`
            Number of items to be returned in each page. Page size can be between
            1 and 1000 objects.</p> The default is 20
        page : :obj:`int`
            Used only with query parameter `pagination_type` set as `limits`.</p>
            An integer for the wanted page of results. The start of the data
            returned will be calculated using the `page_size` and `page` query
            parameters for the location to start and the query parameters
            `sort_by` and `direction` will determine the order of the data.
        next : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the next page in the list.</p> The
            alphanumeric string which are the bookmarks for the beginning and end
            of the current list is given in the previous JSON response value under
            the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> next_page alphanumeric string
            should be used here to show a list of the next page of results.
        previous : :obj:`str`
            Used only with query parameter `pagination_type` set as `cursor`.</p>
            An alphanumeric string to move to the previous page in the list.</p>
            The alphanumeric string which are the bookmarks for the beginning and
            end of the current list is given in the previous JSON response value
            under the key pagination -> previous_page and pagination -> next_page
            respectively.</p> The pagination -> previous_page alphanumeric string
            should be used here to show a list of the previous page of results.
        direction : :obj:`Literal['asc', 'desc']`
            Sorting order for the results according to the `sort_by`
            parameter.</p> There are two options; `asc` (ascending order) and
            `desc` (descending order).</p> The default is `asc` (ascending). (asc,
            desc)
        sort_by : :obj:`Sequence[str]`
            Sort the results by one of the workload parameters. Only one parameter
            can be selected.</p> Allowed options: `resource`,
            `data_type`,`last_timestamp`,`created`, `updated`.</p> The default is
            `resource`
        data: requests.TimeseriesList, optional
        **kwargs:
            Extra parameters for requests.TimeseriesList
              - resource: list
              - source: list

        """

        from . import kerrors, responses

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/timeseries/list",
            {},
            {
                "pagination_type": pagination_type,
                "page_size": page_size,
                "page": page,
                "next": next,
                "previous": previous,
                "direction": direction,
                "sort_by": sort_by,
            },
            {},
            {},
            data,
            "requests.TimeseriesList",
            False,
            {
                "200": responses.TimeseriesPaginatedResponse,
                "400": kerrors.ErrorMessage,
                "401": kerrors.ErrorMessage,
            },
            False,
            _dry_run,
            kwargs,
        )
        return result.fetch("/api/v4/timeseries/list", "POST") if fetch and not _dry_run else result

    @classmethod
    def download_range_timeseries_data(
        cls,
        data: Optional[Union[requests.TimeseriesGetRange, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Iterator[None]:
        """
        Download Range Timeseries Data

        Returns a **CSV file** with time series data within a for a given time range and given list of resources in the parameter `selectors`.

        **Permission Required:** `kelvin.permission.storage.read`.

        ``downloadRangeTimeseriesData``: ``POST`` ``/api/v4/timeseries/range/download``

        Parameters
        ----------
        data: requests.TimeseriesGetRange, optional
        **kwargs:
            Extra parameters for requests.TimeseriesGetRange
              - agg: str
              - end_time: datetime
              - fill: str
              - group_by_selector: bool
              - order: str
              - selectors: list
              - start_time: datetime
              - time_bucket: str
              - time_shift: str

        """

        from . import kerrors

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/timeseries/range/download",
            {},
            {},
            {},
            {},
            data,
            "requests.TimeseriesGetRange",
            False,
            {"200": None, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            True,
            _dry_run,
            kwargs,
        )
        return result

    @classmethod
    def get_range_timeseries_data(
        cls,
        data: Optional[Union[requests.TimeseriesGetRange, Mapping[str, Any]]] = None,
        _dry_run: bool = False,
        _client: Any = None,
        **kwargs: Any,
    ) -> Iterator[responses.Data]:
        """
        Get Range Timeseries Data


        **Permission Required:** `kelvin.permission.storage.read`.

        ``getRangeTimeseriesData``: ``POST`` ``/api/v4/timeseries/range/get``

        Parameters
        ----------
        data: requests.TimeseriesGetRange, optional
        **kwargs:
            Extra parameters for requests.TimeseriesGetRange
              - agg: str
              - end_time: datetime
              - fill: str
              - group_by_selector: bool
              - order: str
              - selectors: list
              - start_time: datetime
              - time_bucket: str
              - time_shift: str

        """

        from . import kerrors, responses

        result = cls._make_request(
            _client,
            "post",
            "/api/v4/timeseries/range/get",
            {},
            {},
            {},
            {},
            data,
            "requests.TimeseriesGetRange",
            False,
            {"200": responses.Data, "400": kerrors.ErrorMessage, "401": kerrors.ErrorMessage},
            True,
            _dry_run,
            kwargs,
        )
        return result
