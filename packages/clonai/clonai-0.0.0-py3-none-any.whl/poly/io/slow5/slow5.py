"""
Package slow5 contains slow5 parsers and writers.

Right now, only parsing slow5 files is supported. Support for writing and blow5
coming soon.

slow5 is a file format alternative to fast5, which is the file format outputted
by Oxford Nanopore sequencing devices. fast5 uses hdf5, which is a complex file
format that can only be read and written with a single software library built
in 1998. On the other hand, slow5 uses a .tsv file format, which is easy to
both parse and write.

slow5 files contain both general metadata about the sequencing run and raw
signal reads from the sequencing run. This raw signal can be used directly or
basecalled and used for alignment.

More information on slow5 can be found here: https://github.com/hasindu2008/slow5tools

"""
# python wrapper for package github.com/bebop/poly/io/slow5 within overall package slow5
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=poly/io/slow5 -vm=python3 github.com/bebop/poly/io/slow5

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _slow5
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from slow5 import slow5
# and then refer to everything using slow5. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for map map[string]int
class Map_string_int(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_slow5.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_slow5.IncRef(self.handle)
		else:
			self.handle = _slow5.Map_string_int_CTor()
			_slow5.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_int.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_slow5.Map_string_int_set(self.handle, k, v)
	def __del__(self):
		_slow5.DecRef(self.handle)
	def __str__(self):
		s = 'slow5.Map_string_int len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'slow5.Map_string_int({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _slow5.Map_string_int_len(self.handle)
	def __getitem__(self, key):
		return _slow5.Map_string_int_elem(self.handle, key)
	def __setitem__(self, key, value):
		_slow5.Map_string_int_set(self.handle, key, value)
	def __delitem__(self, key):
		return _slow5.Map_string_int_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_slow5.Map_string_int_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _slow5.Map_string_int_contains(self.handle, key)

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_slow5.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_slow5.IncRef(self.handle)
		else:
			self.handle = _slow5.Map_string_string_CTor()
			_slow5.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_slow5.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_slow5.DecRef(self.handle)
	def __str__(self):
		s = 'slow5.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'slow5.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _slow5.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _slow5.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_slow5.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _slow5.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_slow5.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _slow5.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct slow5.Header
class Header(go.GoClass):
	"""Header contains metadata about the sequencing run in general.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_slow5.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_slow5.IncRef(self.handle)
		else:
			self.handle = _slow5.slow5_Header_CTor()
			_slow5.IncRef(self.handle)
			if  0 < len(args):
				self.ReadGroupID = args[0]
			if "ReadGroupID" in kwargs:
				self.ReadGroupID = kwargs["ReadGroupID"]
			if  1 < len(args):
				self.Slow5Version = args[1]
			if "Slow5Version" in kwargs:
				self.Slow5Version = kwargs["Slow5Version"]
			if  2 < len(args):
				self.Attributes = args[2]
			if "Attributes" in kwargs:
				self.Attributes = kwargs["Attributes"]
			if  3 < len(args):
				self.EndReasonHeaderMap = args[3]
			if "EndReasonHeaderMap" in kwargs:
				self.EndReasonHeaderMap = kwargs["EndReasonHeaderMap"]
	def __del__(self):
		_slow5.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'slow5.Header{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'slow5.Header ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ReadGroupID(self):
		return _slow5.slow5_Header_ReadGroupID_Get(self.handle)
	@ReadGroupID.setter
	def ReadGroupID(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Header_ReadGroupID_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Header_ReadGroupID_Set(self.handle, value)
	@property
	def Slow5Version(self):
		return _slow5.slow5_Header_Slow5Version_Get(self.handle)
	@Slow5Version.setter
	def Slow5Version(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Header_Slow5Version_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Header_Slow5Version_Set(self.handle, value)
	@property
	def Attributes(self):
		return Map_string_string(handle=_slow5.slow5_Header_Attributes_Get(self.handle))
	@Attributes.setter
	def Attributes(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Header_Attributes_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def EndReasonHeaderMap(self):
		return Map_string_int(handle=_slow5.slow5_Header_EndReasonHeaderMap_Get(self.handle))
	@EndReasonHeaderMap.setter
	def EndReasonHeaderMap(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Header_EndReasonHeaderMap_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct slow5.Parser
class Parser(go.GoClass):
	"""Parser is a flexible parser that provides ample\ncontrol over reading slow5 sequences.\nIt is initialized with NewParser.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_slow5.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_slow5.IncRef(self.handle)
		else:
			self.handle = _slow5.slow5_Parser_CTor()
			_slow5.IncRef(self.handle)
	def __del__(self):
		_slow5.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'slow5.Parser{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'slow5.Parser ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ParseNext(self):
		"""ParseNext() object, str
		
		ParseNext parses the next read from a parser.
		"""
		return Read(handle=_slow5.slow5_Parser_ParseNext(self.handle))

# Python type for struct slow5.Read
class Read(go.GoClass):
	"""Read contains metadata and raw signal strengths for a single nanopore read.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_slow5.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_slow5.IncRef(self.handle)
		else:
			self.handle = _slow5.slow5_Read_CTor()
			_slow5.IncRef(self.handle)
			if  0 < len(args):
				self.ReadID = args[0]
			if "ReadID" in kwargs:
				self.ReadID = kwargs["ReadID"]
			if  1 < len(args):
				self.ReadGroupID = args[1]
			if "ReadGroupID" in kwargs:
				self.ReadGroupID = kwargs["ReadGroupID"]
			if  2 < len(args):
				self.Digitisation = args[2]
			if "Digitisation" in kwargs:
				self.Digitisation = kwargs["Digitisation"]
			if  3 < len(args):
				self.Offset = args[3]
			if "Offset" in kwargs:
				self.Offset = kwargs["Offset"]
			if  4 < len(args):
				self.Range = args[4]
			if "Range" in kwargs:
				self.Range = kwargs["Range"]
			if  5 < len(args):
				self.SamplingRate = args[5]
			if "SamplingRate" in kwargs:
				self.SamplingRate = kwargs["SamplingRate"]
			if  6 < len(args):
				self.LenRawSignal = args[6]
			if "LenRawSignal" in kwargs:
				self.LenRawSignal = kwargs["LenRawSignal"]
			if  7 < len(args):
				self.RawSignal = args[7]
			if "RawSignal" in kwargs:
				self.RawSignal = kwargs["RawSignal"]
			if  8 < len(args):
				self.ChannelNumber = args[8]
			if "ChannelNumber" in kwargs:
				self.ChannelNumber = kwargs["ChannelNumber"]
			if  9 < len(args):
				self.MedianBefore = args[9]
			if "MedianBefore" in kwargs:
				self.MedianBefore = kwargs["MedianBefore"]
			if  10 < len(args):
				self.ReadNumber = args[10]
			if "ReadNumber" in kwargs:
				self.ReadNumber = kwargs["ReadNumber"]
			if  11 < len(args):
				self.StartMux = args[11]
			if "StartMux" in kwargs:
				self.StartMux = kwargs["StartMux"]
			if  12 < len(args):
				self.StartTime = args[12]
			if "StartTime" in kwargs:
				self.StartTime = kwargs["StartTime"]
			if  13 < len(args):
				self.EndReason = args[13]
			if "EndReason" in kwargs:
				self.EndReason = kwargs["EndReason"]
	def __del__(self):
		_slow5.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'slow5.Read{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'slow5.Read ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ReadID(self):
		return _slow5.slow5_Read_ReadID_Get(self.handle)
	@ReadID.setter
	def ReadID(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_ReadID_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_ReadID_Set(self.handle, value)
	@property
	def ReadGroupID(self):
		return _slow5.slow5_Read_ReadGroupID_Get(self.handle)
	@ReadGroupID.setter
	def ReadGroupID(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_ReadGroupID_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_ReadGroupID_Set(self.handle, value)
	@property
	def Digitisation(self):
		return _slow5.slow5_Read_Digitisation_Get(self.handle)
	@Digitisation.setter
	def Digitisation(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_Digitisation_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_Digitisation_Set(self.handle, value)
	@property
	def Offset(self):
		return _slow5.slow5_Read_Offset_Get(self.handle)
	@Offset.setter
	def Offset(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_Offset_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_Offset_Set(self.handle, value)
	@property
	def Range(self):
		return _slow5.slow5_Read_Range_Get(self.handle)
	@Range.setter
	def Range(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_Range_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_Range_Set(self.handle, value)
	@property
	def SamplingRate(self):
		return _slow5.slow5_Read_SamplingRate_Get(self.handle)
	@SamplingRate.setter
	def SamplingRate(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_SamplingRate_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_SamplingRate_Set(self.handle, value)
	@property
	def LenRawSignal(self):
		return _slow5.slow5_Read_LenRawSignal_Get(self.handle)
	@LenRawSignal.setter
	def LenRawSignal(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_LenRawSignal_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_LenRawSignal_Set(self.handle, value)
	@property
	def RawSignal(self):
		return go.Slice_int16(handle=_slow5.slow5_Read_RawSignal_Get(self.handle))
	@RawSignal.setter
	def RawSignal(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_RawSignal_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ChannelNumber(self):
		"""Auxiliary fields
		"""
		return _slow5.slow5_Read_ChannelNumber_Get(self.handle)
	@ChannelNumber.setter
	def ChannelNumber(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_ChannelNumber_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_ChannelNumber_Set(self.handle, value)
	@property
	def MedianBefore(self):
		return _slow5.slow5_Read_MedianBefore_Get(self.handle)
	@MedianBefore.setter
	def MedianBefore(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_MedianBefore_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_MedianBefore_Set(self.handle, value)
	@property
	def ReadNumber(self):
		return _slow5.slow5_Read_ReadNumber_Get(self.handle)
	@ReadNumber.setter
	def ReadNumber(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_ReadNumber_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_ReadNumber_Set(self.handle, value)
	@property
	def StartMux(self):
		return _slow5.slow5_Read_StartMux_Get(self.handle)
	@StartMux.setter
	def StartMux(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_StartMux_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_StartMux_Set(self.handle, value)
	@property
	def StartTime(self):
		return _slow5.slow5_Read_StartTime_Get(self.handle)
	@StartTime.setter
	def StartTime(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_StartTime_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_StartTime_Set(self.handle, value)
	@property
	def EndReason(self):
		return _slow5.slow5_Read_EndReason_Get(self.handle)
	@EndReason.setter
	def EndReason(self, value):
		if isinstance(value, go.GoClass):
			_slow5.slow5_Read_EndReason_Set(self.handle, value.handle)
		else:
			_slow5.slow5_Read_EndReason_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---


