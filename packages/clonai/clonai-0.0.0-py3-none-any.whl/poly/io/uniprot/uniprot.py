"""
Package uniprot provides an XML parser for Uniprot data dumps.

Uniprot is comprehensive, high-quality and freely accessible resource of protein
sequence and functional information. It is the best(1) protein database out there.

Uniprot database dumps are available as gzipped FASTA files or gzipped XML files.
The XML files have significantly more information than the FASTA files, and this
parser specifically works on the gzipped XML files from Uniprot.

Uniprot provides an XML schema of their data dumps(3), which is useful for
autogeneration of Golang structs. xsdgen was used to automatically generate
xml.go from uniprot.xsd.

Each protein in Uniprot is known as an "Entry" (as defined in xml.go).

The function Parse stream-reads Uniprot into an Entry channel, from which you
can use the entries however you want. Read simplifies reading gzipped files
from a disk into an Entry channel.

"""
# python wrapper for package github.com/bebop/poly/io/uniprot within overall package uniprot
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=poly/io/uniprot -vm=python3 github.com/bebop/poly/io/uniprot

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _uniprot
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from uniprot import uniprot
# and then refer to everything using uniprot. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []xml.Attr
class Slice_xml_Attr(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_xml_Attr_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_xml_Attr.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_xml_Attr len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_xml_Attr([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_xml_Attr_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_xml_Attr_len(self.handle)
				return Slice_xml_Attr(handle=_uniprot.Slice_xml_Attr_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.xml_Attr(handle=_uniprot.Slice_xml_Attr_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_xml_Attr_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_xml_Attr.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.xml_Attr(handle=_uniprot.Slice_xml_Attr_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_xml_Attr_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.AlternativeName
class Slice_uniprot_AlternativeName(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_AlternativeName_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_AlternativeName.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_AlternativeName len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_AlternativeName([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_AlternativeName_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_AlternativeName_len(self.handle)
				return Slice_uniprot_AlternativeName(handle=_uniprot.Slice_uniprot_AlternativeName_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return AlternativeName(handle=_uniprot.Slice_uniprot_AlternativeName_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_AlternativeName_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_AlternativeName.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = AlternativeName(handle=_uniprot.Slice_uniprot_AlternativeName_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_AlternativeName_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.CofactorType
class Slice_uniprot_CofactorType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_CofactorType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_CofactorType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_CofactorType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_CofactorType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_CofactorType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_CofactorType_len(self.handle)
				return Slice_uniprot_CofactorType(handle=_uniprot.Slice_uniprot_CofactorType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return CofactorType(handle=_uniprot.Slice_uniprot_CofactorType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_CofactorType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_CofactorType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = CofactorType(handle=_uniprot.Slice_uniprot_CofactorType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_CofactorType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.CommentType
class Slice_uniprot_CommentType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_CommentType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_CommentType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_CommentType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_CommentType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_CommentType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_CommentType_len(self.handle)
				return Slice_uniprot_CommentType(handle=_uniprot.Slice_uniprot_CommentType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return CommentType(handle=_uniprot.Slice_uniprot_CommentType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_CommentType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_CommentType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = CommentType(handle=_uniprot.Slice_uniprot_CommentType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_CommentType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.Component
class Slice_uniprot_Component(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_Component_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_Component.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_Component len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_Component([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_Component_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_Component_len(self.handle)
				return Slice_uniprot_Component(handle=_uniprot.Slice_uniprot_Component_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Component(handle=_uniprot.Slice_uniprot_Component_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_Component_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_Component.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Component(handle=_uniprot.Slice_uniprot_Component_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_Component_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.DbReferenceType
class Slice_uniprot_DbReferenceType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_DbReferenceType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_DbReferenceType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_DbReferenceType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_DbReferenceType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_DbReferenceType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_DbReferenceType_len(self.handle)
				return Slice_uniprot_DbReferenceType(handle=_uniprot.Slice_uniprot_DbReferenceType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return DbReferenceType(handle=_uniprot.Slice_uniprot_DbReferenceType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_DbReferenceType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_DbReferenceType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = DbReferenceType(handle=_uniprot.Slice_uniprot_DbReferenceType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_DbReferenceType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.Domain
class Slice_uniprot_Domain(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_Domain_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_Domain.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_Domain len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_Domain([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_Domain_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_Domain_len(self.handle)
				return Slice_uniprot_Domain(handle=_uniprot.Slice_uniprot_Domain_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Domain(handle=_uniprot.Slice_uniprot_Domain_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_Domain_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_Domain.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Domain(handle=_uniprot.Slice_uniprot_Domain_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_Domain_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.EventType
class Slice_uniprot_EventType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_EventType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_EventType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_EventType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_EventType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_EventType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_EventType_len(self.handle)
				return Slice_uniprot_EventType(handle=_uniprot.Slice_uniprot_EventType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return EventType(handle=_uniprot.Slice_uniprot_EventType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_EventType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_EventType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = EventType(handle=_uniprot.Slice_uniprot_EventType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_EventType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.EvidenceType
class Slice_uniprot_EvidenceType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_EvidenceType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_EvidenceType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_EvidenceType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_EvidenceType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_EvidenceType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_EvidenceType_len(self.handle)
				return Slice_uniprot_EvidenceType(handle=_uniprot.Slice_uniprot_EvidenceType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return EvidenceType(handle=_uniprot.Slice_uniprot_EvidenceType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_EvidenceType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_EvidenceType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = EvidenceType(handle=_uniprot.Slice_uniprot_EvidenceType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_EvidenceType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.EvidencedStringType
class Slice_uniprot_EvidencedStringType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_EvidencedStringType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_EvidencedStringType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_EvidencedStringType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_EvidencedStringType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_EvidencedStringType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_EvidencedStringType_len(self.handle)
				return Slice_uniprot_EvidencedStringType(handle=_uniprot.Slice_uniprot_EvidencedStringType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return EvidencedStringType(handle=_uniprot.Slice_uniprot_EvidencedStringType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_EvidencedStringType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_EvidencedStringType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = EvidencedStringType(handle=_uniprot.Slice_uniprot_EvidencedStringType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_EvidencedStringType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.FeatureType
class Slice_uniprot_FeatureType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_FeatureType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_FeatureType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_FeatureType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_FeatureType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_FeatureType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_FeatureType_len(self.handle)
				return Slice_uniprot_FeatureType(handle=_uniprot.Slice_uniprot_FeatureType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return FeatureType(handle=_uniprot.Slice_uniprot_FeatureType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_FeatureType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_FeatureType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = FeatureType(handle=_uniprot.Slice_uniprot_FeatureType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_FeatureType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.GeneLocationType
class Slice_uniprot_GeneLocationType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_GeneLocationType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_GeneLocationType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_GeneLocationType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_GeneLocationType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_GeneLocationType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_GeneLocationType_len(self.handle)
				return Slice_uniprot_GeneLocationType(handle=_uniprot.Slice_uniprot_GeneLocationType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return GeneLocationType(handle=_uniprot.Slice_uniprot_GeneLocationType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_GeneLocationType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_GeneLocationType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = GeneLocationType(handle=_uniprot.Slice_uniprot_GeneLocationType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_GeneLocationType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.GeneNameType
class Slice_uniprot_GeneNameType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_GeneNameType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_GeneNameType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_GeneNameType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_GeneNameType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_GeneNameType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_GeneNameType_len(self.handle)
				return Slice_uniprot_GeneNameType(handle=_uniprot.Slice_uniprot_GeneNameType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return GeneNameType(handle=_uniprot.Slice_uniprot_GeneNameType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_GeneNameType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_GeneNameType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = GeneNameType(handle=_uniprot.Slice_uniprot_GeneNameType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_GeneNameType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.GeneType
class Slice_uniprot_GeneType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_GeneType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_GeneType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_GeneType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_GeneType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_GeneType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_GeneType_len(self.handle)
				return Slice_uniprot_GeneType(handle=_uniprot.Slice_uniprot_GeneType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return GeneType(handle=_uniprot.Slice_uniprot_GeneType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_GeneType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_GeneType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = GeneType(handle=_uniprot.Slice_uniprot_GeneType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_GeneType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.InteractantType
class Slice_uniprot_InteractantType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_InteractantType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_InteractantType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_InteractantType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_InteractantType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_InteractantType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_InteractantType_len(self.handle)
				return Slice_uniprot_InteractantType(handle=_uniprot.Slice_uniprot_InteractantType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return InteractantType(handle=_uniprot.Slice_uniprot_InteractantType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_InteractantType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_InteractantType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = InteractantType(handle=_uniprot.Slice_uniprot_InteractantType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_InteractantType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.IsoformType
class Slice_uniprot_IsoformType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_IsoformType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_IsoformType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_IsoformType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_IsoformType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_IsoformType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_IsoformType_len(self.handle)
				return Slice_uniprot_IsoformType(handle=_uniprot.Slice_uniprot_IsoformType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return IsoformType(handle=_uniprot.Slice_uniprot_IsoformType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_IsoformType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_IsoformType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = IsoformType(handle=_uniprot.Slice_uniprot_IsoformType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_IsoformType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.KeywordType
class Slice_uniprot_KeywordType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_KeywordType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_KeywordType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_KeywordType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_KeywordType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_KeywordType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_KeywordType_len(self.handle)
				return Slice_uniprot_KeywordType(handle=_uniprot.Slice_uniprot_KeywordType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return KeywordType(handle=_uniprot.Slice_uniprot_KeywordType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_KeywordType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_KeywordType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = KeywordType(handle=_uniprot.Slice_uniprot_KeywordType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_KeywordType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.Link
class Slice_uniprot_Link(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_Link_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_Link.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_Link len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_Link([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_Link_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_Link_len(self.handle)
				return Slice_uniprot_Link(handle=_uniprot.Slice_uniprot_Link_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Link(handle=_uniprot.Slice_uniprot_Link_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_Link_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_Link.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Link(handle=_uniprot.Slice_uniprot_Link_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_Link_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.LocationType
class Slice_uniprot_LocationType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_LocationType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_LocationType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_LocationType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_LocationType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_LocationType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_LocationType_len(self.handle)
				return Slice_uniprot_LocationType(handle=_uniprot.Slice_uniprot_LocationType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return LocationType(handle=_uniprot.Slice_uniprot_LocationType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_LocationType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_LocationType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = LocationType(handle=_uniprot.Slice_uniprot_LocationType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_LocationType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.Name
class Slice_uniprot_Name(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_Name_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_Name.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_Name len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_Name([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_Name_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_Name_len(self.handle)
				return Slice_uniprot_Name(handle=_uniprot.Slice_uniprot_Name_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Name(handle=_uniprot.Slice_uniprot_Name_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_Name_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_Name.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Name(handle=_uniprot.Slice_uniprot_Name_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_Name_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.OrganismNameType
class Slice_uniprot_OrganismNameType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_OrganismNameType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_OrganismNameType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_OrganismNameType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_OrganismNameType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_OrganismNameType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_OrganismNameType_len(self.handle)
				return Slice_uniprot_OrganismNameType(handle=_uniprot.Slice_uniprot_OrganismNameType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return OrganismNameType(handle=_uniprot.Slice_uniprot_OrganismNameType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_OrganismNameType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_OrganismNameType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = OrganismNameType(handle=_uniprot.Slice_uniprot_OrganismNameType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_OrganismNameType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.OrganismType
class Slice_uniprot_OrganismType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_OrganismType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_OrganismType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_OrganismType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_OrganismType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_OrganismType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_OrganismType_len(self.handle)
				return Slice_uniprot_OrganismType(handle=_uniprot.Slice_uniprot_OrganismType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return OrganismType(handle=_uniprot.Slice_uniprot_OrganismType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_OrganismType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_OrganismType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = OrganismType(handle=_uniprot.Slice_uniprot_OrganismType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_OrganismType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.PhysiologicalReactionType
class Slice_uniprot_PhysiologicalReactionType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_PhysiologicalReactionType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_PhysiologicalReactionType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_PhysiologicalReactionType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_PhysiologicalReactionType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_PhysiologicalReactionType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_PhysiologicalReactionType_len(self.handle)
				return Slice_uniprot_PhysiologicalReactionType(handle=_uniprot.Slice_uniprot_PhysiologicalReactionType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return PhysiologicalReactionType(handle=_uniprot.Slice_uniprot_PhysiologicalReactionType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_PhysiologicalReactionType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_PhysiologicalReactionType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = PhysiologicalReactionType(handle=_uniprot.Slice_uniprot_PhysiologicalReactionType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_PhysiologicalReactionType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.PropertyType
class Slice_uniprot_PropertyType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_PropertyType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_PropertyType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_PropertyType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_PropertyType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_PropertyType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_PropertyType_len(self.handle)
				return Slice_uniprot_PropertyType(handle=_uniprot.Slice_uniprot_PropertyType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return PropertyType(handle=_uniprot.Slice_uniprot_PropertyType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_PropertyType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_PropertyType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = PropertyType(handle=_uniprot.Slice_uniprot_PropertyType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_PropertyType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.ReferenceType
class Slice_uniprot_ReferenceType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_ReferenceType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_ReferenceType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_ReferenceType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_ReferenceType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_ReferenceType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_ReferenceType_len(self.handle)
				return Slice_uniprot_ReferenceType(handle=_uniprot.Slice_uniprot_ReferenceType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ReferenceType(handle=_uniprot.Slice_uniprot_ReferenceType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_ReferenceType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_ReferenceType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = ReferenceType(handle=_uniprot.Slice_uniprot_ReferenceType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_ReferenceType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.StatusType
class Slice_uniprot_StatusType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_StatusType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_StatusType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_StatusType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_StatusType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_StatusType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_StatusType_len(self.handle)
				return Slice_uniprot_StatusType(handle=_uniprot.Slice_uniprot_StatusType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return StatusType(handle=_uniprot.Slice_uniprot_StatusType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_StatusType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_StatusType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = StatusType(handle=_uniprot.Slice_uniprot_StatusType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_StatusType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.SubcellularLocationType
class Slice_uniprot_SubcellularLocationType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_SubcellularLocationType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_SubcellularLocationType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_SubcellularLocationType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_SubcellularLocationType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_SubcellularLocationType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_SubcellularLocationType_len(self.handle)
				return Slice_uniprot_SubcellularLocationType(handle=_uniprot.Slice_uniprot_SubcellularLocationType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SubcellularLocationType(handle=_uniprot.Slice_uniprot_SubcellularLocationType_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_SubcellularLocationType_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_SubcellularLocationType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SubcellularLocationType(handle=_uniprot.Slice_uniprot_SubcellularLocationType_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_SubcellularLocationType_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []uniprot.SubmittedName
class Slice_uniprot_SubmittedName(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Slice_uniprot_SubmittedName_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_uniprot_SubmittedName.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Slice_uniprot_SubmittedName len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.Slice_uniprot_SubmittedName([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.Slice_uniprot_SubmittedName_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.Slice_uniprot_SubmittedName_len(self.handle)
				return Slice_uniprot_SubmittedName(handle=_uniprot.Slice_uniprot_SubmittedName_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SubmittedName(handle=_uniprot.Slice_uniprot_SubmittedName_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.Slice_uniprot_SubmittedName_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_uniprot_SubmittedName.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SubmittedName(handle=_uniprot.Slice_uniprot_SubmittedName_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.Slice_uniprot_SubmittedName_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.Map_string_string_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_uniprot.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'uniprot.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _uniprot.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _uniprot.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_uniprot.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _uniprot.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_uniprot.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _uniprot.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface uniprot.Decoder
class Decoder(go.GoClass):
	"""Decoder decodes XML elements2\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = 0
	def DecodeElement(self, v, start):
		"""DecodeElement(str v, object start) str"""
		return _uniprot.uniprot_Decoder_DecodeElement(self.handle, v, start.handle)
	def Token(self):
		"""Token() object, str"""
		return go.xml_Token(handle=_uniprot.uniprot_Decoder_Token(self.handle))


# ---- Structs ---

# Python type for struct uniprot.EvidencedStringType
class EvidencedStringType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_EvidencedStringType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.EvidencedStringType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.EvidencedStringType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_EvidencedStringType_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_EvidencedStringType_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_EvidencedStringType_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_EvidencedStringType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_EvidencedStringType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.PhysiologicalReactionType
class PhysiologicalReactionType(go.GoClass):
	"""Describes a physiological reaction.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_PhysiologicalReactionType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.DbReference = args[0]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
			if  1 < len(args):
				self.Direction = args[1]
			if "Direction" in kwargs:
				self.Direction = kwargs["Direction"]
			if  2 < len(args):
				self.Evidence = args[2]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PhysiologicalReactionType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PhysiologicalReactionType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DbReference(self):
		return DbReferenceType(handle=_uniprot.uniprot_PhysiologicalReactionType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PhysiologicalReactionType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Direction(self):
		return _uniprot.uniprot_PhysiologicalReactionType_Direction_Get(self.handle)
	@Direction.setter
	def Direction(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PhysiologicalReactionType_Direction_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_PhysiologicalReactionType_Direction_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_PhysiologicalReactionType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PhysiologicalReactionType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.PropertyType
class PropertyType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_PropertyType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  1 < len(args):
				self.Value = args[1]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PropertyType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PropertyType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _uniprot.uniprot_PropertyType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PropertyType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_PropertyType_Type_Set(self.handle, value)
	@property
	def Value(self):
		return _uniprot.uniprot_PropertyType_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PropertyType_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_PropertyType_Value_Set(self.handle, value)

# Python type for struct uniprot.EvidenceType
class EvidenceType(go.GoClass):
	"""Describes the evidence for an annotation.\nNo flat file equivalent.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_EvidenceType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Source = args[0]
			if "Source" in kwargs:
				self.Source = kwargs["Source"]
			if  1 < len(args):
				self.ImportedFrom = args[1]
			if "ImportedFrom" in kwargs:
				self.ImportedFrom = kwargs["ImportedFrom"]
			if  2 < len(args):
				self.Type = args[2]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  3 < len(args):
				self.Key = args[3]
			if "Key" in kwargs:
				self.Key = kwargs["Key"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.EvidenceType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.EvidenceType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Source(self):
		return SourceType(handle=_uniprot.uniprot_EvidenceType_Source_Get(self.handle))
	@Source.setter
	def Source(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_EvidenceType_Source_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ImportedFrom(self):
		return ImportedFromType(handle=_uniprot.uniprot_EvidenceType_ImportedFrom_Get(self.handle))
	@ImportedFrom.setter
	def ImportedFrom(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_EvidenceType_ImportedFrom_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_EvidenceType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_EvidenceType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_EvidenceType_Type_Set(self.handle, value)
	@property
	def Key(self):
		return _uniprot.uniprot_EvidenceType_Key_Get(self.handle)
	@Key.setter
	def Key(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_EvidenceType_Key_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_EvidenceType_Key_Set(self.handle, value)

# Python type for struct uniprot.Absorption
class Absorption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Absorption_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Max = args[0]
			if "Max" in kwargs:
				self.Max = kwargs["Max"]
			if  1 < len(args):
				self.Text = args[1]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Absorption{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Absorption ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Max(self):
		return EvidencedStringType(handle=_uniprot.uniprot_Absorption_Max_Get(self.handle))
	@Max.setter
	def Max(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Absorption_Max_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Text(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Absorption_Text_Get(self.handle))
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Absorption_Text_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.ConsortiumType
class ConsortiumType(go.GoClass):
	"""Describes the authors of a citation when these are represented by a consortium.\nEquivalent to the flat file RG-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_ConsortiumType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ConsortiumType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ConsortiumType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _uniprot.uniprot_ConsortiumType_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ConsortiumType_Name_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_ConsortiumType_Name_Set(self.handle, value)

# Python type for struct uniprot.DbReferenceType
class DbReferenceType(go.GoClass):
	"""Describes a database cross-reference.\nEquivalent to the flat file DR-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_DbReferenceType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Molecule = args[0]
			if "Molecule" in kwargs:
				self.Molecule = kwargs["Molecule"]
			if  1 < len(args):
				self.Property = args[1]
			if "Property" in kwargs:
				self.Property = kwargs["Property"]
			if  2 < len(args):
				self.Type = args[2]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  3 < len(args):
				self.Evidence = args[3]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.DbReferenceType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.DbReferenceType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Molecule(self):
		return _uniprot.uniprot_DbReferenceType_Molecule_Get(self.handle)
	@Molecule.setter
	def Molecule(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_DbReferenceType_Molecule_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_DbReferenceType_Molecule_Set(self.handle, value)
	@property
	def Property(self):
		return Slice_uniprot_PropertyType(handle=_uniprot.uniprot_DbReferenceType_Property_Get(self.handle))
	@Property.setter
	def Property(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_DbReferenceType_Property_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_DbReferenceType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_DbReferenceType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_DbReferenceType_Type_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_DbReferenceType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_DbReferenceType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.LocationType
class LocationType(go.GoClass):
	"""Describes a sequence location as either a range with a begin and end or as a position. The 'sequence' attribute is only used when the location is not on the canonical sequence displayed in the current entry.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_LocationType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Begin = args[0]
			if "Begin" in kwargs:
				self.Begin = kwargs["Begin"]
			if  1 < len(args):
				self.End = args[1]
			if "End" in kwargs:
				self.End = kwargs["End"]
			if  2 < len(args):
				self.Position = args[2]
			if "Position" in kwargs:
				self.Position = kwargs["Position"]
			if  3 < len(args):
				self.Sequence = args[3]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.LocationType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.LocationType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Begin(self):
		return PositionType(handle=_uniprot.uniprot_LocationType_Begin_Get(self.handle))
	@Begin.setter
	def Begin(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_LocationType_Begin_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def End(self):
		return PositionType(handle=_uniprot.uniprot_LocationType_End_Get(self.handle))
	@End.setter
	def End(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_LocationType_End_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Position(self):
		return PositionType(handle=_uniprot.uniprot_LocationType_Position_Get(self.handle))
	@Position.setter
	def Position(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_LocationType_Position_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Sequence(self):
		return _uniprot.uniprot_LocationType_Sequence_Get(self.handle)
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_LocationType_Sequence_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_LocationType_Sequence_Set(self.handle, value)

# Python type for struct uniprot.Transposon
class Transposon(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Transposon_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Transposon{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Transposon ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_Transposon_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Transposon_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Transposon_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_Transposon_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Transposon_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Anon6
class Anon6(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Anon6_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Anon6{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Anon6 ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _uniprot.uniprot_Anon6_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Anon6_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Anon6_Type_Set(self.handle, value)

# Python type for struct uniprot.FeatureType
class FeatureType(go.GoClass):
	"""Describes different types of sequence annotations.\nEquivalent to the flat file FT-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_FeatureType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Original = args[0]
			if "Original" in kwargs:
				self.Original = kwargs["Original"]
			if  1 < len(args):
				self.Variation = args[1]
			if "Variation" in kwargs:
				self.Variation = kwargs["Variation"]
			if  2 < len(args):
				self.Location = args[2]
			if "Location" in kwargs:
				self.Location = kwargs["Location"]
			if  3 < len(args):
				self.Type = args[3]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  4 < len(args):
				self.Description = args[4]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
			if  5 < len(args):
				self.Evidence = args[5]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.FeatureType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.FeatureType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Original(self):
		return _uniprot.uniprot_FeatureType_Original_Get(self.handle)
	@Original.setter
	def Original(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_FeatureType_Original_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_FeatureType_Original_Set(self.handle, value)
	@property
	def Variation(self):
		return go.Slice_string(handle=_uniprot.uniprot_FeatureType_Variation_Get(self.handle))
	@Variation.setter
	def Variation(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_FeatureType_Variation_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Location(self):
		return LocationType(handle=_uniprot.uniprot_FeatureType_Location_Get(self.handle))
	@Location.setter
	def Location(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_FeatureType_Location_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_FeatureType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_FeatureType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_FeatureType_Type_Set(self.handle, value)
	@property
	def Description(self):
		return _uniprot.uniprot_FeatureType_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_FeatureType_Description_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_FeatureType_Description_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_FeatureType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_FeatureType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.OrganismNameType
class OrganismNameType(go.GoClass):
	"""Describes different types of source organism names.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_OrganismNameType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.OrganismNameType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.OrganismNameType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_OrganismNameType_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_OrganismNameType_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_OrganismNameType_Value_Set(self.handle, value)
	@property
	def Type(self):
		return _uniprot.uniprot_OrganismNameType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_OrganismNameType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_OrganismNameType_Type_Set(self.handle, value)

# Python type for struct uniprot.OrganismType
class OrganismType(go.GoClass):
	"""Describes the source organism.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_OrganismType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.DbReference = args[1]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
			if  2 < len(args):
				self.Lineage = args[2]
			if "Lineage" in kwargs:
				self.Lineage = kwargs["Lineage"]
			if  3 < len(args):
				self.Evidence = args[3]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.OrganismType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.OrganismType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return Slice_uniprot_OrganismNameType(handle=_uniprot.uniprot_OrganismType_Name_Get(self.handle))
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_OrganismType_Name_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DbReference(self):
		return Slice_uniprot_DbReferenceType(handle=_uniprot.uniprot_OrganismType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_OrganismType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Lineage(self):
		return Lineage(handle=_uniprot.uniprot_OrganismType_Lineage_Get(self.handle))
	@Lineage.setter
	def Lineage(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_OrganismType_Lineage_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_OrganismType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_OrganismType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.ProteinExistenceType
class ProteinExistenceType(go.GoClass):
	"""Describes the evidence for the protein's existence.\nEquivalent to the flat file PE-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_ProteinExistenceType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ProteinExistenceType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ProteinExistenceType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _uniprot.uniprot_ProteinExistenceType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinExistenceType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_ProteinExistenceType_Type_Set(self.handle, value)

# Python type for struct uniprot.SourceType
class SourceType(go.GoClass):
	"""Describes the source of the data using a database cross-reference (or a 'ref' attribute when the source cannot be found in a public data source, such as PubMed, and is cited only within the UniProtKB entry).\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_SourceType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.DbReference = args[0]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SourceType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SourceType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DbReference(self):
		return DbReferenceType(handle=_uniprot.uniprot_SourceType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SourceType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.GeneNameType
class GeneNameType(go.GoClass):
	"""Describes different types of gene designations.\nEquivalent to the flat file GN-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_GeneNameType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
			if  2 < len(args):
				self.Type = args[2]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.GeneNameType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.GeneNameType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_GeneNameType_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_GeneNameType_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_GeneNameType_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_GeneNameType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_GeneNameType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_GeneNameType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_GeneNameType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_GeneNameType_Type_Set(self.handle, value)

# Python type for struct uniprot.Plasmid
class Plasmid(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Plasmid_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Plasmid{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Plasmid ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_Plasmid_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Plasmid_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Plasmid_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_Plasmid_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Plasmid_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Name
class Name(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Name_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Name{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Name ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_Name_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Name_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Name_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_Name_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Name_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.ReferenceType
class ReferenceType(go.GoClass):
	"""Describes a citation and a summary of its content.\nEquivalent to the flat file RN-, RP-, RC-, RX-, RG-, RA-, RT- and RL-lines.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_ReferenceType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Citation = args[0]
			if "Citation" in kwargs:
				self.Citation = kwargs["Citation"]
			if  1 < len(args):
				self.Scope = args[1]
			if "Scope" in kwargs:
				self.Scope = kwargs["Scope"]
			if  2 < len(args):
				self.Source = args[2]
			if "Source" in kwargs:
				self.Source = kwargs["Source"]
			if  3 < len(args):
				self.Evidence = args[3]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
			if  4 < len(args):
				self.Key = args[4]
			if "Key" in kwargs:
				self.Key = kwargs["Key"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ReferenceType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ReferenceType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Citation(self):
		return CitationType(handle=_uniprot.uniprot_ReferenceType_Citation_Get(self.handle))
	@Citation.setter
	def Citation(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReferenceType_Citation_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Scope(self):
		return go.Slice_string(handle=_uniprot.uniprot_ReferenceType_Scope_Get(self.handle))
	@Scope.setter
	def Scope(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReferenceType_Scope_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Source(self):
		return SourceDataType(handle=_uniprot.uniprot_ReferenceType_Source_Get(self.handle))
	@Source.setter
	def Source(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReferenceType_Source_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_ReferenceType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReferenceType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Key(self):
		return _uniprot.uniprot_ReferenceType_Key_Get(self.handle)
	@Key.setter
	def Key(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReferenceType_Key_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_ReferenceType_Key_Set(self.handle, value)

# Python type for struct uniprot.Disease
class Disease(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Disease_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Acronym = args[1]
			if "Acronym" in kwargs:
				self.Acronym = kwargs["Acronym"]
			if  2 < len(args):
				self.Description = args[2]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
			if  3 < len(args):
				self.DbReference = args[3]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Disease{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Disease ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _uniprot.uniprot_Disease_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Disease_Name_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Disease_Name_Set(self.handle, value)
	@property
	def Acronym(self):
		return _uniprot.uniprot_Disease_Acronym_Get(self.handle)
	@Acronym.setter
	def Acronym(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Disease_Acronym_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Disease_Acronym_Set(self.handle, value)
	@property
	def Description(self):
		return _uniprot.uniprot_Disease_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Disease_Description_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Disease_Description_Set(self.handle, value)
	@property
	def DbReference(self):
		return DbReferenceType(handle=_uniprot.uniprot_Disease_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Disease_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Entry
class Entry(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Entry_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Accession = args[0]
			if "Accession" in kwargs:
				self.Accession = kwargs["Accession"]
			if  1 < len(args):
				self.Name = args[1]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  2 < len(args):
				self.Protein = args[2]
			if "Protein" in kwargs:
				self.Protein = kwargs["Protein"]
			if  3 < len(args):
				self.Gene = args[3]
			if "Gene" in kwargs:
				self.Gene = kwargs["Gene"]
			if  4 < len(args):
				self.Organism = args[4]
			if "Organism" in kwargs:
				self.Organism = kwargs["Organism"]
			if  5 < len(args):
				self.OrganismHost = args[5]
			if "OrganismHost" in kwargs:
				self.OrganismHost = kwargs["OrganismHost"]
			if  6 < len(args):
				self.GeneLocation = args[6]
			if "GeneLocation" in kwargs:
				self.GeneLocation = kwargs["GeneLocation"]
			if  7 < len(args):
				self.Reference = args[7]
			if "Reference" in kwargs:
				self.Reference = kwargs["Reference"]
			if  8 < len(args):
				self.Comment = args[8]
			if "Comment" in kwargs:
				self.Comment = kwargs["Comment"]
			if  9 < len(args):
				self.DbReference = args[9]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
			if  10 < len(args):
				self.ProteinExistence = args[10]
			if "ProteinExistence" in kwargs:
				self.ProteinExistence = kwargs["ProteinExistence"]
			if  11 < len(args):
				self.Keyword = args[11]
			if "Keyword" in kwargs:
				self.Keyword = kwargs["Keyword"]
			if  12 < len(args):
				self.Feature = args[12]
			if "Feature" in kwargs:
				self.Feature = kwargs["Feature"]
			if  13 < len(args):
				self.Evidence = args[13]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
			if  14 < len(args):
				self.Sequence = args[14]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
			if  15 < len(args):
				self.Dataset = args[15]
			if "Dataset" in kwargs:
				self.Dataset = kwargs["Dataset"]
			if  16 < len(args):
				self.Created = args[16]
			if "Created" in kwargs:
				self.Created = kwargs["Created"]
			if  17 < len(args):
				self.Modified = args[17]
			if "Modified" in kwargs:
				self.Modified = kwargs["Modified"]
			if  18 < len(args):
				self.Version = args[18]
			if "Version" in kwargs:
				self.Version = kwargs["Version"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Entry{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Entry ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Accession(self):
		return go.Slice_string(handle=_uniprot.uniprot_Entry_Accession_Get(self.handle))
	@Accession.setter
	def Accession(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Accession_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Name(self):
		return go.Slice_string(handle=_uniprot.uniprot_Entry_Name_Get(self.handle))
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Name_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Protein(self):
		return ProteinType(handle=_uniprot.uniprot_Entry_Protein_Get(self.handle))
	@Protein.setter
	def Protein(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Protein_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Gene(self):
		return Slice_uniprot_GeneType(handle=_uniprot.uniprot_Entry_Gene_Get(self.handle))
	@Gene.setter
	def Gene(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Gene_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Organism(self):
		return OrganismType(handle=_uniprot.uniprot_Entry_Organism_Get(self.handle))
	@Organism.setter
	def Organism(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Organism_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def OrganismHost(self):
		return Slice_uniprot_OrganismType(handle=_uniprot.uniprot_Entry_OrganismHost_Get(self.handle))
	@OrganismHost.setter
	def OrganismHost(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_OrganismHost_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def GeneLocation(self):
		return Slice_uniprot_GeneLocationType(handle=_uniprot.uniprot_Entry_GeneLocation_Get(self.handle))
	@GeneLocation.setter
	def GeneLocation(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_GeneLocation_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Reference(self):
		return Slice_uniprot_ReferenceType(handle=_uniprot.uniprot_Entry_Reference_Get(self.handle))
	@Reference.setter
	def Reference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Reference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Comment(self):
		return Slice_uniprot_CommentType(handle=_uniprot.uniprot_Entry_Comment_Get(self.handle))
	@Comment.setter
	def Comment(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Comment_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DbReference(self):
		return Slice_uniprot_DbReferenceType(handle=_uniprot.uniprot_Entry_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ProteinExistence(self):
		return ProteinExistenceType(handle=_uniprot.uniprot_Entry_ProteinExistence_Get(self.handle))
	@ProteinExistence.setter
	def ProteinExistence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_ProteinExistence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Keyword(self):
		return Slice_uniprot_KeywordType(handle=_uniprot.uniprot_Entry_Keyword_Get(self.handle))
	@Keyword.setter
	def Keyword(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Keyword_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Feature(self):
		return Slice_uniprot_FeatureType(handle=_uniprot.uniprot_Entry_Feature_Get(self.handle))
	@Feature.setter
	def Feature(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Feature_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Evidence(self):
		return Slice_uniprot_EvidenceType(handle=_uniprot.uniprot_Entry_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Sequence(self):
		return SequenceType(handle=_uniprot.uniprot_Entry_Sequence_Get(self.handle))
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Sequence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Dataset(self):
		return _uniprot.uniprot_Entry_Dataset_Get(self.handle)
	@Dataset.setter
	def Dataset(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Dataset_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Entry_Dataset_Set(self.handle, value)
	@property
	def Created(self):
		return go.time_Time(handle=_uniprot.uniprot_Entry_Created_Get(self.handle))
	@Created.setter
	def Created(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Created_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Modified(self):
		return go.time_Time(handle=_uniprot.uniprot_Entry_Modified_Get(self.handle))
	@Modified.setter
	def Modified(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Modified_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Version(self):
		return _uniprot.uniprot_Entry_Version_Get(self.handle)
	@Version.setter
	def Version(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Entry_Version_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Entry_Version_Set(self.handle, value)
	def UnmarshalXML(self, d, start):
		"""UnmarshalXML(object d, object start) str"""
		return _uniprot.uniprot_Entry_UnmarshalXML(self.handle, d.handle, start.handle)

# Python type for struct uniprot.KeywordType
class KeywordType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_KeywordType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.KeywordType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.KeywordType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_KeywordType_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_KeywordType_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_KeywordType_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_KeywordType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_KeywordType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.GeneType
class GeneType(go.GoClass):
	"""Describes a gene.\nEquivalent to the flat file GN-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_GeneType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.GeneType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.GeneType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return Slice_uniprot_GeneNameType(handle=_uniprot.uniprot_GeneType_Name_Get(self.handle))
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_GeneType_Name_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.IsoformType
class IsoformType(go.GoClass):
	"""Describes isoforms in 'alternative products' annotations.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_IsoformType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Id = args[0]
			if "Id" in kwargs:
				self.Id = kwargs["Id"]
			if  1 < len(args):
				self.Name = args[1]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  2 < len(args):
				self.Sequence = args[2]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
			if  3 < len(args):
				self.Text = args[3]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.IsoformType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.IsoformType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Id(self):
		return go.Slice_string(handle=_uniprot.uniprot_IsoformType_Id_Get(self.handle))
	@Id.setter
	def Id(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_IsoformType_Id_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Name(self):
		return Slice_uniprot_Name(handle=_uniprot.uniprot_IsoformType_Name_Get(self.handle))
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_IsoformType_Name_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Sequence(self):
		return Anon6(handle=_uniprot.uniprot_IsoformType_Sequence_Get(self.handle))
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_IsoformType_Sequence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Text(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_IsoformType_Text_Get(self.handle))
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_IsoformType_Text_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.NameListType
class NameListType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_NameListType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Consortium = args[0]
			if "Consortium" in kwargs:
				self.Consortium = kwargs["Consortium"]
			if  1 < len(args):
				self.Person = args[1]
			if "Person" in kwargs:
				self.Person = kwargs["Person"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.NameListType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.NameListType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Consortium(self):
		return ConsortiumType(handle=_uniprot.uniprot_NameListType_Consortium_Get(self.handle))
	@Consortium.setter
	def Consortium(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_NameListType_Consortium_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Person(self):
		return PersonType(handle=_uniprot.uniprot_NameListType_Person_Get(self.handle))
	@Person.setter
	def Person(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_NameListType_Person_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.ReactionType
class ReactionType(go.GoClass):
	"""Describes a chemical reaction.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_ReactionType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Text = args[0]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
			if  1 < len(args):
				self.DbReference = args[1]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
			if  2 < len(args):
				self.Evidence = args[2]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ReactionType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ReactionType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Text(self):
		return _uniprot.uniprot_ReactionType_Text_Get(self.handle)
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReactionType_Text_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_ReactionType_Text_Set(self.handle, value)
	@property
	def DbReference(self):
		return Slice_uniprot_DbReferenceType(handle=_uniprot.uniprot_ReactionType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReactionType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_ReactionType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ReactionType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.ImportedFromType
class ImportedFromType(go.GoClass):
	"""Describes the source of the evidence, when it is not assigned by UniProt, but imported from an external database.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_ImportedFromType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.DbReference = args[0]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ImportedFromType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ImportedFromType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DbReference(self):
		return DbReferenceType(handle=_uniprot.uniprot_ImportedFromType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ImportedFromType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Lineage
class Lineage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Lineage_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Taxon = args[0]
			if "Taxon" in kwargs:
				self.Taxon = kwargs["Taxon"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Lineage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Lineage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Taxon(self):
		return go.Slice_string(handle=_uniprot.uniprot_Lineage_Taxon_Get(self.handle))
	@Taxon.setter
	def Taxon(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Lineage_Taxon_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.StatusType
class StatusType(go.GoClass):
	"""Indicates whether the name of a plasmid is known or unknown.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_StatusType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Status = args[1]
			if "Status" in kwargs:
				self.Status = kwargs["Status"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.StatusType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.StatusType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_StatusType_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_StatusType_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_StatusType_Value_Set(self.handle, value)
	@property
	def Status(self):
		return _uniprot.uniprot_StatusType_Status_Get(self.handle)
	@Status.setter
	def Status(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_StatusType_Status_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_StatusType_Status_Set(self.handle, value)

# Python type for struct uniprot.SubcellularLocationType
class SubcellularLocationType(go.GoClass):
	"""Describes the subcellular location and optionally the topology and orientation of a molecule.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_SubcellularLocationType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Location = args[0]
			if "Location" in kwargs:
				self.Location = kwargs["Location"]
			if  1 < len(args):
				self.Topology = args[1]
			if "Topology" in kwargs:
				self.Topology = kwargs["Topology"]
			if  2 < len(args):
				self.Orientation = args[2]
			if "Orientation" in kwargs:
				self.Orientation = kwargs["Orientation"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SubcellularLocationType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SubcellularLocationType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Location(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_SubcellularLocationType_Location_Get(self.handle))
	@Location.setter
	def Location(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SubcellularLocationType_Location_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Topology(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_SubcellularLocationType_Topology_Get(self.handle))
	@Topology.setter
	def Topology(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SubcellularLocationType_Topology_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Orientation(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_SubcellularLocationType_Orientation_Get(self.handle))
	@Orientation.setter
	def Orientation(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SubcellularLocationType_Orientation_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.SubmittedName
class SubmittedName(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_SubmittedName_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.FullName = args[0]
			if "FullName" in kwargs:
				self.FullName = kwargs["FullName"]
			if  1 < len(args):
				self.EcNumber = args[1]
			if "EcNumber" in kwargs:
				self.EcNumber = kwargs["EcNumber"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SubmittedName{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SubmittedName ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FullName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_SubmittedName_FullName_Get(self.handle))
	@FullName.setter
	def FullName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SubmittedName_FullName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def EcNumber(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_SubmittedName_EcNumber_Get(self.handle))
	@EcNumber.setter
	def EcNumber(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SubmittedName_EcNumber_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.CommentType
class CommentType(go.GoClass):
	"""Describes different types of general annotations.\nEquivalent to the flat file CC-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_CommentType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Molecule = args[0]
			if "Molecule" in kwargs:
				self.Molecule = kwargs["Molecule"]
			if  1 < len(args):
				self.Absorption = args[1]
			if "Absorption" in kwargs:
				self.Absorption = kwargs["Absorption"]
			if  2 < len(args):
				self.Kinetics = args[2]
			if "Kinetics" in kwargs:
				self.Kinetics = kwargs["Kinetics"]
			if  3 < len(args):
				self.PhDependence = args[3]
			if "PhDependence" in kwargs:
				self.PhDependence = kwargs["PhDependence"]
			if  4 < len(args):
				self.RedoxPotential = args[4]
			if "RedoxPotential" in kwargs:
				self.RedoxPotential = kwargs["RedoxPotential"]
			if  5 < len(args):
				self.TemperatureDependence = args[5]
			if "TemperatureDependence" in kwargs:
				self.TemperatureDependence = kwargs["TemperatureDependence"]
			if  6 < len(args):
				self.Reaction = args[6]
			if "Reaction" in kwargs:
				self.Reaction = kwargs["Reaction"]
			if  7 < len(args):
				self.PhysiologicalReaction = args[7]
			if "PhysiologicalReaction" in kwargs:
				self.PhysiologicalReaction = kwargs["PhysiologicalReaction"]
			if  8 < len(args):
				self.Cofactor = args[8]
			if "Cofactor" in kwargs:
				self.Cofactor = kwargs["Cofactor"]
			if  9 < len(args):
				self.SubcellularLocation = args[9]
			if "SubcellularLocation" in kwargs:
				self.SubcellularLocation = kwargs["SubcellularLocation"]
			if  10 < len(args):
				self.Conflict = args[10]
			if "Conflict" in kwargs:
				self.Conflict = kwargs["Conflict"]
			if  11 < len(args):
				self.Link = args[11]
			if "Link" in kwargs:
				self.Link = kwargs["Link"]
			if  12 < len(args):
				self.Event = args[12]
			if "Event" in kwargs:
				self.Event = kwargs["Event"]
			if  13 < len(args):
				self.Isoform = args[13]
			if "Isoform" in kwargs:
				self.Isoform = kwargs["Isoform"]
			if  14 < len(args):
				self.Interactant = args[14]
			if "Interactant" in kwargs:
				self.Interactant = kwargs["Interactant"]
			if  15 < len(args):
				self.OrganismsDiffer = args[15]
			if "OrganismsDiffer" in kwargs:
				self.OrganismsDiffer = kwargs["OrganismsDiffer"]
			if  16 < len(args):
				self.Experiments = args[16]
			if "Experiments" in kwargs:
				self.Experiments = kwargs["Experiments"]
			if  17 < len(args):
				self.Disease = args[17]
			if "Disease" in kwargs:
				self.Disease = kwargs["Disease"]
			if  18 < len(args):
				self.Location = args[18]
			if "Location" in kwargs:
				self.Location = kwargs["Location"]
			if  19 < len(args):
				self.Text = args[19]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
			if  20 < len(args):
				self.Type = args[20]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  21 < len(args):
				self.LocationType = args[21]
			if "LocationType" in kwargs:
				self.LocationType = kwargs["LocationType"]
			if  22 < len(args):
				self.Name = args[22]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  23 < len(args):
				self.Mass = args[23]
			if "Mass" in kwargs:
				self.Mass = kwargs["Mass"]
			if  24 < len(args):
				self.Error = args[24]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
			if  25 < len(args):
				self.Method = args[25]
			if "Method" in kwargs:
				self.Method = kwargs["Method"]
			if  26 < len(args):
				self.Evidence = args[26]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.CommentType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.CommentType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Molecule(self):
		return _uniprot.uniprot_CommentType_Molecule_Get(self.handle)
	@Molecule.setter
	def Molecule(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Molecule_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_Molecule_Set(self.handle, value)
	@property
	def Absorption(self):
		return Absorption(handle=_uniprot.uniprot_CommentType_Absorption_Get(self.handle))
	@Absorption.setter
	def Absorption(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Absorption_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Kinetics(self):
		return Kinetics(handle=_uniprot.uniprot_CommentType_Kinetics_Get(self.handle))
	@Kinetics.setter
	def Kinetics(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Kinetics_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def PhDependence(self):
		return PhDependence(handle=_uniprot.uniprot_CommentType_PhDependence_Get(self.handle))
	@PhDependence.setter
	def PhDependence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_PhDependence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def RedoxPotential(self):
		return RedoxPotential(handle=_uniprot.uniprot_CommentType_RedoxPotential_Get(self.handle))
	@RedoxPotential.setter
	def RedoxPotential(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_RedoxPotential_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TemperatureDependence(self):
		return TemperatureDependence(handle=_uniprot.uniprot_CommentType_TemperatureDependence_Get(self.handle))
	@TemperatureDependence.setter
	def TemperatureDependence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_TemperatureDependence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Reaction(self):
		return ReactionType(handle=_uniprot.uniprot_CommentType_Reaction_Get(self.handle))
	@Reaction.setter
	def Reaction(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Reaction_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def PhysiologicalReaction(self):
		return Slice_uniprot_PhysiologicalReactionType(handle=_uniprot.uniprot_CommentType_PhysiologicalReaction_Get(self.handle))
	@PhysiologicalReaction.setter
	def PhysiologicalReaction(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_PhysiologicalReaction_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Cofactor(self):
		return Slice_uniprot_CofactorType(handle=_uniprot.uniprot_CommentType_Cofactor_Get(self.handle))
	@Cofactor.setter
	def Cofactor(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Cofactor_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SubcellularLocation(self):
		return Slice_uniprot_SubcellularLocationType(handle=_uniprot.uniprot_CommentType_SubcellularLocation_Get(self.handle))
	@SubcellularLocation.setter
	def SubcellularLocation(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_SubcellularLocation_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Conflict(self):
		return Conflict(handle=_uniprot.uniprot_CommentType_Conflict_Get(self.handle))
	@Conflict.setter
	def Conflict(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Conflict_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Link(self):
		return Slice_uniprot_Link(handle=_uniprot.uniprot_CommentType_Link_Get(self.handle))
	@Link.setter
	def Link(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Link_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Event(self):
		return Slice_uniprot_EventType(handle=_uniprot.uniprot_CommentType_Event_Get(self.handle))
	@Event.setter
	def Event(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Event_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Isoform(self):
		return Slice_uniprot_IsoformType(handle=_uniprot.uniprot_CommentType_Isoform_Get(self.handle))
	@Isoform.setter
	def Isoform(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Isoform_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Interactant(self):
		return Slice_uniprot_InteractantType(handle=_uniprot.uniprot_CommentType_Interactant_Get(self.handle))
	@Interactant.setter
	def Interactant(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Interactant_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def OrganismsDiffer(self):
		return _uniprot.uniprot_CommentType_OrganismsDiffer_Get(self.handle)
	@OrganismsDiffer.setter
	def OrganismsDiffer(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_OrganismsDiffer_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_OrganismsDiffer_Set(self.handle, value)
	@property
	def Experiments(self):
		return _uniprot.uniprot_CommentType_Experiments_Get(self.handle)
	@Experiments.setter
	def Experiments(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Experiments_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_Experiments_Set(self.handle, value)
	@property
	def Disease(self):
		return Disease(handle=_uniprot.uniprot_CommentType_Disease_Get(self.handle))
	@Disease.setter
	def Disease(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Disease_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Location(self):
		return Slice_uniprot_LocationType(handle=_uniprot.uniprot_CommentType_Location_Get(self.handle))
	@Location.setter
	def Location(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Location_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Text(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_CommentType_Text_Get(self.handle))
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Text_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_CommentType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_Type_Set(self.handle, value)
	@property
	def LocationType(self):
		return _uniprot.uniprot_CommentType_LocationType_Get(self.handle)
	@LocationType.setter
	def LocationType(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_LocationType_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_LocationType_Set(self.handle, value)
	@property
	def Name(self):
		return _uniprot.uniprot_CommentType_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Name_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_Name_Set(self.handle, value)
	@property
	def Mass(self):
		return _uniprot.uniprot_CommentType_Mass_Get(self.handle)
	@Mass.setter
	def Mass(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Mass_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_Mass_Set(self.handle, value)
	@property
	def Error(self):
		return _uniprot.uniprot_CommentType_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Error_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_Error_Set(self.handle, value)
	@property
	def Method(self):
		return _uniprot.uniprot_CommentType_Method_Get(self.handle)
	@Method.setter
	def Method(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Method_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CommentType_Method_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_CommentType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CommentType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def UnmarshalXML(self, d, start):
		"""UnmarshalXML(object d, object start) str"""
		return _uniprot.uniprot_CommentType_UnmarshalXML(self.handle, d.handle, start.handle)

# Python type for struct uniprot.EventType
class EventType(go.GoClass):
	"""Describes the type of events that cause alternative products.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_EventType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.EventType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.EventType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _uniprot.uniprot_EventType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_EventType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_EventType_Type_Set(self.handle, value)

# Python type for struct uniprot.PositionType
class PositionType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_PositionType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Position = args[0]
			if "Position" in kwargs:
				self.Position = kwargs["Position"]
			if  1 < len(args):
				self.Status = args[1]
			if "Status" in kwargs:
				self.Status = kwargs["Status"]
			if  2 < len(args):
				self.Evidence = args[2]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PositionType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PositionType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Position(self):
		return _uniprot.uniprot_PositionType_Position_Get(self.handle)
	@Position.setter
	def Position(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PositionType_Position_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_PositionType_Position_Set(self.handle, value)
	@property
	def Status(self):
		return _uniprot.uniprot_PositionType_Status_Get(self.handle)
	@Status.setter
	def Status(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PositionType_Status_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_PositionType_Status_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_PositionType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PositionType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def UnmarshalXML(self, d, start):
		"""UnmarshalXML(object d, object start) str"""
		return _uniprot.uniprot_PositionType_UnmarshalXML(self.handle, d.handle, start.handle)

# Python type for struct uniprot.RedoxPotential
class RedoxPotential(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_RedoxPotential_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Text = args[0]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.RedoxPotential{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.RedoxPotential ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Text(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_RedoxPotential_Text_Get(self.handle))
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_RedoxPotential_Text_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.CofactorType
class CofactorType(go.GoClass):
	"""Describes a cofactor.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_CofactorType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.DbReference = args[1]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
			if  2 < len(args):
				self.Evidence = args[2]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.CofactorType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.CofactorType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _uniprot.uniprot_CofactorType_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CofactorType_Name_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CofactorType_Name_Set(self.handle, value)
	@property
	def DbReference(self):
		return DbReferenceType(handle=_uniprot.uniprot_CofactorType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CofactorType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_CofactorType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CofactorType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Conflict
class Conflict(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Conflict_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Sequence = args[0]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Conflict{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Conflict ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Sequence(self):
		return Sequence(handle=_uniprot.uniprot_Conflict_Sequence_Get(self.handle))
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Conflict_Sequence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_Conflict_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Conflict_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Conflict_Type_Set(self.handle, value)

# Python type for struct uniprot.Strain
class Strain(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Strain_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Strain{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Strain ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_Strain_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Strain_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Strain_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_Strain_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Strain_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.ProteinType
class ProteinType(go.GoClass):
	"""Describes the names for the protein and parts thereof.\nEquivalent to the flat file DE-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_ProteinType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.RecommendedName = args[0]
			if "RecommendedName" in kwargs:
				self.RecommendedName = kwargs["RecommendedName"]
			if  1 < len(args):
				self.AlternativeName = args[1]
			if "AlternativeName" in kwargs:
				self.AlternativeName = kwargs["AlternativeName"]
			if  2 < len(args):
				self.SubmittedName = args[2]
			if "SubmittedName" in kwargs:
				self.SubmittedName = kwargs["SubmittedName"]
			if  3 < len(args):
				self.AllergenName = args[3]
			if "AllergenName" in kwargs:
				self.AllergenName = kwargs["AllergenName"]
			if  4 < len(args):
				self.BiotechName = args[4]
			if "BiotechName" in kwargs:
				self.BiotechName = kwargs["BiotechName"]
			if  5 < len(args):
				self.CdAntigenName = args[5]
			if "CdAntigenName" in kwargs:
				self.CdAntigenName = kwargs["CdAntigenName"]
			if  6 < len(args):
				self.InnName = args[6]
			if "InnName" in kwargs:
				self.InnName = kwargs["InnName"]
			if  7 < len(args):
				self.Domain = args[7]
			if "Domain" in kwargs:
				self.Domain = kwargs["Domain"]
			if  8 < len(args):
				self.Component = args[8]
			if "Component" in kwargs:
				self.Component = kwargs["Component"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ProteinType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.ProteinType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def RecommendedName(self):
		return RecommendedName(handle=_uniprot.uniprot_ProteinType_RecommendedName_Get(self.handle))
	@RecommendedName.setter
	def RecommendedName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_RecommendedName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AlternativeName(self):
		return Slice_uniprot_AlternativeName(handle=_uniprot.uniprot_ProteinType_AlternativeName_Get(self.handle))
	@AlternativeName.setter
	def AlternativeName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_AlternativeName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SubmittedName(self):
		return Slice_uniprot_SubmittedName(handle=_uniprot.uniprot_ProteinType_SubmittedName_Get(self.handle))
	@SubmittedName.setter
	def SubmittedName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_SubmittedName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AllergenName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_ProteinType_AllergenName_Get(self.handle))
	@AllergenName.setter
	def AllergenName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_AllergenName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def BiotechName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_ProteinType_BiotechName_Get(self.handle))
	@BiotechName.setter
	def BiotechName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_BiotechName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CdAntigenName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_ProteinType_CdAntigenName_Get(self.handle))
	@CdAntigenName.setter
	def CdAntigenName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_CdAntigenName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def InnName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_ProteinType_InnName_Get(self.handle))
	@InnName.setter
	def InnName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_InnName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Domain(self):
		return Slice_uniprot_Domain(handle=_uniprot.uniprot_ProteinType_Domain_Get(self.handle))
	@Domain.setter
	def Domain(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_Domain_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Component(self):
		return Slice_uniprot_Component(handle=_uniprot.uniprot_ProteinType_Component_Get(self.handle))
	@Component.setter
	def Component(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_ProteinType_Component_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.RecommendedName
class RecommendedName(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_RecommendedName_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.FullName = args[0]
			if "FullName" in kwargs:
				self.FullName = kwargs["FullName"]
			if  1 < len(args):
				self.ShortName = args[1]
			if "ShortName" in kwargs:
				self.ShortName = kwargs["ShortName"]
			if  2 < len(args):
				self.EcNumber = args[2]
			if "EcNumber" in kwargs:
				self.EcNumber = kwargs["EcNumber"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.RecommendedName{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.RecommendedName ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FullName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_RecommendedName_FullName_Get(self.handle))
	@FullName.setter
	def FullName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_RecommendedName_FullName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ShortName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_RecommendedName_ShortName_Get(self.handle))
	@ShortName.setter
	def ShortName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_RecommendedName_ShortName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def EcNumber(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_RecommendedName_EcNumber_Get(self.handle))
	@EcNumber.setter
	def EcNumber(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_RecommendedName_EcNumber_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.SequenceType
class SequenceType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_SequenceType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Length = args[1]
			if "Length" in kwargs:
				self.Length = kwargs["Length"]
			if  2 < len(args):
				self.Mass = args[2]
			if "Mass" in kwargs:
				self.Mass = kwargs["Mass"]
			if  3 < len(args):
				self.Checksum = args[3]
			if "Checksum" in kwargs:
				self.Checksum = kwargs["Checksum"]
			if  4 < len(args):
				self.Modified = args[4]
			if "Modified" in kwargs:
				self.Modified = kwargs["Modified"]
			if  5 < len(args):
				self.Version = args[5]
			if "Version" in kwargs:
				self.Version = kwargs["Version"]
			if  6 < len(args):
				self.Precursor = args[6]
			if "Precursor" in kwargs:
				self.Precursor = kwargs["Precursor"]
			if  7 < len(args):
				self.Fragment = args[7]
			if "Fragment" in kwargs:
				self.Fragment = kwargs["Fragment"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SequenceType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SequenceType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_SequenceType_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_SequenceType_Value_Set(self.handle, value)
	@property
	def Length(self):
		return _uniprot.uniprot_SequenceType_Length_Get(self.handle)
	@Length.setter
	def Length(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Length_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_SequenceType_Length_Set(self.handle, value)
	@property
	def Mass(self):
		return _uniprot.uniprot_SequenceType_Mass_Get(self.handle)
	@Mass.setter
	def Mass(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Mass_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_SequenceType_Mass_Set(self.handle, value)
	@property
	def Checksum(self):
		return _uniprot.uniprot_SequenceType_Checksum_Get(self.handle)
	@Checksum.setter
	def Checksum(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Checksum_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_SequenceType_Checksum_Set(self.handle, value)
	@property
	def Modified(self):
		return go.time_Time(handle=_uniprot.uniprot_SequenceType_Modified_Get(self.handle))
	@Modified.setter
	def Modified(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Modified_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Version(self):
		return _uniprot.uniprot_SequenceType_Version_Get(self.handle)
	@Version.setter
	def Version(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Version_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_SequenceType_Version_Set(self.handle, value)
	@property
	def Precursor(self):
		return _uniprot.uniprot_SequenceType_Precursor_Get(self.handle)
	@Precursor.setter
	def Precursor(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Precursor_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_SequenceType_Precursor_Set(self.handle, value)
	@property
	def Fragment(self):
		return _uniprot.uniprot_SequenceType_Fragment_Get(self.handle)
	@Fragment.setter
	def Fragment(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SequenceType_Fragment_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_SequenceType_Fragment_Set(self.handle, value)
	def UnmarshalXML(self, d, start):
		"""UnmarshalXML(object d, object start) str"""
		return _uniprot.uniprot_SequenceType_UnmarshalXML(self.handle, d.handle, start.handle)

# Python type for struct uniprot.Component
class Component(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Component_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.RecommendedName = args[0]
			if "RecommendedName" in kwargs:
				self.RecommendedName = kwargs["RecommendedName"]
			if  1 < len(args):
				self.AlternativeName = args[1]
			if "AlternativeName" in kwargs:
				self.AlternativeName = kwargs["AlternativeName"]
			if  2 < len(args):
				self.SubmittedName = args[2]
			if "SubmittedName" in kwargs:
				self.SubmittedName = kwargs["SubmittedName"]
			if  3 < len(args):
				self.AllergenName = args[3]
			if "AllergenName" in kwargs:
				self.AllergenName = kwargs["AllergenName"]
			if  4 < len(args):
				self.BiotechName = args[4]
			if "BiotechName" in kwargs:
				self.BiotechName = kwargs["BiotechName"]
			if  5 < len(args):
				self.CdAntigenName = args[5]
			if "CdAntigenName" in kwargs:
				self.CdAntigenName = kwargs["CdAntigenName"]
			if  6 < len(args):
				self.InnName = args[6]
			if "InnName" in kwargs:
				self.InnName = kwargs["InnName"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Component{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Component ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def RecommendedName(self):
		return RecommendedName(handle=_uniprot.uniprot_Component_RecommendedName_Get(self.handle))
	@RecommendedName.setter
	def RecommendedName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Component_RecommendedName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AlternativeName(self):
		return Slice_uniprot_AlternativeName(handle=_uniprot.uniprot_Component_AlternativeName_Get(self.handle))
	@AlternativeName.setter
	def AlternativeName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Component_AlternativeName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SubmittedName(self):
		return Slice_uniprot_SubmittedName(handle=_uniprot.uniprot_Component_SubmittedName_Get(self.handle))
	@SubmittedName.setter
	def SubmittedName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Component_SubmittedName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AllergenName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_Component_AllergenName_Get(self.handle))
	@AllergenName.setter
	def AllergenName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Component_AllergenName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def BiotechName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_Component_BiotechName_Get(self.handle))
	@BiotechName.setter
	def BiotechName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Component_BiotechName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CdAntigenName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Component_CdAntigenName_Get(self.handle))
	@CdAntigenName.setter
	def CdAntigenName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Component_CdAntigenName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def InnName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Component_InnName_Get(self.handle))
	@InnName.setter
	def InnName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Component_InnName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Domain
class Domain(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Domain_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.RecommendedName = args[0]
			if "RecommendedName" in kwargs:
				self.RecommendedName = kwargs["RecommendedName"]
			if  1 < len(args):
				self.AlternativeName = args[1]
			if "AlternativeName" in kwargs:
				self.AlternativeName = kwargs["AlternativeName"]
			if  2 < len(args):
				self.SubmittedName = args[2]
			if "SubmittedName" in kwargs:
				self.SubmittedName = kwargs["SubmittedName"]
			if  3 < len(args):
				self.AllergenName = args[3]
			if "AllergenName" in kwargs:
				self.AllergenName = kwargs["AllergenName"]
			if  4 < len(args):
				self.BiotechName = args[4]
			if "BiotechName" in kwargs:
				self.BiotechName = kwargs["BiotechName"]
			if  5 < len(args):
				self.CdAntigenName = args[5]
			if "CdAntigenName" in kwargs:
				self.CdAntigenName = kwargs["CdAntigenName"]
			if  6 < len(args):
				self.InnName = args[6]
			if "InnName" in kwargs:
				self.InnName = kwargs["InnName"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Domain{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Domain ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def RecommendedName(self):
		return RecommendedName(handle=_uniprot.uniprot_Domain_RecommendedName_Get(self.handle))
	@RecommendedName.setter
	def RecommendedName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Domain_RecommendedName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AlternativeName(self):
		return Slice_uniprot_AlternativeName(handle=_uniprot.uniprot_Domain_AlternativeName_Get(self.handle))
	@AlternativeName.setter
	def AlternativeName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Domain_AlternativeName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SubmittedName(self):
		return Slice_uniprot_SubmittedName(handle=_uniprot.uniprot_Domain_SubmittedName_Get(self.handle))
	@SubmittedName.setter
	def SubmittedName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Domain_SubmittedName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AllergenName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_Domain_AllergenName_Get(self.handle))
	@AllergenName.setter
	def AllergenName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Domain_AllergenName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def BiotechName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_Domain_BiotechName_Get(self.handle))
	@BiotechName.setter
	def BiotechName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Domain_BiotechName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CdAntigenName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Domain_CdAntigenName_Get(self.handle))
	@CdAntigenName.setter
	def CdAntigenName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Domain_CdAntigenName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def InnName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Domain_InnName_Get(self.handle))
	@InnName.setter
	def InnName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Domain_InnName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.InteractantType
class InteractantType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_InteractantType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Id = args[0]
			if "Id" in kwargs:
				self.Id = kwargs["Id"]
			if  1 < len(args):
				self.Label = args[1]
			if "Label" in kwargs:
				self.Label = kwargs["Label"]
			if  2 < len(args):
				self.DbReference = args[2]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
			if  3 < len(args):
				self.IntactId = args[3]
			if "IntactId" in kwargs:
				self.IntactId = kwargs["IntactId"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.InteractantType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.InteractantType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Id(self):
		return _uniprot.uniprot_InteractantType_Id_Get(self.handle)
	@Id.setter
	def Id(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_InteractantType_Id_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_InteractantType_Id_Set(self.handle, value)
	@property
	def Label(self):
		return _uniprot.uniprot_InteractantType_Label_Get(self.handle)
	@Label.setter
	def Label(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_InteractantType_Label_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_InteractantType_Label_Set(self.handle, value)
	@property
	def DbReference(self):
		return DbReferenceType(handle=_uniprot.uniprot_InteractantType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_InteractantType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IntactId(self):
		return _uniprot.uniprot_InteractantType_IntactId_Get(self.handle)
	@IntactId.setter
	def IntactId(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_InteractantType_IntactId_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_InteractantType_IntactId_Set(self.handle, value)

# Python type for struct uniprot.Kinetics
class Kinetics(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Kinetics_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.KM = args[0]
			if "KM" in kwargs:
				self.KM = kwargs["KM"]
			if  1 < len(args):
				self.Vmax = args[1]
			if "Vmax" in kwargs:
				self.Vmax = kwargs["Vmax"]
			if  2 < len(args):
				self.Text = args[2]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Kinetics{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Kinetics ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def KM(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Kinetics_KM_Get(self.handle))
	@KM.setter
	def KM(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Kinetics_KM_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Vmax(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Kinetics_Vmax_Get(self.handle))
	@Vmax.setter
	def Vmax(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Kinetics_Vmax_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Text(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_Kinetics_Text_Get(self.handle))
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Kinetics_Text_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Sequence
class Sequence(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Sequence_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Resource = args[0]
			if "Resource" in kwargs:
				self.Resource = kwargs["Resource"]
			if  1 < len(args):
				self.Version = args[1]
			if "Version" in kwargs:
				self.Version = kwargs["Version"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Sequence{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Sequence ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Resource(self):
		return _uniprot.uniprot_Sequence_Resource_Get(self.handle)
	@Resource.setter
	def Resource(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Sequence_Resource_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Sequence_Resource_Set(self.handle, value)
	@property
	def Version(self):
		return _uniprot.uniprot_Sequence_Version_Get(self.handle)
	@Version.setter
	def Version(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Sequence_Version_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Sequence_Version_Set(self.handle, value)

# Python type for struct uniprot.AlternativeName
class AlternativeName(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_AlternativeName_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.FullName = args[0]
			if "FullName" in kwargs:
				self.FullName = kwargs["FullName"]
			if  1 < len(args):
				self.ShortName = args[1]
			if "ShortName" in kwargs:
				self.ShortName = kwargs["ShortName"]
			if  2 < len(args):
				self.EcNumber = args[2]
			if "EcNumber" in kwargs:
				self.EcNumber = kwargs["EcNumber"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.AlternativeName{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.AlternativeName ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FullName(self):
		return EvidencedStringType(handle=_uniprot.uniprot_AlternativeName_FullName_Get(self.handle))
	@FullName.setter
	def FullName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_AlternativeName_FullName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ShortName(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_AlternativeName_ShortName_Get(self.handle))
	@ShortName.setter
	def ShortName(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_AlternativeName_ShortName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def EcNumber(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_AlternativeName_EcNumber_Get(self.handle))
	@EcNumber.setter
	def EcNumber(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_AlternativeName_EcNumber_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Link
class Link(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Link_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Uri = args[0]
			if "Uri" in kwargs:
				self.Uri = kwargs["Uri"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Link{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Link ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Uri(self):
		return _uniprot.uniprot_Link_Uri_Get(self.handle)
	@Uri.setter
	def Uri(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Link_Uri_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Link_Uri_Set(self.handle, value)

# Python type for struct uniprot.PhDependence
class PhDependence(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_PhDependence_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Text = args[0]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PhDependence{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PhDependence ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Text(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_PhDependence_Text_Get(self.handle))
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PhDependence_Text_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.SourceDataType
class SourceDataType(go.GoClass):
	"""Describes the source of the sequence according to the citation.\nEquivalent to the flat file RC-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_SourceDataType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Strain = args[0]
			if "Strain" in kwargs:
				self.Strain = kwargs["Strain"]
			if  1 < len(args):
				self.Plasmid = args[1]
			if "Plasmid" in kwargs:
				self.Plasmid = kwargs["Plasmid"]
			if  2 < len(args):
				self.Transposon = args[2]
			if "Transposon" in kwargs:
				self.Transposon = kwargs["Transposon"]
			if  3 < len(args):
				self.Tissue = args[3]
			if "Tissue" in kwargs:
				self.Tissue = kwargs["Tissue"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SourceDataType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.SourceDataType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Strain(self):
		return Strain(handle=_uniprot.uniprot_SourceDataType_Strain_Get(self.handle))
	@Strain.setter
	def Strain(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SourceDataType_Strain_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Plasmid(self):
		return Plasmid(handle=_uniprot.uniprot_SourceDataType_Plasmid_Get(self.handle))
	@Plasmid.setter
	def Plasmid(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SourceDataType_Plasmid_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Transposon(self):
		return Transposon(handle=_uniprot.uniprot_SourceDataType_Transposon_Get(self.handle))
	@Transposon.setter
	def Transposon(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SourceDataType_Transposon_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Tissue(self):
		return Tissue(handle=_uniprot.uniprot_SourceDataType_Tissue_Get(self.handle))
	@Tissue.setter
	def Tissue(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_SourceDataType_Tissue_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Uniprot
class Uniprot(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Uniprot_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Entry = args[0]
			if "Entry" in kwargs:
				self.Entry = kwargs["Entry"]
			if  1 < len(args):
				self.Copyright = args[1]
			if "Copyright" in kwargs:
				self.Copyright = kwargs["Copyright"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Uniprot{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Uniprot ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Entry(self):
		return go.Slice_string(handle=_uniprot.uniprot_Uniprot_Entry_Get(self.handle))
	@Entry.setter
	def Entry(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Uniprot_Entry_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Copyright(self):
		return _uniprot.uniprot_Uniprot_Copyright_Get(self.handle)
	@Copyright.setter
	def Copyright(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Uniprot_Copyright_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Uniprot_Copyright_Set(self.handle, value)

# Python type for struct uniprot.CitationType
class CitationType(go.GoClass):
	"""Describes different types of citations.\nEquivalent to the flat file RX-, RG-, RA-, RT- and RL-lines.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_CitationType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Title = args[0]
			if "Title" in kwargs:
				self.Title = kwargs["Title"]
			if  1 < len(args):
				self.EditorList = args[1]
			if "EditorList" in kwargs:
				self.EditorList = kwargs["EditorList"]
			if  2 < len(args):
				self.AuthorList = args[2]
			if "AuthorList" in kwargs:
				self.AuthorList = kwargs["AuthorList"]
			if  3 < len(args):
				self.Locator = args[3]
			if "Locator" in kwargs:
				self.Locator = kwargs["Locator"]
			if  4 < len(args):
				self.DbReference = args[4]
			if "DbReference" in kwargs:
				self.DbReference = kwargs["DbReference"]
			if  5 < len(args):
				self.Type = args[5]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  6 < len(args):
				self.Date = args[6]
			if "Date" in kwargs:
				self.Date = kwargs["Date"]
			if  7 < len(args):
				self.Name = args[7]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  8 < len(args):
				self.Volume = args[8]
			if "Volume" in kwargs:
				self.Volume = kwargs["Volume"]
			if  9 < len(args):
				self.First = args[9]
			if "First" in kwargs:
				self.First = kwargs["First"]
			if  10 < len(args):
				self.Last = args[10]
			if "Last" in kwargs:
				self.Last = kwargs["Last"]
			if  11 < len(args):
				self.Publisher = args[11]
			if "Publisher" in kwargs:
				self.Publisher = kwargs["Publisher"]
			if  12 < len(args):
				self.City = args[12]
			if "City" in kwargs:
				self.City = kwargs["City"]
			if  13 < len(args):
				self.Db = args[13]
			if "Db" in kwargs:
				self.Db = kwargs["Db"]
			if  14 < len(args):
				self.Number = args[14]
			if "Number" in kwargs:
				self.Number = kwargs["Number"]
			if  15 < len(args):
				self.Institute = args[15]
			if "Institute" in kwargs:
				self.Institute = kwargs["Institute"]
			if  16 < len(args):
				self.Country = args[16]
			if "Country" in kwargs:
				self.Country = kwargs["Country"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.CitationType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.CitationType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Title(self):
		return _uniprot.uniprot_CitationType_Title_Get(self.handle)
	@Title.setter
	def Title(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Title_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Title_Set(self.handle, value)
	@property
	def EditorList(self):
		return NameListType(handle=_uniprot.uniprot_CitationType_EditorList_Get(self.handle))
	@EditorList.setter
	def EditorList(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_EditorList_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AuthorList(self):
		return NameListType(handle=_uniprot.uniprot_CitationType_AuthorList_Get(self.handle))
	@AuthorList.setter
	def AuthorList(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_AuthorList_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Locator(self):
		return _uniprot.uniprot_CitationType_Locator_Get(self.handle)
	@Locator.setter
	def Locator(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Locator_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Locator_Set(self.handle, value)
	@property
	def DbReference(self):
		return Slice_uniprot_DbReferenceType(handle=_uniprot.uniprot_CitationType_DbReference_Get(self.handle))
	@DbReference.setter
	def DbReference(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_DbReference_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_CitationType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Type_Set(self.handle, value)
	@property
	def Date(self):
		return _uniprot.uniprot_CitationType_Date_Get(self.handle)
	@Date.setter
	def Date(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Date_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Date_Set(self.handle, value)
	@property
	def Name(self):
		return _uniprot.uniprot_CitationType_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Name_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Name_Set(self.handle, value)
	@property
	def Volume(self):
		return _uniprot.uniprot_CitationType_Volume_Get(self.handle)
	@Volume.setter
	def Volume(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Volume_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Volume_Set(self.handle, value)
	@property
	def First(self):
		return _uniprot.uniprot_CitationType_First_Get(self.handle)
	@First.setter
	def First(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_First_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_First_Set(self.handle, value)
	@property
	def Last(self):
		return _uniprot.uniprot_CitationType_Last_Get(self.handle)
	@Last.setter
	def Last(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Last_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Last_Set(self.handle, value)
	@property
	def Publisher(self):
		return _uniprot.uniprot_CitationType_Publisher_Get(self.handle)
	@Publisher.setter
	def Publisher(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Publisher_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Publisher_Set(self.handle, value)
	@property
	def City(self):
		return _uniprot.uniprot_CitationType_City_Get(self.handle)
	@City.setter
	def City(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_City_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_City_Set(self.handle, value)
	@property
	def Db(self):
		return _uniprot.uniprot_CitationType_Db_Get(self.handle)
	@Db.setter
	def Db(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Db_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Db_Set(self.handle, value)
	@property
	def Number(self):
		return _uniprot.uniprot_CitationType_Number_Get(self.handle)
	@Number.setter
	def Number(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Number_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Number_Set(self.handle, value)
	@property
	def Institute(self):
		return _uniprot.uniprot_CitationType_Institute_Get(self.handle)
	@Institute.setter
	def Institute(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Institute_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Institute_Set(self.handle, value)
	@property
	def Country(self):
		return _uniprot.uniprot_CitationType_Country_Get(self.handle)
	@Country.setter
	def Country(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_CitationType_Country_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_CitationType_Country_Set(self.handle, value)

# Python type for struct uniprot.GeneLocationType
class GeneLocationType(go.GoClass):
	"""Describes non-nuclear gene locations (organelles and plasmids).\nEquivalent to the flat file OG-line.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_GeneLocationType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  2 < len(args):
				self.Evidence = args[2]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.GeneLocationType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.GeneLocationType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return Slice_uniprot_StatusType(handle=_uniprot.uniprot_GeneLocationType_Name_Get(self.handle))
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_GeneLocationType_Name_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Type(self):
		return _uniprot.uniprot_GeneLocationType_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_GeneLocationType_Type_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_GeneLocationType_Type_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_GeneLocationType_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_GeneLocationType_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.PersonType
class PersonType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_PersonType_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PersonType{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.PersonType ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _uniprot.uniprot_PersonType_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_PersonType_Name_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_PersonType_Name_Set(self.handle, value)

# Python type for struct uniprot.TemperatureDependence
class TemperatureDependence(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_TemperatureDependence_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Text = args[0]
			if "Text" in kwargs:
				self.Text = kwargs["Text"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.TemperatureDependence{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.TemperatureDependence ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Text(self):
		return Slice_uniprot_EvidencedStringType(handle=_uniprot.uniprot_TemperatureDependence_Text_Get(self.handle))
	@Text.setter
	def Text(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_TemperatureDependence_Text_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct uniprot.Tissue
class Tissue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_Tissue_CTor()
			_uniprot.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.Evidence = args[1]
			if "Evidence" in kwargs:
				self.Evidence = kwargs["Evidence"]
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Tissue{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'uniprot.Tissue ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		return _uniprot.uniprot_Tissue_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Tissue_Value_Set(self.handle, value.handle)
		else:
			_uniprot.uniprot_Tissue_Value_Set(self.handle, value)
	@property
	def Evidence(self):
		return IntListType(handle=_uniprot.uniprot_Tissue_Evidence_Get(self.handle))
	@Evidence.setter
	def Evidence(self, value):
		if isinstance(value, go.GoClass):
			_uniprot.uniprot_Tissue_Evidence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))


# ---- Slices ---

# Python type for slice uniprot.IntListType
class IntListType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_uniprot.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_uniprot.IncRef(self.handle)
		else:
			self.handle = _uniprot.uniprot_IntListType_CTor()
			_uniprot.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('uniprot_IntListType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_uniprot.DecRef(self.handle)
	def __str__(self):
		s = 'uniprot.uniprot_IntListType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'uniprot.uniprot_IntListType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _uniprot.uniprot_IntListType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _uniprot.uniprot_IntListType_len(self.handle)
				return IntListType(handle=_uniprot.uniprot_IntListType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _uniprot.uniprot_IntListType_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_uniprot.uniprot_IntListType_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('uniprot_IntListType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _uniprot.uniprot_IntListType_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_uniprot.uniprot_IntListType_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]
	def UnmarshalText(self, text):
		"""UnmarshalText([]int text) str"""
		return _uniprot.uniprot_IntListType_UnmarshalText(self.handle, text.handle)


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---


