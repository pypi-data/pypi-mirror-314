"""
Package gff provides gff parsers and writers.

GFF stands for "general feature format". It is an alternative to GenBank for
storing data about genomic sequences. While not often used in synthetic biology
research, it is more commonly used in bioinformatics for digesting features of
genomic sequences.

This package provides a parser and writer to convert between the gff file
format and the more general poly.Sequence struct.

"""
# python wrapper for package github.com/bebop/poly/io/gff within overall package poly
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -vm=python3 github.com/bebop/poly

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _poly
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from poly import gff
# and then refer to everything using gff. prefix
# packages imported by this package listed below:

from . import transform
from . import fastq



# ---- Types ---

# Python type for slice [32]byte
class Array_32_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'gff.Array_32_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gff.Array_32_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Array_32_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _poly.Array_32_byte_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Array_32_byte_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _poly.Array_32_byte_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []gff.Feature
class Slice_gff_Feature(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.Slice_gff_Feature_CTor()
			_poly.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_gff_Feature.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'gff.Slice_gff_Feature len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gff.Slice_gff_Feature([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Slice_gff_Feature_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _poly.Slice_gff_Feature_len(self.handle)
				return Slice_gff_Feature(handle=_poly.Slice_gff_Feature_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Feature(handle=_poly.Slice_gff_Feature_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Slice_gff_Feature_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_gff_Feature.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Feature(handle=_poly.Slice_gff_Feature_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_poly.Slice_gff_Feature_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []gff.Location
class Slice_gff_Location(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.Slice_gff_Location_CTor()
			_poly.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_gff_Location.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'gff.Slice_gff_Location len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gff.Slice_gff_Location([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Slice_gff_Location_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _poly.Slice_gff_Location_len(self.handle)
				return Slice_gff_Location(handle=_poly.Slice_gff_Location_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Location(handle=_poly.Slice_gff_Location_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Slice_gff_Location_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_gff_Location.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Location(handle=_poly.Slice_gff_Location_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_poly.Slice_gff_Location_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct gff.Feature
class Feature(go.GoClass):
	"""Feature is a struct that represents a feature in a gff file.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.gff_Feature_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Source = args[1]
			if "Source" in kwargs:
				self.Source = kwargs["Source"]
			if  2 < len(args):
				self.Type = args[2]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  3 < len(args):
				self.Score = args[3]
			if "Score" in kwargs:
				self.Score = kwargs["Score"]
			if  4 < len(args):
				self.Strand = args[4]
			if "Strand" in kwargs:
				self.Strand = kwargs["Strand"]
			if  5 < len(args):
				self.Phase = args[5]
			if "Phase" in kwargs:
				self.Phase = kwargs["Phase"]
			if  6 < len(args):
				self.Attributes = args[6]
			if "Attributes" in kwargs:
				self.Attributes = kwargs["Attributes"]
			if  7 < len(args):
				self.Location = args[7]
			if "Location" in kwargs:
				self.Location = kwargs["Location"]
			if  8 < len(args):
				self.ParentSequence = args[8]
			if "ParentSequence" in kwargs:
				self.ParentSequence = kwargs["ParentSequence"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Feature{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Feature ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _poly.gff_Feature_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Name_Set(self.handle, value.handle)
		else:
			_poly.gff_Feature_Name_Set(self.handle, value)
	@property
	def Source(self):
		return _poly.gff_Feature_Source_Get(self.handle)
	@Source.setter
	def Source(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Source_Set(self.handle, value.handle)
		else:
			_poly.gff_Feature_Source_Set(self.handle, value)
	@property
	def Type(self):
		return _poly.gff_Feature_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Type_Set(self.handle, value.handle)
		else:
			_poly.gff_Feature_Type_Set(self.handle, value)
	@property
	def Score(self):
		return _poly.gff_Feature_Score_Get(self.handle)
	@Score.setter
	def Score(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Score_Set(self.handle, value.handle)
		else:
			_poly.gff_Feature_Score_Set(self.handle, value)
	@property
	def Strand(self):
		return _poly.gff_Feature_Strand_Get(self.handle)
	@Strand.setter
	def Strand(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Strand_Set(self.handle, value.handle)
		else:
			_poly.gff_Feature_Strand_Set(self.handle, value)
	@property
	def Phase(self):
		return _poly.gff_Feature_Phase_Get(self.handle)
	@Phase.setter
	def Phase(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Phase_Set(self.handle, value.handle)
		else:
			_poly.gff_Feature_Phase_Set(self.handle, value)
	@property
	def Attributes(self):
		return fastq.Map_string_string(handle=_poly.gff_Feature_Attributes_Get(self.handle))
	@Attributes.setter
	def Attributes(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Attributes_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Location(self):
		return Location(handle=_poly.gff_Feature_Location_Get(self.handle))
	@Location.setter
	def Location(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_Location_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ParentSequence(self):
		return Gff(handle=_poly.gff_Feature_ParentSequence_Get(self.handle))
	@ParentSequence.setter
	def ParentSequence(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Feature_ParentSequence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetSequence(self):
		"""GetSequence() str, str
		
		GetSequence takes a feature and returns a sequence string for that feature.
		"""
		return _poly.gff_Feature_GetSequence(self.handle)

# Python type for struct gff.Gff
class Gff(go.GoClass):
	"""Gff is a struct that represents a gff file.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.gff_Gff_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Meta = args[0]
			if "Meta" in kwargs:
				self.Meta = kwargs["Meta"]
			if  1 < len(args):
				self.Features = args[1]
			if "Features" in kwargs:
				self.Features = kwargs["Features"]
			if  2 < len(args):
				self.Sequence = args[2]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Gff{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Gff ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Meta(self):
		return Meta(handle=_poly.gff_Gff_Meta_Get(self.handle))
	@Meta.setter
	def Meta(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Gff_Meta_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Features(self):
		return Slice_gff_Feature(handle=_poly.gff_Gff_Features_Get(self.handle))
	@Features.setter
	def Features(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Gff_Features_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Sequence(self):
		return _poly.gff_Gff_Sequence_Get(self.handle)
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Gff_Sequence_Set(self.handle, value.handle)
		else:
			_poly.gff_Gff_Sequence_Set(self.handle, value)
	def AddFeature(self, feature):
		"""AddFeature(object feature) str
		
		AddFeature takes a feature and adds it to the Gff struct.
		"""
		return _poly.gff_Gff_AddFeature(self.handle, feature.handle)

# Python type for struct gff.Location
class Location(go.GoClass):
	"""Location is a struct that represents a location in a gff file.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.gff_Location_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Start = args[0]
			if "Start" in kwargs:
				self.Start = kwargs["Start"]
			if  1 < len(args):
				self.End = args[1]
			if "End" in kwargs:
				self.End = kwargs["End"]
			if  2 < len(args):
				self.Complement = args[2]
			if "Complement" in kwargs:
				self.Complement = kwargs["Complement"]
			if  3 < len(args):
				self.Join = args[3]
			if "Join" in kwargs:
				self.Join = kwargs["Join"]
			if  4 < len(args):
				self.FivePrimePartial = args[4]
			if "FivePrimePartial" in kwargs:
				self.FivePrimePartial = kwargs["FivePrimePartial"]
			if  5 < len(args):
				self.ThreePrimePartial = args[5]
			if "ThreePrimePartial" in kwargs:
				self.ThreePrimePartial = kwargs["ThreePrimePartial"]
			if  6 < len(args):
				self.SubLocations = args[6]
			if "SubLocations" in kwargs:
				self.SubLocations = kwargs["SubLocations"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Location{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Location ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Start(self):
		return _poly.gff_Location_Start_Get(self.handle)
	@Start.setter
	def Start(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Location_Start_Set(self.handle, value.handle)
		else:
			_poly.gff_Location_Start_Set(self.handle, value)
	@property
	def End(self):
		return _poly.gff_Location_End_Get(self.handle)
	@End.setter
	def End(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Location_End_Set(self.handle, value.handle)
		else:
			_poly.gff_Location_End_Set(self.handle, value)
	@property
	def Complement(self):
		return _poly.gff_Location_Complement_Get(self.handle)
	@Complement.setter
	def Complement(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Location_Complement_Set(self.handle, value.handle)
		else:
			_poly.gff_Location_Complement_Set(self.handle, value)
	@property
	def Join(self):
		return _poly.gff_Location_Join_Get(self.handle)
	@Join.setter
	def Join(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Location_Join_Set(self.handle, value.handle)
		else:
			_poly.gff_Location_Join_Set(self.handle, value)
	@property
	def FivePrimePartial(self):
		return _poly.gff_Location_FivePrimePartial_Get(self.handle)
	@FivePrimePartial.setter
	def FivePrimePartial(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Location_FivePrimePartial_Set(self.handle, value.handle)
		else:
			_poly.gff_Location_FivePrimePartial_Set(self.handle, value)
	@property
	def ThreePrimePartial(self):
		return _poly.gff_Location_ThreePrimePartial_Get(self.handle)
	@ThreePrimePartial.setter
	def ThreePrimePartial(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Location_ThreePrimePartial_Set(self.handle, value.handle)
		else:
			_poly.gff_Location_ThreePrimePartial_Set(self.handle, value)
	@property
	def SubLocations(self):
		return Slice_gff_Location(handle=_poly.gff_Location_SubLocations_Get(self.handle))
	@SubLocations.setter
	def SubLocations(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Location_SubLocations_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct gff.Meta
class Meta(go.GoClass):
	"""Meta holds meta information about a gff file.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.gff_Meta_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Description = args[1]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
			if  2 < len(args):
				self.Version = args[2]
			if "Version" in kwargs:
				self.Version = kwargs["Version"]
			if  3 < len(args):
				self.RegionStart = args[3]
			if "RegionStart" in kwargs:
				self.RegionStart = kwargs["RegionStart"]
			if  4 < len(args):
				self.RegionEnd = args[4]
			if "RegionEnd" in kwargs:
				self.RegionEnd = kwargs["RegionEnd"]
			if  5 < len(args):
				self.Size = args[5]
			if "Size" in kwargs:
				self.Size = kwargs["Size"]
			if  6 < len(args):
				self.SequenceHash = args[6]
			if "SequenceHash" in kwargs:
				self.SequenceHash = kwargs["SequenceHash"]
			if  7 < len(args):
				self.SequenceHashFunction = args[7]
			if "SequenceHashFunction" in kwargs:
				self.SequenceHashFunction = kwargs["SequenceHashFunction"]
			if  8 < len(args):
				self.CheckSum = args[8]
			if "CheckSum" in kwargs:
				self.CheckSum = kwargs["CheckSum"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Meta{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gff.Meta ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _poly.gff_Meta_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_Name_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_Name_Set(self.handle, value)
	@property
	def Description(self):
		return _poly.gff_Meta_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_Description_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_Description_Set(self.handle, value)
	@property
	def Version(self):
		return _poly.gff_Meta_Version_Get(self.handle)
	@Version.setter
	def Version(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_Version_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_Version_Set(self.handle, value)
	@property
	def RegionStart(self):
		return _poly.gff_Meta_RegionStart_Get(self.handle)
	@RegionStart.setter
	def RegionStart(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_RegionStart_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_RegionStart_Set(self.handle, value)
	@property
	def RegionEnd(self):
		return _poly.gff_Meta_RegionEnd_Get(self.handle)
	@RegionEnd.setter
	def RegionEnd(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_RegionEnd_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_RegionEnd_Set(self.handle, value)
	@property
	def Size(self):
		return _poly.gff_Meta_Size_Get(self.handle)
	@Size.setter
	def Size(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_Size_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_Size_Set(self.handle, value)
	@property
	def SequenceHash(self):
		return _poly.gff_Meta_SequenceHash_Get(self.handle)
	@SequenceHash.setter
	def SequenceHash(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_SequenceHash_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_SequenceHash_Set(self.handle, value)
	@property
	def SequenceHashFunction(self):
		return _poly.gff_Meta_SequenceHashFunction_Get(self.handle)
	@SequenceHashFunction.setter
	def SequenceHashFunction(self, value):
		if isinstance(value, go.GoClass):
			_poly.gff_Meta_SequenceHashFunction_Set(self.handle, value.handle)
		else:
			_poly.gff_Meta_SequenceHashFunction_Set(self.handle, value)
	@property
	def CheckSum(self):
		return Array_32_byte(handle=_poly.gff_Meta_CheckSum_Get(self.handle))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def Parse(file):
	"""Parse(object file) object, str
	
	Parse Takes in a string representing a gffv3 file and parses it into an Sequence object.
	"""
	return Gff(handle=_poly.gff_Parse(file.handle))
def Read(path):
	"""Read(str path) object, str
	
	Read takes in a filepath for a .gffv3 file and parses it into an Annotated poly.Sequence struct.
	"""
	return Gff(handle=_poly.gff_Read(path))


# ---- Functions ---
def Build(sequence):
	"""Build(object sequence) []int, str
	
	Build takes an Annotated sequence and returns a byte array representing a gff to be written out.
	"""
	return go.Slice_byte(handle=_poly.gff_Build(sequence.handle))
def Write(sequence, path):
	"""Write(object sequence, str path) str
	
	Write takes an poly.Sequence struct and a path string and writes out a gff to that path.
	"""
	return _poly.gff_Write(sequence.handle, path)


