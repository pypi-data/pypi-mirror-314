/*
cgo stubs for package matrix.
File is generated by gopy. Do not edit.
gopy build -output=poly/search/align/matrix -vm=python3 github.com/bebop/poly/search/align/matrix
*/

package main

/*

#cgo CFLAGS: "-I/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/include/python3.13" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13/lib" "-lpython3.13" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"github.com/bebop/poly/alphabet"
	"github.com/bebop/poly/search/align/matrix"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: matrix below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *alphabet.Alphabet
func ptrFromHandle_Ptr_alphabet_Alphabet(h CGoHandle) *alphabet.Alphabet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*alphabet.Alphabet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet)
}
func handleFromPtr_Ptr_alphabet_Alphabet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*alphabet.Alphabet", p))
}

// Converters for non-pointer handles for type: alphabet.Alphabet
func ptrFromHandle_alphabet_Alphabet(h CGoHandle) *alphabet.Alphabet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "alphabet.Alphabet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(alphabet.Alphabet{})).(*alphabet.Alphabet)
}
func handleFromPtr_alphabet_Alphabet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("alphabet.Alphabet", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: matrix ---

// ---- Types ---

// Converters for pointer handles for type: *matrix.SubstitutionMatrix
func ptrFromHandle_Ptr_matrix_SubstitutionMatrix(h CGoHandle) *matrix.SubstitutionMatrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*matrix.SubstitutionMatrix")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(matrix.SubstitutionMatrix{})).(*matrix.SubstitutionMatrix)
}
func handleFromPtr_Ptr_matrix_SubstitutionMatrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*matrix.SubstitutionMatrix", p))
}

// Converters for implicit pointer handles for type: [][]int
func ptrFromHandle_Slice_Slice_int(h CGoHandle) *[][]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]int")
	if p == nil {
		return nil
	}
	return p.(*[][]int)
}
func deptrFromHandle_Slice_Slice_int(h CGoHandle) [][]int {
	p := ptrFromHandle_Slice_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]int", p))
}

// --- wrapping slice: [][]int ---
//
//export Slice_Slice_int_CTor
func Slice_Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_int(&[][]int{}))
}

//export Slice_Slice_int_len
func Slice_Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_int(handle))
}

//export Slice_Slice_int_elem
func Slice_Slice_int_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_int(handle)
	return handleFromPtr_Slice_int(&(s[_idx]))
}

//export Slice_Slice_int_subslice
func Slice_Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_int(&ss))
}

//export Slice_Slice_int_set
func Slice_Slice_int_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_int(handle)
	s[_idx] = deptrFromHandle_Slice_int(_vl)
}

//export Slice_Slice_int_append
func Slice_Slice_int_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_int(handle)
	*s = append(*s, deptrFromHandle_Slice_int(_vl))
}

// Converters for non-pointer handles for type: matrix.SubstitutionMatrix
func ptrFromHandle_matrix_SubstitutionMatrix(h CGoHandle) *matrix.SubstitutionMatrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "matrix.SubstitutionMatrix")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(matrix.SubstitutionMatrix{})).(*matrix.SubstitutionMatrix)
}
func handleFromPtr_matrix_SubstitutionMatrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("matrix.SubstitutionMatrix", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export matrix_BLOSUM100
func matrix_BLOSUM100() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM100)
}

//export matrix_Set_BLOSUM100
func matrix_Set_BLOSUM100(val CGoHandle) {
	matrix.BLOSUM100 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM30
func matrix_BLOSUM30() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM30)
}

//export matrix_Set_BLOSUM30
func matrix_Set_BLOSUM30(val CGoHandle) {
	matrix.BLOSUM30 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM35
func matrix_BLOSUM35() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM35)
}

//export matrix_Set_BLOSUM35
func matrix_Set_BLOSUM35(val CGoHandle) {
	matrix.BLOSUM35 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM40
func matrix_BLOSUM40() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM40)
}

//export matrix_Set_BLOSUM40
func matrix_Set_BLOSUM40(val CGoHandle) {
	matrix.BLOSUM40 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM45
func matrix_BLOSUM45() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM45)
}

//export matrix_Set_BLOSUM45
func matrix_Set_BLOSUM45(val CGoHandle) {
	matrix.BLOSUM45 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM50
func matrix_BLOSUM50() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM50)
}

//export matrix_Set_BLOSUM50
func matrix_Set_BLOSUM50(val CGoHandle) {
	matrix.BLOSUM50 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM55
func matrix_BLOSUM55() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM55)
}

//export matrix_Set_BLOSUM55
func matrix_Set_BLOSUM55(val CGoHandle) {
	matrix.BLOSUM55 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM60
func matrix_BLOSUM60() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM60)
}

//export matrix_Set_BLOSUM60
func matrix_Set_BLOSUM60(val CGoHandle) {
	matrix.BLOSUM60 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM62
func matrix_BLOSUM62() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM62)
}

//export matrix_Set_BLOSUM62
func matrix_Set_BLOSUM62(val CGoHandle) {
	matrix.BLOSUM62 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM65
func matrix_BLOSUM65() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM65)
}

//export matrix_Set_BLOSUM65
func matrix_Set_BLOSUM65(val CGoHandle) {
	matrix.BLOSUM65 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM70
func matrix_BLOSUM70() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM70)
}

//export matrix_Set_BLOSUM70
func matrix_Set_BLOSUM70(val CGoHandle) {
	matrix.BLOSUM70 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM75
func matrix_BLOSUM75() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM75)
}

//export matrix_Set_BLOSUM75
func matrix_Set_BLOSUM75(val CGoHandle) {
	matrix.BLOSUM75 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM80
func matrix_BLOSUM80() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM80)
}

//export matrix_Set_BLOSUM80
func matrix_Set_BLOSUM80(val CGoHandle) {
	matrix.BLOSUM80 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM85
func matrix_BLOSUM85() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM85)
}

//export matrix_Set_BLOSUM85
func matrix_Set_BLOSUM85(val CGoHandle) {
	matrix.BLOSUM85 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUM90
func matrix_BLOSUM90() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUM90)
}

//export matrix_Set_BLOSUM90
func matrix_Set_BLOSUM90(val CGoHandle) {
	matrix.BLOSUM90 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_BLOSUMN
func matrix_BLOSUMN() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.BLOSUMN)
}

//export matrix_Set_BLOSUMN
func matrix_Set_BLOSUMN(val CGoHandle) {
	matrix.BLOSUMN = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_DAYHOFF
func matrix_DAYHOFF() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.DAYHOFF)
}

//export matrix_Set_DAYHOFF
func matrix_Set_DAYHOFF(val CGoHandle) {
	matrix.DAYHOFF = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_Default
func matrix_Default() CGoHandle {
	return handleFromPtr_Ptr_matrix_SubstitutionMatrix(matrix.Default)
}

//export matrix_Set_Default
func matrix_Set_Default(val CGoHandle) {
	matrix.Default = ptrFromHandle_Ptr_matrix_SubstitutionMatrix(val)
}

//export matrix_GONNET
func matrix_GONNET() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.GONNET)
}

//export matrix_Set_GONNET
func matrix_Set_GONNET(val CGoHandle) {
	matrix.GONNET = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_IDENTITY
func matrix_IDENTITY() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.IDENTITY)
}

//export matrix_Set_IDENTITY
func matrix_Set_IDENTITY(val CGoHandle) {
	matrix.IDENTITY = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_MATCH
func matrix_MATCH() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.MATCH)
}

//export matrix_Set_MATCH
func matrix_Set_MATCH(val CGoHandle) {
	matrix.MATCH = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_NUC_4
func matrix_NUC_4() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.NUC_4)
}

//export matrix_Set_NUC_4
func matrix_Set_NUC_4(val CGoHandle) {
	matrix.NUC_4 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_NUC_4_4
func matrix_NUC_4_4() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.NUC_4_4)
}

//export matrix_Set_NUC_4_4
func matrix_Set_NUC_4_4(val CGoHandle) {
	matrix.NUC_4_4 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM10
func matrix_PAM10() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM10)
}

//export matrix_Set_PAM10
func matrix_Set_PAM10(val CGoHandle) {
	matrix.PAM10 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM100
func matrix_PAM100() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM100)
}

//export matrix_Set_PAM100
func matrix_Set_PAM100(val CGoHandle) {
	matrix.PAM100 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM110
func matrix_PAM110() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM110)
}

//export matrix_Set_PAM110
func matrix_Set_PAM110(val CGoHandle) {
	matrix.PAM110 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM120
func matrix_PAM120() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM120)
}

//export matrix_Set_PAM120
func matrix_Set_PAM120(val CGoHandle) {
	matrix.PAM120 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM120_cdi
func matrix_PAM120_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM120_cdi)
}

//export matrix_Set_PAM120_cdi
func matrix_Set_PAM120_cdi(val CGoHandle) {
	matrix.PAM120_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM130
func matrix_PAM130() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM130)
}

//export matrix_Set_PAM130
func matrix_Set_PAM130(val CGoHandle) {
	matrix.PAM130 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM140
func matrix_PAM140() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM140)
}

//export matrix_Set_PAM140
func matrix_Set_PAM140(val CGoHandle) {
	matrix.PAM140 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM150
func matrix_PAM150() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM150)
}

//export matrix_Set_PAM150
func matrix_Set_PAM150(val CGoHandle) {
	matrix.PAM150 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM160
func matrix_PAM160() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM160)
}

//export matrix_Set_PAM160
func matrix_Set_PAM160(val CGoHandle) {
	matrix.PAM160 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM160_cdi
func matrix_PAM160_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM160_cdi)
}

//export matrix_Set_PAM160_cdi
func matrix_Set_PAM160_cdi(val CGoHandle) {
	matrix.PAM160_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM170
func matrix_PAM170() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM170)
}

//export matrix_Set_PAM170
func matrix_Set_PAM170(val CGoHandle) {
	matrix.PAM170 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM180
func matrix_PAM180() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM180)
}

//export matrix_Set_PAM180
func matrix_Set_PAM180(val CGoHandle) {
	matrix.PAM180 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM190
func matrix_PAM190() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM190)
}

//export matrix_Set_PAM190
func matrix_Set_PAM190(val CGoHandle) {
	matrix.PAM190 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM20
func matrix_PAM20() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM20)
}

//export matrix_Set_PAM20
func matrix_Set_PAM20(val CGoHandle) {
	matrix.PAM20 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM200
func matrix_PAM200() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM200)
}

//export matrix_Set_PAM200
func matrix_Set_PAM200(val CGoHandle) {
	matrix.PAM200 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM200_cdi
func matrix_PAM200_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM200_cdi)
}

//export matrix_Set_PAM200_cdi
func matrix_Set_PAM200_cdi(val CGoHandle) {
	matrix.PAM200_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM210
func matrix_PAM210() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM210)
}

//export matrix_Set_PAM210
func matrix_Set_PAM210(val CGoHandle) {
	matrix.PAM210 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM220
func matrix_PAM220() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM220)
}

//export matrix_Set_PAM220
func matrix_Set_PAM220(val CGoHandle) {
	matrix.PAM220 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM230
func matrix_PAM230() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM230)
}

//export matrix_Set_PAM230
func matrix_Set_PAM230(val CGoHandle) {
	matrix.PAM230 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM240
func matrix_PAM240() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM240)
}

//export matrix_Set_PAM240
func matrix_Set_PAM240(val CGoHandle) {
	matrix.PAM240 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM250
func matrix_PAM250() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM250)
}

//export matrix_Set_PAM250
func matrix_Set_PAM250(val CGoHandle) {
	matrix.PAM250 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM250_cdi
func matrix_PAM250_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM250_cdi)
}

//export matrix_Set_PAM250_cdi
func matrix_Set_PAM250_cdi(val CGoHandle) {
	matrix.PAM250_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM260
func matrix_PAM260() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM260)
}

//export matrix_Set_PAM260
func matrix_Set_PAM260(val CGoHandle) {
	matrix.PAM260 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM270
func matrix_PAM270() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM270)
}

//export matrix_Set_PAM270
func matrix_Set_PAM270(val CGoHandle) {
	matrix.PAM270 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM280
func matrix_PAM280() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM280)
}

//export matrix_Set_PAM280
func matrix_Set_PAM280(val CGoHandle) {
	matrix.PAM280 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM290
func matrix_PAM290() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM290)
}

//export matrix_Set_PAM290
func matrix_Set_PAM290(val CGoHandle) {
	matrix.PAM290 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM30
func matrix_PAM30() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM30)
}

//export matrix_Set_PAM30
func matrix_Set_PAM30(val CGoHandle) {
	matrix.PAM30 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM300
func matrix_PAM300() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM300)
}

//export matrix_Set_PAM300
func matrix_Set_PAM300(val CGoHandle) {
	matrix.PAM300 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM310
func matrix_PAM310() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM310)
}

//export matrix_Set_PAM310
func matrix_Set_PAM310(val CGoHandle) {
	matrix.PAM310 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM320
func matrix_PAM320() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM320)
}

//export matrix_Set_PAM320
func matrix_Set_PAM320(val CGoHandle) {
	matrix.PAM320 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM330
func matrix_PAM330() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM330)
}

//export matrix_Set_PAM330
func matrix_Set_PAM330(val CGoHandle) {
	matrix.PAM330 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM340
func matrix_PAM340() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM340)
}

//export matrix_Set_PAM340
func matrix_Set_PAM340(val CGoHandle) {
	matrix.PAM340 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM350
func matrix_PAM350() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM350)
}

//export matrix_Set_PAM350
func matrix_Set_PAM350(val CGoHandle) {
	matrix.PAM350 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM360
func matrix_PAM360() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM360)
}

//export matrix_Set_PAM360
func matrix_Set_PAM360(val CGoHandle) {
	matrix.PAM360 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM370
func matrix_PAM370() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM370)
}

//export matrix_Set_PAM370
func matrix_Set_PAM370(val CGoHandle) {
	matrix.PAM370 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM380
func matrix_PAM380() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM380)
}

//export matrix_Set_PAM380
func matrix_Set_PAM380(val CGoHandle) {
	matrix.PAM380 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM390
func matrix_PAM390() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM390)
}

//export matrix_Set_PAM390
func matrix_Set_PAM390(val CGoHandle) {
	matrix.PAM390 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM40
func matrix_PAM40() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM40)
}

//export matrix_Set_PAM40
func matrix_Set_PAM40(val CGoHandle) {
	matrix.PAM40 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM400
func matrix_PAM400() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM400)
}

//export matrix_Set_PAM400
func matrix_Set_PAM400(val CGoHandle) {
	matrix.PAM400 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM40_cdi
func matrix_PAM40_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM40_cdi)
}

//export matrix_Set_PAM40_cdi
func matrix_Set_PAM40_cdi(val CGoHandle) {
	matrix.PAM40_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM410
func matrix_PAM410() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM410)
}

//export matrix_Set_PAM410
func matrix_Set_PAM410(val CGoHandle) {
	matrix.PAM410 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM420
func matrix_PAM420() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM420)
}

//export matrix_Set_PAM420
func matrix_Set_PAM420(val CGoHandle) {
	matrix.PAM420 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM430
func matrix_PAM430() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM430)
}

//export matrix_Set_PAM430
func matrix_Set_PAM430(val CGoHandle) {
	matrix.PAM430 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM440
func matrix_PAM440() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM440)
}

//export matrix_Set_PAM440
func matrix_Set_PAM440(val CGoHandle) {
	matrix.PAM440 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM450
func matrix_PAM450() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM450)
}

//export matrix_Set_PAM450
func matrix_Set_PAM450(val CGoHandle) {
	matrix.PAM450 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM460
func matrix_PAM460() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM460)
}

//export matrix_Set_PAM460
func matrix_Set_PAM460(val CGoHandle) {
	matrix.PAM460 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM470
func matrix_PAM470() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM470)
}

//export matrix_Set_PAM470
func matrix_Set_PAM470(val CGoHandle) {
	matrix.PAM470 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM480
func matrix_PAM480() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM480)
}

//export matrix_Set_PAM480
func matrix_Set_PAM480(val CGoHandle) {
	matrix.PAM480 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM490
func matrix_PAM490() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM490)
}

//export matrix_Set_PAM490
func matrix_Set_PAM490(val CGoHandle) {
	matrix.PAM490 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM50
func matrix_PAM50() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM50)
}

//export matrix_Set_PAM50
func matrix_Set_PAM50(val CGoHandle) {
	matrix.PAM50 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM500
func matrix_PAM500() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM500)
}

//export matrix_Set_PAM500
func matrix_Set_PAM500(val CGoHandle) {
	matrix.PAM500 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM60
func matrix_PAM60() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM60)
}

//export matrix_Set_PAM60
func matrix_Set_PAM60(val CGoHandle) {
	matrix.PAM60 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM70
func matrix_PAM70() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM70)
}

//export matrix_Set_PAM70
func matrix_Set_PAM70(val CGoHandle) {
	matrix.PAM70 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM80
func matrix_PAM80() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM80)
}

//export matrix_Set_PAM80
func matrix_Set_PAM80(val CGoHandle) {
	matrix.PAM80 = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM80_cdi
func matrix_PAM80_cdi() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM80_cdi)
}

//export matrix_Set_PAM80_cdi
func matrix_Set_PAM80_cdi(val CGoHandle) {
	matrix.PAM80_cdi = deptrFromHandle_Slice_Slice_int(val)
}

//export matrix_PAM90
func matrix_PAM90() CGoHandle {
	return handleFromPtr_Slice_Slice_int(&matrix.PAM90)
}

//export matrix_Set_PAM90
func matrix_Set_PAM90(val CGoHandle) {
	matrix.PAM90 = deptrFromHandle_Slice_Slice_int(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: matrix.SubstitutionMatrix ---
//
//export matrix_SubstitutionMatrix_CTor
func matrix_SubstitutionMatrix_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_matrix_SubstitutionMatrix(&matrix.SubstitutionMatrix{}))
}

//export matrix_SubstitutionMatrix_FirstAlphabet_Get
func matrix_SubstitutionMatrix_FirstAlphabet_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	return handleFromPtr_Ptr_alphabet_Alphabet(op.FirstAlphabet)
}

//export matrix_SubstitutionMatrix_FirstAlphabet_Set
func matrix_SubstitutionMatrix_FirstAlphabet_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	op.FirstAlphabet = ptrFromHandle_Ptr_alphabet_Alphabet(val)
}

//export matrix_SubstitutionMatrix_SecondAlphabet_Get
func matrix_SubstitutionMatrix_SecondAlphabet_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	return handleFromPtr_Ptr_alphabet_Alphabet(op.SecondAlphabet)
}

//export matrix_SubstitutionMatrix_SecondAlphabet_Set
func matrix_SubstitutionMatrix_SecondAlphabet_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_matrix_SubstitutionMatrix(handle)
	op.SecondAlphabet = ptrFromHandle_Ptr_alphabet_Alphabet(val)
}

//export matrix_SubstitutionMatrix_Score
func matrix_SubstitutionMatrix_Score(_handle CGoHandle, a *C.char, b *C.char) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*matrix.SubstitutionMatrix")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(matrix.SubstitutionMatrix{})).(*matrix.SubstitutionMatrix).Score(C.GoString(a), C.GoString(b))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export matrix_NewSubstitutionMatrix
func matrix_NewSubstitutionMatrix(firstAlphabet CGoHandle, secondAlphabet CGoHandle, scores CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := matrix.NewSubstitutionMatrix(ptrFromHandle_Ptr_alphabet_Alphabet(firstAlphabet), ptrFromHandle_Ptr_alphabet_Alphabet(secondAlphabet), deptrFromHandle_Slice_Slice_int(scores))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_matrix_SubstitutionMatrix(nil)
	}
	return handleFromPtr_Ptr_matrix_SubstitutionMatrix(cret)
}

// ---- Functions ---
