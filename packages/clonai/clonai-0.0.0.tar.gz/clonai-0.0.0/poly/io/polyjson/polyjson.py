"""
Package polyjson provides utilities to read and write poly.Sequence structs as JSON.

Poly's JSON schema is still in flux so be on the lookout for breaking changes as we
approach the 1.0 release.

"""
# python wrapper for package github.com/bebop/poly/io/polyjson within overall package polyjson
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=poly/io/polyjson -vm=python3 github.com/bebop/poly/io/polyjson

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _polyjson
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from polyjson import polyjson
# and then refer to everything using polyjson. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []polyjson.Feature
class Slice_polyjson_Feature(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_polyjson.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_polyjson.IncRef(self.handle)
		else:
			self.handle = _polyjson.Slice_polyjson_Feature_CTor()
			_polyjson.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_polyjson_Feature.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_polyjson.DecRef(self.handle)
	def __str__(self):
		s = 'polyjson.Slice_polyjson_Feature len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'polyjson.Slice_polyjson_Feature([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _polyjson.Slice_polyjson_Feature_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _polyjson.Slice_polyjson_Feature_len(self.handle)
				return Slice_polyjson_Feature(handle=_polyjson.Slice_polyjson_Feature_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Feature(handle=_polyjson.Slice_polyjson_Feature_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_polyjson.Slice_polyjson_Feature_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_polyjson_Feature.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Feature(handle=_polyjson.Slice_polyjson_Feature_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_polyjson.Slice_polyjson_Feature_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []polyjson.Location
class Slice_polyjson_Location(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_polyjson.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_polyjson.IncRef(self.handle)
		else:
			self.handle = _polyjson.Slice_polyjson_Location_CTor()
			_polyjson.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_polyjson_Location.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_polyjson.DecRef(self.handle)
	def __str__(self):
		s = 'polyjson.Slice_polyjson_Location len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'polyjson.Slice_polyjson_Location([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _polyjson.Slice_polyjson_Location_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _polyjson.Slice_polyjson_Location_len(self.handle)
				return Slice_polyjson_Location(handle=_polyjson.Slice_polyjson_Location_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Location(handle=_polyjson.Slice_polyjson_Location_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_polyjson.Slice_polyjson_Location_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_polyjson_Location.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Location(handle=_polyjson.Slice_polyjson_Location_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_polyjson.Slice_polyjson_Location_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_polyjson.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_polyjson.IncRef(self.handle)
		else:
			self.handle = _polyjson.Map_string_string_CTor()
			_polyjson.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_polyjson.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_polyjson.DecRef(self.handle)
	def __str__(self):
		s = 'polyjson.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'polyjson.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _polyjson.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _polyjson.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_polyjson.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _polyjson.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_polyjson.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _polyjson.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct polyjson.Poly
class Poly(go.GoClass):
	"""Poly is poly's native JSON representation of a sequence.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_polyjson.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_polyjson.IncRef(self.handle)
		else:
			self.handle = _polyjson.polyjson_Poly_CTor()
			_polyjson.IncRef(self.handle)
			if  0 < len(args):
				self.Meta = args[0]
			if "Meta" in kwargs:
				self.Meta = kwargs["Meta"]
			if  1 < len(args):
				self.Features = args[1]
			if "Features" in kwargs:
				self.Features = kwargs["Features"]
			if  2 < len(args):
				self.Sequence = args[2]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
	def __del__(self):
		_polyjson.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Poly{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Poly ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Meta(self):
		return Meta(handle=_polyjson.polyjson_Poly_Meta_Get(self.handle))
	@Meta.setter
	def Meta(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Poly_Meta_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Features(self):
		return Slice_polyjson_Feature(handle=_polyjson.polyjson_Poly_Features_Get(self.handle))
	@Features.setter
	def Features(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Poly_Features_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Sequence(self):
		return _polyjson.polyjson_Poly_Sequence_Get(self.handle)
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Poly_Sequence_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Poly_Sequence_Set(self.handle, value)
	def AddFeature(self, feature):
		"""AddFeature(object feature) str
		
		AddFeature adds a feature to a Poly struct. Does not add the feature's sequence
		"""
		return _polyjson.polyjson_Poly_AddFeature(self.handle, feature.handle)

# Python type for struct polyjson.Feature
class Feature(go.GoClass):
	"""Feature contains all the feature data for a poly feature struct.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_polyjson.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_polyjson.IncRef(self.handle)
		else:
			self.handle = _polyjson.polyjson_Feature_CTor()
			_polyjson.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Hash = args[1]
			if "Hash" in kwargs:
				self.Hash = kwargs["Hash"]
			if  2 < len(args):
				self.Type = args[2]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  3 < len(args):
				self.Description = args[3]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
			if  4 < len(args):
				self.Location = args[4]
			if "Location" in kwargs:
				self.Location = kwargs["Location"]
			if  5 < len(args):
				self.Tags = args[5]
			if "Tags" in kwargs:
				self.Tags = kwargs["Tags"]
			if  6 < len(args):
				self.Sequence = args[6]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
			if  7 < len(args):
				self.ParentSequence = args[7]
			if "ParentSequence" in kwargs:
				self.ParentSequence = kwargs["ParentSequence"]
	def __del__(self):
		_polyjson.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Feature{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Feature ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _polyjson.polyjson_Feature_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_Name_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Feature_Name_Set(self.handle, value)
	@property
	def Hash(self):
		return _polyjson.polyjson_Feature_Hash_Get(self.handle)
	@Hash.setter
	def Hash(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_Hash_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Feature_Hash_Set(self.handle, value)
	@property
	def Type(self):
		return _polyjson.polyjson_Feature_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_Type_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Feature_Type_Set(self.handle, value)
	@property
	def Description(self):
		return _polyjson.polyjson_Feature_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_Description_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Feature_Description_Set(self.handle, value)
	@property
	def Location(self):
		return Location(handle=_polyjson.polyjson_Feature_Location_Get(self.handle))
	@Location.setter
	def Location(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_Location_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Tags(self):
		return Map_string_string(handle=_polyjson.polyjson_Feature_Tags_Get(self.handle))
	@Tags.setter
	def Tags(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_Tags_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Sequence(self):
		return _polyjson.polyjson_Feature_Sequence_Get(self.handle)
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_Sequence_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Feature_Sequence_Set(self.handle, value)
	@property
	def ParentSequence(self):
		return Poly(handle=_polyjson.polyjson_Feature_ParentSequence_Get(self.handle))
	@ParentSequence.setter
	def ParentSequence(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Feature_ParentSequence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetSequence(self):
		"""GetSequence() str, str
		
		GetSequence takes a feature and returns a sequence string for that feature.
		"""
		return _polyjson.polyjson_Feature_GetSequence(self.handle)

# Python type for struct polyjson.Location
class Location(go.GoClass):
	"""Location contains all the location data for a poly feature's location.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_polyjson.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_polyjson.IncRef(self.handle)
		else:
			self.handle = _polyjson.polyjson_Location_CTor()
			_polyjson.IncRef(self.handle)
			if  0 < len(args):
				self.Start = args[0]
			if "Start" in kwargs:
				self.Start = kwargs["Start"]
			if  1 < len(args):
				self.End = args[1]
			if "End" in kwargs:
				self.End = kwargs["End"]
			if  2 < len(args):
				self.Complement = args[2]
			if "Complement" in kwargs:
				self.Complement = kwargs["Complement"]
			if  3 < len(args):
				self.Join = args[3]
			if "Join" in kwargs:
				self.Join = kwargs["Join"]
			if  4 < len(args):
				self.FivePrimePartial = args[4]
			if "FivePrimePartial" in kwargs:
				self.FivePrimePartial = kwargs["FivePrimePartial"]
			if  5 < len(args):
				self.ThreePrimePartial = args[5]
			if "ThreePrimePartial" in kwargs:
				self.ThreePrimePartial = kwargs["ThreePrimePartial"]
			if  6 < len(args):
				self.SubLocations = args[6]
			if "SubLocations" in kwargs:
				self.SubLocations = kwargs["SubLocations"]
	def __del__(self):
		_polyjson.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Location{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Location ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Start(self):
		return _polyjson.polyjson_Location_Start_Get(self.handle)
	@Start.setter
	def Start(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Location_Start_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Location_Start_Set(self.handle, value)
	@property
	def End(self):
		return _polyjson.polyjson_Location_End_Get(self.handle)
	@End.setter
	def End(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Location_End_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Location_End_Set(self.handle, value)
	@property
	def Complement(self):
		return _polyjson.polyjson_Location_Complement_Get(self.handle)
	@Complement.setter
	def Complement(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Location_Complement_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Location_Complement_Set(self.handle, value)
	@property
	def Join(self):
		return _polyjson.polyjson_Location_Join_Get(self.handle)
	@Join.setter
	def Join(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Location_Join_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Location_Join_Set(self.handle, value)
	@property
	def FivePrimePartial(self):
		return _polyjson.polyjson_Location_FivePrimePartial_Get(self.handle)
	@FivePrimePartial.setter
	def FivePrimePartial(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Location_FivePrimePartial_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Location_FivePrimePartial_Set(self.handle, value)
	@property
	def ThreePrimePartial(self):
		return _polyjson.polyjson_Location_ThreePrimePartial_Get(self.handle)
	@ThreePrimePartial.setter
	def ThreePrimePartial(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Location_ThreePrimePartial_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Location_ThreePrimePartial_Set(self.handle, value)
	@property
	def SubLocations(self):
		return Slice_polyjson_Location(handle=_polyjson.polyjson_Location_SubLocations_Get(self.handle))
	@SubLocations.setter
	def SubLocations(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Location_SubLocations_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct polyjson.Meta
class Meta(go.GoClass):
	"""Meta contains all the metadata for a poly sequence struct.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_polyjson.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_polyjson.IncRef(self.handle)
		else:
			self.handle = _polyjson.polyjson_Meta_CTor()
			_polyjson.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Hash = args[1]
			if "Hash" in kwargs:
				self.Hash = kwargs["Hash"]
			if  2 < len(args):
				self.Description = args[2]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
			if  3 < len(args):
				self.URL = args[3]
			if "URL" in kwargs:
				self.URL = kwargs["URL"]
			if  4 < len(args):
				self.CreatedBy = args[4]
			if "CreatedBy" in kwargs:
				self.CreatedBy = kwargs["CreatedBy"]
			if  5 < len(args):
				self.CreatedWith = args[5]
			if "CreatedWith" in kwargs:
				self.CreatedWith = kwargs["CreatedWith"]
			if  6 < len(args):
				self.CreatedOn = args[6]
			if "CreatedOn" in kwargs:
				self.CreatedOn = kwargs["CreatedOn"]
			if  7 < len(args):
				self.Schema = args[7]
			if "Schema" in kwargs:
				self.Schema = kwargs["Schema"]
	def __del__(self):
		_polyjson.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Meta{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'polyjson.Meta ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _polyjson.polyjson_Meta_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_Name_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Meta_Name_Set(self.handle, value)
	@property
	def Hash(self):
		return _polyjson.polyjson_Meta_Hash_Get(self.handle)
	@Hash.setter
	def Hash(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_Hash_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Meta_Hash_Set(self.handle, value)
	@property
	def Description(self):
		return _polyjson.polyjson_Meta_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_Description_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Meta_Description_Set(self.handle, value)
	@property
	def URL(self):
		return _polyjson.polyjson_Meta_URL_Get(self.handle)
	@URL.setter
	def URL(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_URL_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Meta_URL_Set(self.handle, value)
	@property
	def CreatedBy(self):
		return _polyjson.polyjson_Meta_CreatedBy_Get(self.handle)
	@CreatedBy.setter
	def CreatedBy(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_CreatedBy_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Meta_CreatedBy_Set(self.handle, value)
	@property
	def CreatedWith(self):
		return _polyjson.polyjson_Meta_CreatedWith_Get(self.handle)
	@CreatedWith.setter
	def CreatedWith(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_CreatedWith_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Meta_CreatedWith_Set(self.handle, value)
	@property
	def CreatedOn(self):
		return go.time_Time(handle=_polyjson.polyjson_Meta_CreatedOn_Get(self.handle))
	@CreatedOn.setter
	def CreatedOn(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_CreatedOn_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Schema(self):
		return _polyjson.polyjson_Meta_Schema_Get(self.handle)
	@Schema.setter
	def Schema(self, value):
		if isinstance(value, go.GoClass):
			_polyjson.polyjson_Meta_Schema_Set(self.handle, value.handle)
		else:
			_polyjson.polyjson_Meta_Schema_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def Parse(file):
	"""Parse(object file) object, str
	
	Parse parses a Poly JSON file and adds appropriate pointers to struct.
	"""
	return Poly(handle=_polyjson.polyjson_Parse(file.handle))
def Read(path):
	"""Read(str path) object, str
	
	Read reads a Poly JSON file.
	"""
	return Poly(handle=_polyjson.polyjson_Read(path))


# ---- Functions ---
def Write(sequence, path):
	"""Write(object sequence, str path) str
	
	Write writes a Poly struct out to json.
	"""
	return _polyjson.polyjson_Write(sequence.handle, path)


