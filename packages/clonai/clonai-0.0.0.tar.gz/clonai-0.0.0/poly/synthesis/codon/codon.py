"""
Package codon is a package for optimizing codons for expression when synthesizing DNA.

This package contains almost everything you need to do standard codon optimization.

Biological context: certain cells favor certain codons and will reject or under
express sequences that don't use a similar ratio of codons.
This is called codon bias: https://en.wikipedia.org/wiki/Codon_usage_bias

Furthermore, different ribosomes in different organisms will interpret codons differently.
What may be a start codon for one ribosome may be a stop in the other.
Heck, apparently nucleomorphs contain 4 different kinds of ribosomes.
https://en.wikipedia.org/wiki/Nucleomorph <- Thanks Keoni for mentioning this example!

TTFN,
Tim

"""
# python wrapper for package github.com/bebop/poly/synthesis/codon within overall package codon
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=poly/synthesis/codon -vm=python3 github.com/bebop/poly/synthesis/codon

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _codon
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from codon import codon
# and then refer to everything using codon. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []genbank.BaseCount
class Slice_genbank_BaseCount(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Slice_genbank_BaseCount_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_BaseCount.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Slice_genbank_BaseCount len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'codon.Slice_genbank_BaseCount([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _codon.Slice_genbank_BaseCount_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _codon.Slice_genbank_BaseCount_len(self.handle)
				return Slice_genbank_BaseCount(handle=_codon.Slice_genbank_BaseCount_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.genbank_BaseCount(handle=_codon.Slice_genbank_BaseCount_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_codon.Slice_genbank_BaseCount_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_BaseCount.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.genbank_BaseCount(handle=_codon.Slice_genbank_BaseCount_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_codon.Slice_genbank_BaseCount_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []genbank.Feature
class Slice_genbank_Feature(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Slice_genbank_Feature_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_Feature.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Slice_genbank_Feature len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'codon.Slice_genbank_Feature([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _codon.Slice_genbank_Feature_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _codon.Slice_genbank_Feature_len(self.handle)
				return Slice_genbank_Feature(handle=_codon.Slice_genbank_Feature_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.genbank_Feature(handle=_codon.Slice_genbank_Feature_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_codon.Slice_genbank_Feature_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_Feature.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.genbank_Feature(handle=_codon.Slice_genbank_Feature_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_codon.Slice_genbank_Feature_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []genbank.Location
class Slice_genbank_Location(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Slice_genbank_Location_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_Location.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Slice_genbank_Location len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'codon.Slice_genbank_Location([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _codon.Slice_genbank_Location_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _codon.Slice_genbank_Location_len(self.handle)
				return Slice_genbank_Location(handle=_codon.Slice_genbank_Location_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.genbank_Location(handle=_codon.Slice_genbank_Location_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_codon.Slice_genbank_Location_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_Location.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.genbank_Location(handle=_codon.Slice_genbank_Location_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_codon.Slice_genbank_Location_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []genbank.Reference
class Slice_genbank_Reference(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Slice_genbank_Reference_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_Reference.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Slice_genbank_Reference len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'codon.Slice_genbank_Reference([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _codon.Slice_genbank_Reference_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _codon.Slice_genbank_Reference_len(self.handle)
				return Slice_genbank_Reference(handle=_codon.Slice_genbank_Reference_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.genbank_Reference(handle=_codon.Slice_genbank_Reference_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_codon.Slice_genbank_Reference_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_Reference.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.genbank_Reference(handle=_codon.Slice_genbank_Reference_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_codon.Slice_genbank_Reference_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []codon.AminoAcid
class Slice_codon_AminoAcid(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Slice_codon_AminoAcid_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_codon_AminoAcid.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Slice_codon_AminoAcid len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'codon.Slice_codon_AminoAcid([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _codon.Slice_codon_AminoAcid_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _codon.Slice_codon_AminoAcid_len(self.handle)
				return Slice_codon_AminoAcid(handle=_codon.Slice_codon_AminoAcid_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return AminoAcid(handle=_codon.Slice_codon_AminoAcid_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_codon.Slice_codon_AminoAcid_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_codon_AminoAcid.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = AminoAcid(handle=_codon.Slice_codon_AminoAcid_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_codon.Slice_codon_AminoAcid_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []codon.Codon
class Slice_codon_Codon(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Slice_codon_Codon_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_codon_Codon.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Slice_codon_Codon len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'codon.Slice_codon_Codon([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _codon.Slice_codon_Codon_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _codon.Slice_codon_Codon_len(self.handle)
				return Slice_codon_Codon(handle=_codon.Slice_codon_Codon_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Codon(handle=_codon.Slice_codon_Codon_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_codon.Slice_codon_Codon_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_codon_Codon.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Codon(handle=_codon.Slice_codon_Codon_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_codon.Slice_codon_Codon_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]weightedrand.Chooser
class Map_string_weightedrand_Chooser(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Map_string_weightedrand_Chooser_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_weightedrand_Chooser.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_codon.Map_string_weightedrand_Chooser_set(self.handle, k, v)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Map_string_weightedrand_Chooser len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'codon.Map_string_weightedrand_Chooser({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _codon.Map_string_weightedrand_Chooser_len(self.handle)
	def __getitem__(self, key):
		return go.weightedrand_Chooser(handle=_codon.Map_string_weightedrand_Chooser_elem(self.handle, key))
	def __setitem__(self, key, value):
		_codon.Map_string_weightedrand_Chooser_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _codon.Map_string_weightedrand_Chooser_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_codon.Map_string_weightedrand_Chooser_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _codon.Map_string_weightedrand_Chooser_contains(self.handle, key)

# Python type for map map[string]int
class Map_string_int(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Map_string_int_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_int.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_codon.Map_string_int_set(self.handle, k, v)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Map_string_int len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'codon.Map_string_int({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _codon.Map_string_int_len(self.handle)
	def __getitem__(self, key):
		return _codon.Map_string_int_elem(self.handle, key)
	def __setitem__(self, key, value):
		_codon.Map_string_int_set(self.handle, key, value)
	def __delitem__(self, key):
		return _codon.Map_string_int_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_codon.Map_string_int_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _codon.Map_string_int_contains(self.handle, key)

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.Map_string_string_CTor()
			_codon.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_codon.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		s = 'codon.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'codon.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _codon.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _codon.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_codon.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _codon.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_codon.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _codon.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface codon.Table
class Table(go.GoClass):
	"""Table is an interface encompassing what a potentially codon optimized Translation table can do\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = 0
	def GetWeightedAminoAcids(self):
		"""GetWeightedAminoAcids() []object"""
		return Slice_codon_AminoAcid(handle=_codon.codon_Table_GetWeightedAminoAcids(self.handle))
	def Optimize(self, aminoAcids, *args):
		"""Optimize(str aminoAcids, []int randomState) str, str"""
		randomState = go.Slice_int(args)
		return _codon.codon_Table_Optimize(self.handle, aminoAcids, randomState.handle)
	def Translate(self, dnaSeq):
		"""Translate(str dnaSeq) str, str"""
		return _codon.codon_Table_Translate(self.handle, dnaSeq)


# ---- Structs ---

# Python type for struct codon.AminoAcid
class AminoAcid(go.GoClass):
	"""AminoAcid holds information for an amino acid and related codons in a struct\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.codon_AminoAcid_CTor()
			_codon.IncRef(self.handle)
			if  0 < len(args):
				self.Letter = args[0]
			if "Letter" in kwargs:
				self.Letter = kwargs["Letter"]
			if  1 < len(args):
				self.Codons = args[1]
			if "Codons" in kwargs:
				self.Codons = kwargs["Codons"]
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.AminoAcid{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.AminoAcid ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Letter(self):
		return _codon.codon_AminoAcid_Letter_Get(self.handle)
	@Letter.setter
	def Letter(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_AminoAcid_Letter_Set(self.handle, value.handle)
		else:
			_codon.codon_AminoAcid_Letter_Set(self.handle, value)
	@property
	def Codons(self):
		return Slice_codon_Codon(handle=_codon.codon_AminoAcid_Codons_Get(self.handle))
	@Codons.setter
	def Codons(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_AminoAcid_Codons_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct codon.Codon
class Codon(go.GoClass):
	"""Codon holds information for a codon triplet in a struct\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.codon_Codon_CTor()
			_codon.IncRef(self.handle)
			if  0 < len(args):
				self.Triplet = args[0]
			if "Triplet" in kwargs:
				self.Triplet = kwargs["Triplet"]
			if  1 < len(args):
				self.Weight = args[1]
			if "Weight" in kwargs:
				self.Weight = kwargs["Weight"]
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.Codon{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.Codon ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Triplet(self):
		return _codon.codon_Codon_Triplet_Get(self.handle)
	@Triplet.setter
	def Triplet(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_Codon_Triplet_Set(self.handle, value.handle)
		else:
			_codon.codon_Codon_Triplet_Set(self.handle, value)
	@property
	def Weight(self):
		return _codon.codon_Codon_Weight_Get(self.handle)
	@Weight.setter
	def Weight(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_Codon_Weight_Set(self.handle, value.handle)
		else:
			_codon.codon_Codon_Weight_Set(self.handle, value)

# Python type for struct codon.Stats
class Stats(go.GoClass):
	"""Stats denotes a set of statistics we maintain throughout the translation table's lifetime. For example we track\nthe start codons observed when we update the codon table's weights with other DNA sequences\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.codon_Stats_CTor()
			_codon.IncRef(self.handle)
			if  0 < len(args):
				self.StartCodonCount = args[0]
			if "StartCodonCount" in kwargs:
				self.StartCodonCount = kwargs["StartCodonCount"]
			if  1 < len(args):
				self.GeneCount = args[1]
			if "GeneCount" in kwargs:
				self.GeneCount = kwargs["GeneCount"]
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.Stats{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.Stats ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def StartCodonCount(self):
		return Map_string_int(handle=_codon.codon_Stats_StartCodonCount_Get(self.handle))
	@StartCodonCount.setter
	def StartCodonCount(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_Stats_StartCodonCount_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def GeneCount(self):
		return _codon.codon_Stats_GeneCount_Get(self.handle)
	@GeneCount.setter
	def GeneCount(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_Stats_GeneCount_Set(self.handle, value.handle)
		else:
			_codon.codon_Stats_GeneCount_Set(self.handle, value)

# Python type for struct codon.TranslationTable
class TranslationTable(go.GoClass):
	"""TranslationTable contains a weighted codon table, which is used when translating and optimizing sequences. The\nweights can be updated through the codon frequencies we observe in given DNA sequences.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_codon.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_codon.IncRef(self.handle)
		else:
			self.handle = _codon.codon_TranslationTable_CTor()
			_codon.IncRef(self.handle)
			if  0 < len(args):
				self.StartCodons = args[0]
			if "StartCodons" in kwargs:
				self.StartCodons = kwargs["StartCodons"]
			if  1 < len(args):
				self.StopCodons = args[1]
			if "StopCodons" in kwargs:
				self.StopCodons = kwargs["StopCodons"]
			if  2 < len(args):
				self.AminoAcids = args[2]
			if "AminoAcids" in kwargs:
				self.AminoAcids = kwargs["AminoAcids"]
			if  3 < len(args):
				self.TranslationMap = args[3]
			if "TranslationMap" in kwargs:
				self.TranslationMap = kwargs["TranslationMap"]
			if  4 < len(args):
				self.StartCodonTable = args[4]
			if "StartCodonTable" in kwargs:
				self.StartCodonTable = kwargs["StartCodonTable"]
			if  5 < len(args):
				self.Choosers = args[5]
			if "Choosers" in kwargs:
				self.Choosers = kwargs["Choosers"]
			if  6 < len(args):
				self.Stats = args[6]
			if "Stats" in kwargs:
				self.Stats = kwargs["Stats"]
	def __del__(self):
		_codon.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.TranslationTable{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'codon.TranslationTable ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def StartCodons(self):
		return go.Slice_string(handle=_codon.codon_TranslationTable_StartCodons_Get(self.handle))
	@StartCodons.setter
	def StartCodons(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_TranslationTable_StartCodons_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def StopCodons(self):
		return go.Slice_string(handle=_codon.codon_TranslationTable_StopCodons_Get(self.handle))
	@StopCodons.setter
	def StopCodons(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_TranslationTable_StopCodons_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AminoAcids(self):
		return Slice_codon_AminoAcid(handle=_codon.codon_TranslationTable_AminoAcids_Get(self.handle))
	@AminoAcids.setter
	def AminoAcids(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_TranslationTable_AminoAcids_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TranslationMap(self):
		return Map_string_string(handle=_codon.codon_TranslationTable_TranslationMap_Get(self.handle))
	@TranslationMap.setter
	def TranslationMap(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_TranslationTable_TranslationMap_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def StartCodonTable(self):
		return Map_string_string(handle=_codon.codon_TranslationTable_StartCodonTable_Get(self.handle))
	@StartCodonTable.setter
	def StartCodonTable(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_TranslationTable_StartCodonTable_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Choosers(self):
		return Map_string_weightedrand_Chooser(handle=_codon.codon_TranslationTable_Choosers_Get(self.handle))
	@Choosers.setter
	def Choosers(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_TranslationTable_Choosers_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Stats(self):
		return Stats(handle=_codon.codon_TranslationTable_Stats_Get(self.handle))
	@Stats.setter
	def Stats(self, value):
		if isinstance(value, go.GoClass):
			_codon.codon_TranslationTable_Stats_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Copy(self):
		"""Copy() object, str
		
		Copy returns a deep copy of the translation table. This is to prevent an unintended update of data used in another
		process.
		"""
		return TranslationTable(handle=_codon.codon_TranslationTable_Copy(self.handle))
	def GetWeightedAminoAcids(self):
		"""GetWeightedAminoAcids() []object
		
		GetWeightedAminoAcids returns the amino acids along with their associated codon weights
		"""
		return Slice_codon_AminoAcid(handle=_codon.codon_TranslationTable_GetWeightedAminoAcids(self.handle))
	def Optimize(self, aminoAcids, *args):
		"""Optimize(str aminoAcids, []int randomState) str, str
		
		Optimize will return a set of codons which can be used to encode the given amino acid sequence. The codons
		picked are weighted according to the computed translation table's weights
		"""
		randomState = go.Slice_int(args)
		return _codon.codon_TranslationTable_Optimize(self.handle, aminoAcids, randomState.handle)
	def UpdateWeights(self, aminoAcids):
		"""UpdateWeights([]object aminoAcids) str
		
		UpdateWeights will update the translation table's codon pickers with the given amino acid codon weights
		"""
		return _codon.codon_TranslationTable_UpdateWeights(self.handle, aminoAcids.handle)
	def UpdateWeightsWithSequence(self, data):
		"""UpdateWeightsWithSequence(object data) str
		
		UpdateWeightsWithSequence will look at the coding regions in the given genbank data, and use those to generate new
		weights for the codons in the translation table. The next time a sequence is optimised, it will use those updated
		weights.
		
		This can be used to, for example, figure out which DNA sequence is needed to give the best yield of protein when
		trying to express a protein across different species
		"""
		return _codon.codon_TranslationTable_UpdateWeightsWithSequence(self.handle, data.handle)
	def Translate(self, dnaSeq):
		"""Translate(str dnaSeq) str, str
		
		Translate will return an amino acid sequence which the given DNA will yield
		"""
		return _codon.codon_TranslationTable_Translate(self.handle, dnaSeq)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewStats():
	"""NewStats() object
	
	NewStats returns a new instance of codon statistics (a set of statistics we maintain throughout a translation table's lifetime)
	"""
	return Stats(handle=_codon.codon_NewStats())
def ReadCodonJSON(path):
	"""ReadCodonJSON(str path) object
	
	ReadCodonJSON reads a codonTable JSON file.
	"""
	return TranslationTable(handle=_codon.codon_ReadCodonJSON(path))
def AddCodonTable(firstCodonTable, secondCodonTable):
	"""AddCodonTable(object firstCodonTable, object secondCodonTable) object, str
	
	AddCodonTable takes 2 CodonTables and adds them together to create
	a new codonTable.
	"""
	return TranslationTable(handle=_codon.codon_AddCodonTable(firstCodonTable.handle, secondCodonTable.handle))
def CompromiseCodonTable(firstCodonTable, secondCodonTable, cutOff):
	"""CompromiseCodonTable(object firstCodonTable, object secondCodonTable, float cutOff) object, str
	
	CompromiseCodonTable takes 2 CodonTables and makes a new codonTable
	that is an equal compromise between the two tables.
	"""
	return TranslationTable(handle=_codon.codon_CompromiseCodonTable(firstCodonTable.handle, secondCodonTable.handle, cutOff))
def NewTranslationTable(index):
	"""NewTranslationTable(int index) object, str
	
	NewTranslationTable takes the index of desired NCBI codon table and returns it.
	"""
	return TranslationTable(handle=_codon.codon_NewTranslationTable(index))
def ParseCodonJSON(file):
	"""ParseCodonJSON([]int file) object
	
	ParseCodonJSON parses a codonTable JSON file.
	"""
	return TranslationTable(handle=_codon.codon_ParseCodonJSON(file.handle))


# ---- Functions ---
def WriteCodonJSON(codonTable, path, goRun=False):
	"""WriteCodonJSON(object codonTable, str path) 
	
	WriteCodonJSON writes a codonTable struct out to JSON.
	"""
	_codon.codon_WriteCodonJSON(codonTable.handle, path, goRun)


