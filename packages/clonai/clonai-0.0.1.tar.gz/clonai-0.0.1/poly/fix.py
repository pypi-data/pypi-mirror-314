"""
Package fix fixes synthetic DNA molecules in preparation for synthesis.

Many synthesis companies have restrictions on the DNA they can synthesize. This
synthesis fixer takes advantage of synonymous codons in protein coding
sequences (CDS) to remove problematic sequences that either users don't want
(like restriction enzymes sites) or that would cause DNA synthesis companies to
reject a synthesis project.

This synthesis fixer is meant to cover the majority of use cases for DNA
fixing. It is not intended to cover all possible use cases, since the majority
of DNA design does not actually have these edge cases.

For most users, using `CdsSimple` will be sufficient to prepare a sequence
for synthesis (you may want to add in restriction enzyme sites to remove).

Cds does not guarantee that all requested features will be removed. If you
have use case that Cds cannot properly fix, please put an issue in the poly
github.

"""
# python wrapper for package github.com/bebop/poly/synthesis/fix within overall package poly
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -vm=python3 github.com/bebop/poly

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _poly
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from poly import fix
# and then refer to everything using fix. prefix
# packages imported by this package listed below:

from . import checks
from . import codon
from . import transform



# ---- Types ---


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct fix.Change
class Change(go.GoClass):
	"""Change is a change to a given DNA sequence. A list of changes is given as\nthe output of Cds.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.fix_Change_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Position = args[0]
			if "Position" in kwargs:
				self.Position = kwargs["Position"]
			if  1 < len(args):
				self.Step = args[1]
			if "Step" in kwargs:
				self.Step = kwargs["Step"]
			if  2 < len(args):
				self.From = args[2]
			if "From" in kwargs:
				self.From = kwargs["From"]
			if  3 < len(args):
				self.To = args[3]
			if "To" in kwargs:
				self.To = kwargs["To"]
			if  4 < len(args):
				self.Reason = args[4]
			if "Reason" in kwargs:
				self.Reason = kwargs["Reason"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'fix.Change{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'fix.Change ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Position(self):
		return _poly.fix_Change_Position_Get(self.handle)
	@Position.setter
	def Position(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_Change_Position_Set(self.handle, value.handle)
		else:
			_poly.fix_Change_Position_Set(self.handle, value)
	@property
	def Step(self):
		return _poly.fix_Change_Step_Get(self.handle)
	@Step.setter
	def Step(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_Change_Step_Set(self.handle, value.handle)
		else:
			_poly.fix_Change_Step_Set(self.handle, value)
	@property
	def From(self):
		return _poly.fix_Change_From_Get(self.handle)
	@From.setter
	def From(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_Change_From_Set(self.handle, value.handle)
		else:
			_poly.fix_Change_From_Set(self.handle, value)
	@property
	def To(self):
		return _poly.fix_Change_To_Get(self.handle)
	@To.setter
	def To(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_Change_To_Set(self.handle, value.handle)
		else:
			_poly.fix_Change_To_Set(self.handle, value)
	@property
	def Reason(self):
		return _poly.fix_Change_Reason_Get(self.handle)
	@Reason.setter
	def Reason(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_Change_Reason_Set(self.handle, value.handle)
		else:
			_poly.fix_Change_Reason_Set(self.handle, value)

# Python type for struct fix.DnaSuggestion
class DnaSuggestion(go.GoClass):
	"""DnaSuggestion is a suggestion of a fixer, generated by a\nproblematicSequenceFunc. Bias must be `NA`, `GC`, or `AT`, with `NA`\nrepresenting a neutral skew.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.fix_DnaSuggestion_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Start = args[0]
			if "Start" in kwargs:
				self.Start = kwargs["Start"]
			if  1 < len(args):
				self.End = args[1]
			if "End" in kwargs:
				self.End = kwargs["End"]
			if  2 < len(args):
				self.Bias = args[2]
			if "Bias" in kwargs:
				self.Bias = kwargs["Bias"]
			if  3 < len(args):
				self.QuantityFixes = args[3]
			if "QuantityFixes" in kwargs:
				self.QuantityFixes = kwargs["QuantityFixes"]
			if  4 < len(args):
				self.SuggestionType = args[4]
			if "SuggestionType" in kwargs:
				self.SuggestionType = kwargs["SuggestionType"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'fix.DnaSuggestion{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'fix.DnaSuggestion ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Start(self):
		return _poly.fix_DnaSuggestion_Start_Get(self.handle)
	@Start.setter
	def Start(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_DnaSuggestion_Start_Set(self.handle, value.handle)
		else:
			_poly.fix_DnaSuggestion_Start_Set(self.handle, value)
	@property
	def End(self):
		return _poly.fix_DnaSuggestion_End_Get(self.handle)
	@End.setter
	def End(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_DnaSuggestion_End_Set(self.handle, value.handle)
		else:
			_poly.fix_DnaSuggestion_End_Set(self.handle, value)
	@property
	def Bias(self):
		return _poly.fix_DnaSuggestion_Bias_Get(self.handle)
	@Bias.setter
	def Bias(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_DnaSuggestion_Bias_Set(self.handle, value.handle)
		else:
			_poly.fix_DnaSuggestion_Bias_Set(self.handle, value)
	@property
	def QuantityFixes(self):
		return _poly.fix_DnaSuggestion_QuantityFixes_Get(self.handle)
	@QuantityFixes.setter
	def QuantityFixes(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_DnaSuggestion_QuantityFixes_Set(self.handle, value.handle)
		else:
			_poly.fix_DnaSuggestion_QuantityFixes_Set(self.handle, value)
	@property
	def SuggestionType(self):
		return _poly.fix_DnaSuggestion_SuggestionType_Get(self.handle)
	@SuggestionType.setter
	def SuggestionType(self, value):
		if isinstance(value, go.GoClass):
			_poly.fix_DnaSuggestion_SuggestionType_Set(self.handle, value.handle)
		else:
			_poly.fix_DnaSuggestion_SuggestionType_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---


