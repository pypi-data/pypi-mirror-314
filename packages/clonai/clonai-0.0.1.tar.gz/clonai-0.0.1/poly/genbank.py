"""
Package genbank provides genbank parsers and writers.

GenBank is a flat text file format developed in the 1980s to annotate genetic
sequences, and has since become the standard for sharing annotated genetic
sequences.

This package provides a parser and writer to convert between the GenBank file
format and the more general Genbank struct.

"""
# python wrapper for package github.com/bebop/poly/io/genbank within overall package poly
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -vm=python3 github.com/bebop/poly

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _poly
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from poly import genbank
# and then refer to everything using genbank. prefix
# packages imported by this package listed below:

from . import transform
from . import fastq



# ---- Types ---

# Python type for slice []genbank.BaseCount
class Slice_genbank_BaseCount(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.Slice_genbank_BaseCount_CTor()
			_poly.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_BaseCount.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'genbank.Slice_genbank_BaseCount len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'genbank.Slice_genbank_BaseCount([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Slice_genbank_BaseCount_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _poly.Slice_genbank_BaseCount_len(self.handle)
				return Slice_genbank_BaseCount(handle=_poly.Slice_genbank_BaseCount_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return BaseCount(handle=_poly.Slice_genbank_BaseCount_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Slice_genbank_BaseCount_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_BaseCount.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = BaseCount(handle=_poly.Slice_genbank_BaseCount_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_poly.Slice_genbank_BaseCount_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []genbank.Feature
class Slice_genbank_Feature(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.Slice_genbank_Feature_CTor()
			_poly.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_Feature.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'genbank.Slice_genbank_Feature len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'genbank.Slice_genbank_Feature([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Slice_genbank_Feature_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _poly.Slice_genbank_Feature_len(self.handle)
				return Slice_genbank_Feature(handle=_poly.Slice_genbank_Feature_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Feature(handle=_poly.Slice_genbank_Feature_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Slice_genbank_Feature_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_Feature.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Feature(handle=_poly.Slice_genbank_Feature_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_poly.Slice_genbank_Feature_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []genbank.Genbank
class Slice_genbank_Genbank(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.Slice_genbank_Genbank_CTor()
			_poly.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_Genbank.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'genbank.Slice_genbank_Genbank len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'genbank.Slice_genbank_Genbank([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Slice_genbank_Genbank_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _poly.Slice_genbank_Genbank_len(self.handle)
				return Slice_genbank_Genbank(handle=_poly.Slice_genbank_Genbank_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Genbank(handle=_poly.Slice_genbank_Genbank_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Slice_genbank_Genbank_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_Genbank.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Genbank(handle=_poly.Slice_genbank_Genbank_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_poly.Slice_genbank_Genbank_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []genbank.Location
class Slice_genbank_Location(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.Slice_genbank_Location_CTor()
			_poly.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_Location.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'genbank.Slice_genbank_Location len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'genbank.Slice_genbank_Location([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Slice_genbank_Location_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _poly.Slice_genbank_Location_len(self.handle)
				return Slice_genbank_Location(handle=_poly.Slice_genbank_Location_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Location(handle=_poly.Slice_genbank_Location_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Slice_genbank_Location_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_Location.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Location(handle=_poly.Slice_genbank_Location_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_poly.Slice_genbank_Location_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []genbank.Reference
class Slice_genbank_Reference(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.Slice_genbank_Reference_CTor()
			_poly.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_genbank_Reference.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		s = 'genbank.Slice_genbank_Reference len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'genbank.Slice_genbank_Reference([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _poly.Slice_genbank_Reference_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _poly.Slice_genbank_Reference_len(self.handle)
				return Slice_genbank_Reference(handle=_poly.Slice_genbank_Reference_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Reference(handle=_poly.Slice_genbank_Reference_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_poly.Slice_genbank_Reference_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_genbank_Reference.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Reference(handle=_poly.Slice_genbank_Reference_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_poly.Slice_genbank_Reference_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct genbank.Meta
class Meta(go.GoClass):
	"""Meta holds the meta data for Genbank and other annotated sequence files.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.genbank_Meta_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Date = args[0]
			if "Date" in kwargs:
				self.Date = kwargs["Date"]
			if  1 < len(args):
				self.Definition = args[1]
			if "Definition" in kwargs:
				self.Definition = kwargs["Definition"]
			if  2 < len(args):
				self.Accession = args[2]
			if "Accession" in kwargs:
				self.Accession = kwargs["Accession"]
			if  3 < len(args):
				self.Version = args[3]
			if "Version" in kwargs:
				self.Version = kwargs["Version"]
			if  4 < len(args):
				self.Keywords = args[4]
			if "Keywords" in kwargs:
				self.Keywords = kwargs["Keywords"]
			if  5 < len(args):
				self.Organism = args[5]
			if "Organism" in kwargs:
				self.Organism = kwargs["Organism"]
			if  6 < len(args):
				self.Source = args[6]
			if "Source" in kwargs:
				self.Source = kwargs["Source"]
			if  7 < len(args):
				self.Taxonomy = args[7]
			if "Taxonomy" in kwargs:
				self.Taxonomy = kwargs["Taxonomy"]
			if  8 < len(args):
				self.Origin = args[8]
			if "Origin" in kwargs:
				self.Origin = kwargs["Origin"]
			if  9 < len(args):
				self.Locus = args[9]
			if "Locus" in kwargs:
				self.Locus = kwargs["Locus"]
			if  10 < len(args):
				self.References = args[10]
			if "References" in kwargs:
				self.References = kwargs["References"]
			if  11 < len(args):
				self.BaseCount = args[11]
			if "BaseCount" in kwargs:
				self.BaseCount = kwargs["BaseCount"]
			if  12 < len(args):
				self.Other = args[12]
			if "Other" in kwargs:
				self.Other = kwargs["Other"]
			if  13 < len(args):
				self.Name = args[13]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  14 < len(args):
				self.SequenceHash = args[14]
			if "SequenceHash" in kwargs:
				self.SequenceHash = kwargs["SequenceHash"]
			if  15 < len(args):
				self.SequenceHashFunction = args[15]
			if "SequenceHashFunction" in kwargs:
				self.SequenceHashFunction = kwargs["SequenceHashFunction"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Meta{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Meta ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Date(self):
		return _poly.genbank_Meta_Date_Get(self.handle)
	@Date.setter
	def Date(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Date_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Date_Set(self.handle, value)
	@property
	def Definition(self):
		return _poly.genbank_Meta_Definition_Get(self.handle)
	@Definition.setter
	def Definition(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Definition_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Definition_Set(self.handle, value)
	@property
	def Accession(self):
		return _poly.genbank_Meta_Accession_Get(self.handle)
	@Accession.setter
	def Accession(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Accession_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Accession_Set(self.handle, value)
	@property
	def Version(self):
		return _poly.genbank_Meta_Version_Get(self.handle)
	@Version.setter
	def Version(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Version_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Version_Set(self.handle, value)
	@property
	def Keywords(self):
		return _poly.genbank_Meta_Keywords_Get(self.handle)
	@Keywords.setter
	def Keywords(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Keywords_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Keywords_Set(self.handle, value)
	@property
	def Organism(self):
		return _poly.genbank_Meta_Organism_Get(self.handle)
	@Organism.setter
	def Organism(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Organism_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Organism_Set(self.handle, value)
	@property
	def Source(self):
		return _poly.genbank_Meta_Source_Get(self.handle)
	@Source.setter
	def Source(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Source_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Source_Set(self.handle, value)
	@property
	def Taxonomy(self):
		return go.Slice_string(handle=_poly.genbank_Meta_Taxonomy_Get(self.handle))
	@Taxonomy.setter
	def Taxonomy(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Taxonomy_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Origin(self):
		return _poly.genbank_Meta_Origin_Get(self.handle)
	@Origin.setter
	def Origin(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Origin_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Origin_Set(self.handle, value)
	@property
	def Locus(self):
		return Locus(handle=_poly.genbank_Meta_Locus_Get(self.handle))
	@Locus.setter
	def Locus(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Locus_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def References(self):
		return Slice_genbank_Reference(handle=_poly.genbank_Meta_References_Get(self.handle))
	@References.setter
	def References(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_References_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def BaseCount(self):
		return Slice_genbank_BaseCount(handle=_poly.genbank_Meta_BaseCount_Get(self.handle))
	@BaseCount.setter
	def BaseCount(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_BaseCount_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Other(self):
		return fastq.Map_string_string(handle=_poly.genbank_Meta_Other_Get(self.handle))
	@Other.setter
	def Other(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Other_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Name(self):
		return _poly.genbank_Meta_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_Name_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_Name_Set(self.handle, value)
	@property
	def SequenceHash(self):
		return _poly.genbank_Meta_SequenceHash_Get(self.handle)
	@SequenceHash.setter
	def SequenceHash(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_SequenceHash_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_SequenceHash_Set(self.handle, value)
	@property
	def SequenceHashFunction(self):
		return _poly.genbank_Meta_SequenceHashFunction_Get(self.handle)
	@SequenceHashFunction.setter
	def SequenceHashFunction(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Meta_SequenceHashFunction_Set(self.handle, value.handle)
		else:
			_poly.genbank_Meta_SequenceHashFunction_Set(self.handle, value)

# Python type for struct genbank.Reference
class Reference(go.GoClass):
	"""Reference holds information for one reference in a Meta struct.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.genbank_Reference_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Authors = args[0]
			if "Authors" in kwargs:
				self.Authors = kwargs["Authors"]
			if  1 < len(args):
				self.Title = args[1]
			if "Title" in kwargs:
				self.Title = kwargs["Title"]
			if  2 < len(args):
				self.Journal = args[2]
			if "Journal" in kwargs:
				self.Journal = kwargs["Journal"]
			if  3 < len(args):
				self.PubMed = args[3]
			if "PubMed" in kwargs:
				self.PubMed = kwargs["PubMed"]
			if  4 < len(args):
				self.Remark = args[4]
			if "Remark" in kwargs:
				self.Remark = kwargs["Remark"]
			if  5 < len(args):
				self.Range = args[5]
			if "Range" in kwargs:
				self.Range = kwargs["Range"]
			if  6 < len(args):
				self.Consortium = args[6]
			if "Consortium" in kwargs:
				self.Consortium = kwargs["Consortium"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Reference{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Reference ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Authors(self):
		return _poly.genbank_Reference_Authors_Get(self.handle)
	@Authors.setter
	def Authors(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Reference_Authors_Set(self.handle, value.handle)
		else:
			_poly.genbank_Reference_Authors_Set(self.handle, value)
	@property
	def Title(self):
		return _poly.genbank_Reference_Title_Get(self.handle)
	@Title.setter
	def Title(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Reference_Title_Set(self.handle, value.handle)
		else:
			_poly.genbank_Reference_Title_Set(self.handle, value)
	@property
	def Journal(self):
		return _poly.genbank_Reference_Journal_Get(self.handle)
	@Journal.setter
	def Journal(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Reference_Journal_Set(self.handle, value.handle)
		else:
			_poly.genbank_Reference_Journal_Set(self.handle, value)
	@property
	def PubMed(self):
		return _poly.genbank_Reference_PubMed_Get(self.handle)
	@PubMed.setter
	def PubMed(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Reference_PubMed_Set(self.handle, value.handle)
		else:
			_poly.genbank_Reference_PubMed_Set(self.handle, value)
	@property
	def Remark(self):
		return _poly.genbank_Reference_Remark_Get(self.handle)
	@Remark.setter
	def Remark(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Reference_Remark_Set(self.handle, value.handle)
		else:
			_poly.genbank_Reference_Remark_Set(self.handle, value)
	@property
	def Range(self):
		return _poly.genbank_Reference_Range_Get(self.handle)
	@Range.setter
	def Range(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Reference_Range_Set(self.handle, value.handle)
		else:
			_poly.genbank_Reference_Range_Set(self.handle, value)
	@property
	def Consortium(self):
		return _poly.genbank_Reference_Consortium_Get(self.handle)
	@Consortium.setter
	def Consortium(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Reference_Consortium_Set(self.handle, value.handle)
		else:
			_poly.genbank_Reference_Consortium_Set(self.handle, value)

# Python type for struct genbank.BaseCount
class BaseCount(go.GoClass):
	"""BaseCount is a struct that holds the base counts for a sequence.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.genbank_BaseCount_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Base = args[0]
			if "Base" in kwargs:
				self.Base = kwargs["Base"]
			if  1 < len(args):
				self.Count = args[1]
			if "Count" in kwargs:
				self.Count = kwargs["Count"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.BaseCount{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.BaseCount ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Base(self):
		return _poly.genbank_BaseCount_Base_Get(self.handle)
	@Base.setter
	def Base(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_BaseCount_Base_Set(self.handle, value.handle)
		else:
			_poly.genbank_BaseCount_Base_Set(self.handle, value)
	@property
	def Count(self):
		return _poly.genbank_BaseCount_Count_Get(self.handle)
	@Count.setter
	def Count(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_BaseCount_Count_Set(self.handle, value.handle)
		else:
			_poly.genbank_BaseCount_Count_Set(self.handle, value)

# Python type for struct genbank.Feature
class Feature(go.GoClass):
	"""Feature holds the information for a feature in a Genbank file and other annotated sequence files.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.genbank_Feature_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  1 < len(args):
				self.Description = args[1]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
			if  2 < len(args):
				self.Attributes = args[2]
			if "Attributes" in kwargs:
				self.Attributes = kwargs["Attributes"]
			if  3 < len(args):
				self.SequenceHash = args[3]
			if "SequenceHash" in kwargs:
				self.SequenceHash = kwargs["SequenceHash"]
			if  4 < len(args):
				self.SequenceHashFunction = args[4]
			if "SequenceHashFunction" in kwargs:
				self.SequenceHashFunction = kwargs["SequenceHashFunction"]
			if  5 < len(args):
				self.Sequence = args[5]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
			if  6 < len(args):
				self.Location = args[6]
			if "Location" in kwargs:
				self.Location = kwargs["Location"]
			if  7 < len(args):
				self.ParentSequence = args[7]
			if "ParentSequence" in kwargs:
				self.ParentSequence = kwargs["ParentSequence"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Feature{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Feature ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _poly.genbank_Feature_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_Type_Set(self.handle, value.handle)
		else:
			_poly.genbank_Feature_Type_Set(self.handle, value)
	@property
	def Description(self):
		return _poly.genbank_Feature_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_Description_Set(self.handle, value.handle)
		else:
			_poly.genbank_Feature_Description_Set(self.handle, value)
	@property
	def Attributes(self):
		return fastq.Map_string_string(handle=_poly.genbank_Feature_Attributes_Get(self.handle))
	@Attributes.setter
	def Attributes(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_Attributes_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SequenceHash(self):
		return _poly.genbank_Feature_SequenceHash_Get(self.handle)
	@SequenceHash.setter
	def SequenceHash(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_SequenceHash_Set(self.handle, value.handle)
		else:
			_poly.genbank_Feature_SequenceHash_Set(self.handle, value)
	@property
	def SequenceHashFunction(self):
		return _poly.genbank_Feature_SequenceHashFunction_Get(self.handle)
	@SequenceHashFunction.setter
	def SequenceHashFunction(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_SequenceHashFunction_Set(self.handle, value.handle)
		else:
			_poly.genbank_Feature_SequenceHashFunction_Set(self.handle, value)
	@property
	def Sequence(self):
		return _poly.genbank_Feature_Sequence_Get(self.handle)
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_Sequence_Set(self.handle, value.handle)
		else:
			_poly.genbank_Feature_Sequence_Set(self.handle, value)
	@property
	def Location(self):
		return Location(handle=_poly.genbank_Feature_Location_Get(self.handle))
	@Location.setter
	def Location(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_Location_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ParentSequence(self):
		return Genbank(handle=_poly.genbank_Feature_ParentSequence_Get(self.handle))
	@ParentSequence.setter
	def ParentSequence(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Feature_ParentSequence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetSequence(self):
		"""GetSequence() str, str
		
		GetSequence returns the sequence of a feature.
		"""
		return _poly.genbank_Feature_GetSequence(self.handle)

# Python type for struct genbank.Genbank
class Genbank(go.GoClass):
	"""Genbank is the main struct for the Genbank file format.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.genbank_Genbank_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Meta = args[0]
			if "Meta" in kwargs:
				self.Meta = kwargs["Meta"]
			if  1 < len(args):
				self.Features = args[1]
			if "Features" in kwargs:
				self.Features = kwargs["Features"]
			if  2 < len(args):
				self.Sequence = args[2]
			if "Sequence" in kwargs:
				self.Sequence = kwargs["Sequence"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Genbank{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Genbank ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Meta(self):
		return Meta(handle=_poly.genbank_Genbank_Meta_Get(self.handle))
	@Meta.setter
	def Meta(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Genbank_Meta_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Features(self):
		return Slice_genbank_Feature(handle=_poly.genbank_Genbank_Features_Get(self.handle))
	@Features.setter
	def Features(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Genbank_Features_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Sequence(self):
		return _poly.genbank_Genbank_Sequence_Get(self.handle)
	@Sequence.setter
	def Sequence(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Genbank_Sequence_Set(self.handle, value.handle)
		else:
			_poly.genbank_Genbank_Sequence_Set(self.handle, value)
	def AddFeature(self, feature):
		"""AddFeature(object feature) str
		
		AddFeature adds a feature to a Genbank struct.
		"""
		return _poly.genbank_Genbank_AddFeature(self.handle, feature.handle)

# Python type for struct genbank.Location
class Location(go.GoClass):
	"""Location is a struct that holds the location of a feature.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.genbank_Location_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Start = args[0]
			if "Start" in kwargs:
				self.Start = kwargs["Start"]
			if  1 < len(args):
				self.End = args[1]
			if "End" in kwargs:
				self.End = kwargs["End"]
			if  2 < len(args):
				self.Complement = args[2]
			if "Complement" in kwargs:
				self.Complement = kwargs["Complement"]
			if  3 < len(args):
				self.Join = args[3]
			if "Join" in kwargs:
				self.Join = kwargs["Join"]
			if  4 < len(args):
				self.FivePrimePartial = args[4]
			if "FivePrimePartial" in kwargs:
				self.FivePrimePartial = kwargs["FivePrimePartial"]
			if  5 < len(args):
				self.ThreePrimePartial = args[5]
			if "ThreePrimePartial" in kwargs:
				self.ThreePrimePartial = kwargs["ThreePrimePartial"]
			if  6 < len(args):
				self.GbkLocationString = args[6]
			if "GbkLocationString" in kwargs:
				self.GbkLocationString = kwargs["GbkLocationString"]
			if  7 < len(args):
				self.SubLocations = args[7]
			if "SubLocations" in kwargs:
				self.SubLocations = kwargs["SubLocations"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Location{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Location ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Start(self):
		return _poly.genbank_Location_Start_Get(self.handle)
	@Start.setter
	def Start(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_Start_Set(self.handle, value.handle)
		else:
			_poly.genbank_Location_Start_Set(self.handle, value)
	@property
	def End(self):
		return _poly.genbank_Location_End_Get(self.handle)
	@End.setter
	def End(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_End_Set(self.handle, value.handle)
		else:
			_poly.genbank_Location_End_Set(self.handle, value)
	@property
	def Complement(self):
		return _poly.genbank_Location_Complement_Get(self.handle)
	@Complement.setter
	def Complement(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_Complement_Set(self.handle, value.handle)
		else:
			_poly.genbank_Location_Complement_Set(self.handle, value)
	@property
	def Join(self):
		return _poly.genbank_Location_Join_Get(self.handle)
	@Join.setter
	def Join(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_Join_Set(self.handle, value.handle)
		else:
			_poly.genbank_Location_Join_Set(self.handle, value)
	@property
	def FivePrimePartial(self):
		return _poly.genbank_Location_FivePrimePartial_Get(self.handle)
	@FivePrimePartial.setter
	def FivePrimePartial(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_FivePrimePartial_Set(self.handle, value.handle)
		else:
			_poly.genbank_Location_FivePrimePartial_Set(self.handle, value)
	@property
	def ThreePrimePartial(self):
		return _poly.genbank_Location_ThreePrimePartial_Get(self.handle)
	@ThreePrimePartial.setter
	def ThreePrimePartial(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_ThreePrimePartial_Set(self.handle, value.handle)
		else:
			_poly.genbank_Location_ThreePrimePartial_Set(self.handle, value)
	@property
	def GbkLocationString(self):
		return _poly.genbank_Location_GbkLocationString_Get(self.handle)
	@GbkLocationString.setter
	def GbkLocationString(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_GbkLocationString_Set(self.handle, value.handle)
		else:
			_poly.genbank_Location_GbkLocationString_Set(self.handle, value)
	@property
	def SubLocations(self):
		return Slice_genbank_Location(handle=_poly.genbank_Location_SubLocations_Get(self.handle))
	@SubLocations.setter
	def SubLocations(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Location_SubLocations_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct genbank.Locus
class Locus(go.GoClass):
	"""Locus holds Locus information in a Meta struct.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_poly.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_poly.IncRef(self.handle)
		else:
			self.handle = _poly.genbank_Locus_CTor()
			_poly.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.SequenceLength = args[1]
			if "SequenceLength" in kwargs:
				self.SequenceLength = kwargs["SequenceLength"]
			if  2 < len(args):
				self.MoleculeType = args[2]
			if "MoleculeType" in kwargs:
				self.MoleculeType = kwargs["MoleculeType"]
			if  3 < len(args):
				self.GenbankDivision = args[3]
			if "GenbankDivision" in kwargs:
				self.GenbankDivision = kwargs["GenbankDivision"]
			if  4 < len(args):
				self.ModificationDate = args[4]
			if "ModificationDate" in kwargs:
				self.ModificationDate = kwargs["ModificationDate"]
			if  5 < len(args):
				self.SequenceCoding = args[5]
			if "SequenceCoding" in kwargs:
				self.SequenceCoding = kwargs["SequenceCoding"]
			if  6 < len(args):
				self.Circular = args[6]
			if "Circular" in kwargs:
				self.Circular = kwargs["Circular"]
	def __del__(self):
		_poly.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Locus{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'genbank.Locus ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _poly.genbank_Locus_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Locus_Name_Set(self.handle, value.handle)
		else:
			_poly.genbank_Locus_Name_Set(self.handle, value)
	@property
	def SequenceLength(self):
		return _poly.genbank_Locus_SequenceLength_Get(self.handle)
	@SequenceLength.setter
	def SequenceLength(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Locus_SequenceLength_Set(self.handle, value.handle)
		else:
			_poly.genbank_Locus_SequenceLength_Set(self.handle, value)
	@property
	def MoleculeType(self):
		return _poly.genbank_Locus_MoleculeType_Get(self.handle)
	@MoleculeType.setter
	def MoleculeType(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Locus_MoleculeType_Set(self.handle, value.handle)
		else:
			_poly.genbank_Locus_MoleculeType_Set(self.handle, value)
	@property
	def GenbankDivision(self):
		return _poly.genbank_Locus_GenbankDivision_Get(self.handle)
	@GenbankDivision.setter
	def GenbankDivision(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Locus_GenbankDivision_Set(self.handle, value.handle)
		else:
			_poly.genbank_Locus_GenbankDivision_Set(self.handle, value)
	@property
	def ModificationDate(self):
		return _poly.genbank_Locus_ModificationDate_Get(self.handle)
	@ModificationDate.setter
	def ModificationDate(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Locus_ModificationDate_Set(self.handle, value.handle)
		else:
			_poly.genbank_Locus_ModificationDate_Set(self.handle, value)
	@property
	def SequenceCoding(self):
		return _poly.genbank_Locus_SequenceCoding_Get(self.handle)
	@SequenceCoding.setter
	def SequenceCoding(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Locus_SequenceCoding_Set(self.handle, value.handle)
		else:
			_poly.genbank_Locus_SequenceCoding_Set(self.handle, value)
	@property
	def Circular(self):
		return _poly.genbank_Locus_Circular_Get(self.handle)
	@Circular.setter
	def Circular(self, value):
		if isinstance(value, go.GoClass):
			_poly.genbank_Locus_Circular_Set(self.handle, value.handle)
		else:
			_poly.genbank_Locus_Circular_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def Parse(r):
	"""Parse(object r) object, str
	
	Parse takes in a reader representing a single gbk/gb/genbank file and parses it into a Genbank struct.
	"""
	return Genbank(handle=_poly.genbank_Parse(r.handle))
def Read(path):
	"""Read(str path) object, str
	
	Read reads a GBK file from path and returns a Genbank struct.
	"""
	return Genbank(handle=_poly.genbank_Read(path))


# ---- Functions ---
def BuildFeatureString(feature):
	"""BuildFeatureString(object feature) str
	
	BuildFeatureString is a helper function to build gbk feature strings for Build()
	"""
	return _poly.genbank_BuildFeatureString(feature.handle)
def BuildLocationString(location):
	"""BuildLocationString(object location) str
	
	BuildLocationString is a recursive function that takes a location object and creates a gbk location string for Build()
	"""
	return _poly.genbank_BuildLocationString(location.handle)
def BuildMulti(sequences):
	"""BuildMulti([]object sequences) []int, str
	
	BuildMulti builds a MultiGBK byte slice to be written out to db or file.
	"""
	return go.Slice_byte(handle=_poly.genbank_BuildMulti(sequences.handle))
def ReadMultiNth(path, count):
	"""ReadMultiNth(str path, int count) []object, str"""
	return Slice_genbank_Genbank(handle=_poly.genbank_ReadMultiNth(path, count))
def Write(sequences, path):
	"""Write(object sequences, str path) str
	
	Write takes an Genbank list and a path string and writes out a genbank record to that path.
	"""
	return _poly.genbank_Write(sequences.handle, path)
def WriteMulti(sequences, path):
	"""WriteMulti([]object sequences, str path) str
	
	WriteMulti takes a slice of Genbank structs and a path string and writes out a multi genbank record to that path.
	"""
	return _poly.genbank_WriteMulti(sequences.handle, path)
def Build(gbk):
	"""Build(object gbk) []int, str
	
	Build builds a GBK byte slice to be written out to db or file.
	"""
	return go.Slice_byte(handle=_poly.genbank_Build(gbk.handle))
def ParseMulti(r):
	"""ParseMulti(object r) []object, str"""
	return Slice_genbank_Genbank(handle=_poly.genbank_ParseMulti(r.handle))
def ParseMultiNth(r, count):
	"""ParseMultiNth(object r, int count) []object, str"""
	return Slice_genbank_Genbank(handle=_poly.genbank_ParseMultiNth(r.handle, count))
def ReadMulti(path):
	"""ReadMulti(str path) []object, str"""
	return Slice_genbank_Genbank(handle=_poly.genbank_ReadMulti(path))


