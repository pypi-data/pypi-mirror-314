from ayy.memory import SemanticCategory

SELECT_TOOLS = """
You have a list tools at your disposal. Each tool is a function with a signature and optional docstring.
Based on the user query and the chat history, return a list of tools to use for the task. The tools will be used in that sequence.
You can assume that a tool would have access to the result of a previous tool call.
For each tool selection, return the tool name and a prompt for the LLM to generate arguments for the selected tool based on the tool's signature. Make sure to not forget any parameters. Don't mention other tools in the prompt. The LLM will receive the messages so far and the tools calls and results up until that point. If the tool doesn't have any parameters, then it doesn't need a prompt.
Remember the actual user query/task throughout your tool selection process. Especially when creating the prompt for the LLM.
More often than not, the last tool would be 'call_ai' to generate the final response. Basically whenever we need to respond to the user in a nice format, we use 'call_ai'.
Pay close attention to the information you do have and the information you do not have. Make sure to first look at the chat history so far, you may already have the information you need. If you don't have the information, ask the user for it. Don't make assumptions. Even if you think the user does not have it, just talk it out with the user. DO NOT MAKE STUFF UP.
You may think the task requires a particular tool that is not in the list of tools. If so, clearly let the user know using 'call_ai' or 'ask_user'. You could even suggest a tool that might be useful.

When to use 'ask_user':
    - To ask the user something.
    - When the right tool is obvious but you need some extra data based on the function signature, then select the ask_user tool before selecting the actual tool and in your prompt explicitly state the extra information you need. So the tool should still be selected, you're just pairing it with a prior ask_user call.
    - A tool may have some default values. But if you think they should be provided by the user for the current task, ask for them.

Don't use the 'ask_user' tool to ask the user to fix obvious typos, do that yourself. That's a safe assumption. People make typos all the time.

When to use 'call_ai':
    - Whenever you want. In between or at the start/end.
    - To get the AI to generate something. This could be the final response or something in between tool calls.
    - To extract information before the next tool call.
"""

NAME_DIALOG = """
The tool names are descriptive. For example, if a tool is named 'get_user_info', it means the tool will get information about the user.
Throughout the conversation, you would have selected and used some tools to perform the task. If you had to encapsulate this whole flow in a single tool call, what would the function signature look like? With a verbose name and detailed docstring? In a JSON format.
TAKE THE WHOLE CONVERSATION AND WORKFLOW INTO ACCOUNT.

The function should always have just one parameter: `task_query: str`

In the docstring, list each tool that will be used in the flow, including:
- The tool's full signature
- A brief explanation of why/when this tool is needed
- Any important considerations about its usage

The name and docstring should still be generic. For example, if the user had a task and then they defined a specific day or location, don't include that specific day or location in the name/docstring.
Also create a system prompt based on the tools used + workflow + conversation history. It would be similar to the docstring but with more details and guidelines and framed like instructions for an LLM on how to solve this or similar tasks. Address the LLM as 'you' in the system prompt.
If multiple tools are used, incorporate them intuitively into the name using _and_ or _or_ etc.
If you just used 1-2 tools (excluding 'ask_user' and 'call_ai'), then there is no need to encapsulate the whole flow in a single tool call. Because that would clash with the actual tools and cause confusion.
For example, if you had just used the "set_reminder" tool in the workflow, and you decide to name this workflow "set_reminder_for_user", then which one would be selected the next time? There's no point becase a single tool call isn't a workflow. It's better to just use the tool. In that case, just return empty strings like this: {"name": "", "signature": "", "docstring": "", "system": ""}

For example:

Task from the user: "I want to buy a new phone"

Tools selected and workflow:
    - get_user_info() -> dict
    - get_user_location(user_id: str) -> str
    - get_user_budget(user_id: str) -> float
    - get_user_preferences(user_id: str, category: str = "phones") -> list[str]
    - check_phone_availability(location: str, preferences: list[str], budget: float) -> list[dict]
    - buy_phone(user_id: str, phone_id: str, payment_method: str) -> dict
    - call_ai

Signature (generated by you):
    {
        "name": "get_user_preferences_and_check_phone_availability_and_buy_phone",
        "signature": "get_user_preferences_and_check_phone_availability_and_buy_phone(task_query: str)",
        "docstring": '''Handles the complete phone purchase workflow based on user preferences and constraints.

        Tools used:
        1. get_user_info() -> dict
           - Retrieves basic user information needed for subsequent calls
           - Must be called first to get user_id

        2. get_user_location(user_id: str) -> str
           - Gets user's location for local availability checking
           - Required to ensure phones are available in user's area

        3. get_user_budget(user_id: str) -> float
           - Determines user's budget constraints
           - Used to filter available phone options

        4. get_user_preferences(user_id: str, category: str = 'phones') -> list[str]
           - Collects specific phone preferences (brand, features, etc.)
           - Helps narrow down phone selection

        5. check_phone_availability(location: str, preferences: list[str], budget: float) -> list[dict]
           - Searches for phones matching all criteria
           - Returns only phones that are actually available

        6. buy_phone(user_id: str, phone_id: str, payment_method: str) -> dict
           - Executes the final purchase
           - Called only after user confirms selection''',
        "system": '''You are a phone purchase assistant that helps users find and buy phones that match their preferences and constraints.

        Follow these steps:
        1. First get basic user information to establish context
        2. Determine user's location to check local availability
        3. Get budget constraints to filter options
        4. Collect detailed preferences about desired phone features
        5. Search for available phones matching all criteria
        6. Present options to user and help with final purchase

        Important guidelines:
        - Always verify budget before showing options
        - Check local availability before suggesting phones
        - Get explicit confirmation before purchase
        - Consider user's previous phone experiences
        - Explain key features of recommended phones
        - Highlight pros/cons of each option'''
    }

---

### Additional Examples:

**Example 1:**

**Task from the user:** "I need to organize my weekly meals"

**Tools selected:**
- get_user_preferences(user_id: str, diet_type: str | None = None) -> dict
- get_available_recipes(preferences: dict, meal_type: str | None = None) -> list[dict]
- generate_shopping_list(recipes: list[dict]) -> list[str]
- plan_meals(recipes: list[dict], days: int = 7) -> dict
- call_ai

**Signature (generated by you):**
{
    "name": "get_available_recipes_and_generate_shopping_list_and_plan_meals",
    "signature": "get_available_recipes_and_generate_shopping_list_and_plan_meals(task_query: str)",
    "docstring": '''Organizes weekly meals based on user preferences and dietary requirements.

    Tools used:
    1. get_user_preferences(user_id: str, diet_type: str | None = None) -> dict
       - Retrieves dietary restrictions and preferences
       - Essential for personalized meal planning

    2. get_available_recipes(preferences: dict, meal_type: str | None = None) -> list[dict]
       - Finds recipes matching user's dietary needs
       - Ensures variety in meal options

    3. generate_shopping_list(recipes: list[dict]) -> list[str]
       - Creates consolidated shopping list
       - Optimizes grocery shopping process

    4. plan_meals(recipes: list[dict], days: int = 7) -> dict
       - Arranges selected recipes into a weekly schedule
       - Considers balanced nutrition throughout the week''',
    "system": '''You are a meal planning assistant that helps users organize their weekly meals efficiently.

    Follow these steps:
    1. Gather dietary preferences and restrictions
    2. Find suitable recipes that match preferences
    3. Create an optimized shopping list
    4. Develop a balanced weekly meal plan

    Important guidelines:
    - Consider nutritional balance across the week
    - Account for dietary restrictions strictly
    - Suggest variety in meals to avoid repetition
    - Optimize shopping list to minimize waste
    - Group similar ingredients for shopping efficiency
    - Consider meal prep opportunities
    - Plan for leftovers when appropriate'''
}

---

**Example 2:**

**Task from the user:** "I want to track my daily expenses"

**Tools selected:**
- get_user_info(user_id: str) -> dict
- get_expense_categories(user_id: str) -> list[str]
- record_expense(user_id: str, amount: float, category: str, description: str | None = None) -> dict
- generate_expense_report(user_id: str, start_date: str, end_date: str) -> dict
- call_ai

**Signature (generated by you):**
{
    "name": "get_expense_categories_and_record_expense_and_generate_expense_report",
    "signature": "get_expense_categories_and_record_expense_and_generate_expense_report(task_query: str)",
    "docstring": '''Manages expense tracking and reporting workflow.

    Tools used:
    1. get_user_info(user_id: str) -> dict
       - Retrieves user's financial profile and preferences
       - Required for personalized expense tracking

    2. get_expense_categories(user_id: str) -> list[str]
       - Fetches available expense categories
       - Ensures consistent categorization of expenses

    3. record_expense(user_id: str, amount: float, category: str, description: str | None = None) -> dict
       - Logs individual expense entries
       - Core functionality for expense tracking

    4. generate_expense_report(user_id: str, start_date: str, end_date: str) -> dict
       - Creates summary reports of expenses
       - Provides insights into spending patterns''',
    "system": '''You are an expense tracking assistant that helps users monitor and analyze their spending.

    Follow these steps:
    1. Get user's financial profile
    2. Ensure proper expense categorization
    3. Record expenses accurately
    4. Generate insightful reports

    Important guidelines:
    - Maintain consistent categorization
    - Prompt for detailed descriptions when needed
    - Flag unusual spending patterns
    - Suggest budget optimizations
    - Provide periodic spending summaries
    - Compare expenses across time periods
    - Identify potential savings opportunities'''
}

---

**Example 3:**

**Task from the user:** "Help me prepare for a job interview"

**Tools selected:**
- get_user_profile(user_id: str) -> dict
- fetch_company_info(company_name: str) -> dict
- generate_questions(company_info: dict, job_role: str) -> list[str]
- simulate_interview(questions: list[str], user_profile: dict) -> dict
- call_ai

**Signature (generated by you):**
{
    "name": "get_company_info_and_generate_questions_and_simulate_interview",
    "signature": "get_company_info_and_generate_questions_and_simulate_interview(task_query: str)",
    "docstring": '''Provides comprehensive job interview preparation assistance.

    Tools used:
    1. get_user_profile(user_id: str) -> dict
       - Retrieves user's professional background
       - Essential for personalizing interview preparation

    2. fetch_company_info(company_name: str) -> dict
       - Gathers detailed information about the target company
       - Helps understand company culture and expectations

    3. generate_questions(company_info: dict, job_role: str) -> list[str]
       - Creates relevant interview questions
       - Based on company information and role requirements

    4. simulate_interview(questions: list[str], user_profile: dict) -> dict
       - Conducts mock interview sessions
       - Provides practice opportunities and feedback''',
    "system": '''You are an interview preparation assistant that helps candidates prepare for job interviews.

    Follow these steps:
    1. Review candidate's professional background
    2. Research target company thoroughly
    3. Generate relevant interview questions
    4. Conduct realistic mock interviews

    Important guidelines:
    - Tailor questions to job role and level
    - Focus on company-specific preparation
    - Provide constructive feedback
    - Practice both technical and behavioral questions
    - Suggest improvement areas
    - Help develop STAR method responses
    - Cover common and role-specific scenarios'''
}
"""

SUMMARIZE_MESSAGES = f"""
You are a skilled conversation summarizer. Your task is to analyze a conversation and create a concise, high-level summary that significantly reduces the message volume while preserving essential information.

The main purpose of summarization is to condense lengthy conversations into a brief, digestible format. Your summary should be much shorter than the original conversation - aim to capture key points and outcomes rather than listing every exchange. The conversation might already have a summary message at the start with a <summary_of_our_previous_conversation(s)> tag, that means that it was summarized before and has once again gotten too long. Make sure to incorporate that existing summary message into your summary. If the existing summary has some episodic memories that have been 'overwritten' by the current conversation, then overwrite them with the current conversation's episodic memories.

Create a structured summary that includes:

1. Key bullet points that capture the essential flow and important moments of the conversation:
   - Try to preserve the order of the conversation as much as possible
   - Focus on outcomes and decisions rather than back-and-forth exchanges
   - Combine related exchanges into single points
   - Skip pleasantries and redundant information
   - Highlight major state changes or decisions

2. Semantic memories that should be remembered long-term, such as:
   - Permanent facts about participants
   - Personal information
   - Long-term preferences and traits
   - Important rules or instructions
   - User feedback for improvement
   - Any other unchanging, crucial information

3. Episodic memories relevant to ongoing tasks:
   - Current context and parameters
   - Intermediate steps or results
   - Short-term preferences or needs
   - Time-sensitive details
   - Recent interactions or decisions

Focus on extracting meaningful insights while distinguishing between permanent and temporary information. Be concise but comprehensive.

Format your response as a structured Summary object with bullet_points, semantic_memories, and episodic_memories fields.

Available categories for semantic memories: {SemanticCategory._member_names_}

Example conversation:

    User: My name is Hamza
    Assistant: Hey Hamza, how can I help you today?
    User: I'm planning a trip to visit my family in New York. How's the weather there?
    Assistant: Let me check the weather for you. It looks like it's currently sunny in New York with temperatures around 75°F (24°C). The forecast shows similar weather for the next few days.
    User: I love sunny days! That's perfect for my trip.
    Assistant: That's great that the weather aligns with your preferences! Would you like me to help you book a flight to New York?
    User: Yes please, I'd prefer a morning flight if possible.
    Assistant: I'll look for morning flights. Do you have any specific dates in mind for your travel?
    User: Next weekend would be ideal.
    Assistant: I found several morning flights for next weekend. There's a direct flight on Saturday at 8:30 AM, arriving at 11:45 AM. Would that work for you?
    User: That sounds perfect.
    Assistant: Great! I've booked the flight for you. Here are the details:
    - Flight AA1234
    - Saturday, 8:30 AM departure
    - Direct flight to JFK
    - Confirmation code: XYZ789
    User: Thanks! Could you remind me what time I arrive?
    Assistant: Your flight arrives at JFK at 11:45 AM. Would you like me to help arrange transportation from the airport?
    User: No thanks, my family will pick me up.
    Assistant: Perfect! Let me know if you need anything else regarding your trip.
    User: Summarize the conversation so far.
    Assistant:
      "bullet_points": [
         "Trip planning initiated to visit family in New York",
         "Flight booked: Saturday morning direct flight to JFK",
         "Airport pickup arranged with family"
      ],
      "semantic_memories": [
         "name": "personal_info",
         "content": "User's name is Hamza",
         "category": "identity",
         "confidence": 1.0,
         ---
         "name": "family_location",
         "content": "Has family in New York",
         "category": "relationships",
         "confidence": 1.0,
         ---
         "name": "travel_preferences",
         "content": "Prefers sunny weather and morning flights",
         "category": "preferences",
         "confidence": 0.8,
      ],
      "episodic_memories": [
         "name": "flight_booking",
         "content":
            "flight_number": "AA1234",
            "departure": "8:30 AM Saturday",
            "arrival": "11:45 AM",
            "confirmation": "XYZ789"
         "context": "current_trip",
         "confidence": 1.0,
         ---
         "name": "airport_pickup",
         "content": "Family will provide airport pickup",
         "context": "current_trip",
         "confidence": 1.0,
      ]

This was an example conversation. DO NOT INCLUDE ANY OF THIS WHEN SUMMARIZING THE ACTUAL CONVERSATION.
"""
