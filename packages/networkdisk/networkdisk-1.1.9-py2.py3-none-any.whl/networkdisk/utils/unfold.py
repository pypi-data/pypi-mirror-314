from networkdisk.utils.filtering import BooleanFunctions as BF


def unfold(
    s,
    key_prefix=(),
    up_to=None,
    dictlike=False,
    value_filter=BF.ALL,
    ununfoldable_filter=BF.ALL,
    empty_filter=BF.ALL,
    internal_filter=BF.ALL,
):
    """
    Unfold a dict-like object, by yielding tuples. If `keys` is a
    method of the positional and mandatory argument `s`, then, for
    each key `pk` of `s`, and each tuple `sk` generated by the
    unfolding of the value `s[pk]`, the tuple `(pk,)+sk` is
    yielded. This is achieved by recursively calling the function
    on `s[pk]`. Otherwise, `s` is considered as ununfoldable, and
    it is yielded.

    By default, the unfolding is maximal, namely, the yields are
    tuples in which the last component cannot be unfolded anymore.
    However, the length of these tuple can be bounded thanks to
    the optional keyworded argument `up_to`.

    It is also possible to filter the yielded tuple components to
    appear, possibly cutting off some branches of the unfolding.
    Four optional keyworded arguments which are expected to be
    Boolean function (see, e.g., `networkdisk.utils.filtering`),
    allow a thin filtering control:
    +	`value_filter`: filters the elements encountred at maximal
            depth (namely, the last tuple component, when `up_to` bounds
            the yielded tuple length);
    + `ununfoldable_filter`: filters the elements that are
            encountred at less deep point than the bound specified by
            `up_to`, which happen to be ununfoldable (namely, they
            provide no `keys` method);
    + `empty_filter`: filters the internal unfoldable elements
            which happen to be empty (i.e., no key is yielded when
            calling their `keys` method returns);
    + `internal_filter`: filters all internal elements (namely,
            those which do not occur at maximal depth), including the
            ununfoldable ones and the empty ones. This could be used to
            cut off some branches.
    By default, each filtering function are the constant function
    mapping any element to `True`, thus none element is dropped.

    Additionally, all yields are prefixed by the `key_prefix`
    tuple, which can be specified using the keyworded optional
    argument `key_prefix` (default is the empty tuple). Notice
    that the `up_to` does not count the prefix length when
    bounding the length of the yields.

    Finally, the `dictlike` Boolean optional argument, allows to
    consider as unfoldable any object which are iterables of pairs
    like it is performed in the standard `dict.update` method. The
    default value is `False`. The function raises the `ValueError`
    exception when, with `dictlike` set to `True`, `s` does not
    provide the `keys` method, but is an iterable whose first item
    is pair-like unpackable (i.e., `a, b = next(iter(s))` does not
    raise any exception), but also have non-pair-unpackable items.
    Indeed, in this case, based on the first item, it is assumed
    to be an iterable of pairs, and the function starts to unfold
    it. However, when reaching the non-pair-unpackable item, the
    function cannot reverse its assumption as some tuples already
    have been yielded. The exception obtained when unpacking that
    wrong item, is raised and not catch.

    When `s` does not match its specific filter(s), the empty
    tuple is yielded, so that it can be appended to a unfolded key
    prefix.
    """
    if up_to == 0:
        # deepest
        yield key_prefix + (s,) if value_filter(s) else key_prefix
    elif internal_filter(s):
        if hasattr(s, "keys"):
            # unfoldable
            nokeyflag = True
            for pk in s.keys():
                yield from unfold(
                    s[pk],
                    key_prefix=key_prefix + (pk,),
                    up_to=None if up_to is None else up_to - 1,
                    value_filter=value_filter,
                    ununfoldable_filter=ununfoldable_filter,
                    empty_filter=empty_filter,
                    internal_filter=internal_filter,
                )
                nokeyflag = False
            if nokeyflag:
                # empty
                yield key_prefix + (s,) if empty_filter(s) else key_prefix
        elif dictlike:
            try:
                nokeyflag = True
                res = iter(s)
                for pkv in res:
                    try:
                        pk, v = pkv
                    except (TypeError, ValueError):
                        # unpackables or wrong unpacking arity
                        if nokeyflag:
                            raise
                        break
                    yield from unfold(
                        v,
                        key_prefix=key_prefix + (pk,),
                        up_to=None if up_to is None else up_to - 1,
                        value_filter=value_filter,
                        ununfoldable_filter=ununfoldable_filter,
                        empty_filter=empty_filter,
                        internal_filter=internal_filter,
                    )
                    nokeyflag = False
                if nokeyflag:
                    # empty
                    yield key_prefix + (s,) if empty_filter(s) else key_prefix
            except TypeError as e:
                if e.args[0].endswith(" object is not iterable"):
                    yield key_prefix + (s,)
                else:
                    raise e
        else:
            # ununfoldable
            yield key_prefix + (s,) if ununfoldable_filter(s) else key_prefix
    else:
        # dropped
        yield key_prefix
