import ctypes
import threading
from _typeshed import Incomplete
from dataclasses import dataclass

logger: Incomplete

def init_class_by_name(module_name, class_name, *args, **kwargs): ...

class ExitEvent(threading.Event):
    queues: Incomplete
    to_stops: Incomplete
    def bind_queue(self, queue) -> None: ...
    def bind_stop(self, to_stop) -> None: ...
    def set(self) -> None: ...

@dataclass(order=True)
class ScheduledTask:
    execute_at: float
    task: callable = ...
    def __init__(self, execute_at, task) -> None: ...

class Handler:
    task_queue: Incomplete
    executing: Incomplete
    condition: Incomplete
    exit_event: Incomplete
    thread: Incomplete
    def __init__(self, event: ExitEvent, name: Incomplete | None = None) -> None: ...
    def post(self, task, delay: int = 0, remove_existing: bool = False, skip_if_running: bool = False): ...
    def stop(self) -> None: ...

def read_json_file(file_path) -> dict | None: ...
def write_json_file(file_path, data): ...
def is_admin(): ...
def get_first_item(lst, default: Incomplete | None = None): ...
def safe_get(lst, idx, default: Incomplete | None = None): ...
def find_index_in_list(my_list, target_string, default_index: int = -1): ...
def get_path_relative_to_exe(*files): ...
def get_relative_path(*files): ...
def install_path_isascii(): ...
def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
def ensure_dir_for_file(file_path): ...
def ensure_dir(directory, clear: bool = False): ...
def delete_if_exists(file_path) -> None: ...
def delete_folders_starts_with(path, starts_with) -> None: ...
def handle_remove_error(func, path, exc_info) -> None: ...
def sanitize_filename(filename): ...
def clear_folder(folder_path) -> None: ...
def find_first_existing_file(filenames, directory): ...
def get_path_in_package(base, file): ...
def dir_checksum(directory, excludes: Incomplete | None = None): ...
def find_folder_with_file(root_folder, target_file): ...
def get_folder_size(folder_path): ...
def run_in_new_thread(func): ...

ERROR_ALREADY_EXISTS: int
LPSECURITY_ATTRIBUTES: Incomplete
BOOL = ctypes.c_int
DWORD = ctypes.c_ulong
HANDLE = ctypes.c_void_p
CreateMutex: Incomplete
GetLastError: Incomplete

def check_mutex(): ...
def all_pids() -> list[int]: ...

NtQuerySystemInformation: Incomplete
SystemProcessIdInformation: int

class UNICODE_STRING(ctypes.Structure):
    @classmethod
    def create(cls, init_with: str | int): ...

class SYSTEM_PROCESS_ID_INFORMATION(ctypes.Structure): ...

def resolve_image_name(pid: int):
    """Resolves the image name of a process, in NT device path (\\Device\\HarddiskVolumeX\\...) format."""

GetFinalPathNameByHandleW: Incomplete

def get_final_path(path) -> str: ...
def ratio_text_to_number(supported_ratio): ...
def data_to_base64(data) -> str:
    """
    Serialize a dictionary or a list of dictionaries to a base64 encoded string.

    Args:
        data (Union[Dict, List[Dict]]): The data to serialize.

    Returns:
        str: The base64 encoded string.
    """
def base64_to_data(base64_str: str) -> dict | list[dict]:
    """
    Deserialize a base64 encoded string back to a dictionary or a list of dictionaries.

    Args:
        base64_str (str): The base64 encoded string.

    Returns:
        Union[Dict, List[Dict]]: The deserialized data.
    """
def get_readable_file_size(file_path):
    '''Calculates the readable size of a file.

    Args:
        file_path (str): The path to the file.

    Returns:
        str: The readable file size (e.g., "1.23 MB").
    '''
def bytes_to_readable_size(size_bytes):
    """Converts bytes to a human-readable size.

    Args:
        size_bytes (int): The size in bytes.

    Returns:
        str: The human-readable size.
    """
