"""A web3.py Contract class for the LeakyLido contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from .LeakyLidoTypes import (
    ApprovalEvent,
    AuthorityUpdatedEvent,
    OwnershipTransferredEvent,
    PublicCapabilityUpdatedEvent,
    RoleCapabilityUpdatedEvent,
    TargetCustomAuthorityUpdatedEvent,
    TransferEvent,
    TransferSharesEvent,
    UserRoleUpdatedEvent,
)

structs = {}

leakylido_abi: ABI = cast(
    ABI,
    [
        {"type": "constructor", "inputs": [], "stateMutability": "nonpayable"},
        {
            "type": "function",
            "name": "allowance",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "approve",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "authority",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "balanceOf",
            "inputs": [
                {"name": "_owner", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {"name": "amount", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "burn",
            "inputs": [
                {
                    "name": "_target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "canCall",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "decimals",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint8", "internalType": "uint8"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "doesRoleHaveCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "doesUserHaveRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBufferedEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getPooledEthByShares",
            "inputs": [
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRate",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getRolesWithCapability",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getSharesByPooledEth",
            "inputs": [
                {
                    "name": "_ethAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTargetCustomAuthority",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalPooledEther",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getTotalShares",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserRoles",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCapabilityPublic",
            "inputs": [
                {"name": "", "type": "bytes4", "internalType": "bytes4"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCompetitionMode",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isUnrestricted",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "leakyTransferFrom",
            "inputs": [
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "maxMintAmount",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "owner",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setAuthority",
            "inputs": [
                {
                    "name": "newAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setMaxMintAmount",
            "inputs": [
                {
                    "name": "_maxMintAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPublicCapability",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRate",
            "inputs": [
                {"name": "_rate_", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setRoleCapability",
            "inputs": [
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "internalType": "bytes4",
                },
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setTargetCustomAuthority",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "customAuthority",
                    "type": "address",
                    "internalType": "contract Authority",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUnrestrictedMintStatus",
            "inputs": [
                {
                    "name": "_target",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "_status", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserRole",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {"name": "role", "type": "uint8", "internalType": "uint8"},
                {"name": "enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sharesOf",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "submit",
            "inputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "symbol",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalSupply",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "transfer",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferFrom",
            "inputs": [
                {
                    "name": "_sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferOwnership",
            "inputs": [
                {
                    "name": "newOwner",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferShares",
            "inputs": [
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferSharesFrom",
            "inputs": [
                {
                    "name": "_sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_recipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_sharesAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "Approval",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "spender",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "value",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "AuthorityUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newAuthority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OwnershipTransferred",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "newOwner",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "PublicCapabilityUpdated",
            "inputs": [
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RoleCapabilityUpdated",
            "inputs": [
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "functionSig",
                    "type": "bytes4",
                    "indexed": True,
                    "internalType": "bytes4",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TargetCustomAuthorityUpdated",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "authority",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract Authority",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Transfer",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "value",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "TransferShares",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "sharesValue",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserRoleUpdated",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "role",
                    "type": "uint8",
                    "indexed": True,
                    "internalType": "uint8",
                },
                {
                    "name": "enabled",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "error",
            "name": "ERC20InsufficientAllowance",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "allowance",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "needed",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
        },
        {
            "type": "error",
            "name": "ERC20InsufficientBalance",
            "inputs": [
                {
                    "name": "sender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "balance",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "needed",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidApprover",
            "inputs": [
                {
                    "name": "approver",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidReceiver",
            "inputs": [
                {
                    "name": "receiver",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidSender",
            "inputs": [
                {"name": "sender", "type": "address", "internalType": "address"}
            ],
        },
        {
            "type": "error",
            "name": "ERC20InvalidSpender",
            "inputs": [
                {
                    "name": "spender",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
    ],
)


class LeakyLidoERC20InsufficientAllowanceContractError(PypechainBaseError):
    """ContractError for ERC20InsufficientAllowance."""

    # Error name
    name: str = "ERC20InsufficientAllowance"
    # 4 byte error selector
    selector: str = "0xfb8f41b2"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InsufficientAllowance(address,uint256,uint256)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InsufficientBalanceContractError(PypechainBaseError):
    """ContractError for ERC20InsufficientBalance."""

    # Error name
    name: str = "ERC20InsufficientBalance"
    # 4 byte error selector
    selector: str = "0xe450d38c"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InsufficientBalance(address,uint256,uint256)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidApproverContractError(PypechainBaseError):
    """ContractError for ERC20InvalidApprover."""

    # Error name
    name: str = "ERC20InvalidApprover"
    # 4 byte error selector
    selector: str = "0xe602df05"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidApprover(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidReceiverContractError(PypechainBaseError):
    """ContractError for ERC20InvalidReceiver."""

    # Error name
    name: str = "ERC20InvalidReceiver"
    # 4 byte error selector
    selector: str = "0xec442f05"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidReceiver(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidSenderContractError(PypechainBaseError):
    """ContractError for ERC20InvalidSender."""

    # Error name
    name: str = "ERC20InvalidSender"
    # 4 byte error selector
    selector: str = "0x96c6fd1e"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidSender(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoERC20InvalidSpenderContractError(PypechainBaseError):
    """ContractError for ERC20InvalidSpender."""

    # Error name
    name: str = "ERC20InvalidSpender"
    # 4 byte error selector
    selector: str = "0x94280d62"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ERC20InvalidSpender(address)"
    # Error input types
    abi: ABI = leakylido_abi


class LeakyLidoContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the LeakyLido contract."""

    ERC20InsufficientAllowance: LeakyLidoERC20InsufficientAllowanceContractError

    ERC20InsufficientBalance: LeakyLidoERC20InsufficientBalanceContractError

    ERC20InvalidApprover: LeakyLidoERC20InvalidApproverContractError

    ERC20InvalidReceiver: LeakyLidoERC20InvalidReceiverContractError

    ERC20InvalidSender: LeakyLidoERC20InvalidSenderContractError

    ERC20InvalidSpender: LeakyLidoERC20InvalidSpenderContractError

    def __init__(
        self,
    ) -> None:
        self.ERC20InsufficientAllowance = (
            LeakyLidoERC20InsufficientAllowanceContractError()
        )
        self.ERC20InsufficientBalance = (
            LeakyLidoERC20InsufficientBalanceContractError()
        )
        self.ERC20InvalidApprover = LeakyLidoERC20InvalidApproverContractError()
        self.ERC20InvalidReceiver = LeakyLidoERC20InvalidReceiverContractError()
        self.ERC20InvalidSender = LeakyLidoERC20InvalidSenderContractError()
        self.ERC20InvalidSpender = LeakyLidoERC20InvalidSpenderContractError()

        self._all = [
            self.ERC20InsufficientAllowance,
            self.ERC20InsufficientBalance,
            self.ERC20InvalidApprover,
            self.ERC20InvalidReceiver,
            self.ERC20InvalidSender,
            self.ERC20InvalidSpender,
        ]


class LeakyLidoAllowanceContractFunction0(PypechainContractFunction):
    """ContractFunction for the allowance(str,str) method."""

    _function_name = "allowance"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoAllowanceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the allowance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "allowance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, spender: str) -> LeakyLidoAllowanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoAllowanceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoAllowanceContractFunction0._type_signature: LeakyLidoAllowanceContractFunction0,
        }
        return out


class LeakyLidoApproveContractFunction0(PypechainContractFunction):
    """ContractFunction for the approve(str,int) method."""

    _function_name = "approve"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoApproveContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the approve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "approve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, spender: str, value: int) -> LeakyLidoApproveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoApproveContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoApproveContractFunction0._type_signature: LeakyLidoApproveContractFunction0,
        }
        return out


class LeakyLidoAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the authority() method."""

    _function_name = "authority"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoAuthorityContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the authority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "authority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoAuthorityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoAuthorityContractFunction0._type_signature: LeakyLidoAuthorityContractFunction0,
        }
        return out


class LeakyLidoBalanceOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the balanceOf(str) method."""

    _function_name = "balanceOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoBalanceOfContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the balanceOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "balanceOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _owner: str) -> LeakyLidoBalanceOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoBalanceOfContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoBalanceOfContractFunction0._type_signature: LeakyLidoBalanceOfContractFunction0,
        }
        return out


class LeakyLidoBurnContractFunction0(PypechainContractFunction):
    """ContractFunction for the burn(int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoBurnContractFunction1(PypechainContractFunction):
    """ContractFunction for the burn(str,int) method."""

    _function_name = "burn"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoBurnContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the burn method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "burn"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, amount: int) -> LeakyLidoBurnContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, _target: str, _amount: int) -> LeakyLidoBurnContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoBurnContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoBurnContractFunction0._type_signature: LeakyLidoBurnContractFunction0,
            LeakyLidoBurnContractFunction1._type_signature: LeakyLidoBurnContractFunction1,
        }
        return out


class LeakyLidoCanCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the canCall(str,str,bytes) method."""

    _function_name = "canCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoCanCallContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the canCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "canCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, target: str, functionSig: bytes) -> LeakyLidoCanCallContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoCanCallContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoCanCallContractFunction0._type_signature: LeakyLidoCanCallContractFunction0,
        }
        return out


class LeakyLidoDecimalsContractFunction0(PypechainContractFunction):
    """ContractFunction for the decimals() method."""

    _function_name = "decimals"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoDecimalsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the decimals method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "decimals"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoDecimalsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoDecimalsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoDecimalsContractFunction0._type_signature: LeakyLidoDecimalsContractFunction0,
        }
        return out


class LeakyLidoDoesRoleHaveCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the doesRoleHaveCapability(int,bytes) method."""

    _function_name = "doesRoleHaveCapability"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoDoesRoleHaveCapabilityContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the doesRoleHaveCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesRoleHaveCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes) -> LeakyLidoDoesRoleHaveCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoDoesRoleHaveCapabilityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoDoesRoleHaveCapabilityContractFunction0._type_signature: LeakyLidoDoesRoleHaveCapabilityContractFunction0,
        }
        return out


class LeakyLidoDoesUserHaveRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the doesUserHaveRole(str,int) method."""

    _function_name = "doesUserHaveRole"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoDoesUserHaveRoleContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the doesUserHaveRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "doesUserHaveRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int) -> LeakyLidoDoesUserHaveRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoDoesUserHaveRoleContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoDoesUserHaveRoleContractFunction0._type_signature: LeakyLidoDoesUserHaveRoleContractFunction0,
        }
        return out


class LeakyLidoGetBufferedEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBufferedEther() method."""

    _function_name = "getBufferedEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetBufferedEtherContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBufferedEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBufferedEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetBufferedEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetBufferedEtherContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetBufferedEtherContractFunction0._type_signature: LeakyLidoGetBufferedEtherContractFunction0,
        }
        return out


class LeakyLidoGetPooledEthBySharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getPooledEthByShares(int) method."""

    _function_name = "getPooledEthByShares"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetPooledEthBySharesContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getPooledEthByShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getPooledEthByShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sharesAmount: int) -> LeakyLidoGetPooledEthBySharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetPooledEthBySharesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetPooledEthBySharesContractFunction0._type_signature: LeakyLidoGetPooledEthBySharesContractFunction0,
        }
        return out


class LeakyLidoGetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the getRate() method."""

    _function_name = "getRate"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetRateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetRateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetRateContractFunction0._type_signature: LeakyLidoGetRateContractFunction0,
        }
        return out


class LeakyLidoGetRolesWithCapabilityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getRolesWithCapability(bytes) method."""

    _function_name = "getRolesWithCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetRolesWithCapabilityContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getRolesWithCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRolesWithCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> LeakyLidoGetRolesWithCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetRolesWithCapabilityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetRolesWithCapabilityContractFunction0._type_signature: LeakyLidoGetRolesWithCapabilityContractFunction0,
        }
        return out


class LeakyLidoGetSharesByPooledEthContractFunction0(PypechainContractFunction):
    """ContractFunction for the getSharesByPooledEth(int) method."""

    _function_name = "getSharesByPooledEth"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetSharesByPooledEthContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getSharesByPooledEth method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getSharesByPooledEth"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _ethAmount: int) -> LeakyLidoGetSharesByPooledEthContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetSharesByPooledEthContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetSharesByPooledEthContractFunction0._type_signature: LeakyLidoGetSharesByPooledEthContractFunction0,
        }
        return out


class LeakyLidoGetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getTargetCustomAuthority(str) method."""

    _function_name = "getTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetTargetCustomAuthorityContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoGetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetTargetCustomAuthorityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetTargetCustomAuthorityContractFunction0._type_signature: LeakyLidoGetTargetCustomAuthorityContractFunction0,
        }
        return out


class LeakyLidoGetTotalPooledEtherContractFunction0(PypechainContractFunction):
    """ContractFunction for the getTotalPooledEther() method."""

    _function_name = "getTotalPooledEther"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetTotalPooledEtherContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getTotalPooledEther method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalPooledEther"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetTotalPooledEtherContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetTotalPooledEtherContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetTotalPooledEtherContractFunction0._type_signature: LeakyLidoGetTotalPooledEtherContractFunction0,
        }
        return out


class LeakyLidoGetTotalSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getTotalShares() method."""

    _function_name = "getTotalShares"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetTotalSharesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getTotalShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getTotalShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoGetTotalSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetTotalSharesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetTotalSharesContractFunction0._type_signature: LeakyLidoGetTotalSharesContractFunction0,
        }
        return out


class LeakyLidoGetUserRolesContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserRoles(str) method."""

    _function_name = "getUserRoles"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoGetUserRolesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getUserRoles method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserRoles"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoGetUserRolesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoGetUserRolesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoGetUserRolesContractFunction0._type_signature: LeakyLidoGetUserRolesContractFunction0,
        }
        return out


class LeakyLidoIsCapabilityPublicContractFunction0(PypechainContractFunction):
    """ContractFunction for the isCapabilityPublic(bytes) method."""

    _function_name = "isCapabilityPublic"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoIsCapabilityPublicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isCapabilityPublic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCapabilityPublic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> LeakyLidoIsCapabilityPublicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoIsCapabilityPublicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoIsCapabilityPublicContractFunction0._type_signature: LeakyLidoIsCapabilityPublicContractFunction0,
        }
        return out


class LeakyLidoIsCompetitionModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the isCompetitionMode() method."""

    _function_name = "isCompetitionMode"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoIsCompetitionModeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isCompetitionMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCompetitionMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoIsCompetitionModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoIsCompetitionModeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoIsCompetitionModeContractFunction0._type_signature: LeakyLidoIsCompetitionModeContractFunction0,
        }
        return out


class LeakyLidoIsUnrestrictedContractFunction0(PypechainContractFunction):
    """ContractFunction for the isUnrestricted(str) method."""

    _function_name = "isUnrestricted"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoIsUnrestrictedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isUnrestricted method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isUnrestricted"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoIsUnrestrictedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoIsUnrestrictedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoIsUnrestrictedContractFunction0._type_signature: LeakyLidoIsUnrestrictedContractFunction0,
        }
        return out


class LeakyLidoLeakyTransferFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the leakyTransferFrom(str,str,int) method."""

    _function_name = "leakyTransferFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoLeakyTransferFromContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the leakyTransferFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "leakyTransferFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _from: str, to: str, amount: int) -> LeakyLidoLeakyTransferFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoLeakyTransferFromContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoLeakyTransferFromContractFunction0._type_signature: LeakyLidoLeakyTransferFromContractFunction0,
        }
        return out


class LeakyLidoMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxMintAmount() method."""

    _function_name = "maxMintAmount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoMaxMintAmountContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the maxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoMaxMintAmountContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoMaxMintAmountContractFunction0._type_signature: LeakyLidoMaxMintAmountContractFunction0,
        }
        return out


class LeakyLidoMintContractFunction0(PypechainContractFunction):
    """ContractFunction for the mint(str,int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoMintContractFunction1(PypechainContractFunction):
    """ContractFunction for the mint(int) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoMintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _amount: int) -> LeakyLidoMintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, _amount: int) -> LeakyLidoMintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoMintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoMintContractFunction0._type_signature: LeakyLidoMintContractFunction0,
            LeakyLidoMintContractFunction1._type_signature: LeakyLidoMintContractFunction1,
        }
        return out


class LeakyLidoNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoNameContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoNameContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoNameContractFunction0._type_signature: LeakyLidoNameContractFunction0,
        }
        return out


class LeakyLidoOwnerContractFunction0(PypechainContractFunction):
    """ContractFunction for the owner() method."""

    _function_name = "owner"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoOwnerContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the owner method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "owner"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoOwnerContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoOwnerContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoOwnerContractFunction0._type_signature: LeakyLidoOwnerContractFunction0,
        }
        return out


class LeakyLidoSetAuthorityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setAuthority(str) method."""

    _function_name = "setAuthority"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetAuthorityContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newAuthority: str) -> LeakyLidoSetAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetAuthorityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetAuthorityContractFunction0._type_signature: LeakyLidoSetAuthorityContractFunction0,
        }
        return out


class LeakyLidoSetMaxMintAmountContractFunction0(PypechainContractFunction):
    """ContractFunction for the setMaxMintAmount(int) method."""

    _function_name = "setMaxMintAmount"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetMaxMintAmountContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setMaxMintAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setMaxMintAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _maxMintAmount: int) -> LeakyLidoSetMaxMintAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetMaxMintAmountContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetMaxMintAmountContractFunction0._type_signature: LeakyLidoSetMaxMintAmountContractFunction0,
        }
        return out


class LeakyLidoSetPublicCapabilityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setPublicCapability(bytes,bool) method."""

    _function_name = "setPublicCapability"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bool"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetPublicCapabilityContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setPublicCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setPublicCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, functionSig: bytes, enabled: bool) -> LeakyLidoSetPublicCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetPublicCapabilityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetPublicCapabilityContractFunction0._type_signature: LeakyLidoSetPublicCapabilityContractFunction0,
        }
        return out


class LeakyLidoSetRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the setRate(int) method."""

    _function_name = "setRate"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetRateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _rate_: int) -> LeakyLidoSetRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetRateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetRateContractFunction0._type_signature: LeakyLidoSetRateContractFunction0,
        }
        return out


class LeakyLidoSetRoleCapabilityContractFunction0(PypechainContractFunction):
    """ContractFunction for the setRoleCapability(int,bytes,bool) method."""

    _function_name = "setRoleCapability"
    _type_signature = expand_struct_type_str(
        tuple(["int", "bytes", "bool"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetRoleCapabilityContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setRoleCapability method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setRoleCapability"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, role: int, functionSig: bytes, enabled: bool) -> LeakyLidoSetRoleCapabilityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetRoleCapabilityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetRoleCapabilityContractFunction0._type_signature: LeakyLidoSetRoleCapabilityContractFunction0,
        }
        return out


class LeakyLidoSetTargetCustomAuthorityContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setTargetCustomAuthority(str,str) method."""

    _function_name = "setTargetCustomAuthority"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetTargetCustomAuthorityContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setTargetCustomAuthority method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setTargetCustomAuthority"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, customAuthority: str) -> LeakyLidoSetTargetCustomAuthorityContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetTargetCustomAuthorityContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetTargetCustomAuthorityContractFunction0._type_signature: LeakyLidoSetTargetCustomAuthorityContractFunction0,
        }
        return out


class LeakyLidoSetUnrestrictedMintStatusContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUnrestrictedMintStatus(str,bool) method."""

    _function_name = "setUnrestrictedMintStatus"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetUnrestrictedMintStatusContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setUnrestrictedMintStatus method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUnrestrictedMintStatus"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _target: str, _status: bool) -> LeakyLidoSetUnrestrictedMintStatusContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetUnrestrictedMintStatusContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetUnrestrictedMintStatusContractFunction0._type_signature: LeakyLidoSetUnrestrictedMintStatusContractFunction0,
        }
        return out


class LeakyLidoSetUserRoleContractFunction0(PypechainContractFunction):
    """ContractFunction for the setUserRole(str,int,bool) method."""

    _function_name = "setUserRole"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bool"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoSetUserRoleContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setUserRole method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserRole"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str, role: int, enabled: bool) -> LeakyLidoSetUserRoleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSetUserRoleContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSetUserRoleContractFunction0._type_signature: LeakyLidoSetUserRoleContractFunction0,
        }
        return out


class LeakyLidoSharesOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the sharesOf(str) method."""

    _function_name = "sharesOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoSharesOfContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the sharesOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sharesOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoSharesOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSharesOfContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSharesOfContractFunction0._type_signature: LeakyLidoSharesOfContractFunction0,
        }
        return out


class LeakyLidoSubmitContractFunction0(PypechainContractFunction):
    """ContractFunction for the submit(str) method."""

    _function_name = "submit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoSubmitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the submit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "submit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> LeakyLidoSubmitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSubmitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSubmitContractFunction0._type_signature: LeakyLidoSubmitContractFunction0,
        }
        return out


class LeakyLidoSymbolContractFunction0(PypechainContractFunction):
    """ContractFunction for the symbol() method."""

    _function_name = "symbol"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoSymbolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the symbol method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "symbol"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoSymbolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoSymbolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoSymbolContractFunction0._type_signature: LeakyLidoSymbolContractFunction0,
        }
        return out


class LeakyLidoTotalSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalSupply() method."""

    _function_name = "totalSupply"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTotalSupplyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the totalSupply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalSupply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> LeakyLidoTotalSupplyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTotalSupplyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoTotalSupplyContractFunction0._type_signature: LeakyLidoTotalSupplyContractFunction0,
        }
        return out


class LeakyLidoTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the transfer(str,int) method."""

    _function_name = "transfer"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _amount: int) -> LeakyLidoTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoTransferContractFunction0._type_signature: LeakyLidoTransferContractFunction0,
        }
        return out


class LeakyLidoTransferFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferFrom(str,str,int) method."""

    _function_name = "transferFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferFromContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transferFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str, _recipient: str, _amount: int) -> LeakyLidoTransferFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferFromContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoTransferFromContractFunction0._type_signature: LeakyLidoTransferFromContractFunction0,
        }
        return out


class LeakyLidoTransferOwnershipContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferOwnership(str) method."""

    _function_name = "transferOwnership"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class LeakyLidoTransferOwnershipContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transferOwnership method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferOwnership"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newOwner: str) -> LeakyLidoTransferOwnershipContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferOwnershipContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoTransferOwnershipContractFunction0._type_signature: LeakyLidoTransferOwnershipContractFunction0,
        }
        return out


class LeakyLidoTransferSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferShares(str,int) method."""

    _function_name = "transferShares"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferSharesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transferShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _recipient: str, _sharesAmount: int) -> LeakyLidoTransferSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferSharesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoTransferSharesContractFunction0._type_signature: LeakyLidoTransferSharesContractFunction0,
        }
        return out


class LeakyLidoTransferSharesFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferSharesFrom(str,str,int) method."""

    _function_name = "transferSharesFrom"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = LeakyLidoContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class LeakyLidoTransferSharesFromContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transferSharesFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferSharesFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str, _recipient: str, _sharesAmount: int) -> LeakyLidoTransferSharesFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> LeakyLidoTransferSharesFromContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            LeakyLidoTransferSharesFromContractFunction0._type_signature: LeakyLidoTransferSharesFromContractFunction0,
        }
        return out


class LeakyLidoContractFunctions(ContractFunctions):
    """ContractFunctions for the LeakyLido contract."""

    allowance: LeakyLidoAllowanceContractFunction

    approve: LeakyLidoApproveContractFunction

    authority: LeakyLidoAuthorityContractFunction

    balanceOf: LeakyLidoBalanceOfContractFunction

    burn: LeakyLidoBurnContractFunction

    canCall: LeakyLidoCanCallContractFunction

    decimals: LeakyLidoDecimalsContractFunction

    doesRoleHaveCapability: LeakyLidoDoesRoleHaveCapabilityContractFunction

    doesUserHaveRole: LeakyLidoDoesUserHaveRoleContractFunction

    getBufferedEther: LeakyLidoGetBufferedEtherContractFunction

    getPooledEthByShares: LeakyLidoGetPooledEthBySharesContractFunction

    getRate: LeakyLidoGetRateContractFunction

    getRolesWithCapability: LeakyLidoGetRolesWithCapabilityContractFunction

    getSharesByPooledEth: LeakyLidoGetSharesByPooledEthContractFunction

    getTargetCustomAuthority: LeakyLidoGetTargetCustomAuthorityContractFunction

    getTotalPooledEther: LeakyLidoGetTotalPooledEtherContractFunction

    getTotalShares: LeakyLidoGetTotalSharesContractFunction

    getUserRoles: LeakyLidoGetUserRolesContractFunction

    isCapabilityPublic: LeakyLidoIsCapabilityPublicContractFunction

    isCompetitionMode: LeakyLidoIsCompetitionModeContractFunction

    isUnrestricted: LeakyLidoIsUnrestrictedContractFunction

    leakyTransferFrom: LeakyLidoLeakyTransferFromContractFunction

    maxMintAmount: LeakyLidoMaxMintAmountContractFunction

    mint: LeakyLidoMintContractFunction

    name: LeakyLidoNameContractFunction

    owner: LeakyLidoOwnerContractFunction

    setAuthority: LeakyLidoSetAuthorityContractFunction

    setMaxMintAmount: LeakyLidoSetMaxMintAmountContractFunction

    setPublicCapability: LeakyLidoSetPublicCapabilityContractFunction

    setRate: LeakyLidoSetRateContractFunction

    setRoleCapability: LeakyLidoSetRoleCapabilityContractFunction

    setTargetCustomAuthority: LeakyLidoSetTargetCustomAuthorityContractFunction

    setUnrestrictedMintStatus: (
        LeakyLidoSetUnrestrictedMintStatusContractFunction
    )

    setUserRole: LeakyLidoSetUserRoleContractFunction

    sharesOf: LeakyLidoSharesOfContractFunction

    submit: LeakyLidoSubmitContractFunction

    symbol: LeakyLidoSymbolContractFunction

    totalSupply: LeakyLidoTotalSupplyContractFunction

    transfer: LeakyLidoTransferContractFunction

    transferFrom: LeakyLidoTransferFromContractFunction

    transferOwnership: LeakyLidoTransferOwnershipContractFunction

    transferShares: LeakyLidoTransferSharesContractFunction

    transferSharesFrom: LeakyLidoTransferSharesFromContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.allowance = LeakyLidoAllowanceContractFunction.factory(
            "allowance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="allowance",
        )
        self.approve = LeakyLidoApproveContractFunction.factory(
            "approve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="approve",
        )
        self.authority = LeakyLidoAuthorityContractFunction.factory(
            "authority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="authority",
        )
        self.balanceOf = LeakyLidoBalanceOfContractFunction.factory(
            "balanceOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="balanceOf",
        )
        self.burn = LeakyLidoBurnContractFunction.factory(
            "burn",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="burn",
        )
        self.canCall = LeakyLidoCanCallContractFunction.factory(
            "canCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="canCall",
        )
        self.decimals = LeakyLidoDecimalsContractFunction.factory(
            "decimals",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="decimals",
        )
        self.doesRoleHaveCapability = (
            LeakyLidoDoesRoleHaveCapabilityContractFunction.factory(
                "doesRoleHaveCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesRoleHaveCapability",
            )
        )
        self.doesUserHaveRole = (
            LeakyLidoDoesUserHaveRoleContractFunction.factory(
                "doesUserHaveRole",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="doesUserHaveRole",
            )
        )
        self.getBufferedEther = (
            LeakyLidoGetBufferedEtherContractFunction.factory(
                "getBufferedEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getBufferedEther",
            )
        )
        self.getPooledEthByShares = (
            LeakyLidoGetPooledEthBySharesContractFunction.factory(
                "getPooledEthByShares",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getPooledEthByShares",
            )
        )
        self.getRate = LeakyLidoGetRateContractFunction.factory(
            "getRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getRate",
        )
        self.getRolesWithCapability = (
            LeakyLidoGetRolesWithCapabilityContractFunction.factory(
                "getRolesWithCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getRolesWithCapability",
            )
        )
        self.getSharesByPooledEth = (
            LeakyLidoGetSharesByPooledEthContractFunction.factory(
                "getSharesByPooledEth",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getSharesByPooledEth",
            )
        )
        self.getTargetCustomAuthority = (
            LeakyLidoGetTargetCustomAuthorityContractFunction.factory(
                "getTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTargetCustomAuthority",
            )
        )
        self.getTotalPooledEther = (
            LeakyLidoGetTotalPooledEtherContractFunction.factory(
                "getTotalPooledEther",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getTotalPooledEther",
            )
        )
        self.getTotalShares = LeakyLidoGetTotalSharesContractFunction.factory(
            "getTotalShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getTotalShares",
        )
        self.getUserRoles = LeakyLidoGetUserRolesContractFunction.factory(
            "getUserRoles",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserRoles",
        )
        self.isCapabilityPublic = (
            LeakyLidoIsCapabilityPublicContractFunction.factory(
                "isCapabilityPublic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCapabilityPublic",
            )
        )
        self.isCompetitionMode = (
            LeakyLidoIsCompetitionModeContractFunction.factory(
                "isCompetitionMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCompetitionMode",
            )
        )
        self.isUnrestricted = LeakyLidoIsUnrestrictedContractFunction.factory(
            "isUnrestricted",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isUnrestricted",
        )
        self.leakyTransferFrom = (
            LeakyLidoLeakyTransferFromContractFunction.factory(
                "leakyTransferFrom",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="leakyTransferFrom",
            )
        )
        self.maxMintAmount = LeakyLidoMaxMintAmountContractFunction.factory(
            "maxMintAmount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxMintAmount",
        )
        self.mint = LeakyLidoMintContractFunction.factory(
            "mint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mint",
        )
        self.name = LeakyLidoNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.owner = LeakyLidoOwnerContractFunction.factory(
            "owner",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="owner",
        )
        self.setAuthority = LeakyLidoSetAuthorityContractFunction.factory(
            "setAuthority",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setAuthority",
        )
        self.setMaxMintAmount = (
            LeakyLidoSetMaxMintAmountContractFunction.factory(
                "setMaxMintAmount",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setMaxMintAmount",
            )
        )
        self.setPublicCapability = (
            LeakyLidoSetPublicCapabilityContractFunction.factory(
                "setPublicCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setPublicCapability",
            )
        )
        self.setRate = LeakyLidoSetRateContractFunction.factory(
            "setRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setRate",
        )
        self.setRoleCapability = (
            LeakyLidoSetRoleCapabilityContractFunction.factory(
                "setRoleCapability",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setRoleCapability",
            )
        )
        self.setTargetCustomAuthority = (
            LeakyLidoSetTargetCustomAuthorityContractFunction.factory(
                "setTargetCustomAuthority",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setTargetCustomAuthority",
            )
        )
        self.setUnrestrictedMintStatus = (
            LeakyLidoSetUnrestrictedMintStatusContractFunction.factory(
                "setUnrestrictedMintStatus",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUnrestrictedMintStatus",
            )
        )
        self.setUserRole = LeakyLidoSetUserRoleContractFunction.factory(
            "setUserRole",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserRole",
        )
        self.sharesOf = LeakyLidoSharesOfContractFunction.factory(
            "sharesOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sharesOf",
        )
        self.submit = LeakyLidoSubmitContractFunction.factory(
            "submit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="submit",
        )
        self.symbol = LeakyLidoSymbolContractFunction.factory(
            "symbol",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="symbol",
        )
        self.totalSupply = LeakyLidoTotalSupplyContractFunction.factory(
            "totalSupply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="totalSupply",
        )
        self.transfer = LeakyLidoTransferContractFunction.factory(
            "transfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transfer",
        )
        self.transferFrom = LeakyLidoTransferFromContractFunction.factory(
            "transferFrom",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferFrom",
        )
        self.transferOwnership = (
            LeakyLidoTransferOwnershipContractFunction.factory(
                "transferOwnership",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferOwnership",
            )
        )
        self.transferShares = LeakyLidoTransferSharesContractFunction.factory(
            "transferShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferShares",
        )
        self.transferSharesFrom = (
            LeakyLidoTransferSharesFromContractFunction.factory(
                "transferSharesFrom",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="transferSharesFrom",
            )
        )


class LeakyLidoApprovalContractEvent(ContractEvent):
    """ContractEvent for Approval."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ApprovalEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ApprovalEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for AuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AuthorityUpdatedEvent.AuthorityUpdatedEventArgs(
                    user=abi_event.args["user"],
                    newAuthority=abi_event.args["newAuthority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoOwnershipTransferredContractEvent(ContractEvent):
    """ContractEvent for OwnershipTransferred."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[OwnershipTransferredEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OwnershipTransferredEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OwnershipTransferredEvent.OwnershipTransferredEventArgs(
                    user=abi_event.args["user"],
                    newOwner=abi_event.args["newOwner"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoPublicCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for PublicCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[PublicCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            PublicCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=PublicCapabilityUpdatedEvent.PublicCapabilityUpdatedEventArgs(
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoRoleCapabilityUpdatedContractEvent(ContractEvent):
    """ContractEvent for RoleCapabilityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RoleCapabilityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RoleCapabilityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RoleCapabilityUpdatedEvent.RoleCapabilityUpdatedEventArgs(
                    role=abi_event.args["role"],
                    functionSig=abi_event.args["functionSig"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoTargetCustomAuthorityUpdatedContractEvent(ContractEvent):
    """ContractEvent for TargetCustomAuthorityUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TargetCustomAuthorityUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TargetCustomAuthorityUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TargetCustomAuthorityUpdatedEvent.TargetCustomAuthorityUpdatedEventArgs(
                    target=abi_event.args["target"],
                    authority=abi_event.args["authority"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoTransferContractEvent(ContractEvent):
    """ContractEvent for Transfer."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoTransferSharesContractEvent(ContractEvent):
    """ContractEvent for TransferShares."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferSharesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferSharesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferSharesEvent.TransferSharesEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    sharesValue=abi_event.args["sharesValue"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferSharesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferSharesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferSharesEvent.TransferSharesEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    sharesValue=abi_event.args["sharesValue"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoUserRoleUpdatedContractEvent(ContractEvent):
    """ContractEvent for UserRoleUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserRoleUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserRoleUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserRoleUpdatedEvent.UserRoleUpdatedEventArgs(
                    user=abi_event.args["user"],
                    role=abi_event.args["role"],
                    enabled=abi_event.args["enabled"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class LeakyLidoContractEvents(ContractEvents):
    """ContractEvents for the LeakyLido contract."""

    Approval: LeakyLidoApprovalContractEvent

    AuthorityUpdated: LeakyLidoAuthorityUpdatedContractEvent

    OwnershipTransferred: LeakyLidoOwnershipTransferredContractEvent

    PublicCapabilityUpdated: LeakyLidoPublicCapabilityUpdatedContractEvent

    RoleCapabilityUpdated: LeakyLidoRoleCapabilityUpdatedContractEvent

    TargetCustomAuthorityUpdated: (
        LeakyLidoTargetCustomAuthorityUpdatedContractEvent
    )

    Transfer: LeakyLidoTransferContractEvent

    TransferShares: LeakyLidoTransferSharesContractEvent

    UserRoleUpdated: LeakyLidoUserRoleUpdatedContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.Approval = LeakyLidoApprovalContractEvent.factory(
            "Approval",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Approval",
        )
        self.AuthorityUpdated = LeakyLidoAuthorityUpdatedContractEvent.factory(
            "AuthorityUpdated",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="AuthorityUpdated",
        )
        self.OwnershipTransferred = (
            LeakyLidoOwnershipTransferredContractEvent.factory(
                "OwnershipTransferred",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="OwnershipTransferred",
            )
        )
        self.PublicCapabilityUpdated = (
            LeakyLidoPublicCapabilityUpdatedContractEvent.factory(
                "PublicCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="PublicCapabilityUpdated",
            )
        )
        self.RoleCapabilityUpdated = (
            LeakyLidoRoleCapabilityUpdatedContractEvent.factory(
                "RoleCapabilityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RoleCapabilityUpdated",
            )
        )
        self.TargetCustomAuthorityUpdated = (
            LeakyLidoTargetCustomAuthorityUpdatedContractEvent.factory(
                "TargetCustomAuthorityUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="TargetCustomAuthorityUpdated",
            )
        )
        self.Transfer = LeakyLidoTransferContractEvent.factory(
            "Transfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Transfer",
        )
        self.TransferShares = LeakyLidoTransferSharesContractEvent.factory(
            "TransferShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="TransferShares",
        )
        self.UserRoleUpdated = LeakyLidoUserRoleUpdatedContractEvent.factory(
            "UserRoleUpdated",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="UserRoleUpdated",
        )


class LeakyLidoContract(Contract):
    """A web3.py Contract class for the LeakyLido contract."""

    abi: ABI = leakylido_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x60a060405234801562000010575f80fd5b50604080518082018252601781527f4c6971756964207374616b656420457468657220322e300000000000000000006020808301919091528251808401845260058152640e6e88aa8960db1b918101919091525f80546001600160a01b03199081168255600180543092168217905593519093849384935f19939192909185919082908290829033907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36040516001600160a01b0382169033907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b76389980198905f90a3505050508160099081620001089190620001d1565b50600a620001178282620001d1565b505050600d9390935542600e55151560805250600b556200029d565b634e487b7160e01b5f52604160045260245ffd5b600181811c908216806200015c57607f821691505b6020821081036200017b57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f821115620001cc57805f5260205f20601f840160051c81016020851015620001a85750805b601f840160051c820191505b81811015620001c9575f8155600101620001b4565b50505b505050565b81516001600160401b03811115620001ed57620001ed62000133565b6200020581620001fe845462000147565b8462000181565b602080601f8311600181146200023b575f8415620002235750858301515b5f19600386901b1c1916600185901b17855562000295565b5f85815260208120601f198616915b828110156200026b578886015182559484019460019091019084016200024a565b50858210156200028957878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b608051611e7c620002e75f395f818161056d01528181610898015281816109b201528181610ba201528181610c2101528181610c860152818161110f01526111700152611e7c5ff3fe60806040526004361061026a575f3560e01c8063728b952b1161014a578063aed30777116100be578063dd62ed3e11610078578063dd62ed3e1461075a578063e688747b1461079e578063ea7ca276146107df578063ed0d0efb14610821578063f2fde38b1461084c578063f5eb42dc1461086b575f80fd5b8063aed3077714610687578063b7009613146106b5578063bf7e214f146106d4578063c51ea9cc146106f3578063c53a398514610712578063d5002f2e14610746575f80fd5b80638fcb4e5b1161010f5780638fcb4e5b146105e457806395d89b41146106035780639dc29fac14610617578063a0712d6814610636578063a1903eab14610655578063a9059cbb14610668575f80fd5b8063728b952b1461051e5780637a28fb881461053d5780637a8c63b51461055c5780637a9e5e4b1461058f5780638da5cb5b146105ae575f80fd5b8063313ce567116101e157806347b714e0116101a657806347b714e01461047c5780634b5159da1461048e578063679aefce146104ad57806367aff484146104c15780636d780459146104e057806370a08231146104ff575f80fd5b8063313ce567146103f057806334fcf4371461040b57806337cfdaca1461042a57806340c10f191461043e57806342966c681461045d575f80fd5b80630bade8a4116102325780630bade8a41461033c5780630ea9b75b1461036a57806318160ddd14610389578063192084511461039d578063239c70ae146103bc57806323b872dd146103d1575f80fd5b806305f05a941461026e57806306a36aee1461028f57806306fdde03146102cd578063088a4ed0146102ee578063095ea7b31461030d575b5f80fd5b348015610279575f80fd5b5061028d610288366004611a39565b610896565b005b34801561029a575f80fd5b506102ba6102a9366004611a70565b60036020525f908152604090205481565b6040519081526020015b60405180910390f35b3480156102d8575f80fd5b506102e1610920565b6040516102c49190611a8b565b3480156102f9575f80fd5b5061028d610308366004611ad7565b6109b0565b348015610318575f80fd5b5061032c610327366004611aee565b610a0c565b60405190151581526020016102c4565b348015610347575f80fd5b5061032c610356366004611b34565b60046020525f908152604090205460ff1681565b348015610375575f80fd5b5061028d610384366004611b5d565b610a25565b348015610394575f80fd5b506008546102ba565b3480156103a8575f80fd5b506102ba6103b7366004611ad7565b610afa565b3480156103c7575f80fd5b506102ba600b5481565b3480156103dc575f80fd5b5061032c6103eb366004611ba1565b610b17565b3480156103fb575f80fd5b50604051601281526020016102c4565b348015610416575f80fd5b5061028d610425366004611ad7565b610ba0565b348015610435575f80fd5b506102ba610c04565b348015610449575f80fd5b5061028d610458366004611aee565b610c1f565b348015610468575f80fd5b5061028d610477366004611ad7565b610c84565b348015610487575f80fd5b505f6102ba565b348015610499575f80fd5b5061028d6104a8366004611bdf565b610ce8565b3480156104b8575f80fd5b50600d546102ba565b3480156104cc575f80fd5b5061028d6104db366004611bf9565b610d78565b3480156104eb575f80fd5b506102ba6104fa366004611ba1565b610e3d565b34801561050a575f80fd5b506102ba610519366004611a70565b610ed0565b348015610529575f80fd5b5061028d610538366004611c24565b610ef1565b348015610548575f80fd5b506102ba610557366004611ad7565b610f78565b348015610567575f80fd5b5061032c7f000000000000000000000000000000000000000000000000000000000000000081565b34801561059a575f80fd5b5061028d6105a9366004611a70565b610f8c565b3480156105b9575f80fd5b505f546105cc906001600160a01b031681565b6040516001600160a01b0390911681526020016102c4565b3480156105ef575f80fd5b506102ba6105fe366004611aee565b611070565b34801561060e575f80fd5b506102e16110fe565b348015610622575f80fd5b5061028d610631366004611aee565b61110d565b348015610641575f80fd5b5061028d610650366004611ad7565b61116e565b6102ba610663366004611a70565b6111cf565b348015610673575f80fd5b5061032c610682366004611aee565b61128d565b348015610692575f80fd5b5061032c6106a1366004611a70565b600c6020525f908152604090205460ff1681565b3480156106c0575f80fd5b5061032c6106cf366004611c50565b611311565b3480156106df575f80fd5b506001546105cc906001600160a01b031681565b3480156106fe575f80fd5b5061032c61070d366004611ba1565b61140a565b34801561071d575f80fd5b506105cc61072c366004611a70565b60026020525f90815260409020546001600160a01b031681565b348015610751575f80fd5b506010546102ba565b348015610765575f80fd5b506102ba610774366004611c24565b6001600160a01b039182165f90815260076020908152604080832093909416825291909152205490565b3480156107a9575f80fd5b5061032c6107b8366004611c94565b6001600160e01b0319165f9081526005602052604090205460ff919091161c600116151590565b3480156107ea575f80fd5b5061032c6107f9366004611cc5565b6001600160a01b03919091165f90815260036020526040902054600160ff9092161c16151590565b34801561082c575f80fd5b506102ba61083b366004611b34565b60056020525f908152604090205481565b348015610857575f80fd5b5061028d610866366004611a70565b6114a6565b348015610876575f80fd5b506102ba610885366004611a70565b60116020525f908152604090205481565b7f0000000000000000000000000000000000000000000000000000000000000000156108f6576108d1335f356001600160e01b031916611521565b6108f65760405162461bcd60e51b81526004016108ed90611cef565b60405180910390fd5b6001600160a01b03919091165f908152600c60205260409020805460ff1916911515919091179055565b60606009805461092f90611d26565b80601f016020809104026020016040519081016040528092919081815260200182805461095b90611d26565b80156109a65780601f1061097d576101008083540402835291602001916109a6565b820191905f5260205f20905b81548152906001019060200180831161098957829003601f168201915b5050505050905090565b7f000000000000000000000000000000000000000000000000000000000000000015610a07576109eb335f356001600160e01b031916611521565b610a075760405162461bcd60e51b81526004016108ed90611cef565b600b55565b5f33610a198185856115c7565b60019150505b92915050565b610a3a335f356001600160e01b031916611521565b610a565760405162461bcd60e51b81526004016108ed90611d5e565b8015610a85576001600160e01b031982165f9081526005602052604090208054600160ff86161b179055610aab565b6001600160e01b031982165f9081526005602052604090208054600160ff86161b191690555b816001600160e01b0319168360ff167fbfe16b2c35ce23dfd1ab0e7b5d086a10060c9b52d1574e1680c881b3b3a2b15183604051610aed911515815260200190565b60405180910390a3505050565b5f610a1f610b0760105490565b610b0f610c04565b8491906115d9565b5f610b206115f4565b5f610b2a83610afa565b9050610b37858583611623565b506040518381526001600160a01b0385169033905f80516020611e278339815191529060200160405180910390a36040518181526001600160a01b0385169033905f80516020611e07833981519152906020015b60405180910390a360019150505b9392505050565b7f000000000000000000000000000000000000000000000000000000000000000015610bf757610bdb335f356001600160e01b031916611521565b610bf75760405162461bcd60e51b81526004016108ed90611cef565b610bff6115f4565b600d55565b5f610c0d61169c565b600f54610c1a9190611d98565b905090565b7f000000000000000000000000000000000000000000000000000000000000000015610c7657610c5a335f356001600160e01b031916611521565b610c765760405162461bcd60e51b81526004016108ed90611cef565b610c8082826116fb565b5050565b7f000000000000000000000000000000000000000000000000000000000000000015610cdb57610cbf335f356001600160e01b031916611521565b610cdb5760405162461bcd60e51b81526004016108ed90611cef565b610ce533826117e7565b50565b610cfd335f356001600160e01b031916611521565b610d195760405162461bcd60e51b81526004016108ed90611d5e565b6001600160e01b031982165f81815260046020908152604091829020805460ff191685151590811790915591519182527f36d28126bef21a4f3765d7fcb7c45cead463ae4c41094ef3b771ede598544103910160405180910390a25050565b610d8d335f356001600160e01b031916611521565b610da95760405162461bcd60e51b81526004016108ed90611d5e565b8015610dd7576001600160a01b0383165f9081526003602052604090208054600160ff85161b179055610dfc565b6001600160a01b0383165f9081526003602052604090208054600160ff85161b191690555b8160ff16836001600160a01b03167f4c9bdd0c8e073eb5eda2250b18d8e5121ff27b62064fbeeeed4869bb99bc5bf283604051610aed911515815260200190565b5f610e466115f4565b5f610e52858585611623565b9050836001600160a01b0316856001600160a01b03165f80516020611e2783398151915283604051610e8691815260200190565b60405180910390a3836001600160a01b0316856001600160a01b03165f80516020611e0783398151915285604051610ec091815260200190565b60405180910390a3949350505050565b6001600160a01b0381165f90815260116020526040812054610a1f90610f78565b610f06335f356001600160e01b031916611521565b610f225760405162461bcd60e51b81526004016108ed90611d5e565b6001600160a01b038281165f8181526002602052604080822080546001600160a01b0319169486169485179055517fa4908e11a5f895b13d51526c331ac93cdd30e59772361c5d07874eb36bff20659190a35050565b5f610a1f610f84610c04565b601054610b0f565b5f546001600160a01b031633148061101d575060015460405163b700961360e01b81526001600160a01b039091169063b700961390610fde90339030906001600160e01b03195f351690600401611dab565b602060405180830381865afa158015610ff9573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061101d9190611dd8565b611025575f80fd5b600180546001600160a01b0319166001600160a01b03831690811790915560405133907fa3396fd7f6e0a21b50e5089d2da70d5ac0a3bbbd1f617a93f134b76389980198905f90a350565b5f6110796115f4565b5f611084848461184d565b9050836001600160a01b0316336001600160a01b03165f80516020611e27833981519152836040516110b891815260200190565b60405180910390a36040518381526001600160a01b0385169033905f80516020611e078339815191529060200160405180910390a36110f683610f78565b949350505050565b6060600a805461092f90611d26565b7f00000000000000000000000000000000000000000000000000000000000000001561116457611148335f356001600160e01b031916611521565b6111645760405162461bcd60e51b81526004016108ed90611cef565b610c8082826117e7565b7f0000000000000000000000000000000000000000000000000000000000000000156111c5576111a9335f356001600160e01b031916611521565b6111c55760405162461bcd60e51b81526004016108ed90611cef565b610ce533826116fb565b5f6111d86115f4565b6010545f0361121657346010819055600f819055335f908152601160205260408120805490919061120a908490611d98565b90915550349392505050565b5f61123361122360105490565b61122b610c04565b3491906115d9565b905034600f5f8282546112469190611d98565b925050819055508060105f82825461125e9190611d98565b9091555050335f9081526011602052604081208054839290611281908490611d98565b90915550909392505050565b5f6112966115f4565b5f6112a083610afa565b90506112ac848261184d565b506040518381526001600160a01b0385169033905f80516020611e278339815191529060200160405180910390a36040518181526001600160a01b0385169033905f80516020611e078339815191529060200160405180910390a35060019392505050565b6001600160a01b038083165f9081526002602052604081205490911680156113aa5760405163b700961360e01b81526001600160a01b0382169063b70096139061136390889088908890600401611dab565b602060405180830381865afa15801561137e573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113a29190611dd8565b915050610b99565b6001600160e01b031983165f9081526004602052604090205460ff168061140157506001600160e01b031983165f908152600560209081526040808320546001600160a01b03891684526003909252909120541615155b95945050505050565b5f8061141583610afa565b6001600160a01b0386165f90815260116020526040812080549293508392909190611441908490611df3565b90915550506001600160a01b0384165f908152601160205260408120805483929061146d908490611d98565b92505081905550836001600160a01b0316856001600160a01b03165f80516020611e2783398151915285604051610b8b91815260200190565b6114bb335f356001600160e01b031916611521565b6114d75760405162461bcd60e51b81526004016108ed90611d5e565b5f80546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b6001545f906001600160a01b031680158015906115a8575060405163b700961360e01b81526001600160a01b0382169063b70096139061156990879030908890600401611dab565b602060405180830381865afa158015611584573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906115a89190611dd8565b806110f657505f546001600160a01b0385811691161491505092915050565b6115d483838360016118a8565b505050565b5f825f1904841183021582026115ed575f80fd5b5091020490565b5f6115fd61169c565b9050801561161c5780600f5f8282546116169190611d98565b90915550505b5042600e55565b5f8061162e83610f78565b905061163b85338361197b565b6001600160a01b0385165f9081526011602052604081208054859290611662908490611df3565b90915550506001600160a01b0384165f908152601160205260408120805485929061168e908490611d98565b909155509095945050505050565b5f600d545f036116ab57505f90565b600e544210156116ba57505f90565b5f6116d76301e13380600e54426116d19190611df3565b906119f0565b90505f610b996116f283600d54611a0490919063ffffffff16565b600f5490611a04565b335f908152600c602052604090205460ff1661176357600b548111156117635760405162461bcd60e51b815260206004820152601d60248201527f4d6f636b4c69646f3a20496e76616c6964206d696e7420616d6f756e7400000060448201526064016108ed565b5f61176d60105490565b5f0361177a575080611786565b61178382610afa565b90505b6001600160a01b0383165f90815260116020526040812080548392906117ad908490611d98565b9250508190555081600f5f8282546117c59190611d98565b925050819055508060105f8282546117dd9190611d98565b9091555050505050565b5f6117f182610afa565b6001600160a01b0384165f9081526011602052604081208054929350839290919061181d908490611df3565b9250508190555081600f5f8282546118359190611df3565b925050819055508060105f8282546117dd9190611df3565b335f9081526011602052604081208054839190839061186d908490611df3565b90915550506001600160a01b0383165f9081526011602052604081208054849290611899908490611d98565b90915550610b99905082610f78565b6001600160a01b0384166118d15760405163e602df0560e01b81525f60048201526024016108ed565b6001600160a01b0383166118fa57604051634a1406b160e11b81525f60048201526024016108ed565b6001600160a01b038085165f908152600760209081526040808320938716835292905220829055801561197557826001600160a01b0316846001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9258460405161196c91815260200190565b60405180910390a35b50505050565b6001600160a01b038381165f908152600760209081526040808320938616835292905220545f19811461197557818110156119e257604051637dc7a0d960e11b81526001600160a01b038416600482015260248101829052604481018390526064016108ed565b61197584848484035f6118a8565b5f610b9983670de0b6b3a7640000846115d9565b5f610b998383670de0b6b3a76400006115d9565b6001600160a01b0381168114610ce5575f80fd5b8015158114610ce5575f80fd5b5f8060408385031215611a4a575f80fd5b8235611a5581611a18565b91506020830135611a6581611a2c565b809150509250929050565b5f60208284031215611a80575f80fd5b8135610b9981611a18565b5f602080835283518060208501525f5b81811015611ab757858101830151858201604001528201611a9b565b505f604082860101526040601f19601f8301168501019250505092915050565b5f60208284031215611ae7575f80fd5b5035919050565b5f8060408385031215611aff575f80fd5b8235611b0a81611a18565b946020939093013593505050565b80356001600160e01b031981168114611b2f575f80fd5b919050565b5f60208284031215611b44575f80fd5b610b9982611b18565b803560ff81168114611b2f575f80fd5b5f805f60608486031215611b6f575f80fd5b611b7884611b4d565b9250611b8660208501611b18565b91506040840135611b9681611a2c565b809150509250925092565b5f805f60608486031215611bb3575f80fd5b8335611bbe81611a18565b92506020840135611bce81611a18565b929592945050506040919091013590565b5f8060408385031215611bf0575f80fd5b611a5583611b18565b5f805f60608486031215611c0b575f80fd5b8335611c1681611a18565b9250611b8660208501611b4d565b5f8060408385031215611c35575f80fd5b8235611c4081611a18565b91506020830135611a6581611a18565b5f805f60608486031215611c62575f80fd5b8335611c6d81611a18565b92506020840135611c7d81611a18565b9150611c8b60408501611b18565b90509250925092565b5f8060408385031215611ca5575f80fd5b611cae83611b4d565b9150611cbc60208401611b18565b90509250929050565b5f8060408385031215611cd6575f80fd5b8235611ce181611a18565b9150611cbc60208401611b4d565b60208082526018908201527f4d6f636b4c69646f3a206e6f7420617574686f72697a65640000000000000000604082015260600190565b600181811c90821680611d3a57607f821691505b602082108103611d5857634e487b7160e01b5f52602260045260245ffd5b50919050565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b80820180821115610a1f57610a1f611d84565b6001600160a01b0393841681529190921660208201526001600160e01b0319909116604082015260600190565b5f60208284031215611de8575f80fd5b8151610b9981611a2c565b81810381811115610a1f57610a1f611d8456fe9d9c909296d9c674451c0c24f02cb64981eb3b727f99865939192f880a755dcbddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa26469706673582212200c9174461e796468ee4ed72e48ca050192a9c8934025b5822e5da0c7a3b9002964736f6c63430008180033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = LeakyLidoContractFunctions(leakylido_abi, self.w3, address)  # type: ignore
        self.events = LeakyLidoContractEvents(leakylido_abi, self.w3, address)  # type: ignore
        self.errors = LeakyLidoContractErrors()

    events: LeakyLidoContractEvents

    errors: LeakyLidoContractErrors = LeakyLidoContractErrors()

    functions: LeakyLidoContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = LeakyLidoContractFunctions(leakylido_abi, w3, None)
        contract.errors = LeakyLidoContractErrors()

        return contract
