"""A web3.py Contract class for the YieldSpaceMathTest contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..LPMath import LPMathContract
from ..StdInvariant import StdInvariantTypes as StdInvariant
from .YieldSpaceMathTestTypes import (
    Log_addressEvent,
    Log_arrayEvent,
    Log_bytes32Event,
    Log_bytesEvent,
    Log_intEvent,
    Log_named_addressEvent,
    Log_named_arrayEvent,
    Log_named_bytes32Event,
    Log_named_bytesEvent,
    Log_named_decimal_intEvent,
    Log_named_decimal_uintEvent,
    Log_named_intEvent,
    Log_named_stringEvent,
    Log_named_uintEvent,
    Log_stringEvent,
    Log_uintEvent,
    LogEvent,
    LogsEvent,
)

structs = {
    "StdInvariant.FuzzSelector": StdInvariant.FuzzSelector,
    "StdInvariant.FuzzInterface": StdInvariant.FuzzInterface,
}

yieldspacemathtest_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "IS_TEST",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "failed",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifactSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifactSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetInterfaces",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedInterfaces_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzInterface[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "artifacts",
                            "type": "string[]",
                            "internalType": "string[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "test__calculateBondsOutGivenSharesInDown__failure",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateMaxBuy",
            "inputs": [
                {
                    "name": "fixedRate",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "shareReserves",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "vaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "initialVaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateOutGivenIn",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOut",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOutDown__failure",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOutUp__failure",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test__calculateSharesInGivenBondsOut__extremeValues",
            "inputs": [
                {
                    "name": "fixedRate",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "shareReserves",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "vaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "initialVaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "tradeSize",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "log",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_address",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes32",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_int",
            "inputs": [
                {
                    "name": "",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_address",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes32",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_string",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_string",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_uint",
            "inputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "logs",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {"type": "error", "name": "ExpInvalidExponent", "inputs": []},
        {"type": "error", "name": "InsufficientLiquidity", "inputs": []},
        {"type": "error", "name": "LnInvalidInput", "inputs": []},
        {"type": "error", "name": "UnsafeCastToInt256", "inputs": []},
    ],
)


class YieldSpaceMathTestExpInvalidExponentContractError(PypechainBaseError):
    """ContractError for ExpInvalidExponent."""

    # Error name
    name: str = "ExpInvalidExponent"
    # 4 byte error selector
    selector: str = "0x73a2d6b1"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ExpInvalidExponent()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestInsufficientLiquidityContractError(PypechainBaseError):
    """ContractError for InsufficientLiquidity."""

    # Error name
    name: str = "InsufficientLiquidity"
    # 4 byte error selector
    selector: str = "0xbb55fd27"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InsufficientLiquidity()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestLnInvalidInputContractError(PypechainBaseError):
    """ContractError for LnInvalidInput."""

    # Error name
    name: str = "LnInvalidInput"
    # 4 byte error selector
    selector: str = "0xe61b4975"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "LnInvalidInput()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestUnsafeCastToInt256ContractError(PypechainBaseError):
    """ContractError for UnsafeCastToInt256."""

    # Error name
    name: str = "UnsafeCastToInt256"
    # 4 byte error selector
    selector: str = "0x72dd4e02"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "UnsafeCastToInt256()"
    # Error input types
    abi: ABI = yieldspacemathtest_abi


class YieldSpaceMathTestContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the YieldSpaceMathTest contract."""

    ExpInvalidExponent: YieldSpaceMathTestExpInvalidExponentContractError

    InsufficientLiquidity: YieldSpaceMathTestInsufficientLiquidityContractError

    LnInvalidInput: YieldSpaceMathTestLnInvalidInputContractError

    UnsafeCastToInt256: YieldSpaceMathTestUnsafeCastToInt256ContractError

    def __init__(
        self,
    ) -> None:
        self.ExpInvalidExponent = (
            YieldSpaceMathTestExpInvalidExponentContractError()
        )
        self.InsufficientLiquidity = (
            YieldSpaceMathTestInsufficientLiquidityContractError()
        )
        self.LnInvalidInput = YieldSpaceMathTestLnInvalidInputContractError()
        self.UnsafeCastToInt256 = (
            YieldSpaceMathTestUnsafeCastToInt256ContractError()
        )

        self._all = [
            self.ExpInvalidExponent,
            self.InsufficientLiquidity,
            self.LnInvalidInput,
            self.UnsafeCastToInt256,
        ]


class YieldSpaceMathTestIS_TESTContractFunction0(PypechainContractFunction):
    """ContractFunction for the IS_TEST() method."""

    _function_name = "IS_TEST"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestIS_TESTContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the IS_TEST method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "IS_TEST"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestIS_TESTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestIS_TESTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestIS_TESTContractFunction0._type_signature: YieldSpaceMathTestIS_TESTContractFunction0,
        }
        return out


class YieldSpaceMathTestExcludeArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeArtifacts() method."""

    _function_name = "excludeArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestExcludeArtifactsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestExcludeArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestExcludeArtifactsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestExcludeArtifactsContractFunction0._type_signature: YieldSpaceMathTestExcludeArtifactsContractFunction0,
        }
        return out


class YieldSpaceMathTestExcludeContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeContracts() method."""

    _function_name = "excludeContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestExcludeContractsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestExcludeContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestExcludeContractsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestExcludeContractsContractFunction0._type_signature: YieldSpaceMathTestExcludeContractsContractFunction0,
        }
        return out


class YieldSpaceMathTestExcludeSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeSenders() method."""

    _function_name = "excludeSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestExcludeSendersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestExcludeSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestExcludeSendersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestExcludeSendersContractFunction0._type_signature: YieldSpaceMathTestExcludeSendersContractFunction0,
        }
        return out


class YieldSpaceMathTestFailedContractFunction0(PypechainContractFunction):
    """ContractFunction for the failed() method."""

    _function_name = "failed"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestFailedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the failed method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "failed"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestFailedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestFailedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestFailedContractFunction0._type_signature: YieldSpaceMathTestFailedContractFunction0,
        }
        return out


class YieldSpaceMathTestTargetArtifactSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifactSelectors() method."""

    _function_name = "targetArtifactSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class YieldSpaceMathTestTargetArtifactSelectorsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetArtifactSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifactSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetArtifactSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetArtifactSelectorsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTargetArtifactSelectorsContractFunction0._type_signature: YieldSpaceMathTestTargetArtifactSelectorsContractFunction0,
        }
        return out


class YieldSpaceMathTestTargetArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifacts() method."""

    _function_name = "targetArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestTargetArtifactsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetArtifactsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTargetArtifactsContractFunction0._type_signature: YieldSpaceMathTestTargetArtifactsContractFunction0,
        }
        return out


class YieldSpaceMathTestTargetContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetContracts() method."""

    _function_name = "targetContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestTargetContractsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetContractsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTargetContractsContractFunction0._type_signature: YieldSpaceMathTestTargetContractsContractFunction0,
        }
        return out


class YieldSpaceMathTestTargetInterfacesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetInterfaces() method."""

    _function_name = "targetInterfaces"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzInterface]:
        """returns list[StdInvariant.FuzzInterface]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzInterface]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzInterface],
            rename_returned_types(structs, return_types, raw_values),
        )


class YieldSpaceMathTestTargetInterfacesContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetInterfaces method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetInterfaces"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetInterfacesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetInterfacesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTargetInterfacesContractFunction0._type_signature: YieldSpaceMathTestTargetInterfacesContractFunction0,
        }
        return out


class YieldSpaceMathTestTargetSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSelectors() method."""

    _function_name = "targetSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class YieldSpaceMathTestTargetSelectorsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetSelectorsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTargetSelectorsContractFunction0._type_signature: YieldSpaceMathTestTargetSelectorsContractFunction0,
        }
        return out


class YieldSpaceMathTestTargetSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSenders() method."""

    _function_name = "targetSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class YieldSpaceMathTestTargetSendersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTargetSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTargetSendersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTargetSendersContractFunction0._type_signature: YieldSpaceMathTestTargetSendersContractFunction0,
        }
        return out


class YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateBondsOutGivenSharesInDown__failure() method."""

    _function_name = "test__calculateBondsOutGivenSharesInDown__failure"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test__calculateBondsOutGivenSharesInDown__failure method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateBondsOutGivenSharesInDown__failure"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0._type_signature: YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction0,
        }
        return out


class YieldSpaceMathTestTest__calculateMaxBuyContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateMaxBuy(int,int,int,int) method."""

    _function_name = "test__calculateMaxBuy"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateMaxBuyContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test__calculateMaxBuy method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateMaxBuy"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, fixedRate: int, shareReserves: int, vaultSharePrice: int, initialVaultSharePrice: int) -> YieldSpaceMathTestTest__calculateMaxBuyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateMaxBuyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTest__calculateMaxBuyContractFunction0._type_signature: YieldSpaceMathTestTest__calculateMaxBuyContractFunction0,
        }
        return out


class YieldSpaceMathTestTest__calculateOutGivenInContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateOutGivenIn() method."""

    _function_name = "test__calculateOutGivenIn"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateOutGivenInContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test__calculateOutGivenIn method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateOutGivenIn"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateOutGivenInContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateOutGivenInContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTest__calculateOutGivenInContractFunction0._type_signature: YieldSpaceMathTestTest__calculateOutGivenInContractFunction0,
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut() method."""

    _function_name = "test__calculateSharesInGivenBondsOut"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOut"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction0,
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutDown__failure() method."""

    _function_name = "test__calculateSharesInGivenBondsOutDown__failure"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutDown__failure method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOutDown__failure"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction0,
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutUp__failure() method."""

    _function_name = "test__calculateSharesInGivenBondsOutUp__failure"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test__calculateSharesInGivenBondsOutUp__failure method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOutUp__failure"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction0,
        }
        return out


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut__extremeValues(int,int,int,int,int) method."""

    _function_name = "test__calculateSharesInGivenBondsOut__extremeValues"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "int"]), structs
    )
    _error_class = YieldSpaceMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test__calculateSharesInGivenBondsOut__extremeValues method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test__calculateSharesInGivenBondsOut__extremeValues"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, fixedRate: int, shareReserves: int, vaultSharePrice: int, initialVaultSharePrice: int, tradeSize: int) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0._type_signature: YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction0,
        }
        return out


class YieldSpaceMathTestContractFunctions(ContractFunctions):
    """ContractFunctions for the YieldSpaceMathTest contract."""

    IS_TEST: YieldSpaceMathTestIS_TESTContractFunction

    excludeArtifacts: YieldSpaceMathTestExcludeArtifactsContractFunction

    excludeContracts: YieldSpaceMathTestExcludeContractsContractFunction

    excludeSenders: YieldSpaceMathTestExcludeSendersContractFunction

    failed: YieldSpaceMathTestFailedContractFunction

    targetArtifactSelectors: (
        YieldSpaceMathTestTargetArtifactSelectorsContractFunction
    )

    targetArtifacts: YieldSpaceMathTestTargetArtifactsContractFunction

    targetContracts: YieldSpaceMathTestTargetContractsContractFunction

    targetInterfaces: YieldSpaceMathTestTargetInterfacesContractFunction

    targetSelectors: YieldSpaceMathTestTargetSelectorsContractFunction

    targetSenders: YieldSpaceMathTestTargetSendersContractFunction

    test__calculateBondsOutGivenSharesInDown__failure: YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction

    test__calculateMaxBuy: (
        YieldSpaceMathTestTest__calculateMaxBuyContractFunction
    )

    test__calculateOutGivenIn: (
        YieldSpaceMathTestTest__calculateOutGivenInContractFunction
    )

    test__calculateSharesInGivenBondsOut: (
        YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction
    )

    test__calculateSharesInGivenBondsOutDown__failure: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction

    test__calculateSharesInGivenBondsOutUp__failure: YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction

    test__calculateSharesInGivenBondsOut__extremeValues: YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.IS_TEST = YieldSpaceMathTestIS_TESTContractFunction.factory(
            "IS_TEST",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="IS_TEST",
        )
        self.excludeArtifacts = (
            YieldSpaceMathTestExcludeArtifactsContractFunction.factory(
                "excludeArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeArtifacts",
            )
        )
        self.excludeContracts = (
            YieldSpaceMathTestExcludeContractsContractFunction.factory(
                "excludeContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeContracts",
            )
        )
        self.excludeSenders = (
            YieldSpaceMathTestExcludeSendersContractFunction.factory(
                "excludeSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeSenders",
            )
        )
        self.failed = YieldSpaceMathTestFailedContractFunction.factory(
            "failed",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="failed",
        )
        self.targetArtifactSelectors = (
            YieldSpaceMathTestTargetArtifactSelectorsContractFunction.factory(
                "targetArtifactSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifactSelectors",
            )
        )
        self.targetArtifacts = (
            YieldSpaceMathTestTargetArtifactsContractFunction.factory(
                "targetArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifacts",
            )
        )
        self.targetContracts = (
            YieldSpaceMathTestTargetContractsContractFunction.factory(
                "targetContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetContracts",
            )
        )
        self.targetInterfaces = (
            YieldSpaceMathTestTargetInterfacesContractFunction.factory(
                "targetInterfaces",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetInterfaces",
            )
        )
        self.targetSelectors = (
            YieldSpaceMathTestTargetSelectorsContractFunction.factory(
                "targetSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSelectors",
            )
        )
        self.targetSenders = (
            YieldSpaceMathTestTargetSendersContractFunction.factory(
                "targetSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSenders",
            )
        )
        self.test__calculateBondsOutGivenSharesInDown__failure = YieldSpaceMathTestTest__calculateBondsOutGivenSharesInDown__failureContractFunction.factory(
            "test__calculateBondsOutGivenSharesInDown__failure",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateBondsOutGivenSharesInDown__failure",
        )
        self.test__calculateMaxBuy = (
            YieldSpaceMathTestTest__calculateMaxBuyContractFunction.factory(
                "test__calculateMaxBuy",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test__calculateMaxBuy",
            )
        )
        self.test__calculateOutGivenIn = (
            YieldSpaceMathTestTest__calculateOutGivenInContractFunction.factory(
                "test__calculateOutGivenIn",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test__calculateOutGivenIn",
            )
        )
        self.test__calculateSharesInGivenBondsOut = YieldSpaceMathTestTest__calculateSharesInGivenBondsOutContractFunction.factory(
            "test__calculateSharesInGivenBondsOut",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOut",
        )
        self.test__calculateSharesInGivenBondsOutDown__failure = YieldSpaceMathTestTest__calculateSharesInGivenBondsOutDown__failureContractFunction.factory(
            "test__calculateSharesInGivenBondsOutDown__failure",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOutDown__failure",
        )
        self.test__calculateSharesInGivenBondsOutUp__failure = YieldSpaceMathTestTest__calculateSharesInGivenBondsOutUp__failureContractFunction.factory(
            "test__calculateSharesInGivenBondsOutUp__failure",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOutUp__failure",
        )
        self.test__calculateSharesInGivenBondsOut__extremeValues = YieldSpaceMathTestTest__calculateSharesInGivenBondsOut__extremeValuesContractFunction.factory(
            "test__calculateSharesInGivenBondsOut__extremeValues",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test__calculateSharesInGivenBondsOut__extremeValues",
        )


class YieldSpaceMathTestLogContractEvent(ContractEvent):
    """ContractEvent for log."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_addressContractEvent(ContractEvent):
    """ContractEvent for log_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_arrayContractEvent(ContractEvent):
    """ContractEvent for log_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_bytesContractEvent(ContractEvent):
    """ContractEvent for log_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_intContractEvent(ContractEvent):
    """ContractEvent for log_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_addressContractEvent(ContractEvent):
    """ContractEvent for log_named_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_arrayContractEvent(ContractEvent):
    """ContractEvent for log_named_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_bytesContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_decimal_intContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_decimal_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_intContractEvent(ContractEvent):
    """ContractEvent for log_named_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_stringContractEvent(ContractEvent):
    """ContractEvent for log_named_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_named_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_stringContractEvent(ContractEvent):
    """ContractEvent for log_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLog_uintContractEvent(ContractEvent):
    """ContractEvent for log_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestLogsContractEvent(ContractEvent):
    """ContractEvent for logs."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogsEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogsEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class YieldSpaceMathTestContractEvents(ContractEvents):
    """ContractEvents for the YieldSpaceMathTest contract."""

    log: YieldSpaceMathTestLogContractEvent

    log_address: YieldSpaceMathTestLog_addressContractEvent

    log_array: YieldSpaceMathTestLog_arrayContractEvent

    log_bytes: YieldSpaceMathTestLog_bytesContractEvent

    log_bytes32: YieldSpaceMathTestLog_bytes32ContractEvent

    log_int: YieldSpaceMathTestLog_intContractEvent

    log_named_address: YieldSpaceMathTestLog_named_addressContractEvent

    log_named_array: YieldSpaceMathTestLog_named_arrayContractEvent

    log_named_bytes: YieldSpaceMathTestLog_named_bytesContractEvent

    log_named_bytes32: YieldSpaceMathTestLog_named_bytes32ContractEvent

    log_named_decimal_int: YieldSpaceMathTestLog_named_decimal_intContractEvent

    log_named_decimal_uint: (
        YieldSpaceMathTestLog_named_decimal_uintContractEvent
    )

    log_named_int: YieldSpaceMathTestLog_named_intContractEvent

    log_named_string: YieldSpaceMathTestLog_named_stringContractEvent

    log_named_uint: YieldSpaceMathTestLog_named_uintContractEvent

    log_string: YieldSpaceMathTestLog_stringContractEvent

    log_uint: YieldSpaceMathTestLog_uintContractEvent

    logs: YieldSpaceMathTestLogsContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.log = YieldSpaceMathTestLogContractEvent.factory(
            "log", w3=w3, contract_abi=abi, address=address, event_name="log"
        )
        self.log_address = YieldSpaceMathTestLog_addressContractEvent.factory(
            "log_address",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_address",
        )
        self.log_array = YieldSpaceMathTestLog_arrayContractEvent.factory(
            "log_array",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_array",
        )
        self.log_bytes = YieldSpaceMathTestLog_bytesContractEvent.factory(
            "log_bytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_bytes",
        )
        self.log_bytes32 = YieldSpaceMathTestLog_bytes32ContractEvent.factory(
            "log_bytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_bytes32",
        )
        self.log_int = YieldSpaceMathTestLog_intContractEvent.factory(
            "log_int",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_int",
        )
        self.log_named_address = (
            YieldSpaceMathTestLog_named_addressContractEvent.factory(
                "log_named_address",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_address",
            )
        )
        self.log_named_array = (
            YieldSpaceMathTestLog_named_arrayContractEvent.factory(
                "log_named_array",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_array",
            )
        )
        self.log_named_bytes = (
            YieldSpaceMathTestLog_named_bytesContractEvent.factory(
                "log_named_bytes",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes",
            )
        )
        self.log_named_bytes32 = (
            YieldSpaceMathTestLog_named_bytes32ContractEvent.factory(
                "log_named_bytes32",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes32",
            )
        )
        self.log_named_decimal_int = (
            YieldSpaceMathTestLog_named_decimal_intContractEvent.factory(
                "log_named_decimal_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_int",
            )
        )
        self.log_named_decimal_uint = (
            YieldSpaceMathTestLog_named_decimal_uintContractEvent.factory(
                "log_named_decimal_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_uint",
            )
        )
        self.log_named_int = (
            YieldSpaceMathTestLog_named_intContractEvent.factory(
                "log_named_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_int",
            )
        )
        self.log_named_string = (
            YieldSpaceMathTestLog_named_stringContractEvent.factory(
                "log_named_string",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_string",
            )
        )
        self.log_named_uint = (
            YieldSpaceMathTestLog_named_uintContractEvent.factory(
                "log_named_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_uint",
            )
        )
        self.log_string = YieldSpaceMathTestLog_stringContractEvent.factory(
            "log_string",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_string",
        )
        self.log_uint = YieldSpaceMathTestLog_uintContractEvent.factory(
            "log_uint",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_uint",
        )
        self.logs = YieldSpaceMathTestLogsContractEvent.factory(
            "logs", w3=w3, contract_abi=abi, address=address, event_name="logs"
        )


class YieldSpaceMathTestContract(Contract):
    """A web3.py Contract class for the YieldSpaceMathTest contract."""

    abi: ABI = yieldspacemathtest_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x6080604052600c8054600160ff199182168117909255601e8054909116909117905534801561002c575f80fd5b506146d48061003a5f395ff3fe608060405234801561000f575f80fd5b5060043610610111575f3560e01c806385226c811161009e578063ba414fa61161006e578063ba414fa6146101d2578063caafb419146101ea578063dbd56c8a146101f2578063e20c9f71146101fa578063fa7626d414610202575f80fd5b806385226c811461019a578063916a17c6146101af578063ac522b60146101b7578063b5508aa9146101ca575f80fd5b8063359a0432116100e4578063359a04321461015a5780633e5e3c23146101625780633f7286f41461016a5780634e1230941461017257806366d9a9a014610185575f80fd5b80630e98bbba146101155780631d8ab8631461011f5780631ed7831c146101275780632ade388014610145575b5f80fd5b61011d61020f565b005b61011d610600565b61012f6109d9565b60405161013c919061319f565b60405180910390f35b61014d610a39565b60405161013c919061322e565b61011d610b75565b61012f610ee4565b61012f610f42565b61011d6101803660046132eb565b610fa0565b61018d6113eb565b60405161013c919061331a565b6101a26114cc565b60405161013c91906133cb565b61018d611597565b61011d6101c536600461342d565b611678565b6101a261195b565b6101da611a26565b604051901515815260200161013c565b61011d611ac6565b61011d611c41565b61012f611e51565b601e546101da9060ff1681565b5f60405161021c90613192565b604051809103905ff080158015610235573d5f803e3d5ffd5b5090505f610254670de0b6b3a7640000680133e79f1880bca5ea611eaf565b90505f6001600160a01b0383166386c85e1069152d02c7e14af6800000693f870857a3e0e380000068056bc75e2d631000006102aa876102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b90611ecc565b6102bc90670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016102e79695949392919061348b565b602060405180830381865afa158015610302573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061032691906134b3565b905068058e8b841ae6c8ed906103418282633b9aca00611ee0565b5f6001600160a01b0385166386c85e1069152d02c7e14af6800000693f870857a3e0e38000006910f0cf064dd592000000610390896102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b6103a290670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016103cd9695949392919061348b565b602060405180830381865afa1580156103e8573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061040c91906134b3565b905069112e83c71900141b11806104288282633b9aca00611ee0565b5f6001600160a01b0387166327d0e26569152d02c7e14af6800000693f870857a3e0e380000068056bc75e2d631000006104768b6102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b61048890670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016104b39695949392919061348b565b602060405180830381865afa1580156104ce573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104f291906134b3565b9050680549d2621fcfa28ce061050d8282633b9aca00611ee0565b5f6001600160a01b0389166327d0e26569152d02c7e14af6800000693f870857a3e0e38000006910f0cf064dd59200000061055c8d6102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b61056e90670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b81526004016105999695949392919061348b565b602060405180830381865afa1580156105b4573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105d891906134b3565b90506910460e004cd5ae5b7e006105f48282633b9aca00611ee0565b50505050505050505050565b5f60405161060d90613192565b604051809103905ff080158015610626573d5f803e3d5ffd5b506040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152929350737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb3926106869291016134ca565b5f604051808303815f87803b15801561069d575f80fd5b505af11580156106af573d5f803e3d5ffd5b5050506001600160a01b038216905063a4a6f9d969d3c21bcecceda10000006a027b46536c66c8e30000006a027b46536c66c8e3000001610701670de0b6b3a7640000680133e79f1880bca5ea611eaf565b61071390670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b815260040161073e9695949392919061348b565b602060405180830381865afa158015610759573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061077d91906134b3565b50505f60405161078c90613192565b604051809103905ff0801580156107a5573d5f803e3d5ffd5b509050680aef5074226501a96a6912ae0bae78ab7704beea5f806107da670de0b6b3a7640000680133e79f1880bca5ea611eaf565b90505f6107fb826102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b61080d90670de0b6b3a7640000613478565b90506d35e51921da1a73e8caed30de384d7f01bb2ecac621ca54ea75c5329440ec17993d2f7576a8549d57adaece7d42c554610855875f676765c793fa10079d601a1b611f49565b965061086d865f676765c793fa10079d601a1b611f49565b9550610885855f676765c793fa10079d601a1b611f49565b94506108a082655af3107a4000670de0b6b3a7640000611f49565b91506108bb81655af3107a4000670de0b6b3a7640000611f49565b9050848610156108cf575050505050505050565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb39261092c929091016134ca565b5f604051808303815f87803b158015610943575f80fd5b505af1158015610955573d5f803e3d5ffd5b505060405163a4a6f9d960e01b81526001600160a01b038b16925063a4a6f9d9915061098f908a908a908a9089908990899060040161348b565b602060405180830381865afa1580156109aa573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109ce91906134b3565b505050505050505050565b60606016805480602002602001604051908101604052809291908181526020018280548015610a2f57602002820191905f5260205f20905b81546001600160a01b03168152600190910190602001808311610a11575b5050505050905090565b6060601d805480602002602001604051908101604052809291908181526020015f905b82821015610b6c575f84815260208082206040805180820182526002870290920180546001600160a01b03168352600181018054835181870281018701909452808452939591948681019491929084015b82821015610b55578382905f5260205f20018054610aca906134dc565b80601f0160208091040260200160405190810160405280929190818152602001828054610af6906134dc565b8015610b415780601f10610b1857610100808354040283529160200191610b41565b820191905f5260205f20905b815481529060010190602001808311610b2457829003601f168201915b505050505081526020019060010190610aad565b505050508152505081526020019060010190610a5c565b50505050905090565b5f604051610b8290613192565b604051809103905ff080158015610b9b573d5f803e3d5ffd5b5090505f610bba670de0b6b3a7640000680133e79f1880bca5ea611eaf565b90505f6001600160a01b038316632e74108c69152d02c7e14af6800000693f870857a3e0e380000068056bc75e2d63100000610c0a876102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b610c1c90670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b8152600401610c479695949392919061348b565b602060405180830381865afa158015610c62573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c8691906134b3565b9050680549dc9b3ad2c9ca10610ca18282633b9aca00611ee0565b5f6001600160a01b038516632e74108c69152d02c7e14af6800000693f870857a3e0e38000006910f0cf064dd592000000610cf0896102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b610d0290670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b8152600401610d2d9695949392919061348b565b602060405180830381865afa158015610d48573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d6c91906134b3565b90506910b361bf3f780b2c9500610d888282633b9aca00611ee0565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb392610de5929091016134ca565b5f604051808303815f87803b158015610dfc575f80fd5b505af1158015610e0e573d5f803e3d5ffd5b5050506001600160a01b0387169050632e74108c69152d02c7e14af680000068055de6a779bbac000068056bc75e2d63100000610e5f8a6102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b610e7190670de0b6b3a7640000613478565b670de0b6b3a7640000806040518763ffffffff1660e01b8152600401610e9c9695949392919061348b565b602060405180830381865afa158015610eb7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610edb91906134b3565b50505050505050565b60606018805480602002602001604051908101604052809291908181526020018280548015610a2f57602002820191905f5260205f209081546001600160a01b03168152600190910190602001808311610a11575050505050905090565b60606017805480602002602001604051908101604052809291908181526020018280548015610a2f57602002820191905f5260205f209081546001600160a01b03168152600190910190602001808311610a11575050505050905090565b5f604051610fad90613192565b604051809103905ff080158015610fc6573d5f803e3d5ffd5b509050610fe385662386f26fc10000670de0b6b3a7640000611f49565b945061100184655af3107a4000676765c793fa10079d601a1b611f49565b935061101e82670b1a2bc2ec500000674563918244f40000611f49565b91506110338383674563918244f40000611f49565b92505f611044866301e13380611fc9565b90505f8073__$2b4fa6f02a36eedfe41c65e8dd342257d3$__63b29e1d1e8888888c6301e13380896040518763ffffffff1660e01b815260040161108d9695949392919061348b565b606060405180830381865af41580156110a8573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110cc919061350e565b92509250505f6110dc888461206d565b90505f806001600160a01b03871663a9afa3738486611103670de0b6b3a76400008b611ecc565b61111590670de0b6b3a7640000613478565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018c9052608481018b905260a4016040805180830381865afa158015611169573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061118d9190613539565b9150915061119c816001612092565b5f6001600160a01b038816635880b9fd85876111c0670de0b6b3a76400008c611ecc565b6111d290670de0b6b3a7640000613478565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018d9052608481018c905260a4016040805180830381865afa158015611226573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061124a9190613539565b9250905089896113a86001600160a01b038b1663d79d0835888a6112768e670de0b6b3a7640000613478565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018690526084810185905260a401602060405180830381865afa1580156112cb573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906112ef91906134b3565b6001600160a01b038c1663d79d0835611308878b61356b565b6113128a8d613478565b6113248f670de0b6b3a7640000613478565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606481018790526084810186905260a401602060405180830381865afa158015611379573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061139d91906134b3565b64e8d4a51000611ee0565b6113db6113c96113b8858961356b565b6113c2888b613478565b848d6120ff565b670de0b6b3a764000062989680611ee0565b5050505050505050505050505050565b6060601b805480602002602001604051908101604052809291908181526020015f905b82821015610b6c575f8481526020908190206040805180820182526002860290920180546001600160a01b031683526001810180548351818702810187019094528084529394919385830193928301828280156114b457602002820191905f5260205f20905f905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116114765790505b5050505050815250508152602001906001019061140e565b6060601a805480602002602001604051908101604052809291908181526020015f905b82821015610b6c578382905f5260205f2001805461150c906134dc565b80601f0160208091040260200160405190810160405280929190818152602001828054611538906134dc565b80156115835780601f1061155a57610100808354040283529160200191611583565b820191905f5260205f20905b81548152906001019060200180831161156657829003601f168201915b5050505050815260200190600101906114ef565b6060601c805480602002602001604051908101604052809291908181526020015f905b82821015610b6c575f8481526020908190206040805180820182526002860290920180546001600160a01b0316835260018101805483518187028101870190945280845293949193858301939283018282801561166057602002820191905f5260205f20905f905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116116225790505b505050505081525050815260200190600101906115ba565b5f60405161168590613192565b604051809103905ff08015801561169e573d5f803e3d5ffd5b509050620186a06116bf87662386f26fc10000670de0b6b3a7640000611f49565b96506116dc84670b1a2bc2ec500000674563918244f40000611f49565b93506116f18585674563918244f40000611f49565b945060065b601281116119515761173561170c82600161356b565b61171790600a61365e565b61172283600961356b565b61172d90600a61365e565b899190611f49565b96505f61174360028361367d565b61174e90600161356b565b6117589083613478565b90505b8181101561193e575f6117728a6301e13380611fc9565b60405163594f0e8f60e11b81529091508a905f90819073__$2b4fa6f02a36eedfe41c65e8dd342257d3$__9063b29e1d1e906117c0908f908f908f9089906301e13380908c9060040161348b565b606060405180830381865af41580156117db573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906117ff919061350e565b92509250505f6118626040518061018001604052808f81526020018581526020018481526020015f81526020015f81526020018781526020018e81526020018d81526020018a81526020015f81526020015f81526020015f8152505f600f61211e565b915061187c905061187487600a61365e565b8b9083611f49565b99508c90508b8b8b5f6001600160a01b038d1663a4a6f9d98688856118a9670de0b6b3a76400008f611ecc565b6118bb90670de0b6b3a7640000613478565b89896040518763ffffffff1660e01b81526004016118de9695949392919061348b565b602060405180830381865afa1580156118f9573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061191d91906134b3565b9050611929815f61231d565b50506001909701965061175b95505050505050565b5061194a60018261356b565b90506116f6565b5050505050505050565b60606019805480602002602001604051908101604052809291908181526020015f905b82821015610b6c578382905f5260205f2001805461199b906134dc565b80601f01602080910402602001604051908101604052809291908181526020018280546119c7906134dc565b8015611a125780601f106119e957610100808354040283529160200191611a12565b820191905f5260205f20905b8154815290600101906020018083116119f557829003601f168201915b50505050508152602001906001019061197e565b6008545f9060ff1615611a3d575060085460ff1690565b604051630667f9d760e41b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d600482018190526519985a5b195960d21b60248301525f9163667f9d7090604401602060405180830381865afa158015611a9b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611abf91906134b3565b1415905090565b5f604051611ad390613192565b604051809103905ff080158015611aec573d5f803e3d5ffd5b50905060e0610c9a6117305f611b13670de0b6b3a7640000680133e79f1880bca5ea611eaf565b90505f611b34826102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b611b4690670de0b6b3a7640000613478565b90506a636f6e736f6c652e6c6f676107c0611b6a815f670de0b6b3a7640000611f49565b9050611b7f825f670de0b6b3a7640000611f49565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152929450737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb392611bde9291016134ca565b5f604051808303815f87803b158015611bf5575f80fd5b505af1158015611c07573d5f803e3d5ffd5b505060405163086c85e160e41b81526001600160a01b038b1692506386c85e10915061098f908a908a908a9089908990899060040161348b565b5f604051611c4e90613192565b604051809103905ff080158015611c67573d5f803e3d5ffd5b509050680aef5074226501a96a6912ae0bae78ab7704beea5f80611c9c670de0b6b3a7640000680133e79f1880bca5ea611eaf565b90505f611cbd826102a4670de0b6b3a7640000671bc16d674ec80000611eaf565b611ccf90670de0b6b3a7640000613478565b90506d35e51921da1a73e8caed30de384d7f01bb2ecac621ca54ea75c5329440ec17993d2f7576a8549d57adaece7d42c554611d17875f676765c793fa10079d601a1b611f49565b9650611d2f865f676765c793fa10079d601a1b611f49565b9550611d47855f676765c793fa10079d601a1b611f49565b9450611d6282655af3107a4000670de0b6b3a7640000611f49565b9150611d7d81655af3107a4000670de0b6b3a7640000611f49565b905084861015611d91575050505050505050565b6040805160048082526024820183526020820180516001600160e01b031663bb55fd2760e01b179052915163f28dceb360e01b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d9263f28dceb392611dee929091016134ca565b5f604051808303815f87803b158015611e05575f80fd5b505af1158015611e17573d5f803e3d5ffd5b5050604051630b9d042360e21b81526001600160a01b038b169250632e74108c915061098f908a908a908a9089908990899060040161348b565b60606015805480602002602001604051908101604052809291908181526020018280548015610a2f57602002820191905f5260205f209081546001600160a01b03168152600190910190602001808311610a11575050505050905090565b5f611ec383670de0b6b3a76400008461235c565b90505b92915050565b5f611ec38383670de0b6b3a764000061235c565b604051630b6903e360e11b8152600481018490526024810183905260448101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d906316d207c6906064015f6040518083038186803b158015611f37575f80fd5b505afa158015610edb573d5f803e3d5ffd5b5f81831115611f905760405162461bcd60e51b815260206004820152600e60248201526d098d2c47440dad2dc407c40dac2f60931b60448201526064015b60405180910390fd5b5f611f9b8484613478565b611fa690600161356b565b90505f611fb38287613690565b9050611fbf858261356b565b9695505050505050565b5f80611ff9611fea611fdc8660646136a3565b66a5bbed86c5a00090611ecc565b6748cd4072281e000090611eaf565b905061200d670de0b6b3a764000082611eaf565b9050612065816102a461203861203361202e89670de0b6b3a764000061356b565b612377565b6123a4565b61205f61203361204d8a8a6301e1338061235c565b61202e90670de0b6b3a764000061356b565b90611eaf565b949350505050565b5f8061207984846125d2565b90925090508061208b5761208b61260d565b5092915050565b60405163f7fe347760e01b815282151560048201528115156024820152737109709ecfa91a80626ff3989d68f67f5b1dd12d9063f7fe3477906044015b5f6040518083038186803b1580156120e5575f80fd5b505afa1580156120f7573d5f803e3d5ffd5b505050505050565b5f6121158261210f85888861235c565b90612626565b95945050505050565b5f805f612132865f0151876020015161206d565b90505f61214d8288604001518960e001518a60a001516120ff565b90505f8061215c898585612686565b90925090505f61216f8a8a8585886128d8565b915050801561218657509094509250612315915050565b5061219389838a86612a0a565b95506121a189878686612ab3565b94505f806121b28b8b8a8a896128d8565b915091508061221d5760405162461bcd60e51b815260206004820152603160248201527f496e697469616c20677565737320696e206063616c63756c6174654d61784c6f6044820152703733b01034b99034b739b7b63b32b73a1760791b6064820152608401611f87565b5f5b8981101561230d578489106122925760405162461bcd60e51b815260206004820152603360248201527f52656163686564206162736f6c757465206d617820626f6e6420616d6f756e746044820152721034b7103033b2ba2fb6b0bc2fb637b733b01760691b6064820152608401611f87565b5f61229f8d8b8a8a612b05565b93509050826122ae575061230d565b5f6122b98583611eaf565b6122c3908c61356b565b90505f6122d28f838c8c612ab3565b90506122e18f8f84848d6128d8565b909650945084156122f757819b50809a506122ff565b50505061230d565b50505080600101905061221f565b505050505050505b935093915050565b604051636d83fe6960e11b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d9063db07fcd2906044016120cf565b5f825f190484118302158202612370575f80fd5b5091020490565b5f6001600160ff1b038211156123a05760405163396ea70160e11b815260040160405180910390fd5b5090565b5f8082136123c55760405163e61b497560e01b815260040160405180910390fd5b506fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff10600390811b90911782811c600f1060021b1782811c909110600190811b90911782811c90911017609f8181036060019290921b91605f198201906124519084901c612377565b6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b391909102017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b5f805f836125df86612377565b6125e991906136ba565b90505f8112156125ff575f809250925050612606565b9150600190505b9250929050565b60405163bb55fd2760e01b815260040160405180910390fd5b5f815f0361263d5750670de0b6b3a7640000611ec6565b825f0361264b57505f611ec6565b5f61265583612377565b90505f61266461203386612377565b905081810261267b670de0b6b3a7640000826136d9565b9050611fbf81612b9c565b5f805f806126ba8688604001518960a00151670de0b6b3a76400006126ab9190613478565b8a60c001518b60e00151612d2e565b905061270a876101400151670de0b6b3a76400006126d89190613478565b612704670de0b6b3a76400006126ee818a612d5c565b6126f89190613478565b6101208b015190612d70565b90612d70565b9150612740876101400151670de0b6b3a76400006127289190613478565b61273a84670de0b6b3a764000061356b565b90612d5c565b60a0880151909250612769906127629061205f81670de0b6b3a7640000613478565b8390612626565b91506127868760e001518860c00151612d5c90919063ffffffff16565b612790908361356b565b915061279c8183611eaf565b91506127cb6127628860a00151670de0b6b3a76400006127bc9190613478565b670de0b6b3a764000090611eaf565b9150505f6127e68760e0015183611eaf90919063ffffffff16565b90505f80612832896101400151670de0b6b3a76400006128069190613478565b6102a4670de0b6b3a764000061281c818c611eaf565b6128269190613478565b6101208d015190611ecc565b9050612888846102a461285a8c60a00151670de0b6b3a7640000612d5c90919063ffffffff16565b61210f8d6101400151670de0b6b3a76400006128769190613478565b61205f87670de0b6b3a764000061356b565b91505061289f8860c0015188846102a49190613478565b94506128b185878a6101200151612d84565b8189604001516128c19190613478565b6128cb9190613478565b9350505050935093915050565b5f805f6128f186858a61012001518b6101600151612db0565b90505f61290b8960c0015183611eaf90919063ffffffff16565b60c08a015161291b908990611eaf565b8a51612927919061356b565b6129319190613478565b90505f868a60800151612944919061356b565b90505f6129518a82612dc4565b61295a90613705565b90508a61010001516129798c60c0015184611eaf90919063ffffffff16565b612983919061356b565b60c08c0151612993908390611eaf565b61299d908561356b565b106129f5576101008b015160c08c01516129b8908490611eaf565b60c08d01516129c8908490611eaf565b6129d2908661356b565b6129dc9190613478565b6129e69190613478565b60019550955050505050612a00565b5f8095509550505050505b9550959350505050565b5f80612a1886858586612dd8565b90505f612a5e670b1a2bc2ec5000006102a4612a548a60a00151670de0b6b3a7640000612a459190613478565b670de0b6b3a764000090612d5c565b61210f868b611eaf565b90505f612a73670de0b6b3a764000083611ecc565b612a8f612a8884670de0b6b3a7640000613478565b8790611ecc565b612a99919061356b565b9050612aa788878784612dd8565b98975050505050505050565b5f80612ae9848760400151612ad58960c0015189611eaf90919063ffffffff16565b8960a001518a60c001518b60e00151612ef7565b9050612afb8584886101200151612d84565b611fbf9082613478565b5f80612b1386868686612f17565b909250905080612b25575f9150612b93565b612b4f612b3a84670de0b6b3a7640000613478565b6101208801516101608901516102a491611ecc565b612b59908361356b565b9150612b6d670de0b6b3a764000083613478565b9150612b90670de0b6b3a76400008760c001518461235c9092919063ffffffff16565b91505b94509492505050565b5f680248ce36a70cb26b3e198213612bb557505f919050565b680755bf798b4a1bf1e58212612bde576040516373a2d6b160e01b815260040160405180910390fd5b6503782dace9d9604e83901b0591505f60606bb17217f7d1cf79abc9e3b39884821b056001605f1b01901d6bb17217f7d1cf79abc9e3b3988102909303926c240c330e9fb2d9cbaf0fd5aafb1984018402606090811d6d0277594991cfc85f6e2461837cd9018502811d6d1a521255e34f6a5061b25ef1c9c319018502811d6db1bbb201f443cf962f1a1d3db4a5018502811d6e02c72388d9f74f51a9331fed693f1419018502811d6e05180bb14799ab47a8a8cb2a527d57016d02d16720577bd19bf614176fe9ea6c10fe68e7fd37d0007b713f765087018702831d9081019087016d01d3967ed30fc4f89c02bab570811901810290921d6e0587f503bb6ea29d25fcb7401964500186026d360d7aeea093263ecc6e0ecb291760621b018181059550929350909190611fbf74029d9dc38563c32e5c2f6dc192ee70ef65f9978af3860260c38690031c612377565b5f612d398585612626565b612d52612d4a8661210f868b611ecc565b85908561235c565b611fbf919061356b565b5f611ec383670de0b6b3a764000084613061565b5f611ec38383670de0b6b3a7640000613061565b5f61206584612704670de0b6b3a7640000612d9f8188612d5c565b612da99190613478565b8590612d70565b5f612115846102a4846102a4898989612d84565b5f818313612dd25782611ec3565b50919050565b5f80612de48582612dc4565b612ded90613705565b90505f612e598760c00151671bc16d674ec80000896101000151612e228b60c001518c60800151611eaf90919063ffffffff16565b60c08c0151612e32908890611eaf565b8c51612e3e919061356b565b612e489190613478565b612e529190613478565b919061235c565b9050612eec612e8a670de0b6b3a7640000612e748189611eaf565b612e7e9190613478565b6101208a015190611ecc565b670de0b6b3a7640000612eb5612ea08983613478565b6101208c01516101608d01516102a491611ecc565b612ec7670de0b6b3a764000089611eaf565b612ed1919061356b565b612edb9190613478565b612ee59190613478565b8290611eaf565b979650505050505050565b5f612eec878787612f1088670de0b6b3a7640000613478565b8787613084565b5f805f612f318760c0015187611eaf90919063ffffffff16565b90505f612f4c612f41838861356b565b60e08a015190611ecc565b90505f612f7f878a604001518b60a00151670de0b6b3a7640000612f709190613478565b8c60c001518d60e00151612d2e565b9050612f9b6127bc8a60a001518461262690919063ffffffff16565b94505f612fc9612fb88b60a001518561262690919063ffffffff16565b60e08c015160c08d0151919061235c565b905080821015612fe2575f809550955050505050612b93565b613018612a8861300e8c60a00151670de0b6b3a76400006130039190613478565b60a08e015190612d5c565b61210f8486613478565b9550613046670de0b6b3a7640000613030818a611eaf565b61303a9190613478565b6101208c015190611ecc565b6130509087613478565b9a60019a5098505050505050505050565b5f825f190484118302158202613075575f80fd5b50910281810615159190040190565b5f806130948888888888886130b1565b9092509050806130a6576130a661260d565b509695505050505050565b5f805f6130c1898988888861316e565b90506130d48661210f612a888a8d61356b565b98506130e1858a8661235c565b9850888110156130f7575f809250925050613163565b888103670de0b6b3a7640000811061312c5761312561311e670de0b6b3a764000089612d5c565b8290612626565b9050613144565b61314161311e670de0b6b3a764000089611eaf565b90505b80891015613159575f80935093505050613163565b8803925060019150505b965096945050505050565b5f6131798585612626565b612d5261318a8661210f868b612d70565b859085613061565b610f7f8061372083390190565b602080825282518282018190525f9190848201906040850190845b818110156131df5783516001600160a01b0316835292840192918401916001016131ba565b50909695505050505050565b5f81518084525f5b8181101561320f576020818501810151868301820152016131f3565b505f602082860101526020601f19601f83011685010191505092915050565b602080825282518282018190525f919060409081850190600581811b87018401888601875b848110156132dc57603f198a8403018652815180516001600160a01b03168452880151888401889052805188850181905290890190606081871b8601810191908601905f5b818110156132c657605f198885030183526132b48486516131eb565b948d01949350918c0191600101613298565b5050509689019693505090870190600101613253565b50909998505050505050505050565b5f805f80608085870312156132fe575f80fd5b5050823594602084013594506040840135936060013592509050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156133bd57888303603f19018552815180516001600160a01b031684528701518784018790528051878501819052908801905f9060608601905b808310156133a85783516001600160e01b0319168252928a019260019290920191908a019061337e565b50968901969450505090860190600101613341565b509098975050505050505050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101561342057603f1988860301845261340e8583516131eb565b945092850192908501906001016133f2565b5092979650505050505050565b5f805f805f60a08688031215613441575f80fd5b505083359560208501359550604085013594606081013594506080013592509050565b634e487b7160e01b5f52601160045260245ffd5b81810381811115611ec657611ec6613464565b958652602086019490945260408501929092526060840152608083015260a082015260c00190565b5f602082840312156134c3575f80fd5b5051919050565b602081525f611ec360208301846131eb565b600181811c908216806134f057607f821691505b602082108103612dd257634e487b7160e01b5f52602260045260245ffd5b5f805f60608486031215613520575f80fd5b8351925060208401519150604084015190509250925092565b5f806040838503121561354a575f80fd5b8251915060208301518015158114613560575f80fd5b809150509250929050565b80820180821115611ec657611ec6613464565b600181815b808511156135b857815f190482111561359e5761359e613464565b808516156135ab57918102915b93841c9390800290613583565b509250929050565b5f826135ce57506001611ec6565b816135da57505f611ec6565b81600181146135f057600281146135fa57613616565b6001915050611ec6565b60ff84111561360b5761360b613464565b50506001821b611ec6565b5060208310610133831016604e8410600b8410161715613639575081810a611ec6565b613643838361357e565b805f190482111561365657613656613464565b029392505050565b5f611ec383836135c0565b634e487b7160e01b5f52601260045260245ffd5b5f8261368b5761368b613669565b500490565b5f8261369e5761369e613669565b500690565b8082028115828204841417611ec657611ec6613464565b8181035f83128015838313168383128216171561208b5761208b613464565b5f826136e7576136e7613669565b600160ff1b82145f198414161561370057613700613464565b500590565b5f600160ff1b820161371957613719613464565b505f039056fe608060405234801561000f575f80fd5b50610f628061001d5f395ff3fe608060405234801561000f575f80fd5b506004361061009b575f3560e01c806386c85e101161006357806386c85e1014610126578063a4a6f9d914610139578063a9afa3731461014c578063bc50ebe61461015f578063d79d083514610172575f80fd5b80630aea75631461009f57806327d0e265146100c55780632e74108c146100d85780633ee4114a146100eb5780635880b9fd14610113575b5f80fd5b6100b26100ad366004610dd0565b610185565b6040519081526020015b60405180910390f35b6100b26100d3366004610e07565b61019f565b6100b26100e6366004610e07565b6101bb565b6100fe6100f9366004610e07565b6101cb565b604080519283529015156020830152016100bc565b6100fe610121366004610dd0565b6101f0565b6100b2610134366004610e07565b610213565b6100b2610147366004610e07565b610223565b6100fe61015a366004610dd0565b610233565b6100fe61016d366004610e46565b610244565b6100b2610180366004610dd0565b61026b565b5f80610194878787878761027a565b979650505050505050565b5f806101af8888888888886102b8565b98975050505050505050565b5f806101af8888888888886102e5565b5f805f806101dd8a8a8a8a8a8a6102f5565b909450925050505b965096945050505050565b5f805f8061020189898989896103b8565b909450925050505b9550959350505050565b5f806101af88888888888861046a565b5f806101af88888888888861047a565b5f805f80610201898989898961053a565b5f805f806102578b8b8b8b8b8b8b6105df565b909450925050505b97509795505050505050565b5f8061019487878787876106d9565b5f61028585856106fd565b6102a461029c86610296868b61076e565b906106fd565b859085610789565b6102ae9190610ea1565b9695505050505050565b5f806102c88888888888886102f5565b9092509050806102da576102da6107ac565b509695505050505050565b5f806102c88888888888886107c5565b5f805f610305898988888861027a565b905061031586610296898b610ea1565b97508781101561032b575f8092509250506101e5565b878103610339818688610789565b9050670de0b6b3a7640000811061036d5761036661035f670de0b6b3a764000089610897565b82906106fd565b9050610385565b61038261035f670de0b6b3a7640000896108ab565b90505b61038f8186610897565b9050808a10156103a6575f809350935050506101e5565b90980398600198509650505050505050565b5f805f6103c888888888886106d9565b90505f6103f2670de0b6b3a76400006103e18888610897565b6103eb9190610ea1565b83906108ab565b9050670de0b6b3a7640000811061041f5761041861035f670de0b6b3a7640000896108ab565b9050610437565b61043461035f670de0b6b3a764000089610897565b90505b61044181866108ab565b905088811015610458575f80935093505050610209565b97909703976001975095505050505050565b5f806102c88888888888886108bf565b5f8061048988888787876106d9565b90508587101561049b5761049b6107ac565b95859003956104aa87866106fd565b9650868110156104bc576104bc6107ac565b8681036104ca818587610979565b9050670de0b6b3a764000081106104f7576104f061035f670de0b6b3a7640000886108ab565b905061050f565b61050c61035f670de0b6b3a764000088610897565b90505b61051981856108ab565b90508881101561052b5761052b6107ac565b97909703979650505050505050565b5f805f61054a888888888861027a565b90505f610574670de0b6b3a764000061056388886108ab565b61056d9190610ea1565b8390610897565b9050670de0b6b3a764000081106105a15761059a61035f670de0b6b3a764000089610897565b90506105b9565b6105b661035f670de0b6b3a7640000896108ab565b90505b808810156105ce575f80935093505050610209565b909603976001975095505050505050565b5f805f8812156105ff576105f288610eb4565b6105fc9087610ea1565b95505b5f8061060b8b8b610994565b9150915080610621575f8093509350505061025f565b5f61062f838b8a8a8a6106d9565b90505f61064b6106438a6102968a8e61076e565b899089610789565b905080821015610664575f80955095505050505061025f565b808203670de0b6b3a764000081106106925761068b61035f670de0b6b3a76400008c6108ab565b90506106aa565b6106a761035f670de0b6b3a76400008c610897565b90505b8b8110156106c2575f8096509650505050505061025f565b9a909a039c60019c509a5050505050505050505050565b5f6106e485856106fd565b6102a46106f586610296868b6109cf565b859085610979565b5f815f036107145750670de0b6b3a7640000610768565b825f0361072257505f610768565b5f61072c836109e3565b90505f61074061073b866109e3565b610a10565b9050818102610757670de0b6b3a764000082610ece565b905061076281610c3e565b93505050505b92915050565b5f6107828383670de0b6b3a7640000610789565b9392505050565b5f825f19048411830215820261079d575f80fd5b50910281810615159190040190565b60405163bb55fd2760e01b815260040160405180910390fd5b5f805f6107d5898988888861027a565b9050868810156107eb575f8092509250506101e5565b96869003966107fa88876106fd565b975087811015610810575f8092509250506101e5565b87810361081e818688610789565b9050670de0b6b3a7640000811061084b5761084461035f670de0b6b3a764000089610897565b9050610863565b61086061035f670de0b6b3a7640000896108ab565b90505b61086d8186610897565b905089811015610884575f809350935050506101e5565b9890980398600198509650505050505050565b5f61078283670de0b6b3a764000084610789565b5f61078283670de0b6b3a764000084610979565b5f805f6108cf898988888861027a565b90506108e9866102966108e28a8d610ea1565b87906109cf565b98506108f6858a86610979565b98508881101561090c575f8092509250506101e5565b888103670de0b6b3a7640000811061093a5761093361035f670de0b6b3a764000089610897565b9050610952565b61094f61035f670de0b6b3a7640000896108ab565b90505b80891015610967575f809350935050506101e5565b90970398600198509650505050505050565b5f825f19048411830215820261098d575f80fd5b5091020490565b5f805f836109a1866109e3565b6109ab9190610f06565b90505f8112156109c1575f8092509250506109c8565b9150600190505b9250929050565b5f6107828383670de0b6b3a7640000610979565b5f6001600160ff1b03821115610a0c5760405163396ea70160e11b815260040160405180910390fd5b5090565b5f808213610a315760405163e61b497560e01b815260040160405180910390fd5b506fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff10600390811b90911782811c600f1060021b1782811c909110600190811b90911782811c90911017609f8181036060019290921b91605f19820190610abd9084901c6109e3565b6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b391909102017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b5f680248ce36a70cb26b3e198213610c5757505f919050565b680755bf798b4a1bf1e58212610c80576040516373a2d6b160e01b815260040160405180910390fd5b6503782dace9d9604e83901b0591505f60606bb17217f7d1cf79abc9e3b39884821b056001605f1b01901d6bb17217f7d1cf79abc9e3b3988102909303926c240c330e9fb2d9cbaf0fd5aafb1984018402606090811d6d0277594991cfc85f6e2461837cd9018502811d6d1a521255e34f6a5061b25ef1c9c319018502811d6db1bbb201f443cf962f1a1d3db4a5018502811d6e02c72388d9f74f51a9331fed693f1419018502811d6e05180bb14799ab47a8a8cb2a527d57016d02d16720577bd19bf614176fe9ea6c10fe68e7fd37d0007b713f765087018702831d9081019087016d01d3967ed30fc4f89c02bab570811901810290921d6e0587f503bb6ea29d25fcb7401964500186026d360d7aeea093263ecc6e0ecb291760621b0181810595509293509091906102ae74029d9dc38563c32e5c2f6dc192ee70ef65f9978af3860260c38690031c6109e3565b5f805f805f60a08688031215610de4575f80fd5b505083359560208501359550604085013594606081013594506080013592509050565b5f805f805f8060c08789031215610e1c575f80fd5b505084359660208601359650604086013595606081013595506080810135945060a0013592509050565b5f805f805f805f60e0888a031215610e5c575f80fd5b505085359760208701359750604087013596606081013596506080810135955060a0810135945060c0013592509050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561076857610768610e8d565b5f600160ff1b8201610ec857610ec8610e8d565b505f0390565b5f82610ee857634e487b7160e01b5f52601260045260245ffd5b600160ff1b82145f1984141615610f0157610f01610e8d565b500590565b8181035f831280158383131683831282161715610f2557610f25610e8d565b509291505056fea2646970667358221220b9a162b0fe14e64a98361791311be2a81b8d6e883996eba9395fe7c01b2950b564736f6c63430008180033a26469706673582212204722a351a5b67819bc5ff286bf7a0261f3c5af064925a9fb5a4f18613ed74bcd64736f6c63430008180033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = YieldSpaceMathTestContractFunctions(yieldspacemathtest_abi, self.w3, address)  # type: ignore
        self.events = YieldSpaceMathTestContractEvents(yieldspacemathtest_abi, self.w3, address)  # type: ignore
        self.errors = YieldSpaceMathTestContractErrors()

    events: YieldSpaceMathTestContractEvents

    errors: YieldSpaceMathTestContractErrors = (
        YieldSpaceMathTestContractErrors()
    )

    functions: YieldSpaceMathTestContractFunctions

    class LinkReferences(NamedTuple):
        """Link references required when deploying."""

        LPMath: LPMathContract

    link_references_placeholder_lookup: dict[str, str] = {
        "LPMath": "__$2b4fa6f02a36eedfe41c65e8dd342257d3$__",
    }

    @classmethod
    def constructor(cls, link_references: LinkReferences) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            cls.bytecode = cls.bytecode.replace(
                cls.link_references_placeholder_lookup["LPMath"],
                link_references.LPMath.address[2:].lower(),
            )

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(
        cls,
        w3: Web3,
        account: LocalAccount | ChecksumAddress,
        link_references: LinkReferences,
    ) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor(link_references)

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = YieldSpaceMathTestContractFunctions(
            yieldspacemathtest_abi, w3, None
        )
        contract.errors = YieldSpaceMathTestContractErrors()

        return contract
