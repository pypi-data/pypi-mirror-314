"""A web3.py Contract class for the HyperdriveMatchingEngine contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    BaseEventArgs,
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..IHyperdrive import IHyperdriveTypes as IHyperdrive
from ..IHyperdriveMatchingEngine import (
    IHyperdriveMatchingEngineTypes as IHyperdriveMatchingEngine,
)
from .HyperdriveMatchingEngineTypes import (
    EIP712DomainChangedEvent,
    OrdersCancelledEvent,
    OrdersMatchedEvent,
)

structs = {
    "IHyperdrive.Options": IHyperdrive.Options,
    "IHyperdriveMatchingEngine.OrderIntent": IHyperdriveMatchingEngine.OrderIntent,
}

hyperdrivematchingengine_abi: ABI = cast(
    ABI,
    [
        {
            "type": "constructor",
            "inputs": [
                {"name": "_name", "type": "string", "internalType": "string"},
                {
                    "name": "_morpho",
                    "type": "address",
                    "internalType": "contract IMorpho",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "OPTIONS_TYPEHASH",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "ORDER_INTENT_TYPEHASH",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "cancelOrders",
            "inputs": [
                {
                    "name": "_orders",
                    "type": "tuple[]",
                    "internalType": "struct IHyperdriveMatchingEngine.OrderIntent[]",
                    "components": [
                        {
                            "name": "trader",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "hyperdrive",
                            "type": "address",
                            "internalType": "contract IHyperdrive",
                        },
                        {
                            "name": "amount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "slippageGuard",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "minVaultSharePrice",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "options",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Options",
                            "components": [
                                {
                                    "name": "destination",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "asBase",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                                {
                                    "name": "extraData",
                                    "type": "bytes",
                                    "internalType": "bytes",
                                },
                            ],
                        },
                        {
                            "name": "orderType",
                            "type": "uint8",
                            "internalType": "enum IHyperdriveMatchingEngine.OrderType",
                        },
                        {
                            "name": "signature",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "expiry",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "salt",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                    ],
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "eip712Domain",
            "inputs": [],
            "outputs": [
                {"name": "fields", "type": "bytes1", "internalType": "bytes1"},
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "version", "type": "string", "internalType": "string"},
                {
                    "name": "chainId",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "verifyingContract",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "salt", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "extensions",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "hashOrderIntent",
            "inputs": [
                {
                    "name": "_order",
                    "type": "tuple",
                    "internalType": "struct IHyperdriveMatchingEngine.OrderIntent",
                    "components": [
                        {
                            "name": "trader",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "hyperdrive",
                            "type": "address",
                            "internalType": "contract IHyperdrive",
                        },
                        {
                            "name": "amount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "slippageGuard",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "minVaultSharePrice",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "options",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Options",
                            "components": [
                                {
                                    "name": "destination",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "asBase",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                                {
                                    "name": "extraData",
                                    "type": "bytes",
                                    "internalType": "bytes",
                                },
                            ],
                        },
                        {
                            "name": "orderType",
                            "type": "uint8",
                            "internalType": "enum IHyperdriveMatchingEngine.OrderType",
                        },
                        {
                            "name": "signature",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "expiry",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "salt",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                    ],
                }
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "isCancelled",
            "inputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "kind",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "matchOrders",
            "inputs": [
                {
                    "name": "_longOrder",
                    "type": "tuple",
                    "internalType": "struct IHyperdriveMatchingEngine.OrderIntent",
                    "components": [
                        {
                            "name": "trader",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "hyperdrive",
                            "type": "address",
                            "internalType": "contract IHyperdrive",
                        },
                        {
                            "name": "amount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "slippageGuard",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "minVaultSharePrice",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "options",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Options",
                            "components": [
                                {
                                    "name": "destination",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "asBase",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                                {
                                    "name": "extraData",
                                    "type": "bytes",
                                    "internalType": "bytes",
                                },
                            ],
                        },
                        {
                            "name": "orderType",
                            "type": "uint8",
                            "internalType": "enum IHyperdriveMatchingEngine.OrderType",
                        },
                        {
                            "name": "signature",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "expiry",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "salt",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                    ],
                },
                {
                    "name": "_shortOrder",
                    "type": "tuple",
                    "internalType": "struct IHyperdriveMatchingEngine.OrderIntent",
                    "components": [
                        {
                            "name": "trader",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "hyperdrive",
                            "type": "address",
                            "internalType": "contract IHyperdrive",
                        },
                        {
                            "name": "amount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "slippageGuard",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "minVaultSharePrice",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "options",
                            "type": "tuple",
                            "internalType": "struct IHyperdrive.Options",
                            "components": [
                                {
                                    "name": "destination",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "asBase",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                                {
                                    "name": "extraData",
                                    "type": "bytes",
                                    "internalType": "bytes",
                                },
                            ],
                        },
                        {
                            "name": "orderType",
                            "type": "uint8",
                            "internalType": "enum IHyperdriveMatchingEngine.OrderType",
                        },
                        {
                            "name": "signature",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "expiry",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "salt",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                    ],
                },
                {
                    "name": "_lpAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_addLiquidityOptions",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_removeLiquidityOptions",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_feeRecipient",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "_isLongFirst",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "morpho",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IMorpho",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "onMorphoFlashLoan",
            "inputs": [
                {
                    "name": "_lpAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "_data", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "verifySignature",
            "inputs": [
                {"name": "_hash", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "_signature",
                    "type": "bytes",
                    "internalType": "bytes",
                },
                {
                    "name": "_signer",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "version",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "event",
            "name": "EIP712DomainChanged",
            "inputs": [],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OrdersCancelled",
            "inputs": [
                {
                    "name": "trader",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "orderHashes",
                    "type": "bytes32[]",
                    "indexed": False,
                    "internalType": "bytes32[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "OrdersMatched",
            "inputs": [
                {
                    "name": "hyperdrive",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "longOrderHash",
                    "type": "bytes32",
                    "indexed": True,
                    "internalType": "bytes32",
                },
                {
                    "name": "shortOrderHash",
                    "type": "bytes32",
                    "indexed": True,
                    "internalType": "bytes32",
                },
                {
                    "name": "long",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "short",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "error",
            "name": "AddressEmptyCode",
            "inputs": [
                {"name": "target", "type": "address", "internalType": "address"}
            ],
        },
        {
            "type": "error",
            "name": "AddressInsufficientBalance",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
        },
        {"type": "error", "name": "AlreadyCancelled", "inputs": []},
        {"type": "error", "name": "AlreadyExpired", "inputs": []},
        {"type": "error", "name": "ECDSAInvalidSignature", "inputs": []},
        {
            "type": "error",
            "name": "ECDSAInvalidSignatureLength",
            "inputs": [
                {"name": "length", "type": "uint256", "internalType": "uint256"}
            ],
        },
        {
            "type": "error",
            "name": "ECDSAInvalidSignatureS",
            "inputs": [
                {"name": "s", "type": "bytes32", "internalType": "bytes32"}
            ],
        },
        {"type": "error", "name": "FailedInnerCall", "inputs": []},
        {"type": "error", "name": "InvalidDestination", "inputs": []},
        {"type": "error", "name": "InvalidMatch", "inputs": []},
        {"type": "error", "name": "InvalidOrderType", "inputs": []},
        {"type": "error", "name": "InvalidSender", "inputs": []},
        {"type": "error", "name": "InvalidSettlementAsset", "inputs": []},
        {"type": "error", "name": "InvalidShortString", "inputs": []},
        {"type": "error", "name": "InvalidSignature", "inputs": []},
        {"type": "error", "name": "MismatchedHyperdrive", "inputs": []},
        {"type": "error", "name": "ReentrancyGuardReentrantCall", "inputs": []},
        {
            "type": "error",
            "name": "SafeERC20FailedOperation",
            "inputs": [
                {"name": "token", "type": "address", "internalType": "address"}
            ],
        },
        {
            "type": "error",
            "name": "StringTooLong",
            "inputs": [
                {"name": "str", "type": "string", "internalType": "string"}
            ],
        },
    ],
)


class HyperdriveMatchingEngineAddressEmptyCodeContractError(PypechainBaseError):
    """ContractError for AddressEmptyCode."""

    # Error name
    name: str = "AddressEmptyCode"
    # 4 byte error selector
    selector: str = "0x9996b315"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "AddressEmptyCode(address)"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineAddressInsufficientBalanceContractError(
    PypechainBaseError
):
    """ContractError for AddressInsufficientBalance."""

    # Error name
    name: str = "AddressInsufficientBalance"
    # 4 byte error selector
    selector: str = "0xcd786059"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "AddressInsufficientBalance(address)"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineAlreadyCancelledContractError(PypechainBaseError):
    """ContractError for AlreadyCancelled."""

    # Error name
    name: str = "AlreadyCancelled"
    # 4 byte error selector
    selector: str = "0x54e37625"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "AlreadyCancelled()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineAlreadyExpiredContractError(PypechainBaseError):
    """ContractError for AlreadyExpired."""

    # Error name
    name: str = "AlreadyExpired"
    # 4 byte error selector
    selector: str = "0xa0d64f8a"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "AlreadyExpired()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineECDSAInvalidSignatureContractError(
    PypechainBaseError
):
    """ContractError for ECDSAInvalidSignature."""

    # Error name
    name: str = "ECDSAInvalidSignature"
    # 4 byte error selector
    selector: str = "0xf645eedf"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ECDSAInvalidSignature()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineECDSAInvalidSignatureLengthContractError(
    PypechainBaseError
):
    """ContractError for ECDSAInvalidSignatureLength."""

    # Error name
    name: str = "ECDSAInvalidSignatureLength"
    # 4 byte error selector
    selector: str = "0xfce698f7"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ECDSAInvalidSignatureLength(uint256)"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineECDSAInvalidSignatureSContractError(
    PypechainBaseError
):
    """ContractError for ECDSAInvalidSignatureS."""

    # Error name
    name: str = "ECDSAInvalidSignatureS"
    # 4 byte error selector
    selector: str = "0xd78bce0c"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ECDSAInvalidSignatureS(bytes32)"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineFailedInnerCallContractError(PypechainBaseError):
    """ContractError for FailedInnerCall."""

    # Error name
    name: str = "FailedInnerCall"
    # 4 byte error selector
    selector: str = "0x1425ea42"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "FailedInnerCall()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineInvalidDestinationContractError(
    PypechainBaseError
):
    """ContractError for InvalidDestination."""

    # Error name
    name: str = "InvalidDestination"
    # 4 byte error selector
    selector: str = "0xac6b05f5"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidDestination()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineInvalidMatchContractError(PypechainBaseError):
    """ContractError for InvalidMatch."""

    # Error name
    name: str = "InvalidMatch"
    # 4 byte error selector
    selector: str = "0x29ac473e"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidMatch()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineInvalidOrderTypeContractError(PypechainBaseError):
    """ContractError for InvalidOrderType."""

    # Error name
    name: str = "InvalidOrderType"
    # 4 byte error selector
    selector: str = "0x688c176f"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidOrderType()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineInvalidSenderContractError(PypechainBaseError):
    """ContractError for InvalidSender."""

    # Error name
    name: str = "InvalidSender"
    # 4 byte error selector
    selector: str = "0xddb5de5e"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidSender()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineInvalidSettlementAssetContractError(
    PypechainBaseError
):
    """ContractError for InvalidSettlementAsset."""

    # Error name
    name: str = "InvalidSettlementAsset"
    # 4 byte error selector
    selector: str = "0xabca264a"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidSettlementAsset()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineInvalidShortStringContractError(
    PypechainBaseError
):
    """ContractError for InvalidShortString."""

    # Error name
    name: str = "InvalidShortString"
    # 4 byte error selector
    selector: str = "0xb3512b0c"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidShortString()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineInvalidSignatureContractError(PypechainBaseError):
    """ContractError for InvalidSignature."""

    # Error name
    name: str = "InvalidSignature"
    # 4 byte error selector
    selector: str = "0x8baa579f"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidSignature()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineMismatchedHyperdriveContractError(
    PypechainBaseError
):
    """ContractError for MismatchedHyperdrive."""

    # Error name
    name: str = "MismatchedHyperdrive"
    # 4 byte error selector
    selector: str = "0x4cf1ffa4"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "MismatchedHyperdrive()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineReentrancyGuardReentrantCallContractError(
    PypechainBaseError
):
    """ContractError for ReentrancyGuardReentrantCall."""

    # Error name
    name: str = "ReentrancyGuardReentrantCall"
    # 4 byte error selector
    selector: str = "0x3ee5aeb5"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ReentrancyGuardReentrantCall()"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineSafeERC20FailedOperationContractError(
    PypechainBaseError
):
    """ContractError for SafeERC20FailedOperation."""

    # Error name
    name: str = "SafeERC20FailedOperation"
    # 4 byte error selector
    selector: str = "0x5274afe7"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "SafeERC20FailedOperation(address)"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineStringTooLongContractError(PypechainBaseError):
    """ContractError for StringTooLong."""

    # Error name
    name: str = "StringTooLong"
    # 4 byte error selector
    selector: str = "0x305a27a9"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "StringTooLong(string)"
    # Error input types
    abi: ABI = hyperdrivematchingengine_abi


class HyperdriveMatchingEngineContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the HyperdriveMatchingEngine contract."""

    AddressEmptyCode: HyperdriveMatchingEngineAddressEmptyCodeContractError

    AddressInsufficientBalance: (
        HyperdriveMatchingEngineAddressInsufficientBalanceContractError
    )

    AlreadyCancelled: HyperdriveMatchingEngineAlreadyCancelledContractError

    AlreadyExpired: HyperdriveMatchingEngineAlreadyExpiredContractError

    ECDSAInvalidSignature: (
        HyperdriveMatchingEngineECDSAInvalidSignatureContractError
    )

    ECDSAInvalidSignatureLength: (
        HyperdriveMatchingEngineECDSAInvalidSignatureLengthContractError
    )

    ECDSAInvalidSignatureS: (
        HyperdriveMatchingEngineECDSAInvalidSignatureSContractError
    )

    FailedInnerCall: HyperdriveMatchingEngineFailedInnerCallContractError

    InvalidDestination: HyperdriveMatchingEngineInvalidDestinationContractError

    InvalidMatch: HyperdriveMatchingEngineInvalidMatchContractError

    InvalidOrderType: HyperdriveMatchingEngineInvalidOrderTypeContractError

    InvalidSender: HyperdriveMatchingEngineInvalidSenderContractError

    InvalidSettlementAsset: (
        HyperdriveMatchingEngineInvalidSettlementAssetContractError
    )

    InvalidShortString: HyperdriveMatchingEngineInvalidShortStringContractError

    InvalidSignature: HyperdriveMatchingEngineInvalidSignatureContractError

    MismatchedHyperdrive: (
        HyperdriveMatchingEngineMismatchedHyperdriveContractError
    )

    ReentrancyGuardReentrantCall: (
        HyperdriveMatchingEngineReentrancyGuardReentrantCallContractError
    )

    SafeERC20FailedOperation: (
        HyperdriveMatchingEngineSafeERC20FailedOperationContractError
    )

    StringTooLong: HyperdriveMatchingEngineStringTooLongContractError

    def __init__(
        self,
    ) -> None:
        self.AddressEmptyCode = (
            HyperdriveMatchingEngineAddressEmptyCodeContractError()
        )
        self.AddressInsufficientBalance = (
            HyperdriveMatchingEngineAddressInsufficientBalanceContractError()
        )
        self.AlreadyCancelled = (
            HyperdriveMatchingEngineAlreadyCancelledContractError()
        )
        self.AlreadyExpired = (
            HyperdriveMatchingEngineAlreadyExpiredContractError()
        )
        self.ECDSAInvalidSignature = (
            HyperdriveMatchingEngineECDSAInvalidSignatureContractError()
        )
        self.ECDSAInvalidSignatureLength = (
            HyperdriveMatchingEngineECDSAInvalidSignatureLengthContractError()
        )
        self.ECDSAInvalidSignatureS = (
            HyperdriveMatchingEngineECDSAInvalidSignatureSContractError()
        )
        self.FailedInnerCall = (
            HyperdriveMatchingEngineFailedInnerCallContractError()
        )
        self.InvalidDestination = (
            HyperdriveMatchingEngineInvalidDestinationContractError()
        )
        self.InvalidMatch = HyperdriveMatchingEngineInvalidMatchContractError()
        self.InvalidOrderType = (
            HyperdriveMatchingEngineInvalidOrderTypeContractError()
        )
        self.InvalidSender = (
            HyperdriveMatchingEngineInvalidSenderContractError()
        )
        self.InvalidSettlementAsset = (
            HyperdriveMatchingEngineInvalidSettlementAssetContractError()
        )
        self.InvalidShortString = (
            HyperdriveMatchingEngineInvalidShortStringContractError()
        )
        self.InvalidSignature = (
            HyperdriveMatchingEngineInvalidSignatureContractError()
        )
        self.MismatchedHyperdrive = (
            HyperdriveMatchingEngineMismatchedHyperdriveContractError()
        )
        self.ReentrancyGuardReentrantCall = (
            HyperdriveMatchingEngineReentrancyGuardReentrantCallContractError()
        )
        self.SafeERC20FailedOperation = (
            HyperdriveMatchingEngineSafeERC20FailedOperationContractError()
        )
        self.StringTooLong = (
            HyperdriveMatchingEngineStringTooLongContractError()
        )

        self._all = [
            self.AddressEmptyCode,
            self.AddressInsufficientBalance,
            self.AlreadyCancelled,
            self.AlreadyExpired,
            self.ECDSAInvalidSignature,
            self.ECDSAInvalidSignatureLength,
            self.ECDSAInvalidSignatureS,
            self.FailedInnerCall,
            self.InvalidDestination,
            self.InvalidMatch,
            self.InvalidOrderType,
            self.InvalidSender,
            self.InvalidSettlementAsset,
            self.InvalidShortString,
            self.InvalidSignature,
            self.MismatchedHyperdrive,
            self.ReentrancyGuardReentrantCall,
            self.SafeERC20FailedOperation,
            self.StringTooLong,
        ]


class HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the OPTIONS_TYPEHASH() method."""

    _function_name = "OPTIONS_TYPEHASH"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the OPTIONS_TYPEHASH method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "OPTIONS_TYPEHASH"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction0._type_signature: HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction0,
        }
        return out


class HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the ORDER_INTENT_TYPEHASH() method."""

    _function_name = "ORDER_INTENT_TYPEHASH"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the ORDER_INTENT_TYPEHASH method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ORDER_INTENT_TYPEHASH"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction0._type_signature: HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction0,
        }
        return out


class HyperdriveMatchingEngineCancelOrdersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the cancelOrders(list[IHyperdriveMatchingEngine.OrderIntent]) method."""

    _function_name = "cancelOrders"
    _type_signature = expand_struct_type_str(
        tuple(["list[IHyperdriveMatchingEngine.OrderIntent]"]), structs
    )
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveMatchingEngineCancelOrdersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the cancelOrders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "cancelOrders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _orders: list[IHyperdriveMatchingEngine.OrderIntent]) -> HyperdriveMatchingEngineCancelOrdersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineCancelOrdersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineCancelOrdersContractFunction0._type_signature: HyperdriveMatchingEngineCancelOrdersContractFunction0,
        }
        return out


class HyperdriveMatchingEngineEip712DomainContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the eip712Domain() method."""

    _function_name = "eip712Domain"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Eip712Domain."""

        fields: bytes
        name: str
        version: str
        chainId: int
        verifyingContract: str
        salt: bytes
        extensions: list[int]

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [bytes, str, str, int, str, bytes, list[int]]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineEip712DomainContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the eip712Domain method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "eip712Domain"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveMatchingEngineEip712DomainContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineEip712DomainContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineEip712DomainContractFunction0._type_signature: HyperdriveMatchingEngineEip712DomainContractFunction0,
        }
        return out


class HyperdriveMatchingEngineHashOrderIntentContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the hashOrderIntent(IHyperdriveMatchingEngine.OrderIntent) method."""

    _function_name = "hashOrderIntent"
    _type_signature = expand_struct_type_str(
        tuple(["IHyperdriveMatchingEngine.OrderIntent"]), structs
    )
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineHashOrderIntentContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the hashOrderIntent method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "hashOrderIntent"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _order: IHyperdriveMatchingEngine.OrderIntent) -> HyperdriveMatchingEngineHashOrderIntentContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineHashOrderIntentContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineHashOrderIntentContractFunction0._type_signature: HyperdriveMatchingEngineHashOrderIntentContractFunction0,
        }
        return out


class HyperdriveMatchingEngineIsCancelledContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the isCancelled(bytes) method."""

    _function_name = "isCancelled"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineIsCancelledContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the isCancelled method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isCancelled"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: bytes) -> HyperdriveMatchingEngineIsCancelledContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineIsCancelledContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineIsCancelledContractFunction0._type_signature: HyperdriveMatchingEngineIsCancelledContractFunction0,
        }
        return out


class HyperdriveMatchingEngineKindContractFunction0(PypechainContractFunction):
    """ContractFunction for the kind() method."""

    _function_name = "kind"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineKindContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the kind method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "kind"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveMatchingEngineKindContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineKindContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineKindContractFunction0._type_signature: HyperdriveMatchingEngineKindContractFunction0,
        }
        return out


class HyperdriveMatchingEngineMatchOrdersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the matchOrders(IHyperdriveMatchingEngine.OrderIntent,IHyperdriveMatchingEngine.OrderIntent,int,IHyperdrive.Options,IHyperdrive.Options,str,bool) method."""

    _function_name = "matchOrders"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "IHyperdriveMatchingEngine.OrderIntent",
                "IHyperdriveMatchingEngine.OrderIntent",
                "int",
                "IHyperdrive.Options",
                "IHyperdrive.Options",
                "str",
                "bool",
            ]
        ),
        structs,
    )
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveMatchingEngineMatchOrdersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the matchOrders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "matchOrders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _longOrder: IHyperdriveMatchingEngine.OrderIntent, _shortOrder: IHyperdriveMatchingEngine.OrderIntent, _lpAmount: int, _addLiquidityOptions: IHyperdrive.Options, _removeLiquidityOptions: IHyperdrive.Options, _feeRecipient: str, _isLongFirst: bool) -> HyperdriveMatchingEngineMatchOrdersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineMatchOrdersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineMatchOrdersContractFunction0._type_signature: HyperdriveMatchingEngineMatchOrdersContractFunction0,
        }
        return out


class HyperdriveMatchingEngineMorphoContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the morpho() method."""

    _function_name = "morpho"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineMorphoContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the morpho method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "morpho"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveMatchingEngineMorphoContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineMorphoContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineMorphoContractFunction0._type_signature: HyperdriveMatchingEngineMorphoContractFunction0,
        }
        return out


class HyperdriveMatchingEngineNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineNameContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveMatchingEngineNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineNameContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineNameContractFunction0._type_signature: HyperdriveMatchingEngineNameContractFunction0,
        }
        return out


class HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the onMorphoFlashLoan(int,bytes) method."""

    _function_name = "onMorphoFlashLoan"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the onMorphoFlashLoan method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "onMorphoFlashLoan"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _lpAmount: int, _data: bytes) -> HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction0._type_signature: HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction0,
        }
        return out


class HyperdriveMatchingEngineVerifySignatureContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the verifySignature(bytes,bytes,str) method."""

    _function_name = "verifySignature"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineVerifySignatureContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the verifySignature method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "verifySignature"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hash: bytes, _signature: bytes, _signer: str) -> HyperdriveMatchingEngineVerifySignatureContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineVerifySignatureContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineVerifySignatureContractFunction0._type_signature: HyperdriveMatchingEngineVerifySignatureContractFunction0,
        }
        return out


class HyperdriveMatchingEngineVersionContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the version() method."""

    _function_name = "version"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveMatchingEngineContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveMatchingEngineVersionContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the version method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "version"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveMatchingEngineVersionContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveMatchingEngineVersionContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveMatchingEngineVersionContractFunction0._type_signature: HyperdriveMatchingEngineVersionContractFunction0,
        }
        return out


class HyperdriveMatchingEngineContractFunctions(ContractFunctions):
    """ContractFunctions for the HyperdriveMatchingEngine contract."""

    OPTIONS_TYPEHASH: HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction

    ORDER_INTENT_TYPEHASH: (
        HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction
    )

    cancelOrders: HyperdriveMatchingEngineCancelOrdersContractFunction

    eip712Domain: HyperdriveMatchingEngineEip712DomainContractFunction

    hashOrderIntent: HyperdriveMatchingEngineHashOrderIntentContractFunction

    isCancelled: HyperdriveMatchingEngineIsCancelledContractFunction

    kind: HyperdriveMatchingEngineKindContractFunction

    matchOrders: HyperdriveMatchingEngineMatchOrdersContractFunction

    morpho: HyperdriveMatchingEngineMorphoContractFunction

    name: HyperdriveMatchingEngineNameContractFunction

    onMorphoFlashLoan: HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction

    verifySignature: HyperdriveMatchingEngineVerifySignatureContractFunction

    version: HyperdriveMatchingEngineVersionContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.OPTIONS_TYPEHASH = (
            HyperdriveMatchingEngineOPTIONS_TYPEHASHContractFunction.factory(
                "OPTIONS_TYPEHASH",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="OPTIONS_TYPEHASH",
            )
        )
        self.ORDER_INTENT_TYPEHASH = HyperdriveMatchingEngineORDER_INTENT_TYPEHASHContractFunction.factory(
            "ORDER_INTENT_TYPEHASH",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="ORDER_INTENT_TYPEHASH",
        )
        self.cancelOrders = (
            HyperdriveMatchingEngineCancelOrdersContractFunction.factory(
                "cancelOrders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="cancelOrders",
            )
        )
        self.eip712Domain = (
            HyperdriveMatchingEngineEip712DomainContractFunction.factory(
                "eip712Domain",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="eip712Domain",
            )
        )
        self.hashOrderIntent = (
            HyperdriveMatchingEngineHashOrderIntentContractFunction.factory(
                "hashOrderIntent",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="hashOrderIntent",
            )
        )
        self.isCancelled = (
            HyperdriveMatchingEngineIsCancelledContractFunction.factory(
                "isCancelled",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="isCancelled",
            )
        )
        self.kind = HyperdriveMatchingEngineKindContractFunction.factory(
            "kind",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="kind",
        )
        self.matchOrders = (
            HyperdriveMatchingEngineMatchOrdersContractFunction.factory(
                "matchOrders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="matchOrders",
            )
        )
        self.morpho = HyperdriveMatchingEngineMorphoContractFunction.factory(
            "morpho",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="morpho",
        )
        self.name = HyperdriveMatchingEngineNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.onMorphoFlashLoan = (
            HyperdriveMatchingEngineOnMorphoFlashLoanContractFunction.factory(
                "onMorphoFlashLoan",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="onMorphoFlashLoan",
            )
        )
        self.verifySignature = (
            HyperdriveMatchingEngineVerifySignatureContractFunction.factory(
                "verifySignature",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="verifySignature",
            )
        )
        self.version = HyperdriveMatchingEngineVersionContractFunction.factory(
            "version",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="version",
        )


class HyperdriveMatchingEngineEIP712DomainChangedContractEvent(ContractEvent):
    """ContractEvent for EIP712DomainChanged."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[EIP712DomainChangedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            EIP712DomainChangedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BaseEventArgs(),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[EIP712DomainChangedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            EIP712DomainChangedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BaseEventArgs(),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveMatchingEngineOrdersCancelledContractEvent(ContractEvent):
    """ContractEvent for OrdersCancelled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[OrdersCancelledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OrdersCancelledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OrdersCancelledEvent.OrdersCancelledEventArgs(
                    trader=abi_event.args["trader"],
                    orderHashes=abi_event.args["orderHashes"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[OrdersCancelledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OrdersCancelledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OrdersCancelledEvent.OrdersCancelledEventArgs(
                    trader=abi_event.args["trader"],
                    orderHashes=abi_event.args["orderHashes"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveMatchingEngineOrdersMatchedContractEvent(ContractEvent):
    """ContractEvent for OrdersMatched."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[OrdersMatchedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OrdersMatchedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OrdersMatchedEvent.OrdersMatchedEventArgs(
                    hyperdrive=abi_event.args["hyperdrive"],
                    longOrderHash=abi_event.args["longOrderHash"],
                    shortOrderHash=abi_event.args["shortOrderHash"],
                    long=abi_event.args["long"],
                    short=abi_event.args["short"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[OrdersMatchedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            OrdersMatchedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=OrdersMatchedEvent.OrdersMatchedEventArgs(
                    hyperdrive=abi_event.args["hyperdrive"],
                    longOrderHash=abi_event.args["longOrderHash"],
                    shortOrderHash=abi_event.args["shortOrderHash"],
                    long=abi_event.args["long"],
                    short=abi_event.args["short"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveMatchingEngineContractEvents(ContractEvents):
    """ContractEvents for the HyperdriveMatchingEngine contract."""

    EIP712DomainChanged: (
        HyperdriveMatchingEngineEIP712DomainChangedContractEvent
    )

    OrdersCancelled: HyperdriveMatchingEngineOrdersCancelledContractEvent

    OrdersMatched: HyperdriveMatchingEngineOrdersMatchedContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.EIP712DomainChanged = (
            HyperdriveMatchingEngineEIP712DomainChangedContractEvent.factory(
                "EIP712DomainChanged",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="EIP712DomainChanged",
            )
        )
        self.OrdersCancelled = (
            HyperdriveMatchingEngineOrdersCancelledContractEvent.factory(
                "OrdersCancelled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="OrdersCancelled",
            )
        )
        self.OrdersMatched = (
            HyperdriveMatchingEngineOrdersMatchedContractEvent.factory(
                "OrdersMatched",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="OrdersMatched",
            )
        )


class HyperdriveMatchingEngineContract(Contract):
    """A web3.py Contract class for the HyperdriveMatchingEngine contract."""

    abi: ABI = hyperdrivematchingengine_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x61018060405234801562000011575f80fd5b5060405162002b0738038062002b07833981016040819052620000349162000209565b604080518082019091526007815266076312e302e32360cc1b602082015260015f8190558391906200006890839062000132565b610120526200007981600262000132565b61014052815160208084019190912060e052815190820120610100524660a0526200010660e05161010051604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201529081019290925260608201524660808201523060a08201525f9060c00160405160208183030381529060405280519060200120905090565b60805250503060c05260036200011d83826200035b565b506001600160a01b031661016052506200047f565b5f602083511015620001515762000149836200016a565b905062000164565b816200015e84826200035b565b5060ff90505b92915050565b5f80829050601f81511115620001a0578260405163305a27a960e01b815260040162000197919062000427565b60405180910390fd5b8051620001ad826200045b565b179392505050565b634e487b7160e01b5f52604160045260245ffd5b5f5b83811015620001e5578181015183820152602001620001cb565b50505f910152565b80516001600160a01b038116811462000204575f80fd5b919050565b5f80604083850312156200021b575f80fd5b82516001600160401b038082111562000232575f80fd5b818501915085601f83011262000246575f80fd5b8151818111156200025b576200025b620001b5565b604051601f8201601f19908116603f01168101908382118183101715620002865762000286620001b5565b816040528281528860208487010111156200029f575f80fd5b620002b2836020830160208801620001c9565b8096505050505050620002c860208401620001ed565b90509250929050565b600181811c90821680620002e657607f821691505b6020821081036200030557634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156200035657805f5260205f20601f840160051c81016020851015620003325750805b601f840160051c820191505b8181101562000353575f81556001016200033e565b50505b505050565b81516001600160401b03811115620003775762000377620001b5565b6200038f81620003888454620002d1565b846200030b565b602080601f831160018114620003c5575f8415620003ad5750858301515b5f19600386901b1c1916600185901b1785556200041f565b5f85815260208120601f198616915b82811015620003f557888601518255948401946001909101908401620003d4565b50858210156200041357878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b602081525f825180602084015262000447816040850160208701620001c9565b601f01601f19169190910160400192915050565b8051602080830151919081101562000305575f1960209190910360031b1b16919050565b60805160a05160c05160e0516101005161012051610140516101605161261e620004e95f395f818161024b015281816106360152610a4f01525f610fbb01525f610f8901525f6116ea01525f6116c201525f61161d01525f61164701525f611671015261261e5ff3fe608060405234801561000f575f80fd5b50600436106100cb575f3560e01c8063597c0eaf116100885780639a5d4407116100635780639a5d4407146102115780639d048d5d14610233578063d8fbc83314610246578063e932615914610285575f80fd5b8063597c0eaf146101bc5780637dcf1a2a146101e357806384b0196e146101f6575f80fd5b806304baa00b146100cf57806306fdde0314610121578063180fc4981461012957806331cd41991461015e57806331f570721461018157806354fd4d5014610196575b5f80fd5b61010b6040518060400160405280601881526020017f487970657264726976654d61746368696e67456e67696e65000000000000000081525081565b6040516101189190611a17565b60405180910390f35b61010b610298565b6101507f27a21d781adcb87248d3939453cd23eac75f2131f3ea994cd9fbdd476183f60781565b604051908152602001610118565b61017161016c366004611a91565b610324565b6040519015158152602001610118565b61019461018f366004611aeb565b61043e565b005b61010b60405180604001604052806007815260200166076312e302e32360cc1b81525081565b6101507f54843b7ce0df20ae6fc267a74d99401ec904c241ff6f938402f8bad75459a6d681565b6101946101f1366004611b32565b610675565b6101fe610833565b6040516101189796959493929190611ba0565b61017161021f366004611c37565b60046020525f908152604090205460ff1681565b610150610241366004611c65565b610875565b61026d7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610118565b610194610293366004611cbe565b610a0a565b600380546102a590611d8c565b80601f01602080910402602001604051908101604052809291908181526020018280546102d190611d8c565b801561031c5780601f106102f35761010080835404028352916020019161031c565b820191905f5260205f20905b8154815290600101906020018083116102ff57829003601f168201915b505050505081565b5f6001600160a01b0382163b156103d457604051630b135d3f60e11b81526001600160a01b03831690631626ba7e9061036590889088908890600401611de6565b602060405180830381865afa92505050801561039e575060408051601f3d908101601f1916820190925261039b91810190611dff565b60015b6103a957505f610436565b6001600160e01b03198116630b135d3f60e11b146103ca575f915050610436565b6001915050610436565b816001600160a01b031661041d8686868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610be992505050565b6001600160a01b03161461043257505f610436565b5060015b949350505050565b610446610c11565b5f808080808061045887890189612059565b9550955095509550955095505f866020015190505f816001600160a01b031663c55dae636040518163ffffffff1660e01b8152600401602060405180830381865afa1580156104a9573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104cd919061211d565b90508a5f6104dd8484848b610c39565b90508415610500576104f084848c610cd8565b6104fb84848b610da3565b610516565b61050b84848b610da3565b61051684848c610cd8565b5f80856001600160a01b031663cbc13434845f8c6040518463ffffffff1660e01b81526004016105489392919061216a565b60408051808303815f875af1158015610563573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105879190612188565b9092509050801561060057604051630e07895b60e11b8152600360f81b60048201523060248201526001600160a01b03898116604483015260648201839052871690631c0f12b6906084015f604051808303815f87803b1580156105e9575f80fd5b505af11580156105fb573d5f803e3d5ffd5b505050505b83821115610627576106278861061686856121d2565b6001600160a01b0388169190610e94565b61065b6001600160a01b0386167f000000000000000000000000000000000000000000000000000000000000000086610ef3565b50505050505050505050505061067060015f55565b505050565b5f816001600160401b0381111561068e5761068e611e26565b6040519080825280602002602001820160405280156106b7578160200160208202803683370190505b5090505f5b828110156107ec578383828181106106d6576106d66121e5565b90506020028101906106e891906121f9565b6106f6906020810190612218565b6001600160a01b0316336001600160a01b03161461072757604051636edaef2f60e11b815260040160405180910390fd5b5f61074f85858481811061073d5761073d6121e5565b905060200281019061024191906121f9565b905061078d81868685818110610767576107676121e5565b905060200281019061077991906121f9565b6107879060e0810190612233565b33610324565b6107aa57604051638baa579f60e01b815260040160405180910390fd5b5f818152600460205260409020805460ff19166001179055825181908490849081106107d8576107d86121e5565b6020908102919091010152506001016106bc565b50336001600160a01b03167fa4f958623cd4c90b4a1213ca9f26b442398e4efad078048b6730c826fa4e5da1826040516108269190612275565b60405180910390a2505050565b5f6060805f805f6060610844610f82565b61084c610fb4565b604080515f80825260208201909252600f60f81b9b939a50919850469750309650945092509050565b5f610a047f27a21d781adcb87248d3939453cd23eac75f2131f3ea994cd9fbdd476183f6076108a76020850185612218565b6108b76040860160208701612218565b6040860135606087013560808801357f54843b7ce0df20ae6fc267a74d99401ec904c241ff6f938402f8bad75459a6d66108f460a08b018b6122b8565b610902906020810190612218565b61090f60a08c018c6122b8565b6109209060408101906020016122cc565b60405160200161094e939291909283526001600160a01b039190911660208301521515604082015260600190565b60408051601f19818403018152919052805160209091012061097660e08b0160c08c016122e7565b6001811115610987576109876121aa565b6040805160208101999099526001600160a01b0397881690890152959094166060870152608086019290925260a085015260c084015260e083015260ff1661010082810191909152840135610120828101919091528401356101408201526101600160405160208183030381529060405280519060200120610fe1565b92915050565b5f80610a188989888861100d565b5f8281526004602090815260408083208054600160ff199182168117909255858552938290208054909416179092559294509092507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169163e0232b4291610a8d91908d01908d01612218565b6001600160a01b031663c55dae636040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ac8573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610aec919061211d565b898c8c8b8b8b8b604051602001610b08969594939291906124a3565b6040516020818303038152906040526040518463ffffffff1660e01b8152600401610b3593929190612513565b5f604051808303815f87803b158015610b4c575f80fd5b505af1158015610b5e573d5f803e3d5ffd5b5050505080828a6020016020810190610b779190612218565b6001600160a01b03167f2b9364c1d167d9fc426271dabc00787527516605db527df6d0686ab8ec1dcc04610bae60208e018e612218565b610bbb60208e018e612218565b604080516001600160a01b0393841681529290911660208301520160405180910390a4505050505050505050565b5f805f80610bf78686611327565b925092509250610c078282611370565b5090949350505050565b60025f5403610c3357604051633ee5aeb560e01b815260040160405180910390fd5b60025f55565b5f610c5a85610c49856001612539565b6001600160a01b0387169190610ef3565b604051634c2ac1d960e01b81526001600160a01b03861690634c2ac1d990610c8f9086905f9081905f1990899060040161254c565b6020604051808303815f875af1158015610cab573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ccf9190612581565b95945050505050565b80516040820151610cf5916001600160a01b038516913090611431565b610d1b8382604001516001610d0a9190612539565b6001600160a01b0385169190610ef3565b826001600160a01b031663cba2e58d8260400151836060015184608001518560a001516040518563ffffffff1660e01b8152600401610d5d9493929190612598565b60408051808303815f875af1158015610d78573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d9c9190612188565b5050505050565b80516060820151610dc0916001600160a01b038516913090611431565b610dd58382606001516001610d0a9190612539565b5f836001600160a01b031663dbbe80708360400151846060015185608001518660a001516040518563ffffffff1660e01b8152600401610e189493929190612598565b60408051808303815f875af1158015610e33573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e579190612188565b9150508082606001511115610e8e57610e8e825f0151828460600151610e7d91906121d2565b6001600160a01b0386169190610e94565b50505050565b6040516001600160a01b0383811660248301526044820183905261067091859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b03838183161783525050505061146a565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b179052610f4484826114cb565b610e8e576040516001600160a01b0384811660248301525f6044830152610f7891869182169063095ea7b390606401610ec1565b610e8e848261146a565b6060610faf7f00000000000000000000000000000000000000000000000000000000000000006001611568565b905090565b6060610faf7f00000000000000000000000000000000000000000000000000000000000000006002611568565b5f610a04610fed611611565b8360405161190160f01b8152600281019290925260228201526042902090565b5f808061102060e0880160c089016122e7565b6001811115611031576110316121aa565b14158061105f5750600161104b60e0870160c088016122e7565b600181111561105c5761105c6121aa565b14155b1561107d5760405163688c176f60e01b815260040160405180910390fd5b4286610100013511158061109657504285610100013511155b156110b45760405163506b27c560e11b815260040160405180910390fd5b6110c46040860160208701612218565b6001600160a01b03166110dd6040880160208901612218565b6001600160a01b0316146111045760405163133c7fe960e21b815260040160405180910390fd5b61111160a08701876122b8565b6111229060408101906020016122cc565b1580611149575061113660a08601866122b8565b6111479060408101906020016122cc565b155b80611161575061115f60408501602086016122cc565b155b80611179575061117760408401602085016122cc565b155b15611197576040516355e5132560e11b815260040160405180910390fd5b6060860135158015906111b1575084604001358560600135105b80156111e857506111d460408601356111ce6060880135826121d2565b9061173a565b6111e66040880135606089013561173a565b105b15611206576040516314d6239f60e11b815260040160405180910390fd5b61120f86610875565b915061121a85610875565b5f8381526004602052604090205490915060ff168061124657505f8181526004602052604090205460ff165b15611264576040516354e3762560e01b815260040160405180910390fd5b6112828261127560e0890189612233565b61016c60208b018b612218565b15806112a957506112a78161129a60e0880188612233565b61016c60208a018a612218565b155b156112c757604051638baa579f60e01b815260040160405180910390fd5b306112d56020860186612218565b6001600160a01b03161415806113005750306112f46020850185612218565b6001600160a01b031614155b1561131e5760405163ac6b05f560e01b815260040160405180910390fd5b94509492505050565b5f805f835160410361135e576020840151604085015160608601515f1a61135088828585611755565b955095509550505050611369565b505081515f91506002905b9250925092565b5f826003811115611383576113836121aa565b0361138c575050565b60018260038111156113a0576113a06121aa565b036113be5760405163f645eedf60e01b815260040160405180910390fd5b60028260038111156113d2576113d26121aa565b036113f85760405163fce698f760e01b8152600481018290526024015b60405180910390fd5b600382600381111561140c5761140c6121aa565b0361142d576040516335e2f38360e21b8152600481018290526024016113ef565b5050565b6040516001600160a01b038481166024830152838116604483015260648201839052610e8e9186918216906323b872dd90608401610ec1565b5f61147e6001600160a01b0384168361181d565b905080515f141580156114a25750808060200190518101906114a091906125bc565b155b1561067057604051635274afe760e01b81526001600160a01b03841660048201526024016113ef565b5f805f846001600160a01b0316846040516114e691906125d7565b5f604051808303815f865af19150503d805f811461151f576040519150601f19603f3d011682016040523d82523d5f602084013e611524565b606091505b509150915081801561154e57508051158061154e57508080602001905181019061154e91906125bc565b8015610ccf5750505050506001600160a01b03163b151590565b606060ff83146115825761157b8361182a565b9050610a04565b81805461158e90611d8c565b80601f01602080910402602001604051908101604052809291908181526020018280546115ba90611d8c565b80156116055780601f106115dc57610100808354040283529160200191611605565b820191905f5260205f20905b8154815290600101906020018083116115e857829003601f168201915b50505050509050610a04565b5f306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614801561166957507f000000000000000000000000000000000000000000000000000000000000000046145b1561169357507f000000000000000000000000000000000000000000000000000000000000000090565b610faf604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60208201527f0000000000000000000000000000000000000000000000000000000000000000918101919091527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a08201525f9060c00160405160208183030381529060405280519060200120905090565b5f61174e83670de0b6b3a764000084611867565b9392505050565b5f80807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a084111561178e57505f91506003905082611813565b604080515f808252602082018084528a905260ff891692820192909252606081018790526080810186905260019060a0016020604051602081039080840390855afa1580156117df573d5f803e3d5ffd5b5050604051601f1901519150506001600160a01b03811661180a57505f925060019150829050611813565b92505f91508190505b9450945094915050565b606061174e83835f611882565b60605f6118368361191b565b6040805160208082528183019092529192505f91906020820181803683375050509182525060208101929092525090565b5f825f19048411830215820261187b575f80fd5b5091020490565b6060814710156118a75760405163cd78605960e01b81523060048201526024016113ef565b5f80856001600160a01b031684866040516118c291906125d7565b5f6040518083038185875af1925050503d805f81146118fc576040519150601f19603f3d011682016040523d82523d5f602084013e611901565b606091505b5091509150611911868383611942565b9695505050505050565b5f60ff8216601f811115610a0457604051632cd44ac360e21b815260040160405180910390fd5b606082611957576119528261199e565b61174e565b815115801561196e57506001600160a01b0384163b155b1561199757604051639996b31560e01b81526001600160a01b03851660048201526024016113ef565b508061174e565b8051156119ae5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b50565b5f5b838110156119e45781810151838201526020016119cc565b50505f910152565b5f8151808452611a038160208601602086016119ca565b601f01601f19169290920160200192915050565b602081525f61174e60208301846119ec565b5f8083601f840112611a39575f80fd5b5081356001600160401b03811115611a4f575f80fd5b602083019150836020828501011115611a66575f80fd5b9250929050565b6001600160a01b03811681146119c7575f80fd5b8035611a8c81611a6d565b919050565b5f805f8060608587031215611aa4575f80fd5b8435935060208501356001600160401b03811115611ac0575f80fd5b611acc87828801611a29565b9094509250506040850135611ae081611a6d565b939692955090935050565b5f805f60408486031215611afd575f80fd5b8335925060208401356001600160401b03811115611b19575f80fd5b611b2586828701611a29565b9497909650939450505050565b5f8060208385031215611b43575f80fd5b82356001600160401b0380821115611b59575f80fd5b818501915085601f830112611b6c575f80fd5b813581811115611b7a575f80fd5b8660208260051b8501011115611b8e575f80fd5b60209290920196919550909350505050565b60ff60f81b881681525f602060e06020840152611bc060e084018a6119ec565b8381036040850152611bd2818a6119ec565b606085018990526001600160a01b038816608086015260a0850187905284810360c0860152855180825260208088019350909101905f5b81811015611c2557835183529284019291840191600101611c09565b50909c9b505050505050505050505050565b5f60208284031215611c47575f80fd5b5035919050565b5f6101408284031215611c5f575f80fd5b50919050565b5f60208284031215611c75575f80fd5b81356001600160401b03811115611c8a575f80fd5b61043684828501611c4e565b5f60608284031215611c5f575f80fd5b80151581146119c7575f80fd5b8035611a8c81611ca6565b5f805f805f805f60e0888a031215611cd4575f80fd5b87356001600160401b0380821115611cea575f80fd5b611cf68b838c01611c4e565b985060208a0135915080821115611d0b575f80fd5b611d178b838c01611c4e565b975060408a0135965060608a0135915080821115611d33575f80fd5b611d3f8b838c01611c96565b955060808a0135915080821115611d54575f80fd5b50611d618a828b01611c96565b935050611d7060a08901611a81565b9150611d7e60c08901611cb3565b905092959891949750929550565b600181811c90821680611da057607f821691505b602082108103611c5f57634e487b7160e01b5f52602260045260245ffd5b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b838152604060208201525f610ccf604083018486611dbe565b5f60208284031215611e0f575f80fd5b81516001600160e01b03198116811461174e575f80fd5b634e487b7160e01b5f52604160045260245ffd5b60405161014081016001600160401b0381118282101715611e5d57611e5d611e26565b60405290565b5f82601f830112611e72575f80fd5b81356001600160401b0380821115611e8c57611e8c611e26565b604051601f8301601f19908116603f01168101908282118183101715611eb457611eb4611e26565b81604052838152866020858801011115611ecc575f80fd5b836020870160208301375f602085830101528094505050505092915050565b5f60608284031215611efb575f80fd5b604051606081016001600160401b038282108183111715611f1e57611f1e611e26565b8160405282935084359150611f3282611a6d565b908252602084013590611f4482611ca6565b8160208401526040850135915080821115611f5d575f80fd5b50611f6a85828601611e63565b6040830152505092915050565b803560028110611a8c575f80fd5b5f6101408284031215611f96575f80fd5b611f9e611e3a565b9050611fa982611a81565b8152611fb760208301611a81565b602082015260408201356040820152606082013560608201526080820135608082015260a08201356001600160401b0380821115611ff3575f80fd5b611fff85838601611eeb565b60a084015261201060c08501611f77565b60c084015260e0840135915080821115612028575f80fd5b5061203584828501611e63565b60e08301525061010080830135818301525061012080830135818301525092915050565b5f805f805f8060c0878903121561206e575f80fd5b86356001600160401b0380821115612084575f80fd5b6120908a838b01611f85565b975060208901359150808211156120a5575f80fd5b6120b18a838b01611f85565b965060408901359150808211156120c6575f80fd5b6120d28a838b01611eeb565b955060608901359150808211156120e7575f80fd5b506120f489828a01611eeb565b93505061210360808801611a81565b915061211160a08801611cb3565b90509295509295509295565b5f6020828403121561212d575f80fd5b815161174e81611a6d565b60018060a01b0381511682526020810151151560208301525f60408201516060604085015261043660608501826119ec565b838152826020820152606060408201525f610ccf6060830184612138565b5f8060408385031215612199575f80fd5b505080516020909101519092909150565b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b81810381811115610a0457610a046121be565b634e487b7160e01b5f52603260045260245ffd5b5f823561013e1983360301811261220e575f80fd5b9190910192915050565b5f60208284031215612228575f80fd5b813561174e81611a6d565b5f808335601e19843603018112612248575f80fd5b8301803591506001600160401b03821115612261575f80fd5b602001915036819003821315611a66575f80fd5b602080825282518282018190525f9190848201906040850190845b818110156122ac57835183529284019291840191600101612290565b50909695505050505050565b5f8235605e1983360301811261220e575f80fd5b5f602082840312156122dc575f80fd5b813561174e81611ca6565b5f602082840312156122f7575f80fd5b61174e82611f77565b5f8235605e19833603018112612314575f80fd5b90910192915050565b5f808335601e19843603018112612332575f80fd5b83016020810192503590506001600160401b03811115612350575f80fd5b803603821315611a66575f80fd5b5f813561236a81611a6d565b6001600160a01b03168352602082013561238381611ca6565b15156020840152612397604083018361231d565b60606040860152610ccf606086018284611dbe565b600281106123c857634e487b7160e01b5f52602160045260245ffd5b9052565b5f6101406123ea846123dd85611a81565b6001600160a01b03169052565b6123f660208401611a81565b6001600160a01b03811660208601525060408301356040850152606083013560608501526080830135608085015261243160a0840184612300565b8160a08601526124438286018261235e565b91505061245260c08401611f77565b61245f60c08601826123ac565b5061246d60e084018461231d565b85830360e0870152612480838284611dbe565b610100868101359088015261012095860135959096019490945250929392505050565b60c081525f6124b560c08301896123cc565b82810360208401526124c781896123cc565b905082810360408401526124db818861235e565b905082810360608401526124ef818761235e565b6001600160a01b03959095166080840152505090151560a090910152949350505050565b60018060a01b0384168152826020820152606060408201525f610ccf60608301846119ec565b80820180821115610a0457610a046121be565b85815284602082015283604082015282606082015260a060808201525f61257660a0830184612138565b979650505050505050565b5f60208284031215612591575f80fd5b5051919050565b848152836020820152826040820152608060608201525f6119116080830184612138565b5f602082840312156125cc575f80fd5b815161174e81611ca6565b5f825161220e8184602087016119ca56fea2646970667358221220838d58faaefaf3b6fba23b43a4a4ab44d555efde322e5901327d8e0561d95d2164736f6c63430008180033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = HyperdriveMatchingEngineContractFunctions(hyperdrivematchingengine_abi, self.w3, address)  # type: ignore
        self.events = HyperdriveMatchingEngineContractEvents(hyperdrivematchingengine_abi, self.w3, address)  # type: ignore
        self.errors = HyperdriveMatchingEngineContractErrors()

    events: HyperdriveMatchingEngineContractEvents

    errors: HyperdriveMatchingEngineContractErrors = (
        HyperdriveMatchingEngineContractErrors()
    )

    functions: HyperdriveMatchingEngineContractFunctions

    class ConstructorArgs(NamedTuple):
        """Arguments to pass the contract's constructor function."""

        name: str

        morpho: str

    @classmethod
    def constructor(cls, name: str, morpho: str) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor(
            dataclass_to_tuple(name), dataclass_to_tuple(morpho)
        )

    @classmethod
    def deploy(
        cls,
        w3: Web3,
        account: LocalAccount | ChecksumAddress,
        constructor_args: ConstructorArgs,
    ) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor(
            *constructor_args,
        )

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = HyperdriveMatchingEngineContractFunctions(
            hyperdrivematchingengine_abi, w3, None
        )
        contract.errors = HyperdriveMatchingEngineContractErrors()

        return contract
