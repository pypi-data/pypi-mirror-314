"""A web3.py Contract class for the L2Pool contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..DataTypes import DataTypesTypes as DataTypes
from .L2PoolTypes import (
    BackUnbackedEvent,
    BorrowEvent,
    FlashLoanEvent,
    IsolationModeTotalDebtUpdatedEvent,
    LiquidationCallEvent,
    MintedToTreasuryEvent,
    MintUnbackedEvent,
    RebalanceStableBorrowRateEvent,
    RepayEvent,
    ReserveDataUpdatedEvent,
    ReserveUsedAsCollateralDisabledEvent,
    ReserveUsedAsCollateralEnabledEvent,
    SupplyEvent,
    SwapBorrowRateModeEvent,
    UserEModeSetEvent,
    WithdrawEvent,
)

structs = {
    "DataTypes.EModeCategory": DataTypes.EModeCategory,
    "DataTypes.ReserveConfigurationMap": DataTypes.ReserveConfigurationMap,
    "DataTypes.ReserveDataLegacy": DataTypes.ReserveDataLegacy,
    "DataTypes.ReserveData": DataTypes.ReserveData,
    "DataTypes.UserConfigurationMap": DataTypes.UserConfigurationMap,
}

l2pool_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "ADDRESSES_PROVIDER",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IPoolAddressesProvider",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "BRIDGE_PROTOCOL_FEE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TOTAL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TO_PROTOCOL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_NUMBER_RESERVES",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint16", "internalType": "uint16"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "backUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "fee", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "borrow",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "borrow",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "configureEModeCategory",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "category",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deposit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "dropReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "finalizeTransfer",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceFromBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceToBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoan",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "amounts",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "interestRateModes",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoanSimple",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getBorrowLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getBridgeLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getEModeCategoryData",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getEModeLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getFlashLoanLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getLiquidationGracePeriod",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint40", "internalType": "uint40"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getLiquidationLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getPoolLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getReserveAddressById",
            "inputs": [
                {"name": "id", "type": "uint16", "internalType": "uint16"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveData",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveDataLegacy",
                    "components": [
                        {
                            "name": "configuration",
                            "type": "tuple",
                            "internalType": "struct DataTypes.ReserveConfigurationMap",
                            "components": [
                                {
                                    "name": "data",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                }
                            ],
                        },
                        {
                            "name": "liquidityIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentLiquidityRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "variableBorrowIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentVariableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentStableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "lastUpdateTimestamp",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "id",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "aTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "stableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "variableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "interestRateStrategyAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accruedToTreasury",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "unbacked",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "isolationModeTotalDebt",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveDataExtended",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveData",
                    "components": [
                        {
                            "name": "configuration",
                            "type": "tuple",
                            "internalType": "struct DataTypes.ReserveConfigurationMap",
                            "components": [
                                {
                                    "name": "data",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                }
                            ],
                        },
                        {
                            "name": "liquidityIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentLiquidityRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "variableBorrowIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentVariableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentStableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "lastUpdateTimestamp",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "id",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationGracePeriodUntil",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "aTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "stableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "variableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "interestRateStrategyAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accruedToTreasury",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "unbacked",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "isolationModeTotalDebt",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "virtualUnderlyingBalance",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedIncome",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedVariableDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReservesCount",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReservesList",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getSupplyLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "getUserAccountData",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "totalCollateralBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "totalDebtBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "availableBorrowsBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "currentLiquidationThreshold",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "ltv", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "healthFactor",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserConfiguration",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.UserConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserEMode",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getVirtualUnderlyingBalance",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "initReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "aTokenAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "stableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "variableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "interestRateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "initialize",
            "inputs": [
                {
                    "name": "provider",
                    "type": "address",
                    "internalType": "contract IPoolAddressesProvider",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "liquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "liquidationCall",
            "inputs": [
                {"name": "args1", "type": "bytes32", "internalType": "bytes32"},
                {"name": "args2", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintToTreasury",
            "inputs": [
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rebalanceStableBorrowRate",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rebalanceStableBorrowRate",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "user", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repay",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repay",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithATokens",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithATokens",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithPermit",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rescueTokens",
            "inputs": [
                {"name": "token", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "resetIsolationModeTotalDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "configuration",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setLiquidationGracePeriod",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "until", "type": "uint40", "internalType": "uint40"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setReserveInterestRateStrategyAddress",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "rateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserEMode",
            "inputs": [
                {"name": "categoryId", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserUseReserveAsCollateral",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserUseReserveAsCollateral",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "useAsCollateral",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supply",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supply",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supplyWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supplyWithPermit",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapBorrowRateMode",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapBorrowRateMode",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapToVariable",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "user", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "syncIndexesState",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "syncRatesState",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateBridgeProtocolFee",
            "inputs": [
                {
                    "name": "protocolFee",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateFlashloanPremiums",
            "inputs": [
                {
                    "name": "flashLoanPremiumTotal",
                    "type": "uint128",
                    "internalType": "uint128",
                },
                {
                    "name": "flashLoanPremiumToProtocol",
                    "type": "uint128",
                    "internalType": "uint128",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "to", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "args", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "BackUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "backer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "fee",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Borrow",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "borrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "FlashLoan",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "initiator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "premium",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "IsolationModeTotalDebtUpdated",
            "inputs": [
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "totalDebt",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "LiquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidatedCollateralAmount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintedToTreasury",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amountMinted",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RebalanceStableBorrowRate",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Repay",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "repayer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "useATokens",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveDataUpdated",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "liquidityRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "stableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidityIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveDataUpdated",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "liquidityRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "stableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidityIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralDisabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralEnabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Supply",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "SwapBorrowRateMode",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserEModeSet",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "categoryId",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "uint8",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Withdraw",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
    ],
)


class L2PoolContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the L2Pool contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class L2PoolADDRESSES_PROVIDERContractFunction0(PypechainContractFunction):
    """ContractFunction for the ADDRESSES_PROVIDER() method."""

    _function_name = "ADDRESSES_PROVIDER"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolADDRESSES_PROVIDERContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the ADDRESSES_PROVIDER method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ADDRESSES_PROVIDER"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolADDRESSES_PROVIDERContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolADDRESSES_PROVIDERContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolADDRESSES_PROVIDERContractFunction0._type_signature: L2PoolADDRESSES_PROVIDERContractFunction0,
        }
        return out


class L2PoolBRIDGE_PROTOCOL_FEEContractFunction0(PypechainContractFunction):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE() method."""

    _function_name = "BRIDGE_PROTOCOL_FEE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolBRIDGE_PROTOCOL_FEEContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "BRIDGE_PROTOCOL_FEE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolBRIDGE_PROTOCOL_FEEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolBRIDGE_PROTOCOL_FEEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolBRIDGE_PROTOCOL_FEEContractFunction0._type_signature: L2PoolBRIDGE_PROTOCOL_FEEContractFunction0,
        }
        return out


class L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0(PypechainContractFunction):
    """ContractFunction for the FLASHLOAN_PREMIUM_TOTAL() method."""

    _function_name = "FLASHLOAN_PREMIUM_TOTAL"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TOTAL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_PREMIUM_TOTAL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0._type_signature: L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction0,
        }
        return out


class L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TO_PROTOCOL() method."""

    _function_name = "FLASHLOAN_PREMIUM_TO_PROTOCOL"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TO_PROTOCOL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_PREMIUM_TO_PROTOCOL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0._type_signature: L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0,
        }
        return out


class L2PoolMAX_NUMBER_RESERVESContractFunction0(PypechainContractFunction):
    """ContractFunction for the MAX_NUMBER_RESERVES() method."""

    _function_name = "MAX_NUMBER_RESERVES"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolMAX_NUMBER_RESERVESContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the MAX_NUMBER_RESERVES method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "MAX_NUMBER_RESERVES"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolMAX_NUMBER_RESERVESContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolMAX_NUMBER_RESERVESContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolMAX_NUMBER_RESERVESContractFunction0._type_signature: L2PoolMAX_NUMBER_RESERVESContractFunction0,
        }
        return out


class L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the MAX_STABLE_RATE_BORROW_SIZE_PERCENT() method."""

    _function_name = "MAX_STABLE_RATE_BORROW_SIZE_PERCENT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the MAX_STABLE_RATE_BORROW_SIZE_PERCENT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "MAX_STABLE_RATE_BORROW_SIZE_PERCENT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0._type_signature: L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0,
        }
        return out


class L2PoolBackUnbackedContractFunction0(PypechainContractFunction):
    """ContractFunction for the backUnbacked(str,int,int) method."""

    _function_name = "backUnbacked"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolBackUnbackedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the backUnbacked method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "backUnbacked"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, fee: int) -> L2PoolBackUnbackedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolBackUnbackedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolBackUnbackedContractFunction0._type_signature: L2PoolBackUnbackedContractFunction0,
        }
        return out


class L2PoolBorrowContractFunction0(PypechainContractFunction):
    """ContractFunction for the borrow(str,int,int,int,str) method."""

    _function_name = "borrow"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "int", "str"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolBorrowContractFunction1(PypechainContractFunction):
    """ContractFunction for the borrow(bytes) method."""

    _function_name = "borrow"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolBorrowContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the borrow method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "borrow"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, referralCode: int, onBehalfOf: str) -> L2PoolBorrowContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> L2PoolBorrowContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolBorrowContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolBorrowContractFunction0._type_signature: L2PoolBorrowContractFunction0,
            L2PoolBorrowContractFunction1._type_signature: L2PoolBorrowContractFunction1,
        }
        return out


class L2PoolConfigureEModeCategoryContractFunction0(PypechainContractFunction):
    """ContractFunction for the configureEModeCategory(int,DataTypes.EModeCategory) method."""

    _function_name = "configureEModeCategory"
    _type_signature = expand_struct_type_str(
        tuple(["int", "DataTypes.EModeCategory"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolConfigureEModeCategoryContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the configureEModeCategory method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "configureEModeCategory"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int, category: DataTypes.EModeCategory) -> L2PoolConfigureEModeCategoryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolConfigureEModeCategoryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolConfigureEModeCategoryContractFunction0._type_signature: L2PoolConfigureEModeCategoryContractFunction0,
        }
        return out


class L2PoolDepositContractFunction0(PypechainContractFunction):
    """ContractFunction for the deposit(str,int,str,int) method."""

    _function_name = "deposit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolDepositContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deposit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deposit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> L2PoolDepositContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolDepositContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolDepositContractFunction0._type_signature: L2PoolDepositContractFunction0,
        }
        return out


class L2PoolDropReserveContractFunction0(PypechainContractFunction):
    """ContractFunction for the dropReserve(str) method."""

    _function_name = "dropReserve"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolDropReserveContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the dropReserve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "dropReserve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolDropReserveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolDropReserveContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolDropReserveContractFunction0._type_signature: L2PoolDropReserveContractFunction0,
        }
        return out


class L2PoolFinalizeTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the finalizeTransfer(str,str,str,int,int,int) method."""

    _function_name = "finalizeTransfer"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "int", "int", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolFinalizeTransferContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the finalizeTransfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "finalizeTransfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, _from: str, to: str, amount: int, balanceFromBefore: int, balanceToBefore: int) -> L2PoolFinalizeTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolFinalizeTransferContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolFinalizeTransferContractFunction0._type_signature: L2PoolFinalizeTransferContractFunction0,
        }
        return out


class L2PoolFlashLoanContractFunction0(PypechainContractFunction):
    """ContractFunction for the flashLoan(str,list[str],list[int],list[int],str,bytes,int) method."""

    _function_name = "flashLoan"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "list[str]",
                "list[int]",
                "list[int]",
                "str",
                "bytes",
                "int",
            ]
        ),
        structs,
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolFlashLoanContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the flashLoan method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "flashLoan"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiverAddress: str, assets: list[str], amounts: list[int], interestRateModes: list[int], onBehalfOf: str, params: bytes, referralCode: int) -> L2PoolFlashLoanContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolFlashLoanContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolFlashLoanContractFunction0._type_signature: L2PoolFlashLoanContractFunction0,
        }
        return out


class L2PoolFlashLoanSimpleContractFunction0(PypechainContractFunction):
    """ContractFunction for the flashLoanSimple(str,str,int,bytes,int) method."""

    _function_name = "flashLoanSimple"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int", "bytes", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolFlashLoanSimpleContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the flashLoanSimple method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "flashLoanSimple"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiverAddress: str, asset: str, amount: int, params: bytes, referralCode: int) -> L2PoolFlashLoanSimpleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolFlashLoanSimpleContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolFlashLoanSimpleContractFunction0._type_signature: L2PoolFlashLoanSimpleContractFunction0,
        }
        return out


class L2PoolGetBorrowLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBorrowLogic() method."""

    _function_name = "getBorrowLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetBorrowLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBorrowLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBorrowLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetBorrowLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetBorrowLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetBorrowLogicContractFunction0._type_signature: L2PoolGetBorrowLogicContractFunction0,
        }
        return out


class L2PoolGetBridgeLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBridgeLogic() method."""

    _function_name = "getBridgeLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetBridgeLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBridgeLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBridgeLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetBridgeLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetBridgeLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetBridgeLogicContractFunction0._type_signature: L2PoolGetBridgeLogicContractFunction0,
        }
        return out


class L2PoolGetConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the getConfiguration(str) method."""

    _function_name = "getConfiguration"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveConfigurationMap:
        """returns DataTypes.ReserveConfigurationMap."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveConfigurationMap

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class L2PoolGetConfigurationContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolGetConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetConfigurationContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetConfigurationContractFunction0._type_signature: L2PoolGetConfigurationContractFunction0,
        }
        return out


class L2PoolGetEModeCategoryDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getEModeCategoryData(int) method."""

    _function_name = "getEModeCategoryData"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.EModeCategory:
        """returns DataTypes.EModeCategory."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.EModeCategory

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.EModeCategory,
            rename_returned_types(structs, return_types, raw_values),
        )


class L2PoolGetEModeCategoryDataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getEModeCategoryData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getEModeCategoryData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int) -> L2PoolGetEModeCategoryDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetEModeCategoryDataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetEModeCategoryDataContractFunction0._type_signature: L2PoolGetEModeCategoryDataContractFunction0,
        }
        return out


class L2PoolGetEModeLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getEModeLogic() method."""

    _function_name = "getEModeLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetEModeLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getEModeLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getEModeLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetEModeLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetEModeLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetEModeLogicContractFunction0._type_signature: L2PoolGetEModeLogicContractFunction0,
        }
        return out


class L2PoolGetFlashLoanLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getFlashLoanLogic() method."""

    _function_name = "getFlashLoanLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetFlashLoanLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getFlashLoanLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFlashLoanLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetFlashLoanLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetFlashLoanLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetFlashLoanLogicContractFunction0._type_signature: L2PoolGetFlashLoanLogicContractFunction0,
        }
        return out


class L2PoolGetLiquidationGracePeriodContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getLiquidationGracePeriod(str) method."""

    _function_name = "getLiquidationGracePeriod"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetLiquidationGracePeriodContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getLiquidationGracePeriod method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLiquidationGracePeriod"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolGetLiquidationGracePeriodContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetLiquidationGracePeriodContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetLiquidationGracePeriodContractFunction0._type_signature: L2PoolGetLiquidationGracePeriodContractFunction0,
        }
        return out


class L2PoolGetLiquidationLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getLiquidationLogic() method."""

    _function_name = "getLiquidationLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetLiquidationLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getLiquidationLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLiquidationLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetLiquidationLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetLiquidationLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetLiquidationLogicContractFunction0._type_signature: L2PoolGetLiquidationLogicContractFunction0,
        }
        return out


class L2PoolGetPoolLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getPoolLogic() method."""

    _function_name = "getPoolLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetPoolLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getPoolLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getPoolLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetPoolLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetPoolLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetPoolLogicContractFunction0._type_signature: L2PoolGetPoolLogicContractFunction0,
        }
        return out


class L2PoolGetReserveAddressByIdContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReserveAddressById(int) method."""

    _function_name = "getReserveAddressById"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetReserveAddressByIdContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReserveAddressById method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveAddressById"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int) -> L2PoolGetReserveAddressByIdContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetReserveAddressByIdContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetReserveAddressByIdContractFunction0._type_signature: L2PoolGetReserveAddressByIdContractFunction0,
        }
        return out


class L2PoolGetReserveDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReserveData(str) method."""

    _function_name = "getReserveData"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveDataLegacy:
        """returns DataTypes.ReserveDataLegacy."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveDataLegacy

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveDataLegacy,
            rename_returned_types(structs, return_types, raw_values),
        )


class L2PoolGetReserveDataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReserveData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolGetReserveDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetReserveDataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetReserveDataContractFunction0._type_signature: L2PoolGetReserveDataContractFunction0,
        }
        return out


class L2PoolGetReserveDataExtendedContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReserveDataExtended(str) method."""

    _function_name = "getReserveDataExtended"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveData:
        """returns DataTypes.ReserveData."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveData

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveData,
            rename_returned_types(structs, return_types, raw_values),
        )


class L2PoolGetReserveDataExtendedContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getReserveDataExtended method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveDataExtended"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolGetReserveDataExtendedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetReserveDataExtendedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetReserveDataExtendedContractFunction0._type_signature: L2PoolGetReserveDataExtendedContractFunction0,
        }
        return out


class L2PoolGetReserveNormalizedIncomeContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedIncome(str) method."""

    _function_name = "getReserveNormalizedIncome"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetReserveNormalizedIncomeContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getReserveNormalizedIncome method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveNormalizedIncome"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolGetReserveNormalizedIncomeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetReserveNormalizedIncomeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetReserveNormalizedIncomeContractFunction0._type_signature: L2PoolGetReserveNormalizedIncomeContractFunction0,
        }
        return out


class L2PoolGetReserveNormalizedVariableDebtContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedVariableDebt(str) method."""

    _function_name = "getReserveNormalizedVariableDebt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetReserveNormalizedVariableDebtContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getReserveNormalizedVariableDebt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveNormalizedVariableDebt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolGetReserveNormalizedVariableDebtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetReserveNormalizedVariableDebtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetReserveNormalizedVariableDebtContractFunction0._type_signature: L2PoolGetReserveNormalizedVariableDebtContractFunction0,
        }
        return out


class L2PoolGetReservesCountContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReservesCount() method."""

    _function_name = "getReservesCount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetReservesCountContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReservesCount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReservesCount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetReservesCountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetReservesCountContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetReservesCountContractFunction0._type_signature: L2PoolGetReservesCountContractFunction0,
        }
        return out


class L2PoolGetReservesListContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReservesList() method."""

    _function_name = "getReservesList"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetReservesListContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReservesList method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReservesList"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetReservesListContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetReservesListContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetReservesListContractFunction0._type_signature: L2PoolGetReservesListContractFunction0,
        }
        return out


class L2PoolGetSupplyLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getSupplyLogic() method."""

    _function_name = "getSupplyLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetSupplyLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getSupplyLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getSupplyLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> L2PoolGetSupplyLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetSupplyLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetSupplyLogicContractFunction0._type_signature: L2PoolGetSupplyLogicContractFunction0,
        }
        return out


class L2PoolGetUserAccountDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserAccountData(str) method."""

    _function_name = "getUserAccountData"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for GetUserAccountData."""

        totalCollateralBase: int
        totalDebtBase: int
        availableBorrowsBase: int
        currentLiquidationThreshold: int
        ltv: int
        healthFactor: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int, int, int, int, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetUserAccountDataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getUserAccountData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserAccountData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> L2PoolGetUserAccountDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetUserAccountDataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetUserAccountDataContractFunction0._type_signature: L2PoolGetUserAccountDataContractFunction0,
        }
        return out


class L2PoolGetUserConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserConfiguration(str) method."""

    _function_name = "getUserConfiguration"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.UserConfigurationMap:
        """returns DataTypes.UserConfigurationMap."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.UserConfigurationMap

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.UserConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class L2PoolGetUserConfigurationContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getUserConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> L2PoolGetUserConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetUserConfigurationContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetUserConfigurationContractFunction0._type_signature: L2PoolGetUserConfigurationContractFunction0,
        }
        return out


class L2PoolGetUserEModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserEMode(str) method."""

    _function_name = "getUserEMode"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetUserEModeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getUserEMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserEMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> L2PoolGetUserEModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetUserEModeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetUserEModeContractFunction0._type_signature: L2PoolGetUserEModeContractFunction0,
        }
        return out


class L2PoolGetVirtualUnderlyingBalanceContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getVirtualUnderlyingBalance(str) method."""

    _function_name = "getVirtualUnderlyingBalance"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolGetVirtualUnderlyingBalanceContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getVirtualUnderlyingBalance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getVirtualUnderlyingBalance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolGetVirtualUnderlyingBalanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolGetVirtualUnderlyingBalanceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolGetVirtualUnderlyingBalanceContractFunction0._type_signature: L2PoolGetVirtualUnderlyingBalanceContractFunction0,
        }
        return out


class L2PoolInitReserveContractFunction0(PypechainContractFunction):
    """ContractFunction for the initReserve(str,str,str,str,str) method."""

    _function_name = "initReserve"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "str", "str"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolInitReserveContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the initReserve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "initReserve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, aTokenAddress: str, stableDebtAddress: str, variableDebtAddress: str, interestRateStrategyAddress: str) -> L2PoolInitReserveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolInitReserveContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolInitReserveContractFunction0._type_signature: L2PoolInitReserveContractFunction0,
        }
        return out


class L2PoolInitializeContractFunction0(PypechainContractFunction):
    """ContractFunction for the initialize(str) method."""

    _function_name = "initialize"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolInitializeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the initialize method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "initialize"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, provider: str) -> L2PoolInitializeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolInitializeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolInitializeContractFunction0._type_signature: L2PoolInitializeContractFunction0,
        }
        return out


class L2PoolLiquidationCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the liquidationCall(str,str,str,int,bool) method."""

    _function_name = "liquidationCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "int", "bool"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolLiquidationCallContractFunction1(PypechainContractFunction):
    """ContractFunction for the liquidationCall(bytes,bytes) method."""

    _function_name = "liquidationCall"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolLiquidationCallContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the liquidationCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "liquidationCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, collateralAsset: str, debtAsset: str, user: str, debtToCover: int, receiveAToken: bool) -> L2PoolLiquidationCallContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args1: bytes, args2: bytes) -> L2PoolLiquidationCallContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolLiquidationCallContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolLiquidationCallContractFunction0._type_signature: L2PoolLiquidationCallContractFunction0,
            L2PoolLiquidationCallContractFunction1._type_signature: L2PoolLiquidationCallContractFunction1,
        }
        return out


class L2PoolMintToTreasuryContractFunction0(PypechainContractFunction):
    """ContractFunction for the mintToTreasury(list[str]) method."""

    _function_name = "mintToTreasury"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolMintToTreasuryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mintToTreasury method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mintToTreasury"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: list[str]) -> L2PoolMintToTreasuryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolMintToTreasuryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolMintToTreasuryContractFunction0._type_signature: L2PoolMintToTreasuryContractFunction0,
        }
        return out


class L2PoolMintUnbackedContractFunction0(PypechainContractFunction):
    """ContractFunction for the mintUnbacked(str,int,str,int) method."""

    _function_name = "mintUnbacked"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolMintUnbackedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mintUnbacked method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mintUnbacked"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> L2PoolMintUnbackedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolMintUnbackedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolMintUnbackedContractFunction0._type_signature: L2PoolMintUnbackedContractFunction0,
        }
        return out


class L2PoolRebalanceStableBorrowRateContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the rebalanceStableBorrowRate(bytes) method."""

    _function_name = "rebalanceStableBorrowRate"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolRebalanceStableBorrowRateContractFunction1(
    PypechainContractFunction
):
    """ContractFunction for the rebalanceStableBorrowRate(str,str) method."""

    _function_name = "rebalanceStableBorrowRate"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolRebalanceStableBorrowRateContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the rebalanceStableBorrowRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rebalanceStableBorrowRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> L2PoolRebalanceStableBorrowRateContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, user: str) -> L2PoolRebalanceStableBorrowRateContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolRebalanceStableBorrowRateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolRebalanceStableBorrowRateContractFunction0._type_signature: L2PoolRebalanceStableBorrowRateContractFunction0,
            L2PoolRebalanceStableBorrowRateContractFunction1._type_signature: L2PoolRebalanceStableBorrowRateContractFunction1,
        }
        return out


class L2PoolRepayContractFunction0(PypechainContractFunction):
    """ContractFunction for the repay(bytes) method."""

    _function_name = "repay"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolRepayContractFunction1(PypechainContractFunction):
    """ContractFunction for the repay(str,int,int,str) method."""

    _function_name = "repay"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "str"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolRepayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the repay method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repay"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> L2PoolRepayContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str) -> L2PoolRepayContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolRepayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolRepayContractFunction0._type_signature: L2PoolRepayContractFunction0,
            L2PoolRepayContractFunction1._type_signature: L2PoolRepayContractFunction1,
        }
        return out


class L2PoolRepayWithATokensContractFunction0(PypechainContractFunction):
    """ContractFunction for the repayWithATokens(str,int,int) method."""

    _function_name = "repayWithATokens"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolRepayWithATokensContractFunction1(PypechainContractFunction):
    """ContractFunction for the repayWithATokens(bytes) method."""

    _function_name = "repayWithATokens"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolRepayWithATokensContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the repayWithATokens method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repayWithATokens"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int) -> L2PoolRepayWithATokensContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> L2PoolRepayWithATokensContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolRepayWithATokensContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolRepayWithATokensContractFunction0._type_signature: L2PoolRepayWithATokensContractFunction0,
            L2PoolRepayWithATokensContractFunction1._type_signature: L2PoolRepayWithATokensContractFunction1,
        }
        return out


class L2PoolRepayWithPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the repayWithPermit(bytes,bytes,bytes) method."""

    _function_name = "repayWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "bytes"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolRepayWithPermitContractFunction1(PypechainContractFunction):
    """ContractFunction for the repayWithPermit(str,int,int,str,int,int,bytes,bytes) method."""

    _function_name = "repayWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "str", "int", "int", "bytes", "bytes"]),
        structs,
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolRepayWithPermitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the repayWithPermit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repayWithPermit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes, r: bytes, s: bytes) -> L2PoolRepayWithPermitContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> L2PoolRepayWithPermitContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolRepayWithPermitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolRepayWithPermitContractFunction0._type_signature: L2PoolRepayWithPermitContractFunction0,
            L2PoolRepayWithPermitContractFunction1._type_signature: L2PoolRepayWithPermitContractFunction1,
        }
        return out


class L2PoolRescueTokensContractFunction0(PypechainContractFunction):
    """ContractFunction for the rescueTokens(str,str,int) method."""

    _function_name = "rescueTokens"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolRescueTokensContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rescueTokens method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rescueTokens"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, token: str, to: str, amount: int) -> L2PoolRescueTokensContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolRescueTokensContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolRescueTokensContractFunction0._type_signature: L2PoolRescueTokensContractFunction0,
        }
        return out


class L2PoolResetIsolationModeTotalDebtContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the resetIsolationModeTotalDebt(str) method."""

    _function_name = "resetIsolationModeTotalDebt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolResetIsolationModeTotalDebtContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the resetIsolationModeTotalDebt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "resetIsolationModeTotalDebt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolResetIsolationModeTotalDebtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolResetIsolationModeTotalDebtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolResetIsolationModeTotalDebtContractFunction0._type_signature: L2PoolResetIsolationModeTotalDebtContractFunction0,
        }
        return out


class L2PoolSetConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the setConfiguration(str,DataTypes.ReserveConfigurationMap) method."""

    _function_name = "setConfiguration"
    _type_signature = expand_struct_type_str(
        tuple(["str", "DataTypes.ReserveConfigurationMap"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSetConfigurationContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, configuration: DataTypes.ReserveConfigurationMap) -> L2PoolSetConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSetConfigurationContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSetConfigurationContractFunction0._type_signature: L2PoolSetConfigurationContractFunction0,
        }
        return out


class L2PoolSetLiquidationGracePeriodContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setLiquidationGracePeriod(str,int) method."""

    _function_name = "setLiquidationGracePeriod"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSetLiquidationGracePeriodContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setLiquidationGracePeriod method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setLiquidationGracePeriod"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, until: int) -> L2PoolSetLiquidationGracePeriodContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSetLiquidationGracePeriodContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSetLiquidationGracePeriodContractFunction0._type_signature: L2PoolSetLiquidationGracePeriodContractFunction0,
        }
        return out


class L2PoolSetReserveInterestRateStrategyAddressContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setReserveInterestRateStrategyAddress(str,str) method."""

    _function_name = "setReserveInterestRateStrategyAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSetReserveInterestRateStrategyAddressContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setReserveInterestRateStrategyAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setReserveInterestRateStrategyAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, rateStrategyAddress: str) -> L2PoolSetReserveInterestRateStrategyAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSetReserveInterestRateStrategyAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSetReserveInterestRateStrategyAddressContractFunction0._type_signature: L2PoolSetReserveInterestRateStrategyAddressContractFunction0,
        }
        return out


class L2PoolSetUserEModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the setUserEMode(int) method."""

    _function_name = "setUserEMode"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSetUserEModeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setUserEMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserEMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, categoryId: int) -> L2PoolSetUserEModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSetUserEModeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSetUserEModeContractFunction0._type_signature: L2PoolSetUserEModeContractFunction0,
        }
        return out


class L2PoolSetUserUseReserveAsCollateralContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUserUseReserveAsCollateral(bytes) method."""

    _function_name = "setUserUseReserveAsCollateral"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSetUserUseReserveAsCollateralContractFunction1(
    PypechainContractFunction
):
    """ContractFunction for the setUserUseReserveAsCollateral(str,bool) method."""

    _function_name = "setUserUseReserveAsCollateral"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSetUserUseReserveAsCollateralContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setUserUseReserveAsCollateral method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserUseReserveAsCollateral"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> L2PoolSetUserUseReserveAsCollateralContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, useAsCollateral: bool) -> L2PoolSetUserUseReserveAsCollateralContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSetUserUseReserveAsCollateralContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSetUserUseReserveAsCollateralContractFunction0._type_signature: L2PoolSetUserUseReserveAsCollateralContractFunction0,
            L2PoolSetUserUseReserveAsCollateralContractFunction1._type_signature: L2PoolSetUserUseReserveAsCollateralContractFunction1,
        }
        return out


class L2PoolSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the supply(str,int,str,int) method."""

    _function_name = "supply"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSupplyContractFunction1(PypechainContractFunction):
    """ContractFunction for the supply(bytes) method."""

    _function_name = "supply"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSupplyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the supply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "supply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> L2PoolSupplyContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> L2PoolSupplyContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSupplyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSupplyContractFunction0._type_signature: L2PoolSupplyContractFunction0,
            L2PoolSupplyContractFunction1._type_signature: L2PoolSupplyContractFunction1,
        }
        return out


class L2PoolSupplyWithPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the supplyWithPermit(str,int,str,int,int,int,bytes,bytes) method."""

    _function_name = "supplyWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int", "int", "int", "bytes", "bytes"]),
        structs,
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSupplyWithPermitContractFunction1(PypechainContractFunction):
    """ContractFunction for the supplyWithPermit(bytes,bytes,bytes) method."""

    _function_name = "supplyWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "bytes"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSupplyWithPermitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the supplyWithPermit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "supplyWithPermit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> L2PoolSupplyWithPermitContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes, r: bytes, s: bytes) -> L2PoolSupplyWithPermitContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSupplyWithPermitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSupplyWithPermitContractFunction0._type_signature: L2PoolSupplyWithPermitContractFunction0,
            L2PoolSupplyWithPermitContractFunction1._type_signature: L2PoolSupplyWithPermitContractFunction1,
        }
        return out


class L2PoolSwapBorrowRateModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the swapBorrowRateMode(bytes) method."""

    _function_name = "swapBorrowRateMode"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSwapBorrowRateModeContractFunction1(PypechainContractFunction):
    """ContractFunction for the swapBorrowRateMode(str,int) method."""

    _function_name = "swapBorrowRateMode"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSwapBorrowRateModeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the swapBorrowRateMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "swapBorrowRateMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, args: bytes) -> L2PoolSwapBorrowRateModeContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, asset: str, interestRateMode: int) -> L2PoolSwapBorrowRateModeContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSwapBorrowRateModeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSwapBorrowRateModeContractFunction0._type_signature: L2PoolSwapBorrowRateModeContractFunction0,
            L2PoolSwapBorrowRateModeContractFunction1._type_signature: L2PoolSwapBorrowRateModeContractFunction1,
        }
        return out


class L2PoolSwapToVariableContractFunction0(PypechainContractFunction):
    """ContractFunction for the swapToVariable(str,str) method."""

    _function_name = "swapToVariable"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSwapToVariableContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the swapToVariable method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "swapToVariable"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, user: str) -> L2PoolSwapToVariableContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSwapToVariableContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSwapToVariableContractFunction0._type_signature: L2PoolSwapToVariableContractFunction0,
        }
        return out


class L2PoolSyncIndexesStateContractFunction0(PypechainContractFunction):
    """ContractFunction for the syncIndexesState(str) method."""

    _function_name = "syncIndexesState"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSyncIndexesStateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the syncIndexesState method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "syncIndexesState"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolSyncIndexesStateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSyncIndexesStateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSyncIndexesStateContractFunction0._type_signature: L2PoolSyncIndexesStateContractFunction0,
        }
        return out


class L2PoolSyncRatesStateContractFunction0(PypechainContractFunction):
    """ContractFunction for the syncRatesState(str) method."""

    _function_name = "syncRatesState"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolSyncRatesStateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the syncRatesState method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "syncRatesState"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> L2PoolSyncRatesStateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolSyncRatesStateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolSyncRatesStateContractFunction0._type_signature: L2PoolSyncRatesStateContractFunction0,
        }
        return out


class L2PoolUpdateBridgeProtocolFeeContractFunction0(PypechainContractFunction):
    """ContractFunction for the updateBridgeProtocolFee(int) method."""

    _function_name = "updateBridgeProtocolFee"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolUpdateBridgeProtocolFeeContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the updateBridgeProtocolFee method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateBridgeProtocolFee"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, protocolFee: int) -> L2PoolUpdateBridgeProtocolFeeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolUpdateBridgeProtocolFeeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolUpdateBridgeProtocolFeeContractFunction0._type_signature: L2PoolUpdateBridgeProtocolFeeContractFunction0,
        }
        return out


class L2PoolUpdateFlashloanPremiumsContractFunction0(PypechainContractFunction):
    """ContractFunction for the updateFlashloanPremiums(int,int) method."""

    _function_name = "updateFlashloanPremiums"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class L2PoolUpdateFlashloanPremiumsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the updateFlashloanPremiums method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateFlashloanPremiums"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, flashLoanPremiumTotal: int, flashLoanPremiumToProtocol: int) -> L2PoolUpdateFlashloanPremiumsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolUpdateFlashloanPremiumsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolUpdateFlashloanPremiumsContractFunction0._type_signature: L2PoolUpdateFlashloanPremiumsContractFunction0,
        }
        return out


class L2PoolWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the withdraw(str,int,str) method."""

    _function_name = "withdraw"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str"]), structs
    )
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolWithdrawContractFunction1(PypechainContractFunction):
    """ContractFunction for the withdraw(bytes) method."""

    _function_name = "withdraw"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = L2PoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class L2PoolWithdrawContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the withdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "withdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, to: str) -> L2PoolWithdrawContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, args: bytes) -> L2PoolWithdrawContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> L2PoolWithdrawContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            L2PoolWithdrawContractFunction0._type_signature: L2PoolWithdrawContractFunction0,
            L2PoolWithdrawContractFunction1._type_signature: L2PoolWithdrawContractFunction1,
        }
        return out


class L2PoolContractFunctions(ContractFunctions):
    """ContractFunctions for the L2Pool contract."""

    ADDRESSES_PROVIDER: L2PoolADDRESSES_PROVIDERContractFunction

    BRIDGE_PROTOCOL_FEE: L2PoolBRIDGE_PROTOCOL_FEEContractFunction

    FLASHLOAN_PREMIUM_TOTAL: L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction

    FLASHLOAN_PREMIUM_TO_PROTOCOL: (
        L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction
    )

    MAX_NUMBER_RESERVES: L2PoolMAX_NUMBER_RESERVESContractFunction

    MAX_STABLE_RATE_BORROW_SIZE_PERCENT: (
        L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction
    )

    backUnbacked: L2PoolBackUnbackedContractFunction

    borrow: L2PoolBorrowContractFunction

    configureEModeCategory: L2PoolConfigureEModeCategoryContractFunction

    deposit: L2PoolDepositContractFunction

    dropReserve: L2PoolDropReserveContractFunction

    finalizeTransfer: L2PoolFinalizeTransferContractFunction

    flashLoan: L2PoolFlashLoanContractFunction

    flashLoanSimple: L2PoolFlashLoanSimpleContractFunction

    getBorrowLogic: L2PoolGetBorrowLogicContractFunction

    getBridgeLogic: L2PoolGetBridgeLogicContractFunction

    getConfiguration: L2PoolGetConfigurationContractFunction

    getEModeCategoryData: L2PoolGetEModeCategoryDataContractFunction

    getEModeLogic: L2PoolGetEModeLogicContractFunction

    getFlashLoanLogic: L2PoolGetFlashLoanLogicContractFunction

    getLiquidationGracePeriod: L2PoolGetLiquidationGracePeriodContractFunction

    getLiquidationLogic: L2PoolGetLiquidationLogicContractFunction

    getPoolLogic: L2PoolGetPoolLogicContractFunction

    getReserveAddressById: L2PoolGetReserveAddressByIdContractFunction

    getReserveData: L2PoolGetReserveDataContractFunction

    getReserveDataExtended: L2PoolGetReserveDataExtendedContractFunction

    getReserveNormalizedIncome: L2PoolGetReserveNormalizedIncomeContractFunction

    getReserveNormalizedVariableDebt: (
        L2PoolGetReserveNormalizedVariableDebtContractFunction
    )

    getReservesCount: L2PoolGetReservesCountContractFunction

    getReservesList: L2PoolGetReservesListContractFunction

    getSupplyLogic: L2PoolGetSupplyLogicContractFunction

    getUserAccountData: L2PoolGetUserAccountDataContractFunction

    getUserConfiguration: L2PoolGetUserConfigurationContractFunction

    getUserEMode: L2PoolGetUserEModeContractFunction

    getVirtualUnderlyingBalance: (
        L2PoolGetVirtualUnderlyingBalanceContractFunction
    )

    initReserve: L2PoolInitReserveContractFunction

    initialize: L2PoolInitializeContractFunction

    liquidationCall: L2PoolLiquidationCallContractFunction

    mintToTreasury: L2PoolMintToTreasuryContractFunction

    mintUnbacked: L2PoolMintUnbackedContractFunction

    rebalanceStableBorrowRate: L2PoolRebalanceStableBorrowRateContractFunction

    repay: L2PoolRepayContractFunction

    repayWithATokens: L2PoolRepayWithATokensContractFunction

    repayWithPermit: L2PoolRepayWithPermitContractFunction

    rescueTokens: L2PoolRescueTokensContractFunction

    resetIsolationModeTotalDebt: (
        L2PoolResetIsolationModeTotalDebtContractFunction
    )

    setConfiguration: L2PoolSetConfigurationContractFunction

    setLiquidationGracePeriod: L2PoolSetLiquidationGracePeriodContractFunction

    setReserveInterestRateStrategyAddress: (
        L2PoolSetReserveInterestRateStrategyAddressContractFunction
    )

    setUserEMode: L2PoolSetUserEModeContractFunction

    setUserUseReserveAsCollateral: (
        L2PoolSetUserUseReserveAsCollateralContractFunction
    )

    supply: L2PoolSupplyContractFunction

    supplyWithPermit: L2PoolSupplyWithPermitContractFunction

    swapBorrowRateMode: L2PoolSwapBorrowRateModeContractFunction

    swapToVariable: L2PoolSwapToVariableContractFunction

    syncIndexesState: L2PoolSyncIndexesStateContractFunction

    syncRatesState: L2PoolSyncRatesStateContractFunction

    updateBridgeProtocolFee: L2PoolUpdateBridgeProtocolFeeContractFunction

    updateFlashloanPremiums: L2PoolUpdateFlashloanPremiumsContractFunction

    withdraw: L2PoolWithdrawContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.ADDRESSES_PROVIDER = (
            L2PoolADDRESSES_PROVIDERContractFunction.factory(
                "ADDRESSES_PROVIDER",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ADDRESSES_PROVIDER",
            )
        )
        self.BRIDGE_PROTOCOL_FEE = (
            L2PoolBRIDGE_PROTOCOL_FEEContractFunction.factory(
                "BRIDGE_PROTOCOL_FEE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="BRIDGE_PROTOCOL_FEE",
            )
        )
        self.FLASHLOAN_PREMIUM_TOTAL = (
            L2PoolFLASHLOAN_PREMIUM_TOTALContractFunction.factory(
                "FLASHLOAN_PREMIUM_TOTAL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TOTAL",
            )
        )
        self.FLASHLOAN_PREMIUM_TO_PROTOCOL = (
            L2PoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction.factory(
                "FLASHLOAN_PREMIUM_TO_PROTOCOL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TO_PROTOCOL",
            )
        )
        self.MAX_NUMBER_RESERVES = (
            L2PoolMAX_NUMBER_RESERVESContractFunction.factory(
                "MAX_NUMBER_RESERVES",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="MAX_NUMBER_RESERVES",
            )
        )
        self.MAX_STABLE_RATE_BORROW_SIZE_PERCENT = (
            L2PoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction.factory(
                "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            )
        )
        self.backUnbacked = L2PoolBackUnbackedContractFunction.factory(
            "backUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="backUnbacked",
        )
        self.borrow = L2PoolBorrowContractFunction.factory(
            "borrow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="borrow",
        )
        self.configureEModeCategory = (
            L2PoolConfigureEModeCategoryContractFunction.factory(
                "configureEModeCategory",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="configureEModeCategory",
            )
        )
        self.deposit = L2PoolDepositContractFunction.factory(
            "deposit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deposit",
        )
        self.dropReserve = L2PoolDropReserveContractFunction.factory(
            "dropReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="dropReserve",
        )
        self.finalizeTransfer = L2PoolFinalizeTransferContractFunction.factory(
            "finalizeTransfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="finalizeTransfer",
        )
        self.flashLoan = L2PoolFlashLoanContractFunction.factory(
            "flashLoan",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="flashLoan",
        )
        self.flashLoanSimple = L2PoolFlashLoanSimpleContractFunction.factory(
            "flashLoanSimple",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="flashLoanSimple",
        )
        self.getBorrowLogic = L2PoolGetBorrowLogicContractFunction.factory(
            "getBorrowLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBorrowLogic",
        )
        self.getBridgeLogic = L2PoolGetBridgeLogicContractFunction.factory(
            "getBridgeLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBridgeLogic",
        )
        self.getConfiguration = L2PoolGetConfigurationContractFunction.factory(
            "getConfiguration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getConfiguration",
        )
        self.getEModeCategoryData = (
            L2PoolGetEModeCategoryDataContractFunction.factory(
                "getEModeCategoryData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getEModeCategoryData",
            )
        )
        self.getEModeLogic = L2PoolGetEModeLogicContractFunction.factory(
            "getEModeLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getEModeLogic",
        )
        self.getFlashLoanLogic = (
            L2PoolGetFlashLoanLogicContractFunction.factory(
                "getFlashLoanLogic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getFlashLoanLogic",
            )
        )
        self.getLiquidationGracePeriod = (
            L2PoolGetLiquidationGracePeriodContractFunction.factory(
                "getLiquidationGracePeriod",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getLiquidationGracePeriod",
            )
        )
        self.getLiquidationLogic = (
            L2PoolGetLiquidationLogicContractFunction.factory(
                "getLiquidationLogic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getLiquidationLogic",
            )
        )
        self.getPoolLogic = L2PoolGetPoolLogicContractFunction.factory(
            "getPoolLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getPoolLogic",
        )
        self.getReserveAddressById = (
            L2PoolGetReserveAddressByIdContractFunction.factory(
                "getReserveAddressById",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveAddressById",
            )
        )
        self.getReserveData = L2PoolGetReserveDataContractFunction.factory(
            "getReserveData",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReserveData",
        )
        self.getReserveDataExtended = (
            L2PoolGetReserveDataExtendedContractFunction.factory(
                "getReserveDataExtended",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveDataExtended",
            )
        )
        self.getReserveNormalizedIncome = (
            L2PoolGetReserveNormalizedIncomeContractFunction.factory(
                "getReserveNormalizedIncome",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedIncome",
            )
        )
        self.getReserveNormalizedVariableDebt = (
            L2PoolGetReserveNormalizedVariableDebtContractFunction.factory(
                "getReserveNormalizedVariableDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedVariableDebt",
            )
        )
        self.getReservesCount = L2PoolGetReservesCountContractFunction.factory(
            "getReservesCount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReservesCount",
        )
        self.getReservesList = L2PoolGetReservesListContractFunction.factory(
            "getReservesList",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReservesList",
        )
        self.getSupplyLogic = L2PoolGetSupplyLogicContractFunction.factory(
            "getSupplyLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getSupplyLogic",
        )
        self.getUserAccountData = (
            L2PoolGetUserAccountDataContractFunction.factory(
                "getUserAccountData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserAccountData",
            )
        )
        self.getUserConfiguration = (
            L2PoolGetUserConfigurationContractFunction.factory(
                "getUserConfiguration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserConfiguration",
            )
        )
        self.getUserEMode = L2PoolGetUserEModeContractFunction.factory(
            "getUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserEMode",
        )
        self.getVirtualUnderlyingBalance = (
            L2PoolGetVirtualUnderlyingBalanceContractFunction.factory(
                "getVirtualUnderlyingBalance",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getVirtualUnderlyingBalance",
            )
        )
        self.initReserve = L2PoolInitReserveContractFunction.factory(
            "initReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initReserve",
        )
        self.initialize = L2PoolInitializeContractFunction.factory(
            "initialize",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initialize",
        )
        self.liquidationCall = L2PoolLiquidationCallContractFunction.factory(
            "liquidationCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="liquidationCall",
        )
        self.mintToTreasury = L2PoolMintToTreasuryContractFunction.factory(
            "mintToTreasury",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintToTreasury",
        )
        self.mintUnbacked = L2PoolMintUnbackedContractFunction.factory(
            "mintUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintUnbacked",
        )
        self.rebalanceStableBorrowRate = (
            L2PoolRebalanceStableBorrowRateContractFunction.factory(
                "rebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="rebalanceStableBorrowRate",
            )
        )
        self.repay = L2PoolRepayContractFunction.factory(
            "repay",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repay",
        )
        self.repayWithATokens = L2PoolRepayWithATokensContractFunction.factory(
            "repayWithATokens",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repayWithATokens",
        )
        self.repayWithPermit = L2PoolRepayWithPermitContractFunction.factory(
            "repayWithPermit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repayWithPermit",
        )
        self.rescueTokens = L2PoolRescueTokensContractFunction.factory(
            "rescueTokens",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rescueTokens",
        )
        self.resetIsolationModeTotalDebt = (
            L2PoolResetIsolationModeTotalDebtContractFunction.factory(
                "resetIsolationModeTotalDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="resetIsolationModeTotalDebt",
            )
        )
        self.setConfiguration = L2PoolSetConfigurationContractFunction.factory(
            "setConfiguration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setConfiguration",
        )
        self.setLiquidationGracePeriod = (
            L2PoolSetLiquidationGracePeriodContractFunction.factory(
                "setLiquidationGracePeriod",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setLiquidationGracePeriod",
            )
        )
        self.setReserveInterestRateStrategyAddress = (
            L2PoolSetReserveInterestRateStrategyAddressContractFunction.factory(
                "setReserveInterestRateStrategyAddress",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setReserveInterestRateStrategyAddress",
            )
        )
        self.setUserEMode = L2PoolSetUserEModeContractFunction.factory(
            "setUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserEMode",
        )
        self.setUserUseReserveAsCollateral = (
            L2PoolSetUserUseReserveAsCollateralContractFunction.factory(
                "setUserUseReserveAsCollateral",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUserUseReserveAsCollateral",
            )
        )
        self.supply = L2PoolSupplyContractFunction.factory(
            "supply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="supply",
        )
        self.supplyWithPermit = L2PoolSupplyWithPermitContractFunction.factory(
            "supplyWithPermit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="supplyWithPermit",
        )
        self.swapBorrowRateMode = (
            L2PoolSwapBorrowRateModeContractFunction.factory(
                "swapBorrowRateMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="swapBorrowRateMode",
            )
        )
        self.swapToVariable = L2PoolSwapToVariableContractFunction.factory(
            "swapToVariable",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="swapToVariable",
        )
        self.syncIndexesState = L2PoolSyncIndexesStateContractFunction.factory(
            "syncIndexesState",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="syncIndexesState",
        )
        self.syncRatesState = L2PoolSyncRatesStateContractFunction.factory(
            "syncRatesState",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="syncRatesState",
        )
        self.updateBridgeProtocolFee = (
            L2PoolUpdateBridgeProtocolFeeContractFunction.factory(
                "updateBridgeProtocolFee",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateBridgeProtocolFee",
            )
        )
        self.updateFlashloanPremiums = (
            L2PoolUpdateFlashloanPremiumsContractFunction.factory(
                "updateFlashloanPremiums",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateFlashloanPremiums",
            )
        )
        self.withdraw = L2PoolWithdrawContractFunction.factory(
            "withdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="withdraw",
        )


class L2PoolBackUnbackedContractEvent(ContractEvent):
    """ContractEvent for BackUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolBorrowContractEvent(ContractEvent):
    """ContractEvent for Borrow."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BorrowEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BorrowEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolFlashLoanContractEvent(ContractEvent):
    """ContractEvent for FlashLoan."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolIsolationModeTotalDebtUpdatedContractEvent(ContractEvent):
    """ContractEvent for IsolationModeTotalDebtUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolLiquidationCallContractEvent(ContractEvent):
    """ContractEvent for LiquidationCall."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolMintUnbackedContractEvent(ContractEvent):
    """ContractEvent for MintUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolMintedToTreasuryContractEvent(ContractEvent):
    """ContractEvent for MintedToTreasury."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolRebalanceStableBorrowRateContractEvent(ContractEvent):
    """ContractEvent for RebalanceStableBorrowRate."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolRepayContractEvent(ContractEvent):
    """ContractEvent for Repay."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RepayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RepayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolReserveDataUpdatedContractEvent(ContractEvent):
    """ContractEvent for ReserveDataUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolReserveUsedAsCollateralDisabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralDisabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolReserveUsedAsCollateralEnabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralEnabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolSupplyContractEvent(ContractEvent):
    """ContractEvent for Supply."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SupplyEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SupplyEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolSwapBorrowRateModeContractEvent(ContractEvent):
    """ContractEvent for SwapBorrowRateMode."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolUserEModeSetContractEvent(ContractEvent):
    """ContractEvent for UserEModeSet."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolWithdrawContractEvent(ContractEvent):
    """ContractEvent for Withdraw."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[WithdrawEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[WithdrawEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class L2PoolContractEvents(ContractEvents):
    """ContractEvents for the L2Pool contract."""

    BackUnbacked: L2PoolBackUnbackedContractEvent

    Borrow: L2PoolBorrowContractEvent

    FlashLoan: L2PoolFlashLoanContractEvent

    IsolationModeTotalDebtUpdated: (
        L2PoolIsolationModeTotalDebtUpdatedContractEvent
    )

    LiquidationCall: L2PoolLiquidationCallContractEvent

    MintUnbacked: L2PoolMintUnbackedContractEvent

    MintedToTreasury: L2PoolMintedToTreasuryContractEvent

    RebalanceStableBorrowRate: L2PoolRebalanceStableBorrowRateContractEvent

    Repay: L2PoolRepayContractEvent

    ReserveDataUpdated: L2PoolReserveDataUpdatedContractEvent

    ReserveUsedAsCollateralDisabled: (
        L2PoolReserveUsedAsCollateralDisabledContractEvent
    )

    ReserveUsedAsCollateralEnabled: (
        L2PoolReserveUsedAsCollateralEnabledContractEvent
    )

    Supply: L2PoolSupplyContractEvent

    SwapBorrowRateMode: L2PoolSwapBorrowRateModeContractEvent

    UserEModeSet: L2PoolUserEModeSetContractEvent

    Withdraw: L2PoolWithdrawContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.BackUnbacked = L2PoolBackUnbackedContractEvent.factory(
            "BackUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="BackUnbacked",
        )
        self.Borrow = L2PoolBorrowContractEvent.factory(
            "Borrow",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Borrow",
        )
        self.FlashLoan = L2PoolFlashLoanContractEvent.factory(
            "FlashLoan",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="FlashLoan",
        )
        self.IsolationModeTotalDebtUpdated = (
            L2PoolIsolationModeTotalDebtUpdatedContractEvent.factory(
                "IsolationModeTotalDebtUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="IsolationModeTotalDebtUpdated",
            )
        )
        self.LiquidationCall = L2PoolLiquidationCallContractEvent.factory(
            "LiquidationCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="LiquidationCall",
        )
        self.MintUnbacked = L2PoolMintUnbackedContractEvent.factory(
            "MintUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="MintUnbacked",
        )
        self.MintedToTreasury = L2PoolMintedToTreasuryContractEvent.factory(
            "MintedToTreasury",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="MintedToTreasury",
        )
        self.RebalanceStableBorrowRate = (
            L2PoolRebalanceStableBorrowRateContractEvent.factory(
                "RebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RebalanceStableBorrowRate",
            )
        )
        self.Repay = L2PoolRepayContractEvent.factory(
            "Repay",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Repay",
        )
        self.ReserveDataUpdated = L2PoolReserveDataUpdatedContractEvent.factory(
            "ReserveDataUpdated",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="ReserveDataUpdated",
        )
        self.ReserveUsedAsCollateralDisabled = (
            L2PoolReserveUsedAsCollateralDisabledContractEvent.factory(
                "ReserveUsedAsCollateralDisabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralDisabled",
            )
        )
        self.ReserveUsedAsCollateralEnabled = (
            L2PoolReserveUsedAsCollateralEnabledContractEvent.factory(
                "ReserveUsedAsCollateralEnabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralEnabled",
            )
        )
        self.Supply = L2PoolSupplyContractEvent.factory(
            "Supply",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Supply",
        )
        self.SwapBorrowRateMode = L2PoolSwapBorrowRateModeContractEvent.factory(
            "SwapBorrowRateMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="SwapBorrowRateMode",
        )
        self.UserEModeSet = L2PoolUserEModeSetContractEvent.factory(
            "UserEModeSet",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="UserEModeSet",
        )
        self.Withdraw = L2PoolWithdrawContractEvent.factory(
            "Withdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Withdraw",
        )


class L2PoolContract(Contract):
    """A web3.py Contract class for the L2Pool contract."""

    abi: ABI = l2pool_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = L2PoolContractFunctions(l2pool_abi, self.w3, address)  # type: ignore
        self.events = L2PoolContractEvents(l2pool_abi, self.w3, address)  # type: ignore

    events: L2PoolContractEvents

    functions: L2PoolContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = L2PoolContractFunctions(l2pool_abi, w3, None)

        return contract
