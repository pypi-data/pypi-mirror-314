"""A web3.py Contract class for the IPool contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..DataTypes import DataTypesTypes as DataTypes
from .IPoolTypes import (
    BackUnbackedEvent,
    BorrowEvent,
    FlashLoanEvent,
    IsolationModeTotalDebtUpdatedEvent,
    LiquidationCallEvent,
    MintedToTreasuryEvent,
    MintUnbackedEvent,
    RebalanceStableBorrowRateEvent,
    RepayEvent,
    ReserveDataUpdatedEvent,
    ReserveUsedAsCollateralDisabledEvent,
    ReserveUsedAsCollateralEnabledEvent,
    SupplyEvent,
    SwapBorrowRateModeEvent,
    UserEModeSetEvent,
    WithdrawEvent,
)

structs = {
    "DataTypes.EModeCategory": DataTypes.EModeCategory,
    "DataTypes.ReserveConfigurationMap": DataTypes.ReserveConfigurationMap,
    "DataTypes.ReserveDataLegacy": DataTypes.ReserveDataLegacy,
    "DataTypes.ReserveData": DataTypes.ReserveData,
    "DataTypes.UserConfigurationMap": DataTypes.UserConfigurationMap,
}

ipool_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "ADDRESSES_PROVIDER",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract IPoolAddressesProvider",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "BRIDGE_PROTOCOL_FEE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TOTAL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_TO_PROTOCOL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_NUMBER_RESERVES",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint16", "internalType": "uint16"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "backUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "fee", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "borrow",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "configureEModeCategory",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "config",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deposit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "dropReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "finalizeTransfer",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceFromBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "balanceToBefore",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoan",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "amounts",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "interestRateModes",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "flashLoanSimple",
            "inputs": [
                {
                    "name": "receiverAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "params", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getBorrowLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getBridgeLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getEModeCategoryData",
            "inputs": [
                {"name": "id", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.EModeCategory",
                    "components": [
                        {
                            "name": "ltv",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationThreshold",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationBonus",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "priceSource",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "label",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getEModeLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getFlashLoanLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getLiquidationGracePeriod",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint40", "internalType": "uint40"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getLiquidationLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getPoolLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getReserveAddressById",
            "inputs": [
                {"name": "id", "type": "uint16", "internalType": "uint16"}
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveData",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveDataLegacy",
                    "components": [
                        {
                            "name": "configuration",
                            "type": "tuple",
                            "internalType": "struct DataTypes.ReserveConfigurationMap",
                            "components": [
                                {
                                    "name": "data",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                }
                            ],
                        },
                        {
                            "name": "liquidityIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentLiquidityRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "variableBorrowIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentVariableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentStableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "lastUpdateTimestamp",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "id",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "aTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "stableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "variableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "interestRateStrategyAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accruedToTreasury",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "unbacked",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "isolationModeTotalDebt",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveDataExtended",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveData",
                    "components": [
                        {
                            "name": "configuration",
                            "type": "tuple",
                            "internalType": "struct DataTypes.ReserveConfigurationMap",
                            "components": [
                                {
                                    "name": "data",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                }
                            ],
                        },
                        {
                            "name": "liquidityIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentLiquidityRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "variableBorrowIndex",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentVariableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "currentStableBorrowRate",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "lastUpdateTimestamp",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "id",
                            "type": "uint16",
                            "internalType": "uint16",
                        },
                        {
                            "name": "liquidationGracePeriodUntil",
                            "type": "uint40",
                            "internalType": "uint40",
                        },
                        {
                            "name": "aTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "stableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "variableDebtTokenAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "interestRateStrategyAddress",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accruedToTreasury",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "unbacked",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "isolationModeTotalDebt",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                        {
                            "name": "virtualUnderlyingBalance",
                            "type": "uint128",
                            "internalType": "uint128",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedIncome",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReserveNormalizedVariableDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReservesCount",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getReservesList",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getSupplyLogic",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getUserAccountData",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "totalCollateralBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "totalDebtBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "availableBorrowsBase",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "currentLiquidationThreshold",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "ltv", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "healthFactor",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserConfiguration",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "tuple",
                    "internalType": "struct DataTypes.UserConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getUserEMode",
            "inputs": [
                {"name": "user", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getVirtualUnderlyingBalance",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {"name": "", "type": "uint128", "internalType": "uint128"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "initReserve",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "aTokenAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "stableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "variableDebtAddress",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "interestRateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "liquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintToTreasury",
            "inputs": [
                {
                    "name": "assets",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mintUnbacked",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rebalanceStableBorrowRate",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "user", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repay",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithATokens",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "repayWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rescueTokens",
            "inputs": [
                {"name": "token", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "resetIsolationModeTotalDebt",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setConfiguration",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "configuration",
                    "type": "tuple",
                    "internalType": "struct DataTypes.ReserveConfigurationMap",
                    "components": [
                        {
                            "name": "data",
                            "type": "uint256",
                            "internalType": "uint256",
                        }
                    ],
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setLiquidationGracePeriod",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "until", "type": "uint40", "internalType": "uint40"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setReserveInterestRateStrategyAddress",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "rateStrategyAddress",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserEMode",
            "inputs": [
                {"name": "categoryId", "type": "uint8", "internalType": "uint8"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setUserUseReserveAsCollateral",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "useAsCollateral",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supply",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "supplyWithPermit",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "internalType": "uint16",
                },
                {
                    "name": "deadline",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "permitV", "type": "uint8", "internalType": "uint8"},
                {
                    "name": "permitR",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "permitS",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapBorrowRateMode",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "interestRateMode",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapToVariable",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {"name": "user", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "syncIndexesState",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "syncRatesState",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateBridgeProtocolFee",
            "inputs": [
                {
                    "name": "bridgeProtocolFee",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "updateFlashloanPremiums",
            "inputs": [
                {
                    "name": "flashLoanPremiumTotal",
                    "type": "uint128",
                    "internalType": "uint128",
                },
                {
                    "name": "flashLoanPremiumToProtocol",
                    "type": "uint128",
                    "internalType": "uint128",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "asset", "type": "address", "internalType": "address"},
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "to", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "BackUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "backer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "fee",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Borrow",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "borrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "FlashLoan",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "initiator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
                {
                    "name": "premium",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "IsolationModeTotalDebtUpdated",
            "inputs": [
                {
                    "name": "asset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "totalDebt",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "LiquidationCall",
            "inputs": [
                {
                    "name": "collateralAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtAsset",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "debtToCover",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidatedCollateralAmount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidator",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "receiveAToken",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintUnbacked",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "MintedToTreasury",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amountMinted",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "RebalanceStableBorrowRate",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Repay",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "repayer",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "useATokens",
                    "type": "bool",
                    "indexed": False,
                    "internalType": "bool",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveDataUpdated",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "liquidityRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "stableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowRate",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "liquidityIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "variableBorrowIndex",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralDisabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "ReserveUsedAsCollateralEnabled",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Supply",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
                {
                    "name": "onBehalfOf",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "referralCode",
                    "type": "uint16",
                    "indexed": True,
                    "internalType": "uint16",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "SwapBorrowRateMode",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "interestRateMode",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "enum DataTypes.InterestRateMode",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UserEModeSet",
            "inputs": [
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "categoryId",
                    "type": "uint8",
                    "indexed": False,
                    "internalType": "uint8",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Withdraw",
            "inputs": [
                {
                    "name": "reserve",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "user",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
    ],
)


class IPoolContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the IPool contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class IPoolADDRESSES_PROVIDERContractFunction0(PypechainContractFunction):
    """ContractFunction for the ADDRESSES_PROVIDER() method."""

    _function_name = "ADDRESSES_PROVIDER"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolADDRESSES_PROVIDERContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the ADDRESSES_PROVIDER method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ADDRESSES_PROVIDER"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolADDRESSES_PROVIDERContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolADDRESSES_PROVIDERContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolADDRESSES_PROVIDERContractFunction0._type_signature: IPoolADDRESSES_PROVIDERContractFunction0,
        }
        return out


class IPoolBRIDGE_PROTOCOL_FEEContractFunction0(PypechainContractFunction):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE() method."""

    _function_name = "BRIDGE_PROTOCOL_FEE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolBRIDGE_PROTOCOL_FEEContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "BRIDGE_PROTOCOL_FEE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolBRIDGE_PROTOCOL_FEEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolBRIDGE_PROTOCOL_FEEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolBRIDGE_PROTOCOL_FEEContractFunction0._type_signature: IPoolBRIDGE_PROTOCOL_FEEContractFunction0,
        }
        return out


class IPoolFLASHLOAN_PREMIUM_TOTALContractFunction0(PypechainContractFunction):
    """ContractFunction for the FLASHLOAN_PREMIUM_TOTAL() method."""

    _function_name = "FLASHLOAN_PREMIUM_TOTAL"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolFLASHLOAN_PREMIUM_TOTALContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TOTAL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_PREMIUM_TOTAL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolFLASHLOAN_PREMIUM_TOTALContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolFLASHLOAN_PREMIUM_TOTALContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolFLASHLOAN_PREMIUM_TOTALContractFunction0._type_signature: IPoolFLASHLOAN_PREMIUM_TOTALContractFunction0,
        }
        return out


class IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TO_PROTOCOL() method."""

    _function_name = "FLASHLOAN_PREMIUM_TO_PROTOCOL"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the FLASHLOAN_PREMIUM_TO_PROTOCOL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_PREMIUM_TO_PROTOCOL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0._type_signature: IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction0,
        }
        return out


class IPoolMAX_NUMBER_RESERVESContractFunction0(PypechainContractFunction):
    """ContractFunction for the MAX_NUMBER_RESERVES() method."""

    _function_name = "MAX_NUMBER_RESERVES"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolMAX_NUMBER_RESERVESContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the MAX_NUMBER_RESERVES method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "MAX_NUMBER_RESERVES"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolMAX_NUMBER_RESERVESContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolMAX_NUMBER_RESERVESContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolMAX_NUMBER_RESERVESContractFunction0._type_signature: IPoolMAX_NUMBER_RESERVESContractFunction0,
        }
        return out


class IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the MAX_STABLE_RATE_BORROW_SIZE_PERCENT() method."""

    _function_name = "MAX_STABLE_RATE_BORROW_SIZE_PERCENT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the MAX_STABLE_RATE_BORROW_SIZE_PERCENT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "MAX_STABLE_RATE_BORROW_SIZE_PERCENT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0._type_signature: IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction0,
        }
        return out


class IPoolBackUnbackedContractFunction0(PypechainContractFunction):
    """ContractFunction for the backUnbacked(str,int,int) method."""

    _function_name = "backUnbacked"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolBackUnbackedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the backUnbacked method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "backUnbacked"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, fee: int) -> IPoolBackUnbackedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolBackUnbackedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolBackUnbackedContractFunction0._type_signature: IPoolBackUnbackedContractFunction0,
        }
        return out


class IPoolBorrowContractFunction0(PypechainContractFunction):
    """ContractFunction for the borrow(str,int,int,int,str) method."""

    _function_name = "borrow"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "int", "str"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolBorrowContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the borrow method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "borrow"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, referralCode: int, onBehalfOf: str) -> IPoolBorrowContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolBorrowContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolBorrowContractFunction0._type_signature: IPoolBorrowContractFunction0,
        }
        return out


class IPoolConfigureEModeCategoryContractFunction0(PypechainContractFunction):
    """ContractFunction for the configureEModeCategory(int,DataTypes.EModeCategory) method."""

    _function_name = "configureEModeCategory"
    _type_signature = expand_struct_type_str(
        tuple(["int", "DataTypes.EModeCategory"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolConfigureEModeCategoryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the configureEModeCategory method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "configureEModeCategory"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int, config: DataTypes.EModeCategory) -> IPoolConfigureEModeCategoryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolConfigureEModeCategoryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolConfigureEModeCategoryContractFunction0._type_signature: IPoolConfigureEModeCategoryContractFunction0,
        }
        return out


class IPoolDepositContractFunction0(PypechainContractFunction):
    """ContractFunction for the deposit(str,int,str,int) method."""

    _function_name = "deposit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolDepositContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deposit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deposit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> IPoolDepositContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolDepositContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolDepositContractFunction0._type_signature: IPoolDepositContractFunction0,
        }
        return out


class IPoolDropReserveContractFunction0(PypechainContractFunction):
    """ContractFunction for the dropReserve(str) method."""

    _function_name = "dropReserve"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolDropReserveContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the dropReserve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "dropReserve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolDropReserveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolDropReserveContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolDropReserveContractFunction0._type_signature: IPoolDropReserveContractFunction0,
        }
        return out


class IPoolFinalizeTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the finalizeTransfer(str,str,str,int,int,int) method."""

    _function_name = "finalizeTransfer"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "int", "int", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolFinalizeTransferContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the finalizeTransfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "finalizeTransfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, _from: str, to: str, amount: int, balanceFromBefore: int, balanceToBefore: int) -> IPoolFinalizeTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolFinalizeTransferContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolFinalizeTransferContractFunction0._type_signature: IPoolFinalizeTransferContractFunction0,
        }
        return out


class IPoolFlashLoanContractFunction0(PypechainContractFunction):
    """ContractFunction for the flashLoan(str,list[str],list[int],list[int],str,bytes,int) method."""

    _function_name = "flashLoan"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "list[str]",
                "list[int]",
                "list[int]",
                "str",
                "bytes",
                "int",
            ]
        ),
        structs,
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolFlashLoanContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the flashLoan method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "flashLoan"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiverAddress: str, assets: list[str], amounts: list[int], interestRateModes: list[int], onBehalfOf: str, params: bytes, referralCode: int) -> IPoolFlashLoanContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolFlashLoanContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolFlashLoanContractFunction0._type_signature: IPoolFlashLoanContractFunction0,
        }
        return out


class IPoolFlashLoanSimpleContractFunction0(PypechainContractFunction):
    """ContractFunction for the flashLoanSimple(str,str,int,bytes,int) method."""

    _function_name = "flashLoanSimple"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int", "bytes", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolFlashLoanSimpleContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the flashLoanSimple method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "flashLoanSimple"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiverAddress: str, asset: str, amount: int, params: bytes, referralCode: int) -> IPoolFlashLoanSimpleContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolFlashLoanSimpleContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolFlashLoanSimpleContractFunction0._type_signature: IPoolFlashLoanSimpleContractFunction0,
        }
        return out


class IPoolGetBorrowLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBorrowLogic() method."""

    _function_name = "getBorrowLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetBorrowLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBorrowLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBorrowLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetBorrowLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetBorrowLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetBorrowLogicContractFunction0._type_signature: IPoolGetBorrowLogicContractFunction0,
        }
        return out


class IPoolGetBridgeLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBridgeLogic() method."""

    _function_name = "getBridgeLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetBridgeLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBridgeLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBridgeLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetBridgeLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetBridgeLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetBridgeLogicContractFunction0._type_signature: IPoolGetBridgeLogicContractFunction0,
        }
        return out


class IPoolGetConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the getConfiguration(str) method."""

    _function_name = "getConfiguration"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveConfigurationMap:
        """returns DataTypes.ReserveConfigurationMap."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveConfigurationMap

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetConfigurationContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolGetConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetConfigurationContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetConfigurationContractFunction0._type_signature: IPoolGetConfigurationContractFunction0,
        }
        return out


class IPoolGetEModeCategoryDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getEModeCategoryData(int) method."""

    _function_name = "getEModeCategoryData"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.EModeCategory:
        """returns DataTypes.EModeCategory."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.EModeCategory

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.EModeCategory,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetEModeCategoryDataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getEModeCategoryData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getEModeCategoryData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int) -> IPoolGetEModeCategoryDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetEModeCategoryDataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetEModeCategoryDataContractFunction0._type_signature: IPoolGetEModeCategoryDataContractFunction0,
        }
        return out


class IPoolGetEModeLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getEModeLogic() method."""

    _function_name = "getEModeLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetEModeLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getEModeLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getEModeLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetEModeLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetEModeLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetEModeLogicContractFunction0._type_signature: IPoolGetEModeLogicContractFunction0,
        }
        return out


class IPoolGetFlashLoanLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getFlashLoanLogic() method."""

    _function_name = "getFlashLoanLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetFlashLoanLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getFlashLoanLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getFlashLoanLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetFlashLoanLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetFlashLoanLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetFlashLoanLogicContractFunction0._type_signature: IPoolGetFlashLoanLogicContractFunction0,
        }
        return out


class IPoolGetLiquidationGracePeriodContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getLiquidationGracePeriod(str) method."""

    _function_name = "getLiquidationGracePeriod"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetLiquidationGracePeriodContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getLiquidationGracePeriod method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLiquidationGracePeriod"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolGetLiquidationGracePeriodContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetLiquidationGracePeriodContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetLiquidationGracePeriodContractFunction0._type_signature: IPoolGetLiquidationGracePeriodContractFunction0,
        }
        return out


class IPoolGetLiquidationLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getLiquidationLogic() method."""

    _function_name = "getLiquidationLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetLiquidationLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getLiquidationLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLiquidationLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetLiquidationLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetLiquidationLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetLiquidationLogicContractFunction0._type_signature: IPoolGetLiquidationLogicContractFunction0,
        }
        return out


class IPoolGetPoolLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getPoolLogic() method."""

    _function_name = "getPoolLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetPoolLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getPoolLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getPoolLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetPoolLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetPoolLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetPoolLogicContractFunction0._type_signature: IPoolGetPoolLogicContractFunction0,
        }
        return out


class IPoolGetReserveAddressByIdContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReserveAddressById(int) method."""

    _function_name = "getReserveAddressById"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReserveAddressByIdContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReserveAddressById method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveAddressById"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _id: int) -> IPoolGetReserveAddressByIdContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetReserveAddressByIdContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetReserveAddressByIdContractFunction0._type_signature: IPoolGetReserveAddressByIdContractFunction0,
        }
        return out


class IPoolGetReserveDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReserveData(str) method."""

    _function_name = "getReserveData"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveDataLegacy:
        """returns DataTypes.ReserveDataLegacy."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveDataLegacy

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveDataLegacy,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetReserveDataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReserveData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolGetReserveDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetReserveDataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetReserveDataContractFunction0._type_signature: IPoolGetReserveDataContractFunction0,
        }
        return out


class IPoolGetReserveDataExtendedContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReserveDataExtended(str) method."""

    _function_name = "getReserveDataExtended"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.ReserveData:
        """returns DataTypes.ReserveData."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.ReserveData

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.ReserveData,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetReserveDataExtendedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReserveDataExtended method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveDataExtended"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolGetReserveDataExtendedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetReserveDataExtendedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetReserveDataExtendedContractFunction0._type_signature: IPoolGetReserveDataExtendedContractFunction0,
        }
        return out


class IPoolGetReserveNormalizedIncomeContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedIncome(str) method."""

    _function_name = "getReserveNormalizedIncome"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReserveNormalizedIncomeContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getReserveNormalizedIncome method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveNormalizedIncome"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolGetReserveNormalizedIncomeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetReserveNormalizedIncomeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetReserveNormalizedIncomeContractFunction0._type_signature: IPoolGetReserveNormalizedIncomeContractFunction0,
        }
        return out


class IPoolGetReserveNormalizedVariableDebtContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getReserveNormalizedVariableDebt(str) method."""

    _function_name = "getReserveNormalizedVariableDebt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReserveNormalizedVariableDebtContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getReserveNormalizedVariableDebt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReserveNormalizedVariableDebt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolGetReserveNormalizedVariableDebtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetReserveNormalizedVariableDebtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetReserveNormalizedVariableDebtContractFunction0._type_signature: IPoolGetReserveNormalizedVariableDebtContractFunction0,
        }
        return out


class IPoolGetReservesCountContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReservesCount() method."""

    _function_name = "getReservesCount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReservesCountContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReservesCount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReservesCount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetReservesCountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetReservesCountContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetReservesCountContractFunction0._type_signature: IPoolGetReservesCountContractFunction0,
        }
        return out


class IPoolGetReservesListContractFunction0(PypechainContractFunction):
    """ContractFunction for the getReservesList() method."""

    _function_name = "getReservesList"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetReservesListContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getReservesList method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getReservesList"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetReservesListContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetReservesListContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetReservesListContractFunction0._type_signature: IPoolGetReservesListContractFunction0,
        }
        return out


class IPoolGetSupplyLogicContractFunction0(PypechainContractFunction):
    """ContractFunction for the getSupplyLogic() method."""

    _function_name = "getSupplyLogic"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetSupplyLogicContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getSupplyLogic method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getSupplyLogic"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPoolGetSupplyLogicContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetSupplyLogicContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetSupplyLogicContractFunction0._type_signature: IPoolGetSupplyLogicContractFunction0,
        }
        return out


class IPoolGetUserAccountDataContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserAccountData(str) method."""

    _function_name = "getUserAccountData"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for GetUserAccountData."""

        totalCollateralBase: int
        totalDebtBase: int
        availableBorrowsBase: int
        currentLiquidationThreshold: int
        ltv: int
        healthFactor: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int, int, int, int, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetUserAccountDataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getUserAccountData method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserAccountData"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> IPoolGetUserAccountDataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetUserAccountDataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetUserAccountDataContractFunction0._type_signature: IPoolGetUserAccountDataContractFunction0,
        }
        return out


class IPoolGetUserConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserConfiguration(str) method."""

    _function_name = "getUserConfiguration"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> DataTypes.UserConfigurationMap:
        """returns DataTypes.UserConfigurationMap."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = DataTypes.UserConfigurationMap

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            DataTypes.UserConfigurationMap,
            rename_returned_types(structs, return_types, raw_values),
        )


class IPoolGetUserConfigurationContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getUserConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> IPoolGetUserConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetUserConfigurationContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetUserConfigurationContractFunction0._type_signature: IPoolGetUserConfigurationContractFunction0,
        }
        return out


class IPoolGetUserEModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the getUserEMode(str) method."""

    _function_name = "getUserEMode"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetUserEModeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getUserEMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getUserEMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, user: str) -> IPoolGetUserEModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetUserEModeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetUserEModeContractFunction0._type_signature: IPoolGetUserEModeContractFunction0,
        }
        return out


class IPoolGetVirtualUnderlyingBalanceContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getVirtualUnderlyingBalance(str) method."""

    _function_name = "getVirtualUnderlyingBalance"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolGetVirtualUnderlyingBalanceContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getVirtualUnderlyingBalance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getVirtualUnderlyingBalance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolGetVirtualUnderlyingBalanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolGetVirtualUnderlyingBalanceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolGetVirtualUnderlyingBalanceContractFunction0._type_signature: IPoolGetVirtualUnderlyingBalanceContractFunction0,
        }
        return out


class IPoolInitReserveContractFunction0(PypechainContractFunction):
    """ContractFunction for the initReserve(str,str,str,str,str) method."""

    _function_name = "initReserve"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "str", "str"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolInitReserveContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the initReserve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "initReserve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, aTokenAddress: str, stableDebtAddress: str, variableDebtAddress: str, interestRateStrategyAddress: str) -> IPoolInitReserveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolInitReserveContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolInitReserveContractFunction0._type_signature: IPoolInitReserveContractFunction0,
        }
        return out


class IPoolLiquidationCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the liquidationCall(str,str,str,int,bool) method."""

    _function_name = "liquidationCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str", "int", "bool"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolLiquidationCallContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the liquidationCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "liquidationCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, collateralAsset: str, debtAsset: str, user: str, debtToCover: int, receiveAToken: bool) -> IPoolLiquidationCallContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolLiquidationCallContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolLiquidationCallContractFunction0._type_signature: IPoolLiquidationCallContractFunction0,
        }
        return out


class IPoolMintToTreasuryContractFunction0(PypechainContractFunction):
    """ContractFunction for the mintToTreasury(list[str]) method."""

    _function_name = "mintToTreasury"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolMintToTreasuryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mintToTreasury method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mintToTreasury"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: list[str]) -> IPoolMintToTreasuryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolMintToTreasuryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolMintToTreasuryContractFunction0._type_signature: IPoolMintToTreasuryContractFunction0,
        }
        return out


class IPoolMintUnbackedContractFunction0(PypechainContractFunction):
    """ContractFunction for the mintUnbacked(str,int,str,int) method."""

    _function_name = "mintUnbacked"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolMintUnbackedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mintUnbacked method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mintUnbacked"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> IPoolMintUnbackedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolMintUnbackedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolMintUnbackedContractFunction0._type_signature: IPoolMintUnbackedContractFunction0,
        }
        return out


class IPoolRebalanceStableBorrowRateContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the rebalanceStableBorrowRate(str,str) method."""

    _function_name = "rebalanceStableBorrowRate"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolRebalanceStableBorrowRateContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the rebalanceStableBorrowRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rebalanceStableBorrowRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, user: str) -> IPoolRebalanceStableBorrowRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolRebalanceStableBorrowRateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolRebalanceStableBorrowRateContractFunction0._type_signature: IPoolRebalanceStableBorrowRateContractFunction0,
        }
        return out


class IPoolRepayContractFunction0(PypechainContractFunction):
    """ContractFunction for the repay(str,int,int,str) method."""

    _function_name = "repay"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "str"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolRepayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the repay method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repay"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str) -> IPoolRepayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolRepayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolRepayContractFunction0._type_signature: IPoolRepayContractFunction0,
        }
        return out


class IPoolRepayWithATokensContractFunction0(PypechainContractFunction):
    """ContractFunction for the repayWithATokens(str,int,int) method."""

    _function_name = "repayWithATokens"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolRepayWithATokensContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the repayWithATokens method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repayWithATokens"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int) -> IPoolRepayWithATokensContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolRepayWithATokensContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolRepayWithATokensContractFunction0._type_signature: IPoolRepayWithATokensContractFunction0,
        }
        return out


class IPoolRepayWithPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the repayWithPermit(str,int,int,str,int,int,bytes,bytes) method."""

    _function_name = "repayWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "str", "int", "int", "bytes", "bytes"]),
        structs,
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolRepayWithPermitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the repayWithPermit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "repayWithPermit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, interestRateMode: int, onBehalfOf: str, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> IPoolRepayWithPermitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolRepayWithPermitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolRepayWithPermitContractFunction0._type_signature: IPoolRepayWithPermitContractFunction0,
        }
        return out


class IPoolRescueTokensContractFunction0(PypechainContractFunction):
    """ContractFunction for the rescueTokens(str,str,int) method."""

    _function_name = "rescueTokens"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolRescueTokensContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rescueTokens method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rescueTokens"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, token: str, to: str, amount: int) -> IPoolRescueTokensContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolRescueTokensContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolRescueTokensContractFunction0._type_signature: IPoolRescueTokensContractFunction0,
        }
        return out


class IPoolResetIsolationModeTotalDebtContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the resetIsolationModeTotalDebt(str) method."""

    _function_name = "resetIsolationModeTotalDebt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolResetIsolationModeTotalDebtContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the resetIsolationModeTotalDebt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "resetIsolationModeTotalDebt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolResetIsolationModeTotalDebtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolResetIsolationModeTotalDebtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolResetIsolationModeTotalDebtContractFunction0._type_signature: IPoolResetIsolationModeTotalDebtContractFunction0,
        }
        return out


class IPoolSetConfigurationContractFunction0(PypechainContractFunction):
    """ContractFunction for the setConfiguration(str,DataTypes.ReserveConfigurationMap) method."""

    _function_name = "setConfiguration"
    _type_signature = expand_struct_type_str(
        tuple(["str", "DataTypes.ReserveConfigurationMap"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSetConfigurationContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setConfiguration method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setConfiguration"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, configuration: DataTypes.ReserveConfigurationMap) -> IPoolSetConfigurationContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSetConfigurationContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSetConfigurationContractFunction0._type_signature: IPoolSetConfigurationContractFunction0,
        }
        return out


class IPoolSetLiquidationGracePeriodContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setLiquidationGracePeriod(str,int) method."""

    _function_name = "setLiquidationGracePeriod"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSetLiquidationGracePeriodContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setLiquidationGracePeriod method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setLiquidationGracePeriod"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, until: int) -> IPoolSetLiquidationGracePeriodContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSetLiquidationGracePeriodContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSetLiquidationGracePeriodContractFunction0._type_signature: IPoolSetLiquidationGracePeriodContractFunction0,
        }
        return out


class IPoolSetReserveInterestRateStrategyAddressContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setReserveInterestRateStrategyAddress(str,str) method."""

    _function_name = "setReserveInterestRateStrategyAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSetReserveInterestRateStrategyAddressContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setReserveInterestRateStrategyAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setReserveInterestRateStrategyAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, rateStrategyAddress: str) -> IPoolSetReserveInterestRateStrategyAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSetReserveInterestRateStrategyAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSetReserveInterestRateStrategyAddressContractFunction0._type_signature: IPoolSetReserveInterestRateStrategyAddressContractFunction0,
        }
        return out


class IPoolSetUserEModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the setUserEMode(int) method."""

    _function_name = "setUserEMode"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSetUserEModeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setUserEMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserEMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, categoryId: int) -> IPoolSetUserEModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSetUserEModeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSetUserEModeContractFunction0._type_signature: IPoolSetUserEModeContractFunction0,
        }
        return out


class IPoolSetUserUseReserveAsCollateralContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUserUseReserveAsCollateral(str,bool) method."""

    _function_name = "setUserUseReserveAsCollateral"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSetUserUseReserveAsCollateralContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setUserUseReserveAsCollateral method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUserUseReserveAsCollateral"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, useAsCollateral: bool) -> IPoolSetUserUseReserveAsCollateralContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSetUserUseReserveAsCollateralContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSetUserUseReserveAsCollateralContractFunction0._type_signature: IPoolSetUserUseReserveAsCollateralContractFunction0,
        }
        return out


class IPoolSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the supply(str,int,str,int) method."""

    _function_name = "supply"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSupplyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the supply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "supply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int) -> IPoolSupplyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSupplyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSupplyContractFunction0._type_signature: IPoolSupplyContractFunction0,
        }
        return out


class IPoolSupplyWithPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the supplyWithPermit(str,int,str,int,int,int,bytes,bytes) method."""

    _function_name = "supplyWithPermit"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str", "int", "int", "int", "bytes", "bytes"]),
        structs,
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSupplyWithPermitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the supplyWithPermit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "supplyWithPermit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, onBehalfOf: str, referralCode: int, deadline: int, permitV: int, permitR: bytes, permitS: bytes) -> IPoolSupplyWithPermitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSupplyWithPermitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSupplyWithPermitContractFunction0._type_signature: IPoolSupplyWithPermitContractFunction0,
        }
        return out


class IPoolSwapBorrowRateModeContractFunction0(PypechainContractFunction):
    """ContractFunction for the swapBorrowRateMode(str,int) method."""

    _function_name = "swapBorrowRateMode"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSwapBorrowRateModeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the swapBorrowRateMode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "swapBorrowRateMode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, interestRateMode: int) -> IPoolSwapBorrowRateModeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSwapBorrowRateModeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSwapBorrowRateModeContractFunction0._type_signature: IPoolSwapBorrowRateModeContractFunction0,
        }
        return out


class IPoolSwapToVariableContractFunction0(PypechainContractFunction):
    """ContractFunction for the swapToVariable(str,str) method."""

    _function_name = "swapToVariable"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSwapToVariableContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the swapToVariable method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "swapToVariable"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, user: str) -> IPoolSwapToVariableContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSwapToVariableContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSwapToVariableContractFunction0._type_signature: IPoolSwapToVariableContractFunction0,
        }
        return out


class IPoolSyncIndexesStateContractFunction0(PypechainContractFunction):
    """ContractFunction for the syncIndexesState(str) method."""

    _function_name = "syncIndexesState"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSyncIndexesStateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the syncIndexesState method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "syncIndexesState"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolSyncIndexesStateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSyncIndexesStateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSyncIndexesStateContractFunction0._type_signature: IPoolSyncIndexesStateContractFunction0,
        }
        return out


class IPoolSyncRatesStateContractFunction0(PypechainContractFunction):
    """ContractFunction for the syncRatesState(str) method."""

    _function_name = "syncRatesState"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolSyncRatesStateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the syncRatesState method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "syncRatesState"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str) -> IPoolSyncRatesStateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolSyncRatesStateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolSyncRatesStateContractFunction0._type_signature: IPoolSyncRatesStateContractFunction0,
        }
        return out


class IPoolUpdateBridgeProtocolFeeContractFunction0(PypechainContractFunction):
    """ContractFunction for the updateBridgeProtocolFee(int) method."""

    _function_name = "updateBridgeProtocolFee"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolUpdateBridgeProtocolFeeContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the updateBridgeProtocolFee method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateBridgeProtocolFee"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, bridgeProtocolFee: int) -> IPoolUpdateBridgeProtocolFeeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolUpdateBridgeProtocolFeeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolUpdateBridgeProtocolFeeContractFunction0._type_signature: IPoolUpdateBridgeProtocolFeeContractFunction0,
        }
        return out


class IPoolUpdateFlashloanPremiumsContractFunction0(PypechainContractFunction):
    """ContractFunction for the updateFlashloanPremiums(int,int) method."""

    _function_name = "updateFlashloanPremiums"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class IPoolUpdateFlashloanPremiumsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the updateFlashloanPremiums method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "updateFlashloanPremiums"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, flashLoanPremiumTotal: int, flashLoanPremiumToProtocol: int) -> IPoolUpdateFlashloanPremiumsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolUpdateFlashloanPremiumsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolUpdateFlashloanPremiumsContractFunction0._type_signature: IPoolUpdateFlashloanPremiumsContractFunction0,
        }
        return out


class IPoolWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the withdraw(str,int,str) method."""

    _function_name = "withdraw"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str"]), structs
    )
    _error_class = IPoolContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IPoolWithdrawContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the withdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "withdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, asset: str, amount: int, to: str) -> IPoolWithdrawContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPoolWithdrawContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPoolWithdrawContractFunction0._type_signature: IPoolWithdrawContractFunction0,
        }
        return out


class IPoolContractFunctions(ContractFunctions):
    """ContractFunctions for the IPool contract."""

    ADDRESSES_PROVIDER: IPoolADDRESSES_PROVIDERContractFunction

    BRIDGE_PROTOCOL_FEE: IPoolBRIDGE_PROTOCOL_FEEContractFunction

    FLASHLOAN_PREMIUM_TOTAL: IPoolFLASHLOAN_PREMIUM_TOTALContractFunction

    FLASHLOAN_PREMIUM_TO_PROTOCOL: (
        IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction
    )

    MAX_NUMBER_RESERVES: IPoolMAX_NUMBER_RESERVESContractFunction

    MAX_STABLE_RATE_BORROW_SIZE_PERCENT: (
        IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction
    )

    backUnbacked: IPoolBackUnbackedContractFunction

    borrow: IPoolBorrowContractFunction

    configureEModeCategory: IPoolConfigureEModeCategoryContractFunction

    deposit: IPoolDepositContractFunction

    dropReserve: IPoolDropReserveContractFunction

    finalizeTransfer: IPoolFinalizeTransferContractFunction

    flashLoan: IPoolFlashLoanContractFunction

    flashLoanSimple: IPoolFlashLoanSimpleContractFunction

    getBorrowLogic: IPoolGetBorrowLogicContractFunction

    getBridgeLogic: IPoolGetBridgeLogicContractFunction

    getConfiguration: IPoolGetConfigurationContractFunction

    getEModeCategoryData: IPoolGetEModeCategoryDataContractFunction

    getEModeLogic: IPoolGetEModeLogicContractFunction

    getFlashLoanLogic: IPoolGetFlashLoanLogicContractFunction

    getLiquidationGracePeriod: IPoolGetLiquidationGracePeriodContractFunction

    getLiquidationLogic: IPoolGetLiquidationLogicContractFunction

    getPoolLogic: IPoolGetPoolLogicContractFunction

    getReserveAddressById: IPoolGetReserveAddressByIdContractFunction

    getReserveData: IPoolGetReserveDataContractFunction

    getReserveDataExtended: IPoolGetReserveDataExtendedContractFunction

    getReserveNormalizedIncome: IPoolGetReserveNormalizedIncomeContractFunction

    getReserveNormalizedVariableDebt: (
        IPoolGetReserveNormalizedVariableDebtContractFunction
    )

    getReservesCount: IPoolGetReservesCountContractFunction

    getReservesList: IPoolGetReservesListContractFunction

    getSupplyLogic: IPoolGetSupplyLogicContractFunction

    getUserAccountData: IPoolGetUserAccountDataContractFunction

    getUserConfiguration: IPoolGetUserConfigurationContractFunction

    getUserEMode: IPoolGetUserEModeContractFunction

    getVirtualUnderlyingBalance: (
        IPoolGetVirtualUnderlyingBalanceContractFunction
    )

    initReserve: IPoolInitReserveContractFunction

    liquidationCall: IPoolLiquidationCallContractFunction

    mintToTreasury: IPoolMintToTreasuryContractFunction

    mintUnbacked: IPoolMintUnbackedContractFunction

    rebalanceStableBorrowRate: IPoolRebalanceStableBorrowRateContractFunction

    repay: IPoolRepayContractFunction

    repayWithATokens: IPoolRepayWithATokensContractFunction

    repayWithPermit: IPoolRepayWithPermitContractFunction

    rescueTokens: IPoolRescueTokensContractFunction

    resetIsolationModeTotalDebt: (
        IPoolResetIsolationModeTotalDebtContractFunction
    )

    setConfiguration: IPoolSetConfigurationContractFunction

    setLiquidationGracePeriod: IPoolSetLiquidationGracePeriodContractFunction

    setReserveInterestRateStrategyAddress: (
        IPoolSetReserveInterestRateStrategyAddressContractFunction
    )

    setUserEMode: IPoolSetUserEModeContractFunction

    setUserUseReserveAsCollateral: (
        IPoolSetUserUseReserveAsCollateralContractFunction
    )

    supply: IPoolSupplyContractFunction

    supplyWithPermit: IPoolSupplyWithPermitContractFunction

    swapBorrowRateMode: IPoolSwapBorrowRateModeContractFunction

    swapToVariable: IPoolSwapToVariableContractFunction

    syncIndexesState: IPoolSyncIndexesStateContractFunction

    syncRatesState: IPoolSyncRatesStateContractFunction

    updateBridgeProtocolFee: IPoolUpdateBridgeProtocolFeeContractFunction

    updateFlashloanPremiums: IPoolUpdateFlashloanPremiumsContractFunction

    withdraw: IPoolWithdrawContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.ADDRESSES_PROVIDER = (
            IPoolADDRESSES_PROVIDERContractFunction.factory(
                "ADDRESSES_PROVIDER",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ADDRESSES_PROVIDER",
            )
        )
        self.BRIDGE_PROTOCOL_FEE = (
            IPoolBRIDGE_PROTOCOL_FEEContractFunction.factory(
                "BRIDGE_PROTOCOL_FEE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="BRIDGE_PROTOCOL_FEE",
            )
        )
        self.FLASHLOAN_PREMIUM_TOTAL = (
            IPoolFLASHLOAN_PREMIUM_TOTALContractFunction.factory(
                "FLASHLOAN_PREMIUM_TOTAL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TOTAL",
            )
        )
        self.FLASHLOAN_PREMIUM_TO_PROTOCOL = (
            IPoolFLASHLOAN_PREMIUM_TO_PROTOCOLContractFunction.factory(
                "FLASHLOAN_PREMIUM_TO_PROTOCOL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_TO_PROTOCOL",
            )
        )
        self.MAX_NUMBER_RESERVES = (
            IPoolMAX_NUMBER_RESERVESContractFunction.factory(
                "MAX_NUMBER_RESERVES",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="MAX_NUMBER_RESERVES",
            )
        )
        self.MAX_STABLE_RATE_BORROW_SIZE_PERCENT = (
            IPoolMAX_STABLE_RATE_BORROW_SIZE_PERCENTContractFunction.factory(
                "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
            )
        )
        self.backUnbacked = IPoolBackUnbackedContractFunction.factory(
            "backUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="backUnbacked",
        )
        self.borrow = IPoolBorrowContractFunction.factory(
            "borrow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="borrow",
        )
        self.configureEModeCategory = (
            IPoolConfigureEModeCategoryContractFunction.factory(
                "configureEModeCategory",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="configureEModeCategory",
            )
        )
        self.deposit = IPoolDepositContractFunction.factory(
            "deposit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deposit",
        )
        self.dropReserve = IPoolDropReserveContractFunction.factory(
            "dropReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="dropReserve",
        )
        self.finalizeTransfer = IPoolFinalizeTransferContractFunction.factory(
            "finalizeTransfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="finalizeTransfer",
        )
        self.flashLoan = IPoolFlashLoanContractFunction.factory(
            "flashLoan",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="flashLoan",
        )
        self.flashLoanSimple = IPoolFlashLoanSimpleContractFunction.factory(
            "flashLoanSimple",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="flashLoanSimple",
        )
        self.getBorrowLogic = IPoolGetBorrowLogicContractFunction.factory(
            "getBorrowLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBorrowLogic",
        )
        self.getBridgeLogic = IPoolGetBridgeLogicContractFunction.factory(
            "getBridgeLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBridgeLogic",
        )
        self.getConfiguration = IPoolGetConfigurationContractFunction.factory(
            "getConfiguration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getConfiguration",
        )
        self.getEModeCategoryData = (
            IPoolGetEModeCategoryDataContractFunction.factory(
                "getEModeCategoryData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getEModeCategoryData",
            )
        )
        self.getEModeLogic = IPoolGetEModeLogicContractFunction.factory(
            "getEModeLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getEModeLogic",
        )
        self.getFlashLoanLogic = IPoolGetFlashLoanLogicContractFunction.factory(
            "getFlashLoanLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getFlashLoanLogic",
        )
        self.getLiquidationGracePeriod = (
            IPoolGetLiquidationGracePeriodContractFunction.factory(
                "getLiquidationGracePeriod",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getLiquidationGracePeriod",
            )
        )
        self.getLiquidationLogic = (
            IPoolGetLiquidationLogicContractFunction.factory(
                "getLiquidationLogic",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getLiquidationLogic",
            )
        )
        self.getPoolLogic = IPoolGetPoolLogicContractFunction.factory(
            "getPoolLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getPoolLogic",
        )
        self.getReserveAddressById = (
            IPoolGetReserveAddressByIdContractFunction.factory(
                "getReserveAddressById",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveAddressById",
            )
        )
        self.getReserveData = IPoolGetReserveDataContractFunction.factory(
            "getReserveData",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReserveData",
        )
        self.getReserveDataExtended = (
            IPoolGetReserveDataExtendedContractFunction.factory(
                "getReserveDataExtended",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveDataExtended",
            )
        )
        self.getReserveNormalizedIncome = (
            IPoolGetReserveNormalizedIncomeContractFunction.factory(
                "getReserveNormalizedIncome",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedIncome",
            )
        )
        self.getReserveNormalizedVariableDebt = (
            IPoolGetReserveNormalizedVariableDebtContractFunction.factory(
                "getReserveNormalizedVariableDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getReserveNormalizedVariableDebt",
            )
        )
        self.getReservesCount = IPoolGetReservesCountContractFunction.factory(
            "getReservesCount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReservesCount",
        )
        self.getReservesList = IPoolGetReservesListContractFunction.factory(
            "getReservesList",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getReservesList",
        )
        self.getSupplyLogic = IPoolGetSupplyLogicContractFunction.factory(
            "getSupplyLogic",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getSupplyLogic",
        )
        self.getUserAccountData = (
            IPoolGetUserAccountDataContractFunction.factory(
                "getUserAccountData",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserAccountData",
            )
        )
        self.getUserConfiguration = (
            IPoolGetUserConfigurationContractFunction.factory(
                "getUserConfiguration",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getUserConfiguration",
            )
        )
        self.getUserEMode = IPoolGetUserEModeContractFunction.factory(
            "getUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getUserEMode",
        )
        self.getVirtualUnderlyingBalance = (
            IPoolGetVirtualUnderlyingBalanceContractFunction.factory(
                "getVirtualUnderlyingBalance",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getVirtualUnderlyingBalance",
            )
        )
        self.initReserve = IPoolInitReserveContractFunction.factory(
            "initReserve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initReserve",
        )
        self.liquidationCall = IPoolLiquidationCallContractFunction.factory(
            "liquidationCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="liquidationCall",
        )
        self.mintToTreasury = IPoolMintToTreasuryContractFunction.factory(
            "mintToTreasury",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintToTreasury",
        )
        self.mintUnbacked = IPoolMintUnbackedContractFunction.factory(
            "mintUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mintUnbacked",
        )
        self.rebalanceStableBorrowRate = (
            IPoolRebalanceStableBorrowRateContractFunction.factory(
                "rebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="rebalanceStableBorrowRate",
            )
        )
        self.repay = IPoolRepayContractFunction.factory(
            "repay",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repay",
        )
        self.repayWithATokens = IPoolRepayWithATokensContractFunction.factory(
            "repayWithATokens",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repayWithATokens",
        )
        self.repayWithPermit = IPoolRepayWithPermitContractFunction.factory(
            "repayWithPermit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="repayWithPermit",
        )
        self.rescueTokens = IPoolRescueTokensContractFunction.factory(
            "rescueTokens",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rescueTokens",
        )
        self.resetIsolationModeTotalDebt = (
            IPoolResetIsolationModeTotalDebtContractFunction.factory(
                "resetIsolationModeTotalDebt",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="resetIsolationModeTotalDebt",
            )
        )
        self.setConfiguration = IPoolSetConfigurationContractFunction.factory(
            "setConfiguration",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setConfiguration",
        )
        self.setLiquidationGracePeriod = (
            IPoolSetLiquidationGracePeriodContractFunction.factory(
                "setLiquidationGracePeriod",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setLiquidationGracePeriod",
            )
        )
        self.setReserveInterestRateStrategyAddress = (
            IPoolSetReserveInterestRateStrategyAddressContractFunction.factory(
                "setReserveInterestRateStrategyAddress",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setReserveInterestRateStrategyAddress",
            )
        )
        self.setUserEMode = IPoolSetUserEModeContractFunction.factory(
            "setUserEMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setUserEMode",
        )
        self.setUserUseReserveAsCollateral = (
            IPoolSetUserUseReserveAsCollateralContractFunction.factory(
                "setUserUseReserveAsCollateral",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUserUseReserveAsCollateral",
            )
        )
        self.supply = IPoolSupplyContractFunction.factory(
            "supply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="supply",
        )
        self.supplyWithPermit = IPoolSupplyWithPermitContractFunction.factory(
            "supplyWithPermit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="supplyWithPermit",
        )
        self.swapBorrowRateMode = (
            IPoolSwapBorrowRateModeContractFunction.factory(
                "swapBorrowRateMode",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="swapBorrowRateMode",
            )
        )
        self.swapToVariable = IPoolSwapToVariableContractFunction.factory(
            "swapToVariable",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="swapToVariable",
        )
        self.syncIndexesState = IPoolSyncIndexesStateContractFunction.factory(
            "syncIndexesState",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="syncIndexesState",
        )
        self.syncRatesState = IPoolSyncRatesStateContractFunction.factory(
            "syncRatesState",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="syncRatesState",
        )
        self.updateBridgeProtocolFee = (
            IPoolUpdateBridgeProtocolFeeContractFunction.factory(
                "updateBridgeProtocolFee",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateBridgeProtocolFee",
            )
        )
        self.updateFlashloanPremiums = (
            IPoolUpdateFlashloanPremiumsContractFunction.factory(
                "updateFlashloanPremiums",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="updateFlashloanPremiums",
            )
        )
        self.withdraw = IPoolWithdrawContractFunction.factory(
            "withdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="withdraw",
        )


class IPoolBackUnbackedContractEvent(ContractEvent):
    """ContractEvent for BackUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BackUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BackUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BackUnbackedEvent.BackUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    backer=abi_event.args["backer"],
                    amount=abi_event.args["amount"],
                    fee=abi_event.args["fee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolBorrowContractEvent(ContractEvent):
    """ContractEvent for Borrow."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[BorrowEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[BorrowEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            BorrowEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BorrowEvent.BorrowEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    borrowRate=abi_event.args["borrowRate"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolFlashLoanContractEvent(ContractEvent):
    """ContractEvent for FlashLoan."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[FlashLoanEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            FlashLoanEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=FlashLoanEvent.FlashLoanEventArgs(
                    target=abi_event.args["target"],
                    initiator=abi_event.args["initiator"],
                    asset=abi_event.args["asset"],
                    amount=abi_event.args["amount"],
                    interestRateMode=abi_event.args["interestRateMode"],
                    premium=abi_event.args["premium"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolIsolationModeTotalDebtUpdatedContractEvent(ContractEvent):
    """ContractEvent for IsolationModeTotalDebtUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[IsolationModeTotalDebtUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            IsolationModeTotalDebtUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=IsolationModeTotalDebtUpdatedEvent.IsolationModeTotalDebtUpdatedEventArgs(
                    asset=abi_event.args["asset"],
                    totalDebt=abi_event.args["totalDebt"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolLiquidationCallContractEvent(ContractEvent):
    """ContractEvent for LiquidationCall."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LiquidationCallEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LiquidationCallEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LiquidationCallEvent.LiquidationCallEventArgs(
                    collateralAsset=abi_event.args["collateralAsset"],
                    debtAsset=abi_event.args["debtAsset"],
                    user=abi_event.args["user"],
                    debtToCover=abi_event.args["debtToCover"],
                    liquidatedCollateralAmount=abi_event.args[
                        "liquidatedCollateralAmount"
                    ],
                    liquidator=abi_event.args["liquidator"],
                    receiveAToken=abi_event.args["receiveAToken"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolMintUnbackedContractEvent(ContractEvent):
    """ContractEvent for MintUnbacked."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintUnbackedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintUnbackedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintUnbackedEvent.MintUnbackedEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolMintedToTreasuryContractEvent(ContractEvent):
    """ContractEvent for MintedToTreasury."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[MintedToTreasuryEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            MintedToTreasuryEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=MintedToTreasuryEvent.MintedToTreasuryEventArgs(
                    reserve=abi_event.args["reserve"],
                    amountMinted=abi_event.args["amountMinted"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolRebalanceStableBorrowRateContractEvent(ContractEvent):
    """ContractEvent for RebalanceStableBorrowRate."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RebalanceStableBorrowRateEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RebalanceStableBorrowRateEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RebalanceStableBorrowRateEvent.RebalanceStableBorrowRateEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolRepayContractEvent(ContractEvent):
    """ContractEvent for Repay."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[RepayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[RepayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            RepayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=RepayEvent.RepayEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    repayer=abi_event.args["repayer"],
                    amount=abi_event.args["amount"],
                    useATokens=abi_event.args["useATokens"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolReserveDataUpdatedContractEvent(ContractEvent):
    """ContractEvent for ReserveDataUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveDataUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveDataUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveDataUpdatedEvent.ReserveDataUpdatedEventArgs(
                    reserve=abi_event.args["reserve"],
                    liquidityRate=abi_event.args["liquidityRate"],
                    stableBorrowRate=abi_event.args["stableBorrowRate"],
                    variableBorrowRate=abi_event.args["variableBorrowRate"],
                    liquidityIndex=abi_event.args["liquidityIndex"],
                    variableBorrowIndex=abi_event.args["variableBorrowIndex"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolReserveUsedAsCollateralDisabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralDisabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralDisabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralDisabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralDisabledEvent.ReserveUsedAsCollateralDisabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolReserveUsedAsCollateralEnabledContractEvent(ContractEvent):
    """ContractEvent for ReserveUsedAsCollateralEnabled."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReserveUsedAsCollateralEnabledEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReserveUsedAsCollateralEnabledEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReserveUsedAsCollateralEnabledEvent.ReserveUsedAsCollateralEnabledEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolSupplyContractEvent(ContractEvent):
    """ContractEvent for Supply."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SupplyEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SupplyEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SupplyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SupplyEvent.SupplyEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    onBehalfOf=abi_event.args["onBehalfOf"],
                    amount=abi_event.args["amount"],
                    referralCode=abi_event.args["referralCode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolSwapBorrowRateModeContractEvent(ContractEvent):
    """ContractEvent for SwapBorrowRateMode."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SwapBorrowRateModeEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SwapBorrowRateModeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SwapBorrowRateModeEvent.SwapBorrowRateModeEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    interestRateMode=abi_event.args["interestRateMode"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolUserEModeSetContractEvent(ContractEvent):
    """ContractEvent for UserEModeSet."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UserEModeSetEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UserEModeSetEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UserEModeSetEvent.UserEModeSetEventArgs(
                    user=abi_event.args["user"],
                    categoryId=abi_event.args["categoryId"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolWithdrawContractEvent(ContractEvent):
    """ContractEvent for Withdraw."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[WithdrawEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[WithdrawEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    reserve=abi_event.args["reserve"],
                    user=abi_event.args["user"],
                    to=abi_event.args["to"],
                    amount=abi_event.args["amount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPoolContractEvents(ContractEvents):
    """ContractEvents for the IPool contract."""

    BackUnbacked: IPoolBackUnbackedContractEvent

    Borrow: IPoolBorrowContractEvent

    FlashLoan: IPoolFlashLoanContractEvent

    IsolationModeTotalDebtUpdated: (
        IPoolIsolationModeTotalDebtUpdatedContractEvent
    )

    LiquidationCall: IPoolLiquidationCallContractEvent

    MintUnbacked: IPoolMintUnbackedContractEvent

    MintedToTreasury: IPoolMintedToTreasuryContractEvent

    RebalanceStableBorrowRate: IPoolRebalanceStableBorrowRateContractEvent

    Repay: IPoolRepayContractEvent

    ReserveDataUpdated: IPoolReserveDataUpdatedContractEvent

    ReserveUsedAsCollateralDisabled: (
        IPoolReserveUsedAsCollateralDisabledContractEvent
    )

    ReserveUsedAsCollateralEnabled: (
        IPoolReserveUsedAsCollateralEnabledContractEvent
    )

    Supply: IPoolSupplyContractEvent

    SwapBorrowRateMode: IPoolSwapBorrowRateModeContractEvent

    UserEModeSet: IPoolUserEModeSetContractEvent

    Withdraw: IPoolWithdrawContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.BackUnbacked = IPoolBackUnbackedContractEvent.factory(
            "BackUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="BackUnbacked",
        )
        self.Borrow = IPoolBorrowContractEvent.factory(
            "Borrow",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Borrow",
        )
        self.FlashLoan = IPoolFlashLoanContractEvent.factory(
            "FlashLoan",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="FlashLoan",
        )
        self.IsolationModeTotalDebtUpdated = (
            IPoolIsolationModeTotalDebtUpdatedContractEvent.factory(
                "IsolationModeTotalDebtUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="IsolationModeTotalDebtUpdated",
            )
        )
        self.LiquidationCall = IPoolLiquidationCallContractEvent.factory(
            "LiquidationCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="LiquidationCall",
        )
        self.MintUnbacked = IPoolMintUnbackedContractEvent.factory(
            "MintUnbacked",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="MintUnbacked",
        )
        self.MintedToTreasury = IPoolMintedToTreasuryContractEvent.factory(
            "MintedToTreasury",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="MintedToTreasury",
        )
        self.RebalanceStableBorrowRate = (
            IPoolRebalanceStableBorrowRateContractEvent.factory(
                "RebalanceStableBorrowRate",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="RebalanceStableBorrowRate",
            )
        )
        self.Repay = IPoolRepayContractEvent.factory(
            "Repay",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Repay",
        )
        self.ReserveDataUpdated = IPoolReserveDataUpdatedContractEvent.factory(
            "ReserveDataUpdated",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="ReserveDataUpdated",
        )
        self.ReserveUsedAsCollateralDisabled = (
            IPoolReserveUsedAsCollateralDisabledContractEvent.factory(
                "ReserveUsedAsCollateralDisabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralDisabled",
            )
        )
        self.ReserveUsedAsCollateralEnabled = (
            IPoolReserveUsedAsCollateralEnabledContractEvent.factory(
                "ReserveUsedAsCollateralEnabled",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="ReserveUsedAsCollateralEnabled",
            )
        )
        self.Supply = IPoolSupplyContractEvent.factory(
            "Supply",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Supply",
        )
        self.SwapBorrowRateMode = IPoolSwapBorrowRateModeContractEvent.factory(
            "SwapBorrowRateMode",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="SwapBorrowRateMode",
        )
        self.UserEModeSet = IPoolUserEModeSetContractEvent.factory(
            "UserEModeSet",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="UserEModeSet",
        )
        self.Withdraw = IPoolWithdrawContractEvent.factory(
            "Withdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="Withdraw",
        )


class IPoolContract(Contract):
    """A web3.py Contract class for the IPool contract."""

    abi: ABI = ipool_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = IPoolContractFunctions(ipool_abi, self.w3, address)  # type: ignore
        self.events = IPoolContractEvents(ipool_abi, self.w3, address)  # type: ignore

    events: IPoolContractEvents

    functions: IPoolContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = IPoolContractFunctions(ipool_abi, w3, None)

        return contract
