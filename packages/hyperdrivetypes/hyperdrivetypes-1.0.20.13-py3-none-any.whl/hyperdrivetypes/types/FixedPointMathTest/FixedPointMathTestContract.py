"""A web3.py Contract class for the FixedPointMathTest contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..StdInvariant import StdInvariantTypes as StdInvariant
from .FixedPointMathTestTypes import (
    Log_addressEvent,
    Log_arrayEvent,
    Log_bytes32Event,
    Log_bytesEvent,
    Log_intEvent,
    Log_named_addressEvent,
    Log_named_arrayEvent,
    Log_named_bytes32Event,
    Log_named_bytesEvent,
    Log_named_decimal_intEvent,
    Log_named_decimal_uintEvent,
    Log_named_intEvent,
    Log_named_stringEvent,
    Log_named_uintEvent,
    Log_stringEvent,
    Log_uintEvent,
    LogEvent,
    LogsEvent,
)

structs = {
    "StdInvariant.FuzzSelector": StdInvariant.FuzzSelector,
    "StdInvariant.FuzzInterface": StdInvariant.FuzzInterface,
}

fixedpointmathtest_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "IS_TEST",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "failed",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifactSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifactSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetInterfaces",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedInterfaces_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzInterface[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "artifacts",
                            "type": "string[]",
                            "internalType": "string[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "test_differential_fuzz_pow",
            "inputs": [
                {"name": "x", "type": "uint256", "internalType": "uint256"},
                {"name": "y", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_differential_fuzz_pow_zero",
            "inputs": [
                {"name": "x", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_divDown",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_divUp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_exp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_divDown_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_divUp_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_exp_negative_or_zero_input",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_ln_negative_or_zero_input",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_mulDivDown_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_fail_mulDivUp_zero_denominator",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_ln",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulDivDown",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulDivUp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulDown",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_mulUp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_pow",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateWeightedAverage",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateWeightedAverage_fuzz",
            "inputs": [
                {
                    "name": "average",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "totalWeight",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "delta", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "deltaWeight",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "log",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_address",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes32",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_int",
            "inputs": [
                {
                    "name": "",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_address",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes32",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_string",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_string",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_uint",
            "inputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "logs",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
    ],
)


class FixedPointMathTestContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the FixedPointMathTest contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class FixedPointMathTestIS_TESTContractFunction0(PypechainContractFunction):
    """ContractFunction for the IS_TEST() method."""

    _function_name = "IS_TEST"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestIS_TESTContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the IS_TEST method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "IS_TEST"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestIS_TESTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestIS_TESTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestIS_TESTContractFunction0._type_signature: FixedPointMathTestIS_TESTContractFunction0,
        }
        return out


class FixedPointMathTestExcludeArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeArtifacts() method."""

    _function_name = "excludeArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestExcludeArtifactsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestExcludeArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestExcludeArtifactsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestExcludeArtifactsContractFunction0._type_signature: FixedPointMathTestExcludeArtifactsContractFunction0,
        }
        return out


class FixedPointMathTestExcludeContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeContracts() method."""

    _function_name = "excludeContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestExcludeContractsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestExcludeContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestExcludeContractsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestExcludeContractsContractFunction0._type_signature: FixedPointMathTestExcludeContractsContractFunction0,
        }
        return out


class FixedPointMathTestExcludeSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeSenders() method."""

    _function_name = "excludeSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestExcludeSendersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestExcludeSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestExcludeSendersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestExcludeSendersContractFunction0._type_signature: FixedPointMathTestExcludeSendersContractFunction0,
        }
        return out


class FixedPointMathTestFailedContractFunction0(PypechainContractFunction):
    """ContractFunction for the failed() method."""

    _function_name = "failed"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestFailedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the failed method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "failed"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestFailedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestFailedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestFailedContractFunction0._type_signature: FixedPointMathTestFailedContractFunction0,
        }
        return out


class FixedPointMathTestTargetArtifactSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifactSelectors() method."""

    _function_name = "targetArtifactSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class FixedPointMathTestTargetArtifactSelectorsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetArtifactSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifactSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetArtifactSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetArtifactSelectorsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTargetArtifactSelectorsContractFunction0._type_signature: FixedPointMathTestTargetArtifactSelectorsContractFunction0,
        }
        return out


class FixedPointMathTestTargetArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifacts() method."""

    _function_name = "targetArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestTargetArtifactsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetArtifactsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTargetArtifactsContractFunction0._type_signature: FixedPointMathTestTargetArtifactsContractFunction0,
        }
        return out


class FixedPointMathTestTargetContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetContracts() method."""

    _function_name = "targetContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestTargetContractsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetContractsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTargetContractsContractFunction0._type_signature: FixedPointMathTestTargetContractsContractFunction0,
        }
        return out


class FixedPointMathTestTargetInterfacesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetInterfaces() method."""

    _function_name = "targetInterfaces"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzInterface]:
        """returns list[StdInvariant.FuzzInterface]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzInterface]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzInterface],
            rename_returned_types(structs, return_types, raw_values),
        )


class FixedPointMathTestTargetInterfacesContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetInterfaces method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetInterfaces"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetInterfacesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetInterfacesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTargetInterfacesContractFunction0._type_signature: FixedPointMathTestTargetInterfacesContractFunction0,
        }
        return out


class FixedPointMathTestTargetSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSelectors() method."""

    _function_name = "targetSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class FixedPointMathTestTargetSelectorsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetSelectorsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTargetSelectorsContractFunction0._type_signature: FixedPointMathTestTargetSelectorsContractFunction0,
        }
        return out


class FixedPointMathTestTargetSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSenders() method."""

    _function_name = "targetSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class FixedPointMathTestTargetSendersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTargetSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTargetSendersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTargetSendersContractFunction0._type_signature: FixedPointMathTestTargetSendersContractFunction0,
        }
        return out


class FixedPointMathTestTest_differential_fuzz_powContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_differential_fuzz_pow(int,int) method."""

    _function_name = "test_differential_fuzz_pow"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_differential_fuzz_powContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_differential_fuzz_pow method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_differential_fuzz_pow"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, x: int, y: int) -> FixedPointMathTestTest_differential_fuzz_powContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_differential_fuzz_powContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_differential_fuzz_powContractFunction0._type_signature: FixedPointMathTestTest_differential_fuzz_powContractFunction0,
        }
        return out


class FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_differential_fuzz_pow_zero(int) method."""

    _function_name = "test_differential_fuzz_pow_zero"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_differential_fuzz_pow_zero method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_differential_fuzz_pow_zero"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, x: int) -> FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0._type_signature: FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction0,
        }
        return out


class FixedPointMathTestTest_divDownContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_divDown() method."""

    _function_name = "test_divDown"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_divDownContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_divDown method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_divDown"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_divDownContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_divDownContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_divDownContractFunction0._type_signature: FixedPointMathTestTest_divDownContractFunction0,
        }
        return out


class FixedPointMathTestTest_divUpContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_divUp() method."""

    _function_name = "test_divUp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_divUpContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_divUp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_divUp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_divUpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_divUpContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_divUpContractFunction0._type_signature: FixedPointMathTestTest_divUpContractFunction0,
        }
        return out


class FixedPointMathTestTest_expContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_exp() method."""

    _function_name = "test_exp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_expContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the test_exp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_exp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_expContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_expContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_expContractFunction0._type_signature: FixedPointMathTestTest_expContractFunction0,
        }
        return out


class FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_divDown_zero_denominator() method."""

    _function_name = "test_fail_divDown_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_fail_divDown_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_divDown_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction0,
        }
        return out


class FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_divUp_zero_denominator() method."""

    _function_name = "test_fail_divUp_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_fail_divUp_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_divUp_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction0,
        }
        return out


class FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_exp_negative_or_zero_input() method."""

    _function_name = "test_fail_exp_negative_or_zero_input"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_fail_exp_negative_or_zero_input method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_exp_negative_or_zero_input"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0._type_signature: FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction0,
        }
        return out


class FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_ln_negative_or_zero_input() method."""

    _function_name = "test_fail_ln_negative_or_zero_input"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_fail_ln_negative_or_zero_input method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_ln_negative_or_zero_input"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0._type_signature: FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction0,
        }
        return out


class FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_mulDivDown_zero_denominator() method."""

    _function_name = "test_fail_mulDivDown_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_fail_mulDivDown_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_mulDivDown_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction0,
        }
        return out


class FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_fail_mulDivUp_zero_denominator() method."""

    _function_name = "test_fail_mulDivUp_zero_denominator"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_fail_mulDivUp_zero_denominator method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_fail_mulDivUp_zero_denominator"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0._type_signature: FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction0,
        }
        return out


class FixedPointMathTestTest_lnContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_ln() method."""

    _function_name = "test_ln"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_lnContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the test_ln method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_ln"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_lnContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_lnContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_lnContractFunction0._type_signature: FixedPointMathTestTest_lnContractFunction0,
        }
        return out


class FixedPointMathTestTest_mulDivDownContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDivDown() method."""

    _function_name = "test_mulDivDown"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulDivDownContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_mulDivDown method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulDivDown"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulDivDownContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulDivDownContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_mulDivDownContractFunction0._type_signature: FixedPointMathTestTest_mulDivDownContractFunction0,
        }
        return out


class FixedPointMathTestTest_mulDivUpContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDivUp() method."""

    _function_name = "test_mulDivUp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulDivUpContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_mulDivUp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulDivUp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulDivUpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulDivUpContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_mulDivUpContractFunction0._type_signature: FixedPointMathTestTest_mulDivUpContractFunction0,
        }
        return out


class FixedPointMathTestTest_mulDownContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_mulDown() method."""

    _function_name = "test_mulDown"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulDownContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_mulDown method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulDown"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulDownContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulDownContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_mulDownContractFunction0._type_signature: FixedPointMathTestTest_mulDownContractFunction0,
        }
        return out


class FixedPointMathTestTest_mulUpContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_mulUp() method."""

    _function_name = "test_mulUp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_mulUpContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_mulUp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_mulUp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_mulUpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_mulUpContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_mulUpContractFunction0._type_signature: FixedPointMathTestTest_mulUpContractFunction0,
        }
        return out


class FixedPointMathTestTest_powContractFunction0(PypechainContractFunction):
    """ContractFunction for the test_pow() method."""

    _function_name = "test_pow"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_powContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the test_pow method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_pow"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_powContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_powContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_powContractFunction0._type_signature: FixedPointMathTestTest_powContractFunction0,
        }
        return out


class FixedPointMathTestTest_updateWeightedAverageContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateWeightedAverage() method."""

    _function_name = "test_updateWeightedAverage"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_updateWeightedAverageContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_updateWeightedAverage method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateWeightedAverage"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> FixedPointMathTestTest_updateWeightedAverageContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_updateWeightedAverageContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_updateWeightedAverageContractFunction0._type_signature: FixedPointMathTestTest_updateWeightedAverageContractFunction0,
        }
        return out


class FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateWeightedAverage_fuzz(int,int,int,int) method."""

    _function_name = "test_updateWeightedAverage_fuzz"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = FixedPointMathTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_updateWeightedAverage_fuzz method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateWeightedAverage_fuzz"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, average: int, totalWeight: int, delta: int, deltaWeight: int) -> FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0._type_signature: FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction0,
        }
        return out


class FixedPointMathTestContractFunctions(ContractFunctions):
    """ContractFunctions for the FixedPointMathTest contract."""

    IS_TEST: FixedPointMathTestIS_TESTContractFunction

    excludeArtifacts: FixedPointMathTestExcludeArtifactsContractFunction

    excludeContracts: FixedPointMathTestExcludeContractsContractFunction

    excludeSenders: FixedPointMathTestExcludeSendersContractFunction

    failed: FixedPointMathTestFailedContractFunction

    targetArtifactSelectors: (
        FixedPointMathTestTargetArtifactSelectorsContractFunction
    )

    targetArtifacts: FixedPointMathTestTargetArtifactsContractFunction

    targetContracts: FixedPointMathTestTargetContractsContractFunction

    targetInterfaces: FixedPointMathTestTargetInterfacesContractFunction

    targetSelectors: FixedPointMathTestTargetSelectorsContractFunction

    targetSenders: FixedPointMathTestTargetSendersContractFunction

    test_differential_fuzz_pow: (
        FixedPointMathTestTest_differential_fuzz_powContractFunction
    )

    test_differential_fuzz_pow_zero: (
        FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction
    )

    test_divDown: FixedPointMathTestTest_divDownContractFunction

    test_divUp: FixedPointMathTestTest_divUpContractFunction

    test_exp: FixedPointMathTestTest_expContractFunction

    test_fail_divDown_zero_denominator: (
        FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction
    )

    test_fail_divUp_zero_denominator: (
        FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction
    )

    test_fail_exp_negative_or_zero_input: (
        FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction
    )

    test_fail_ln_negative_or_zero_input: (
        FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction
    )

    test_fail_mulDivDown_zero_denominator: (
        FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction
    )

    test_fail_mulDivUp_zero_denominator: (
        FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction
    )

    test_ln: FixedPointMathTestTest_lnContractFunction

    test_mulDivDown: FixedPointMathTestTest_mulDivDownContractFunction

    test_mulDivUp: FixedPointMathTestTest_mulDivUpContractFunction

    test_mulDown: FixedPointMathTestTest_mulDownContractFunction

    test_mulUp: FixedPointMathTestTest_mulUpContractFunction

    test_pow: FixedPointMathTestTest_powContractFunction

    test_updateWeightedAverage: (
        FixedPointMathTestTest_updateWeightedAverageContractFunction
    )

    test_updateWeightedAverage_fuzz: (
        FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction
    )

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.IS_TEST = FixedPointMathTestIS_TESTContractFunction.factory(
            "IS_TEST",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="IS_TEST",
        )
        self.excludeArtifacts = (
            FixedPointMathTestExcludeArtifactsContractFunction.factory(
                "excludeArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeArtifacts",
            )
        )
        self.excludeContracts = (
            FixedPointMathTestExcludeContractsContractFunction.factory(
                "excludeContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeContracts",
            )
        )
        self.excludeSenders = (
            FixedPointMathTestExcludeSendersContractFunction.factory(
                "excludeSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="excludeSenders",
            )
        )
        self.failed = FixedPointMathTestFailedContractFunction.factory(
            "failed",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="failed",
        )
        self.targetArtifactSelectors = (
            FixedPointMathTestTargetArtifactSelectorsContractFunction.factory(
                "targetArtifactSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifactSelectors",
            )
        )
        self.targetArtifacts = (
            FixedPointMathTestTargetArtifactsContractFunction.factory(
                "targetArtifacts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetArtifacts",
            )
        )
        self.targetContracts = (
            FixedPointMathTestTargetContractsContractFunction.factory(
                "targetContracts",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetContracts",
            )
        )
        self.targetInterfaces = (
            FixedPointMathTestTargetInterfacesContractFunction.factory(
                "targetInterfaces",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetInterfaces",
            )
        )
        self.targetSelectors = (
            FixedPointMathTestTargetSelectorsContractFunction.factory(
                "targetSelectors",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSelectors",
            )
        )
        self.targetSenders = (
            FixedPointMathTestTargetSendersContractFunction.factory(
                "targetSenders",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="targetSenders",
            )
        )
        self.test_differential_fuzz_pow = FixedPointMathTestTest_differential_fuzz_powContractFunction.factory(
            "test_differential_fuzz_pow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_differential_fuzz_pow",
        )
        self.test_differential_fuzz_pow_zero = FixedPointMathTestTest_differential_fuzz_pow_zeroContractFunction.factory(
            "test_differential_fuzz_pow_zero",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_differential_fuzz_pow_zero",
        )
        self.test_divDown = (
            FixedPointMathTestTest_divDownContractFunction.factory(
                "test_divDown",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_divDown",
            )
        )
        self.test_divUp = FixedPointMathTestTest_divUpContractFunction.factory(
            "test_divUp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_divUp",
        )
        self.test_exp = FixedPointMathTestTest_expContractFunction.factory(
            "test_exp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_exp",
        )
        self.test_fail_divDown_zero_denominator = FixedPointMathTestTest_fail_divDown_zero_denominatorContractFunction.factory(
            "test_fail_divDown_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_divDown_zero_denominator",
        )
        self.test_fail_divUp_zero_denominator = FixedPointMathTestTest_fail_divUp_zero_denominatorContractFunction.factory(
            "test_fail_divUp_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_divUp_zero_denominator",
        )
        self.test_fail_exp_negative_or_zero_input = FixedPointMathTestTest_fail_exp_negative_or_zero_inputContractFunction.factory(
            "test_fail_exp_negative_or_zero_input",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_exp_negative_or_zero_input",
        )
        self.test_fail_ln_negative_or_zero_input = FixedPointMathTestTest_fail_ln_negative_or_zero_inputContractFunction.factory(
            "test_fail_ln_negative_or_zero_input",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_ln_negative_or_zero_input",
        )
        self.test_fail_mulDivDown_zero_denominator = FixedPointMathTestTest_fail_mulDivDown_zero_denominatorContractFunction.factory(
            "test_fail_mulDivDown_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_mulDivDown_zero_denominator",
        )
        self.test_fail_mulDivUp_zero_denominator = FixedPointMathTestTest_fail_mulDivUp_zero_denominatorContractFunction.factory(
            "test_fail_mulDivUp_zero_denominator",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_fail_mulDivUp_zero_denominator",
        )
        self.test_ln = FixedPointMathTestTest_lnContractFunction.factory(
            "test_ln",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_ln",
        )
        self.test_mulDivDown = (
            FixedPointMathTestTest_mulDivDownContractFunction.factory(
                "test_mulDivDown",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_mulDivDown",
            )
        )
        self.test_mulDivUp = (
            FixedPointMathTestTest_mulDivUpContractFunction.factory(
                "test_mulDivUp",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_mulDivUp",
            )
        )
        self.test_mulDown = (
            FixedPointMathTestTest_mulDownContractFunction.factory(
                "test_mulDown",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="test_mulDown",
            )
        )
        self.test_mulUp = FixedPointMathTestTest_mulUpContractFunction.factory(
            "test_mulUp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_mulUp",
        )
        self.test_pow = FixedPointMathTestTest_powContractFunction.factory(
            "test_pow",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_pow",
        )
        self.test_updateWeightedAverage = FixedPointMathTestTest_updateWeightedAverageContractFunction.factory(
            "test_updateWeightedAverage",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateWeightedAverage",
        )
        self.test_updateWeightedAverage_fuzz = FixedPointMathTestTest_updateWeightedAverage_fuzzContractFunction.factory(
            "test_updateWeightedAverage_fuzz",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateWeightedAverage_fuzz",
        )


class FixedPointMathTestLogContractEvent(ContractEvent):
    """ContractEvent for log."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_addressContractEvent(ContractEvent):
    """ContractEvent for log_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_arrayContractEvent(ContractEvent):
    """ContractEvent for log_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_bytesContractEvent(ContractEvent):
    """ContractEvent for log_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_intContractEvent(ContractEvent):
    """ContractEvent for log_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_addressContractEvent(ContractEvent):
    """ContractEvent for log_named_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_arrayContractEvent(ContractEvent):
    """ContractEvent for log_named_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_bytesContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_named_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_decimal_intContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_decimal_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_decimal_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_intContractEvent(ContractEvent):
    """ContractEvent for log_named_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_stringContractEvent(ContractEvent):
    """ContractEvent for log_named_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_named_uintContractEvent(ContractEvent):
    """ContractEvent for log_named_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_stringContractEvent(ContractEvent):
    """ContractEvent for log_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLog_uintContractEvent(ContractEvent):
    """ContractEvent for log_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestLogsContractEvent(ContractEvent):
    """ContractEvent for logs."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogsEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogsEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class FixedPointMathTestContractEvents(ContractEvents):
    """ContractEvents for the FixedPointMathTest contract."""

    log: FixedPointMathTestLogContractEvent

    log_address: FixedPointMathTestLog_addressContractEvent

    log_array: FixedPointMathTestLog_arrayContractEvent

    log_bytes: FixedPointMathTestLog_bytesContractEvent

    log_bytes32: FixedPointMathTestLog_bytes32ContractEvent

    log_int: FixedPointMathTestLog_intContractEvent

    log_named_address: FixedPointMathTestLog_named_addressContractEvent

    log_named_array: FixedPointMathTestLog_named_arrayContractEvent

    log_named_bytes: FixedPointMathTestLog_named_bytesContractEvent

    log_named_bytes32: FixedPointMathTestLog_named_bytes32ContractEvent

    log_named_decimal_int: FixedPointMathTestLog_named_decimal_intContractEvent

    log_named_decimal_uint: (
        FixedPointMathTestLog_named_decimal_uintContractEvent
    )

    log_named_int: FixedPointMathTestLog_named_intContractEvent

    log_named_string: FixedPointMathTestLog_named_stringContractEvent

    log_named_uint: FixedPointMathTestLog_named_uintContractEvent

    log_string: FixedPointMathTestLog_stringContractEvent

    log_uint: FixedPointMathTestLog_uintContractEvent

    logs: FixedPointMathTestLogsContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.log = FixedPointMathTestLogContractEvent.factory(
            "log", w3=w3, contract_abi=abi, address=address, event_name="log"
        )
        self.log_address = FixedPointMathTestLog_addressContractEvent.factory(
            "log_address",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_address",
        )
        self.log_array = FixedPointMathTestLog_arrayContractEvent.factory(
            "log_array",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_array",
        )
        self.log_bytes = FixedPointMathTestLog_bytesContractEvent.factory(
            "log_bytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_bytes",
        )
        self.log_bytes32 = FixedPointMathTestLog_bytes32ContractEvent.factory(
            "log_bytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_bytes32",
        )
        self.log_int = FixedPointMathTestLog_intContractEvent.factory(
            "log_int",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_int",
        )
        self.log_named_address = (
            FixedPointMathTestLog_named_addressContractEvent.factory(
                "log_named_address",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_address",
            )
        )
        self.log_named_array = (
            FixedPointMathTestLog_named_arrayContractEvent.factory(
                "log_named_array",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_array",
            )
        )
        self.log_named_bytes = (
            FixedPointMathTestLog_named_bytesContractEvent.factory(
                "log_named_bytes",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes",
            )
        )
        self.log_named_bytes32 = (
            FixedPointMathTestLog_named_bytes32ContractEvent.factory(
                "log_named_bytes32",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_bytes32",
            )
        )
        self.log_named_decimal_int = (
            FixedPointMathTestLog_named_decimal_intContractEvent.factory(
                "log_named_decimal_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_int",
            )
        )
        self.log_named_decimal_uint = (
            FixedPointMathTestLog_named_decimal_uintContractEvent.factory(
                "log_named_decimal_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_decimal_uint",
            )
        )
        self.log_named_int = (
            FixedPointMathTestLog_named_intContractEvent.factory(
                "log_named_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_int",
            )
        )
        self.log_named_string = (
            FixedPointMathTestLog_named_stringContractEvent.factory(
                "log_named_string",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_string",
            )
        )
        self.log_named_uint = (
            FixedPointMathTestLog_named_uintContractEvent.factory(
                "log_named_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_uint",
            )
        )
        self.log_string = FixedPointMathTestLog_stringContractEvent.factory(
            "log_string",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_string",
        )
        self.log_uint = FixedPointMathTestLog_uintContractEvent.factory(
            "log_uint",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_uint",
        )
        self.logs = FixedPointMathTestLogsContractEvent.factory(
            "logs", w3=w3, contract_abi=abi, address=address, event_name="logs"
        )


class FixedPointMathTestContract(Contract):
    """A web3.py Contract class for the FixedPointMathTest contract."""

    abi: ABI = fixedpointmathtest_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x6080604052600c8054600160ff199182168117909255601e8054909116909117905534801561002c575f80fd5b50614e528061003a5f395ff3fe608060405234801561000f575f80fd5b50600436106101d1575f3560e01c806366d9a9a0116100fe578063ba414fa61161009e578063fa7626d41161006e578063fa7626d414610315578063fb588a4814610322578063fb928cde1461032a578063fbba16f914610332575f80fd5b8063ba414fa6146102da578063e20c9f71146102f2578063e3bfaadd146102fa578063ed6fe59a14610302575f80fd5b8063916a17c6116100d9578063916a17c6146102ba578063a7d78b82146102c2578063b1cd1825146102ca578063b5508aa9146102d2575f80fd5b806366d9a9a01461028857806385226c811461029d5780638d9108a5146102b2575f80fd5b8063343de8cb1161017457806352ff9e5f1161014457806352ff9e5f14610268578063545d7202146102705780635c7b14aa1461027857806362ca879714610280575f80fd5b8063343de8cb1461024857806339c71a7d146102505780633e5e3c23146102585780633f7286f414610260575f80fd5b80631ed7831c116101af5780631ed7831c1461020557806320423cbc146102235780632ab1873c1461022b5780632ade388014610233575f80fd5b806307d72d02146101d55780630faf012b146101ea5780631a0c8ad8146101fd575b5f80fd5b6101e86101e3366004614077565b61033a565b005b6101e86101f836600461408e565b6103fd565b6101e86104da565b61020d6106fb565b60405161021a91906140ae565b60405180910390f35b6101e861075b565b6101e8610967565b61023b610a4b565b60405161021a91906140fa565b6101e8610b87565b6101e8611251565b61020d611350565b61020d6113ae565b6101e861140c565b6101e86114c8565b6101e861190e565b6101e8611af3565b610290611c2c565b60405161021a91906141ea565b6102a5611d0d565b60405161021a919061428d565b6101e8611dd8565b610290611e98565b6101e8611f79565b6101e861211c565b6102a56121e1565b6102e26122ac565b604051901515815260200161021a565b61020d61234c565b6101e86123aa565b6101e861031036600461431a565b6128ab565b601e546102e29060ff1681565b6101e86129fa565b6101e8612ac0565b6101e8612d42565b610349815f600160ff1b612e09565b90505f6040516103589061406a565b604051809103905ff080158015610371573d5f803e3d5ffd5b50604051632e4c697f60e01b8152600481018490525f602482018190529192506001600160a01b03831690632e4c697f90604401602060405180830381865afa1580156103c0573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906103e49190614349565b90506103f881670de0b6b3a7640000612e88565b505050565b61040c825f600160ff1b612e09565b915061041a815f6001612e09565b90505f6040516104299061406a565b604051809103905ff080158015610442573d5f803e3d5ffd5b50604051632e4c697f60e01b815260048101859052602481018490529091505f906001600160a01b03831690632e4c697f90604401602060405180830381865afa158015610492573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104b69190614349565b90505f6104c38585612eeb565b90506104d38282620186a061305b565b5050505050565b5f6040516104e79061406a565b604051809103905ff080158015610500573d5f803e3d5ffd5b5060405163e46751e360e01b8152670de0b6b3a76400006004820152909150610584906001600160a01b0383169063e46751e390602401602060405180830381865afa158015610552573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105769190614349565b6725b946ebc0b361736130cd565b60405163e46751e360e01b81525f60048201526105fc906001600160a01b0383169063e46751e390602401602060405180830381865afa1580156105ca573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105ee9190614349565b670de0b6b3a76400006130cd565b60405163e46751e360e01b8152670de0b6b3a763ffff19600482015261067d906001600160a01b0383169063e46751e390602401602060405180830381865afa15801561064b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061066f9190614349565b67051af86713316a916130cd565b60405163e46751e360e01b8152680248ce36a70cb26b3e1960048201526106f8906001600160a01b0383169063e46751e3906024015b602060405180830381865afa1580156106ce573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906106f29190614349565b5f6130cd565b50565b6060601680548060200260200160405190810160405280929190818152602001828054801561075157602002820191905f5260205f20905b81546001600160a01b03168152600190910190602001808311610733575b5050505050905090565b5f6040516107689061406a565b604051809103905ff080158015610781573d5f803e3d5ffd5b50604051634dd2fa9760e11b8152671158e460913d000060048201526706f05b59d3b200006024820152909150610814906001600160a01b03831690639ba5f52e906044015b602060405180830381865afa1580156107e2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108069190614349565b6722b1c8c1227a0000612e88565b604051634dd2fa9760e11b81526729a2241af62c00006004820152670de0b6b3a764000060248201526108a3906001600160a01b03831690639ba5f52e906044015b602060405180830381865afa158015610871573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906108959190614349565b6729a2241af62c0000612e88565b604051634dd2fa9760e11b8152600260048201526d04ee2d6d415b85acef81000000006024820152610929906001600160a01b03831690639ba5f52e906044015b602060405180830381865afa1580156108ff573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109239190614349565b5f612e88565b604051634dd2fa9760e11b81525f6004820152670de0b6b3a764000060248201526106f8906001600160a01b03831690639ba5f52e906044016108e4565b5f6040516109749061406a565b604051809103905ff08015801561098d573d5f803e3d5ffd5b50604051638e6f235360e01b8152670de0b6b3a764000060048201529091506109c9906001600160a01b03831690638e6f2353906024016106b3565b604051638e6f235360e01b815269d3c21bcecceda100000060048201526106f8906001600160a01b03831690638e6f235390602401602060405180830381865afa158015610a19573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a3d9190614349565b67bfba8da79e1e89b86130cd565b6060601d805480602002602001604051908101604052809291908181526020015f905b82821015610b7e575f84815260208082206040805180820182526002870290920180546001600160a01b03168352600181018054835181870281018701909452808452939591948681019491929084015b82821015610b67578382905f5260205f20018054610adc90614360565b80601f0160208091040260200160405190810160405280929190818152602001828054610b0890614360565b8015610b535780601f10610b2a57610100808354040283529160200191610b53565b820191905f5260205f20905b815481529060010190602001808311610b3657829003601f168201915b505050505081526020019060010190610abf565b505050508152505081526020019060010190610a6e565b50505050905090565b5f604051610b949061406a565b604051809103905ff080158015610bad573d5f803e3d5ffd5b50604051624af5ab60e61b81526b0813f3978f8940984400000060048201526b019d971e4fe8401e7400000060248201526b033b2e3c9fd0803ce80000006044820152909150610c5d906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610c27573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c4b9190614349565b6b0409f9cbc7c4a04c22000000612e88565b604051624af5ab60e61b81526722b1c8c1227a000060048201526706f05b59d3b200006024820152670de0b6b3a76400006044820152610cf9906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610cc7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610ceb9190614349565b671158e460913d0000612e88565b604051624af5ab60e61b8152630ee6b28060048201526302faf08060248201526305f5e1006044820152610d85906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610d57573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d7b9190614349565b6307735940612e88565b604051624af5ab60e61b8152610171600482015261010f6024820152606460448201819052610e07916001600160a01b038416916312bd6ac09101602060405180830381865afa158015610ddb573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610dff9190614349565b6103e8612e88565b604051624af5ab60e61b81526b033b2e3c9fd0803ce80000006004820181905260248201526b06765c793fa10079d00000006044820152610ea8906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610e72573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e969190614349565b6b019d971e4fe8401e74000000612e88565b604051624af5ab60e61b8152670de0b6b3a7640000600482018190526024820152671bc16d674ec800006044820152610f3d906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610f0b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610f2f9190614349565b6706f05b59d3b20000612e88565b604051624af5ab60e61b81526305f5e100600482018190526024820152630bebc2006044820152610fc6906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015610f98573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610fbc9190614349565b6302faf080612e88565b604051624af5ab60e61b81526b06765c793fa10079d0000000600482018190526b09b18ab5df7180b6b800000060248301526044820152611067906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015611031573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110559190614349565b6b09b18ab5df7180b6b8000000612e88565b604051624af5ab60e61b81526729a2241af62c000060048201819052671bc16d674ec80000602483015260448201526110fc906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa1580156110ca573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906110ee9190614349565b671bc16d674ec80000612e88565b604051624af5ab60e61b8152630bebc200600482018190526311e1a30060248301526044820152611185906001600160a01b038316906312bd6ac0906064015b602060405180830381865afa158015611157573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061117b9190614349565b6311e1a300612e88565b604051624af5ab60e61b81525f6004820152670de0b6b3a76400006024820181905260448201526111c9906001600160a01b038316906312bd6ac0906064016108e4565b604051624af5ab60e61b8152670de0b6b3a7640000600482018190525f6024830152604482015261120d906001600160a01b038316906312bd6ac0906064016108e4565b604051624af5ab60e61b81525f600482018190526024820152670de0b6b3a764000060448201526106f8906001600160a01b038316906312bd6ac0906064016108e4565b5f60405161125e9061406a565b604051809103905ff080158015611277573d5f803e3d5ffd5b5090505f80516020614dfd8339815191525f1c6001600160a01b031663f48448146040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156112c1575f80fd5b505af11580156112d3573d5f803e3d5ffd5b5050604051634dd2fa9760e11b8152670de0b6b3a764000060048201525f60248201526001600160a01b0384169250639ba5f52e91506044015b602060405180830381865afa158015611328573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061134c9190614349565b5050565b6060601880548060200260200160405190810160405280929190818152602001828054801561075157602002820191905f5260205f209081546001600160a01b03168152600190910190602001808311610733575050505050905090565b6060601780548060200260200160405190810160405280929190818152602001828054801561075157602002820191905f5260205f209081546001600160a01b03168152600190910190602001808311610733575050505050905090565b5f6040516114199061406a565b604051809103905ff080158015611432573d5f803e3d5ffd5b50604051630618f58760e51b815263e61b497560e01b6004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d9063c31eb0e0906024015f604051808303815f87803b158015611486575f80fd5b505af1158015611498573d5f803e3d5ffd5b5050604051638e6f235360e01b81525f60048201526001600160a01b0384169250638e6f2353915060240161130d565b5f6040516114d59061406a565b604051809103905ff0801580156114ee573d5f803e3d5ffd5b50604051632d9efb8160e21b81526b0813f3978f8940984400000060048201526b019d971e4fe8401e7400000060248201526b033b2e3c9fd0803ce80000006044820152909150611552906001600160a01b0383169063b67bee0490606401610c0c565b604051632d9efb8160e21b81526722b1c8c1227a000060048201526706f05b59d3b200006024820152670de0b6b3a764000060448201526115a6906001600160a01b0383169063b67bee0490606401610cac565b604051632d9efb8160e21b8152630ee6b28060048201526302faf08060248201526305f5e10060448201526115ee906001600160a01b0383169063b67bee0490606401610d3c565b604051632d9efb8160e21b8152610171600482015261010f6024820152606460448201819052611671916001600160a01b0384169163b67bee049101602060405180830381865afa158015611645573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116699190614349565b6103e7612e88565b604051632d9efb8160e21b81526b033b2e3c9fd0803ce80000006004820181905260248201526b06765c793fa10079d000000060448201526116c6906001600160a01b0383169063b67bee0490606401610e57565b604051632d9efb8160e21b8152670de0b6b3a7640000600482018190526024820152671bc16d674ec800006044820152611713906001600160a01b0383169063b67bee0490606401610ef0565b604051632d9efb8160e21b81526305f5e100600482018190526024820152630bebc2006044820152611758906001600160a01b0383169063b67bee0490606401610f7d565b604051632d9efb8160e21b81526b06765c793fa10079d0000000600482018190526b09b18ab5df7180b6b8000000602483015260448201526117ad906001600160a01b0383169063b67bee0490606401611016565b604051632d9efb8160e21b81526729a2241af62c000060048201819052671bc16d674ec80000602483015260448201526117fa906001600160a01b0383169063b67bee04906064016110af565b604051632d9efb8160e21b8152630bebc200600482018190526311e1a3006024830152604482015261183f906001600160a01b0383169063b67bee049060640161113c565b604051632d9efb8160e21b81525f6004820152670de0b6b3a7640000602482018190526044820152611884906001600160a01b0383169063b67bee04906064016108e4565b604051632d9efb8160e21b8152670de0b6b3a7640000600482018190525f602483015260448201526118c9906001600160a01b0383169063b67bee04906064016108e4565b604051632d9efb8160e21b81525f600482018190526024820152670de0b6b3a764000060448201526106f8906001600160a01b0383169063b67bee04906064016108e4565b5f60405161191b9061406a565b604051809103905ff080158015611934573d5f803e3d5ffd5b50604051633cf93e1f60e21b81526722b1c8c1227a000060048201526706f05b59d3b20000602482015290915061197e906001600160a01b0383169063f3e4f87c90604401610cac565b604051633cf93e1f60e21b81526729a2241af62c00006004820152670de0b6b3a764000060248201526119c4906001600160a01b0383169063f3e4f87c90604401610856565b604051633cf93e1f60e21b8152610171600482015261010f6024820152611a40906001600160a01b0383169063f3e4f87c906044015b602060405180830381865afa158015611a15573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611a399190614349565b6001612e88565b604051633cf93e1f60e21b81525f6004820152670de0b6b3a76400006024820152611a7e906001600160a01b0383169063f3e4f87c906044016108e4565b604051633cf93e1f60e21b8152670de0b6b3a764000060048201525f6024820152611abc906001600160a01b0383169063f3e4f87c906044016108e4565b604051633cf93e1f60e21b81525f6004820181905260248201526106f8906001600160a01b0383169063f3e4f87c906044016108e4565b5f604051611b009061406a565b604051809103905ff080158015611b19573d5f803e3d5ffd5b5060405163cbe8623f60e01b8152671158e460913d000060048201526706f05b59d3b200006024820152909150611b63906001600160a01b0383169063cbe8623f906044016107c7565b60405163cbe8623f60e01b81526729a2241af62c00006004820152670de0b6b3a76400006024820152611ba9906001600160a01b0383169063cbe8623f90604401610856565b60405163cbe8623f60e01b8152600260048201526d04ee2d6d415b85acef81000000006024820152611bee906001600160a01b0383169063cbe8623f906044016119fa565b60405163cbe8623f60e01b81525f6004820152670de0b6b3a764000060248201526106f8906001600160a01b0383169063cbe8623f906044016108e4565b6060601b805480602002602001604051908101604052809291908181526020015f905b82821015610b7e575f8481526020908190206040805180820182526002860290920180546001600160a01b03168352600181018054835181870281018701909452808452939491938583019392830182828015611cf557602002820191905f5260205f20905f905b82829054906101000a900460e01b6001600160e01b03191681526020019060040190602082600301049283019260010382029150808411611cb75790505b50505050508152505081526020019060010190611c4f565b6060601a805480602002602001604051908101604052809291908181526020015f905b82821015610b7e578382905f5260205f20018054611d4d90614360565b80601f0160208091040260200160405190810160405280929190818152602001828054611d7990614360565b8015611dc45780601f10611d9b57610100808354040283529160200191611dc4565b820191905f5260205f20905b815481529060010190602001808311611da757829003601f168201915b505050505081526020019060010190611d30565b5f604051611de59061406a565b604051809103905ff080158015611dfe573d5f803e3d5ffd5b5090505f80516020614dfd8339815191525f1c6001600160a01b031663f48448146040518163ffffffff1660e01b81526004015f604051808303815f87803b158015611e48575f80fd5b505af1158015611e5a573d5f803e3d5ffd5b505060405163cbe8623f60e01b8152670de0b6b3a764000060048201525f60248201526001600160a01b038416925063cbe8623f915060440161130d565b6060601c805480602002602001604051908101604052809291908181526020015f905b82821015610b7e575f8481526020908190206040805180820182526002860290920180546001600160a01b03168352600181018054835181870281018701909452808452939491938583019392830182828015611f6157602002820191905f5260205f20905f905b82829054906101000a900460e01b6001600160e01b03191681526020019060040190602082600301049283019260010382029150808411611f235790505b50505050508152505081526020019060010190611ebb565b5f604051611f869061406a565b604051809103905ff080158015611f9f573d5f803e3d5ffd5b50604051630c9b988160e01b81526722b1c8c1227a000060048201526706f05b59d3b200006024820152909150611fe9906001600160a01b03831690630c9b988190604401610cac565b604051630c9b988160e01b81526729a2241af62c00006004820152670de0b6b3a7640000602482015261202f906001600160a01b03831690630c9b988190604401610856565b604051630c9b988160e01b8152610171600482015261010f6024820152612069906001600160a01b03831690630c9b9881906044016108e4565b604051630c9b988160e01b81525f6004820152670de0b6b3a764000060248201526120a7906001600160a01b03831690630c9b9881906044016108e4565b604051630c9b988160e01b8152670de0b6b3a764000060048201525f60248201526120e5906001600160a01b03831690630c9b9881906044016108e4565b604051630c9b988160e01b81525f6004820181905260248201526106f8906001600160a01b03831690630c9b9881906044016108e4565b5f6040516121299061406a565b604051809103905ff080158015612142573d5f803e3d5ffd5b50604051630618f58760e51b81526373a2d6b160e01b6004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d9063c31eb0e0906024015f604051808303815f87803b158015612196575f80fd5b505af11580156121a8573d5f803e3d5ffd5b505060405163e46751e360e01b8152680755bf798b4a1bf1e560048201526001600160a01b038416925063e46751e3915060240161130d565b60606019805480602002602001604051908101604052809291908181526020015f905b82821015610b7e578382905f5260205f2001805461222190614360565b80601f016020809104026020016040519081016040528092919081815260200182805461224d90614360565b80156122985780601f1061226f57610100808354040283529160200191612298565b820191905f5260205f20905b81548152906001019060200180831161227b57829003601f168201915b505050505081526020019060010190612204565b6008545f9060ff16156122c3575060085460ff1690565b604051630667f9d760e41b8152737109709ecfa91a80626ff3989d68f67f5b1dd12d600482018190526519985a5b195960d21b60248301525f9163667f9d7090604401602060405180830381865afa158015612321573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906123459190614349565b1415905090565b6060601580548060200260200160405190810160405280929190818152602001828054801561075157602002820191905f5260205f209081546001600160a01b03168152600190910190602001808311610733575050505050905090565b5f6040516123b79061406a565b604051809103905ff0801580156123d0573d5f803e3d5ffd5b50604051632e4c697f60e01b81525f6004820181905260248201819052919250819081906001600160a01b03851690632e4c697f90604401602060405180830381865afa158015612423573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124479190614349565b90505f6124548484612eeb565b90506124608282612e88565b604051632e4c697f60e01b8152693f870857a3e0e3800000600482018190525f6024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa1580156124bb573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124df9190614349565b91506124eb8484612eeb565b90506124f78282612e88565b604051632e4c697f60e01b81525f60048201819052670d90a678952c76076024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa158015612550573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906125749190614349565b91506125808484612eeb565b905061258c8282612e88565b604051632e4c697f60e01b8152693f870857a3e0e380000060048201819052670d90a678952c76076024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa1580156125ef573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906126139190614349565b915061261f8484612eeb565b905061262f8282620186a061305b565b604051632e4c697f60e01b815269261dd1ce2f208880000060048201819052670d90a678952c76076024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa158015612692573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906126b69190614349565b91506126c28484612eeb565b90506126d28282620186a061305b565b604051632e4c697f60e01b81526923210168cbc69589efa160048201819052670e329f7b4eec18506024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa158015612735573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906127599190614349565b91506127658484612eeb565b90506127758282620186a061305b565b604051632e4c697f60e01b81526910522d11711bd8e4997160048201819052670e329f7b4eec18506024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa1580156127d8573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906127fc9190614349565b91506128088484612eeb565b90506128188282620186a061305b565b604051632e4c697f60e01b81526903e89f12e2375d69fb1060048201819052670e329f7b4eec18506024830181905290955093506001600160a01b03861690632e4c697f90604401602060405180830381865afa15801561287b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061289f9190614349565b91506104c38484612eeb565b5f6040516128b89061406a565b604051809103905ff0801580156128d1573d5f803e3d5ffd5b5090506128ee85633b9aca006a52b7d2dcc80cd2e4000000612e09565b945061290a84633b9aca006a52b7d2dcc80cd2e4000000612e09565b935061292683633b9aca006a52b7d2dcc80cd2e4000000612e09565b925061294282633b9aca006a52b7d2dcc80cd2e4000000612e09565b6040516381e5f7c960e01b815260048101879052602481018690526044810185905260648101829052600160848201529092505f906001600160a01b038316906381e5f7c99060a401602060405180830381865afa1580156129a6573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906129ca9190614349565b90506129df816129da888761310c565b613123565b6129f2816129ed8887613162565b613177565b505050505050565b5f604051612a079061406a565b604051809103905ff080158015612a20573d5f803e3d5ffd5b5090505f80516020614dfd8339815191525f1c6001600160a01b031663f48448146040518163ffffffff1660e01b81526004015f604051808303815f87803b158015612a6a575f80fd5b505af1158015612a7c573d5f803e3d5ffd5b5050604051624af5ab60e61b8152670de0b6b3a76400006004820181905260248201525f60448201526001600160a01b03841692506312bd6ac0915060640161130d565b5f604051612acd9061406a565b604051809103905ff080158015612ae6573d5f803e3d5ffd5b506040516381e5f7c960e01b8152671bc16d674ec800006004820152670de0b6b3a764000060248201526729a2241af62c000060448201525f606482015260016084820152909150612b4b906001600160a01b038316906381e5f7c99060a4016110af565b6040516381e5f7c960e01b8152670de0b6b3a7640000600482018190526024820181905260448201819052606482015260016084820152612be8906001600160a01b038316906381e5f7c99060a4015b602060405180830381865afa158015612bb6573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612bda9190614349565b670de0b6b3a7640000612e88565b6040516381e5f7c960e01b8152670de0b6b3a764000060048201819052602482018190526044820181905260648201525f6084820152612c3b906001600160a01b038316906381e5f7c99060a4016108e4565b6040516381e5f7c960e01b8152670de0b6b3a764000060048201819052671bc16d674ec8000060248301526044820181905260648201525f6084820152612c95906001600160a01b038316906381e5f7c99060a401612b9b565b6040516381e5f7c960e01b815268056bc75e2d631000006004820152678ac7230489e8000060248201819052680ad78ebc5ac620000060448301526064820152600160848201526106f8906001600160a01b038316906381e5f7c99060a401602060405180830381865afa158015612d0f573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612d339190614349565b680821ab0d4414980000612e88565b5f604051612d4f9061406a565b604051809103905ff080158015612d68573d5f803e3d5ffd5b5090505f80516020614dfd8339815191525f1c6001600160a01b031663f48448146040518163ffffffff1660e01b81526004015f604051808303815f87803b158015612db2575f80fd5b505af1158015612dc4573d5f803e3d5ffd5b5050604051632d9efb8160e21b8152670de0b6b3a76400006004820181905260248201525f60448201526001600160a01b038416925063b67bee04915060640161130d565b5f81831115612e4f5760405162461bcd60e51b815260206004820152600e60248201526d098d2c47440dad2dc407c40dac2f60931b604482015260640160405180910390fd5b5f612e5a84846143ac565b612e659060016143bf565b90505f612e7282876143e6565b9050612e7e85826143bf565b9695505050505050565b60405163260a5b1560e21b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d906398296c54906044015b5f6040518083038186803b158015612ed9575f80fd5b505afa1580156129f2573d5f803e3d5ffd5b5f815f03612f025750670de0b6b3a7640000613055565b825f03612f1057505f613055565b612f2060ff84901c1560066131b6565b82612f44612f3b68056bc75e2d63100000600160fe1b6143f9565b841060076131b6565b825f82612f6167016345785d8a0000670de0b6b3a764000061440c565b128015612f865750612f83670de0b6b3a764000067016345785d8a0000614432565b83125b15612fee575f612f95846131c4565b9050670de0b6b3a764000083612fab8284614459565b612fb5919061446c565b612fbf919061449b565b83612fd2670de0b6b3a76400008461449b565b612fdc919061446c565b612fe69190614432565b915050613005565b81612ff8846133f8565b613002919061446c565b90505b613017670de0b6b3a76400008261449b565b905061304681680238fd42c5cf03ffff191315801561303f575068070c1cc73b00c800008213155b60086131b6565b61304f816139da565b93505050505b92915050565b604051630b6903e360e11b8152600481018490526024810183905260448101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d906316d207c6906064015f6040518083038186803b1580156130b2575f80fd5b505afa1580156130c4573d5f803e3d5ffd5b50505050505050565b60405163fe74f05b60e01b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d9063fe74f05b90604401612ec3565b5f81831161311a578261311c565b815b9392505050565b60405163a8d4d1d960e01b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d9063a8d4d1d990604401612ec3565b5f818311613170578161311c565b5090919050565b604051638466f41560e01b81526004810183905260248101829052737109709ecfa91a80626ff3989d68f67f5b1dd12d90638466f41590604401612ec3565b8161134c5761134c8161400e565b5f6131d7670de0b6b3a76400008361446c565b91505f6131f26a0c097ce7bc90715b34b9f160241b84614432565b6a0c097ce7bc90715b34b9f160241b61320b818661440c565b613215919061446c565b61321f919061449b565b90505f6a0c097ce7bc90715b34b9f160241b61323b838061446c565b613245919061449b565b905081806a0c097ce7bc90715b34b9f160241b613262848361446c565b61326c919061449b565b915061327960038361449b565b6132839082614432565b90506a0c097ce7bc90715b34b9f160241b61329e848461446c565b6132a8919061449b565b91506132b560058361449b565b6132bf9082614432565b90506a0c097ce7bc90715b34b9f160241b6132da848461446c565b6132e4919061449b565b91506132f160078361449b565b6132fb9082614432565b90506a0c097ce7bc90715b34b9f160241b613316848461446c565b613320919061449b565b915061332d60098361449b565b6133379082614432565b90506a0c097ce7bc90715b34b9f160241b613352848461446c565b61335c919061449b565b9150613369600b8361449b565b6133739082614432565b90506a0c097ce7bc90715b34b9f160241b61338e848461446c565b613398919061449b565b91506133a5600d8361449b565b6133af9082614432565b90506a0c097ce7bc90715b34b9f160241b6133ca848461446c565b6133d4919061449b565b91506133e1600f8361449b565b6133eb9082614432565b9050612e7e81600261446c565b5f670de0b6b3a76400008212156134375761342e8261341f670de0b6b3a76400008061446c565b613429919061449b565b6133f8565b613055906144c7565b5f613462670de0b6b3a7640000770195e54c5dd42177f53a27172fa9ec63026282700000000061446c565b83126134a25761348a770195e54c5dd42177f53a27172fa9ec6302628270000000008461449b565b925061349f6806f05b59d3b200000082614432565b90505b6134c0670de0b6b3a76400006b1425982cf597cd205cef738061446c565b83126134f4576134dc6b1425982cf597cd205cef73808461449b565b92506134f16803782dace9d900000082614432565b90505b6134ff60648261446c565b905061350c60648461446c565b92506e01855144814a7ff805980ff00840008312613569576e01855144814a7ff805980ff008400061354768056bc75e2d631000008561446c565b613551919061449b565b925061356668ad78ebc5ac6200000082614432565b90505b6b02df0ab5a80a22c61ab5a70083126135be576b02df0ab5a80a22c61ab5a70061359c68056bc75e2d631000008561446c565b6135a6919061449b565b92506135bb6856bc75e2d63100000082614432565b90505b693f1fce3da636ea5cf850831261360f57693f1fce3da636ea5cf8506135ed68056bc75e2d631000008561446c565b6135f7919061449b565b925061360c682b5e3af16b1880000082614432565b90505b690127fa27722cc06cc5e2831261366057690127fa27722cc06cc5e261363e68056bc75e2d631000008561446c565b613648919061449b565b925061365d6815af1d78b58c40000082614432565b90505b68280e60114edb805d0383126136af5768280e60114edb805d0361368d68056bc75e2d631000008561446c565b613697919061449b565b92506136ac680ad78ebc5ac620000082614432565b90505b680ebc5fb4174612111083126136fe57680ebc5fb417461211106136dc68056bc75e2d631000008561446c565b6136e6919061449b565b92506136fb68056bc75e2d6310000082614432565b90505b6808f00f760a4b2db55d831261374d576808f00f760a4b2db55d61372b68056bc75e2d631000008561446c565b613735919061449b565b925061374a6802b5e3af16b188000082614432565b90505b6806f5f1775788937937831261379c576806f5f177578893793761377a68056bc75e2d631000008561446c565b613784919061449b565b925061379968015af1d78b58c4000082614432565b90505b6806248f33704b28660383126137ea576806248f33704b2866036137c968056bc75e2d631000008561446c565b6137d3919061449b565b92506137e767ad78ebc5ac62000082614432565b90505b6805c548670b9510e7ac8312613838576805c548670b9510e7ac61381768056bc75e2d631000008561446c565b613821919061449b565b92506138356756bc75e2d631000082614432565b90505b5f61384c68056bc75e2d6310000085614432565b68056bc75e2d63100000613860818761440c565b61386a919061446c565b613874919061449b565b90505f68056bc75e2d6310000061388b838061446c565b613895919061449b565b9050818068056bc75e2d631000006138ad848361446c565b6138b7919061449b565b91506138c460038361449b565b6138ce9082614432565b905068056bc75e2d631000006138e4848461446c565b6138ee919061449b565b91506138fb60058361449b565b6139059082614432565b905068056bc75e2d6310000061391b848461446c565b613925919061449b565b915061393260078361449b565b61393c9082614432565b905068056bc75e2d63100000613952848461446c565b61395c919061449b565b915061396960098361449b565b6139739082614432565b905068056bc75e2d63100000613989848461446c565b613993919061449b565b91506139a0600b8361449b565b6139aa9082614432565b90506139b760028261446c565b905060646139c58287614432565b6139cf919061449b565b979650505050505050565b5f613a08680238fd42c5cf03ffff198312158015613a01575068070c1cc73b00c800008313155b60096131b6565b5f821215613a3d57613a21613a1c836144c7565b6139da565b613a33670de0b6b3a76400008061446c565b613055919061449b565b5f6806f05b59d3b20000008312613a8357613a616806f05b59d3b20000008461440c565b9250770195e54c5dd42177f53a27172fa9ec6302628270000000009050613ac0565b6803782dace9d90000008312613abc57613aa66803782dace9d90000008461440c565b92506b1425982cf597cd205cef73809050613ac0565b5060015b613acb60648461446c565b925068056bc75e2d6310000068ad78ebc5ac620000008412613b2c57613afa68ad78ebc5ac620000008561440c565b935068056bc75e2d63100000613b1f6e01855144814a7ff805980ff00840008361446c565b613b29919061449b565b90505b6856bc75e2d6310000008412613b7e57613b4f6856bc75e2d6310000008561440c565b935068056bc75e2d63100000613b716b02df0ab5a80a22c61ab5a7008361446c565b613b7b919061449b565b90505b682b5e3af16b188000008412613bce57613ba1682b5e3af16b188000008561440c565b935068056bc75e2d63100000613bc1693f1fce3da636ea5cf8508361446c565b613bcb919061449b565b90505b6815af1d78b58c4000008412613c1e57613bf16815af1d78b58c4000008561440c565b935068056bc75e2d63100000613c11690127fa27722cc06cc5e28361446c565b613c1b919061449b565b90505b680ad78ebc5ac62000008412613c6d57613c41680ad78ebc5ac62000008561440c565b935068056bc75e2d63100000613c6068280e60114edb805d038361446c565b613c6a919061449b565b90505b68056bc75e2d631000008412613cbc57613c9068056bc75e2d631000008561440c565b935068056bc75e2d63100000613caf680ebc5fb417461211108361446c565b613cb9919061449b565b90505b6802b5e3af16b18800008412613d0b57613cdf6802b5e3af16b18800008561440c565b935068056bc75e2d63100000613cfe6808f00f760a4b2db55d8361446c565b613d08919061449b565b90505b68015af1d78b58c400008412613d5a57613d2e68015af1d78b58c400008561440c565b935068056bc75e2d63100000613d4d6806f5f17757889379378361446c565b613d57919061449b565b90505b68056bc75e2d6310000084613d6f8183614432565b9150600268056bc75e2d63100000613d87888461446c565b613d91919061449b565b613d9b919061449b565b9050613da78183614432565b9150600368056bc75e2d63100000613dbf888461446c565b613dc9919061449b565b613dd3919061449b565b9050613ddf8183614432565b9150600468056bc75e2d63100000613df7888461446c565b613e01919061449b565b613e0b919061449b565b9050613e178183614432565b9150600568056bc75e2d63100000613e2f888461446c565b613e39919061449b565b613e43919061449b565b9050613e4f8183614432565b9150600668056bc75e2d63100000613e67888461446c565b613e71919061449b565b613e7b919061449b565b9050613e878183614432565b9150600768056bc75e2d63100000613e9f888461446c565b613ea9919061449b565b613eb3919061449b565b9050613ebf8183614432565b9150600868056bc75e2d63100000613ed7888461446c565b613ee1919061449b565b613eeb919061449b565b9050613ef78183614432565b9150600968056bc75e2d63100000613f0f888461446c565b613f19919061449b565b613f23919061449b565b9050613f2f8183614432565b9150600a68056bc75e2d63100000613f47888461446c565b613f51919061449b565b613f5b919061449b565b9050613f678183614432565b9150600b68056bc75e2d63100000613f7f888461446c565b613f89919061449b565b613f93919061449b565b9050613f9f8183614432565b9150600c68056bc75e2d63100000613fb7888461446c565b613fc1919061449b565b613fcb919061449b565b9050613fd78183614432565b915060648468056bc75e2d63100000613ff0858761446c565b613ffa919061449b565b614004919061446c565b612e7e919061449b565b62461bcd60e51b5f90815260206004526007602452600a808304818106603090810160081b83860601918390049283060160101b016642414c230000300160c81b60448190526106f8926210905360ea1b916242414c91606490fd5b61091b806144e283390190565b5f60208284031215614087575f80fd5b5035919050565b5f806040838503121561409f575f80fd5b50508035926020909101359150565b602080825282518282018190525f9190848201906040850190845b818110156140ee5783516001600160a01b0316835292840192918401916001016140c9565b50909695505050505050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156141dc57603f19898403018552815180516001600160a01b031684528701518784018790528051878501819052908801906060600582901b8601810191908601905f5b818110156141c657878403605f19018352845180518086525f5b818110156141a0578e81840101518f82890101528e81019050614182565b505f8682018f0152958d0195601f01601f19169094018c019350918b0191600101614168565b5050509588019593505090860190600101614121565b509098975050505050505050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b838110156141dc57888303603f19018552815180516001600160a01b031684528701518784018790528051878501819052908801905f9060608601905b808310156142785783516001600160e01b0319168252928a019260019290920191908a019061424e565b50968901969450505090860190600101614211565b5f602080830181845280855180835260408601915060408160051b87010192508387015f5b8281101561430d57878503603f19018452815180518087525f5b818110156142e7578281018901518882018a015288016142cc565b505f878201890152601f01601f19169095018601945092850192908501906001016142b2565b5092979650505050505050565b5f805f806080858703121561432d575f80fd5b5050823594602084013594506040840135936060013592509050565b5f60208284031215614359575f80fd5b5051919050565b600181811c9082168061437457607f821691505b60208210810361439257634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561305557613055614398565b8082018082111561305557613055614398565b634e487b7160e01b5f52601260045260245ffd5b5f826143f4576143f46143d2565b500690565b5f82614407576144076143d2565b500490565b8181035f83128015838313168383128216171561442b5761442b614398565b5092915050565b8082018281125f83128015821682158216171561445157614451614398565b505092915050565b5f82614467576144676143d2565b500790565b8082025f8212600160ff1b8414161561448757614487614398565b818105831482151761305557613055614398565b5f826144a9576144a96143d2565b600160ff1b82145f19841416156144c2576144c2614398565b500590565b5f600160ff1b82016144db576144db614398565b505f039056fe608060405234801561000f575f80fd5b506108fe8061001d5f395ff3fe608060405234801561000f575f80fd5b506004361061009b575f3560e01c80639ba5f52e116100635780639ba5f52e14610110578063b67bee0414610123578063cbe8623f14610136578063e46751e314610149578063f3e4f87c1461015c575f80fd5b80630c9b98811461009f57806312bd6ac0146100c45780632e4c697f146100d757806381e5f7c9146100ea5780638e6f2353146100fd575b5f80fd5b6100b26100ad3660046107a9565b61016f565b60405190815260200160405180910390f35b6100b26100d23660046107c9565b610185565b6100b26100e53660046107a9565b61019b565b6100b26100f83660046107f2565b6101a7565b6100b261010b36600461083f565b6101c1565b6100b261011e3660046107a9565b6101d3565b6100b26101313660046107c9565b6101df565b6100b26101443660046107a9565b6101ec565b6100b261015736600461083f565b6101f8565b6100b261016a3660046107a9565b610203565b5f8061017b848461020f565b9150505b92915050565b5f80610192858585610223565b95945050505050565b5f8061017b8484610246565b5f806101b687878787876102b5565b979650505050505050565b5f806101cc83610355565b9392505050565b5f8061017b8484610583565b5f80610192858585610593565b5f8061017b84846105ae565b5f806101cc836105c2565b5f8061017b8484610754565b5f6101cc8383670de0b6b3a7640000610593565b5f825f190484118302158202610237575f80fd5b50910281810615159190040190565b5f815f0361025d5750670de0b6b3a764000061017f565b825f0361026b57505f61017f565b5f61027583610768565b90505f61028961028486610768565b610355565b90508181026102a0670de0b6b3a76400008261086a565b90506102ab816105c2565b9695505050505050565b5f825f036102c4575084610192565b811561031c576102fb6102d784876108a2565b6102e1858761020f565b6102eb888a61020f565b6102f591906108a2565b90610583565b90505f6103088588610795565b905080821015610316578091505b50610192565b82850361032a57505f610192565b6102ab61033784876108b5565b6103418587610754565b61034b888a61020f565b6102f591906108b5565b5f8082136103765760405163e61b497560e01b815260040160405180910390fd5b506fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff1060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1781811c60ff10600390811b90911782811c600f1060021b1782811c909110600190811b90911782811c90911017609f8181036060019290921b91605f198201906104029084901c610768565b6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b391909102017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b5f6101cc83670de0b6b3a7640000845b5f825f1904841183021582026105a7575f80fd5b5091020490565b5f6101cc83670de0b6b3a764000084610223565b5f680248ce36a70cb26b3e1982136105db57505f919050565b680755bf798b4a1bf1e58212610604576040516373a2d6b160e01b815260040160405180910390fd5b6503782dace9d9604e83901b0591505f60606bb17217f7d1cf79abc9e3b39884821b056001605f1b01901d6bb17217f7d1cf79abc9e3b3988102909303926c240c330e9fb2d9cbaf0fd5aafb1984018402606090811d6d0277594991cfc85f6e2461837cd9018502811d6d1a521255e34f6a5061b25ef1c9c319018502811d6db1bbb201f443cf962f1a1d3db4a5018502811d6e02c72388d9f74f51a9331fed693f1419018502811d6e05180bb14799ab47a8a8cb2a527d57016d02d16720577bd19bf614176fe9ea6c10fe68e7fd37d0007b713f765087018702831d9081019087016d01d3967ed30fc4f89c02bab570811901810290921d6e0587f503bb6ea29d25fcb7401964500186026d360d7aeea093263ecc6e0ecb291760621b0181810595509293509091906102ab74029d9dc38563c32e5c2f6dc192ee70ef65f9978af3860260c38690031c610768565b5f6101cc8383670de0b6b3a7640000610223565b5f6001600160ff1b038211156107915760405163396ea70160e11b815260040160405180910390fd5b5090565b5f8183116107a357826101cc565b50919050565b5f80604083850312156107ba575f80fd5b50508035926020909101359150565b5f805f606084860312156107db575f80fd5b505081359360208301359350604090920135919050565b5f805f805f60a08688031215610806575f80fd5b8535945060208601359350604086013592506060860135915060808601358015158114610831575f80fd5b809150509295509295909350565b5f6020828403121561084f575f80fd5b5035919050565b634e487b7160e01b5f52601160045260245ffd5b5f8261088457634e487b7160e01b5f52601260045260245ffd5b600160ff1b82145f198414161561089d5761089d610856565b500590565b8082018082111561017f5761017f610856565b8181038181111561017f5761017f61085656fea264697066735822122085481551aca817f1c4b98a9539427e5396cfc0ff7e624ddc16440fd8e3316d4764736f6c63430008180033885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12da26469706673582212205efe1aa6b4644cb4fb74587d258d80a68172ca835bb191fa9a30202311bee4bf64736f6c63430008180033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = FixedPointMathTestContractFunctions(fixedpointmathtest_abi, self.w3, address)  # type: ignore
        self.events = FixedPointMathTestContractEvents(fixedpointmathtest_abi, self.w3, address)  # type: ignore

    events: FixedPointMathTestContractEvents

    functions: FixedPointMathTestContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = FixedPointMathTestContractFunctions(
            fixedpointmathtest_abi, w3, None
        )

        return contract
