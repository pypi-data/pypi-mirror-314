"""A web3.py Contract class for the VmSafe contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, NamedTuple, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractFunctions,
)
from web3.types import BlockIdentifier, StateOverride, TxParams

from ..VmSafe import VmSafeTypes as VmSafe

structs = {
    "VmSafe.Wallet": VmSafe.Wallet,
    "VmSafe.EthGetLogs": VmSafe.EthGetLogs,
    "VmSafe.FsMetadata": VmSafe.FsMetadata,
    "VmSafe.Log": VmSafe.Log,
    "VmSafe.DirEntry": VmSafe.DirEntry,
    "VmSafe.Rpc": VmSafe.Rpc,
    "VmSafe.ChainInfo": VmSafe.ChainInfo,
    "VmSafe.StorageAccess": VmSafe.StorageAccess,
    "VmSafe.AccountAccess": VmSafe.AccountAccess,
    "VmSafe.FfiResult": VmSafe.FfiResult,
}

vmsafe_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "accesses",
            "inputs": [
                {"name": "target", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "readSlots",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "writeSlots",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "addr",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {
                    "name": "keyAddr",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertFalse",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertFalse",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertTrue",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertTrue",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assume",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "breakpoint",
            "inputs": [
                {"name": "char", "type": "string", "internalType": "string"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "breakpoint",
            "inputs": [
                {"name": "char", "type": "string", "internalType": "string"},
                {"name": "value", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "broadcast",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "broadcast",
            "inputs": [
                {"name": "signer", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "broadcast",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "closeFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "computeCreate2Address",
            "inputs": [
                {"name": "salt", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "initCodeHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "computeCreate2Address",
            "inputs": [
                {"name": "salt", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "initCodeHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "deployer",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "computeCreateAddress",
            "inputs": [
                {
                    "name": "deployer",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "nonce", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "copyFile",
            "inputs": [
                {"name": "from", "type": "string", "internalType": "string"},
                {"name": "to", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "copied", "type": "uint64", "internalType": "uint64"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "recursive", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createWallet",
            "inputs": [
                {
                    "name": "walletLabel",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createWallet",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createWallet",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "walletLabel",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "derivationPath",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
                {
                    "name": "language",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
                {
                    "name": "language",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "derivationPath",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "envAddress",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envAddress",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBool",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBool",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "value", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "value", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes32",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes32",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envInt",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "int256[]",
                    "internalType": "int256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envInt",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "int256[]",
                    "internalType": "int256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "value", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "value", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes[]",
                    "internalType": "bytes[]",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes",
                    "internalType": "bytes",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "int256",
                    "internalType": "int256",
                },
            ],
            "outputs": [
                {"name": "value", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {"name": "value", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bool[]",
                    "internalType": "bool[]",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envString",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envString",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envUint",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envUint",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "eth_getLogs",
            "inputs": [
                {
                    "name": "fromBlock",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "toBlock",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "topics",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [
                {
                    "name": "logs",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.EthGetLogs[]",
                    "components": [
                        {
                            "name": "emitter",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "topics",
                            "type": "bytes32[]",
                            "internalType": "bytes32[]",
                        },
                        {
                            "name": "data",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "blockHash",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                        {
                            "name": "blockNumber",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "transactionHash",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                        {
                            "name": "transactionIndex",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "logIndex",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "removed",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "exists",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "result", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "ffi",
            "inputs": [
                {
                    "name": "commandInput",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "outputs": [
                {"name": "result", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "fsMetadata",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "metadata",
                    "type": "tuple",
                    "internalType": "struct VmSafe.FsMetadata",
                    "components": [
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "length",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "readOnly",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "modified",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "accessed",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "created",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBlockNumber",
            "inputs": [],
            "outputs": [
                {"name": "height", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBlockTimestamp",
            "inputs": [],
            "outputs": [
                {
                    "name": "timestamp",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getCode",
            "inputs": [
                {
                    "name": "artifactPath",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "creationBytecode",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getDeployedCode",
            "inputs": [
                {
                    "name": "artifactPath",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "runtimeBytecode",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getLabel",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {
                    "name": "currentLabel",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getMappingKeyAndParentOf",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "elementSlot",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "found", "type": "bool", "internalType": "bool"},
                {"name": "key", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "parent",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getMappingLength",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "mappingSlot",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "length", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getMappingSlotAt",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "mappingSlot",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {"name": "idx", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getNonce",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {"name": "nonce", "type": "uint64", "internalType": "uint64"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getNonce",
            "inputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "outputs": [
                {"name": "nonce", "type": "uint64", "internalType": "uint64"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getRecordedLogs",
            "inputs": [],
            "outputs": [
                {
                    "name": "logs",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.Log[]",
                    "components": [
                        {
                            "name": "topics",
                            "type": "bytes32[]",
                            "internalType": "bytes32[]",
                        },
                        {
                            "name": "data",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "emitter",
                            "type": "address",
                            "internalType": "address",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "isDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "result", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "isFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "result", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "keyExists",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "keyExistsJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "keyExistsToml",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "label",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "newLabel",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "load",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "slot", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {"name": "data", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "parseAddress",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseBool",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {"name": "parsedValue", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseBytes",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseBytes32",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "bytes32",
                    "internalType": "bytes32",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseInt",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "int256",
                    "internalType": "int256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonAddress",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonAddressArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBool",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBoolArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytes",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bytes", "internalType": "bytes"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytes32",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytes32Array",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32[]", "internalType": "bytes32[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytesArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonInt",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonIntArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256[]", "internalType": "int256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonKeys",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "keys", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonString",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonStringArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonUint",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonUintArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256[]", "internalType": "uint256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseToml",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseToml",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlAddress",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlAddressArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBool",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBoolArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytes",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bytes", "internalType": "bytes"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytes32",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytes32Array",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32[]", "internalType": "bytes32[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytesArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlInt",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlIntArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256[]", "internalType": "int256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlKeys",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "keys", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlString",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlStringArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlUint",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlUintArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256[]", "internalType": "uint256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseUint",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "pauseGasMetering",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "projectRoot",
            "inputs": [],
            "outputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "maxDepth",
                    "type": "uint64",
                    "internalType": "uint64",
                },
            ],
            "outputs": [
                {
                    "name": "entries",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.DirEntry[]",
                    "components": [
                        {
                            "name": "errorMessage",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "maxDepth",
                    "type": "uint64",
                    "internalType": "uint64",
                },
                {"name": "followLinks", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {
                    "name": "entries",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.DirEntry[]",
                    "components": [
                        {
                            "name": "errorMessage",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "entries",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.DirEntry[]",
                    "components": [
                        {
                            "name": "errorMessage",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "data", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readFileBinary",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readLine",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "line", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readLink",
            "inputs": [
                {"name": "linkPath", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "targetPath",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "record",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "recordLogs",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rememberKey",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {
                    "name": "keyAddr",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "removeDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "recursive", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "removeFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "replace",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"},
                {"name": "from", "type": "string", "internalType": "string"},
                {"name": "to", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "resumeGasMetering",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rpc",
            "inputs": [
                {"name": "method", "type": "string", "internalType": "string"},
                {"name": "params", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rpcUrl",
            "inputs": [
                {"name": "rpcAlias", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "rpcUrlStructs",
            "inputs": [],
            "outputs": [
                {
                    "name": "urls",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.Rpc[]",
                    "components": [
                        {
                            "name": "key",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "url",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "rpcUrls",
            "inputs": [],
            "outputs": [
                {
                    "name": "urls",
                    "type": "string[2][]",
                    "internalType": "string[2][]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "serializeAddress",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeAddress",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBool",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "values", "type": "bool[]", "internalType": "bool[]"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBool",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "bytes[]",
                    "internalType": "bytes[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes32",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes32",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeInt",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeInt",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeJson",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeString",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeString",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeUint",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeUint",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setEnv",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "value", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sign",
            "inputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                },
                {
                    "name": "digest",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "v", "type": "uint8", "internalType": "uint8"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sign",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "digest",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "v", "type": "uint8", "internalType": "uint8"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "signP256",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "digest",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "sleep",
            "inputs": [
                {
                    "name": "duration",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "split",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"},
                {
                    "name": "delimiter",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "outputs",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "startBroadcast",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startBroadcast",
            "inputs": [
                {"name": "signer", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startBroadcast",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startMappingRecording",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startStateDiffRecording",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopAndReturnStateDiff",
            "inputs": [],
            "outputs": [
                {
                    "name": "accountAccesses",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.AccountAccess[]",
                    "components": [
                        {
                            "name": "chainInfo",
                            "type": "tuple",
                            "internalType": "struct VmSafe.ChainInfo",
                            "components": [
                                {
                                    "name": "forkId",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "chainId",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                        {
                            "name": "kind",
                            "type": "uint8",
                            "internalType": "enum VmSafe.AccountAccessKind",
                        },
                        {
                            "name": "account",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accessor",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "initialized",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "oldBalance",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "newBalance",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "deployedCode",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "value",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "data",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "reverted",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "storageAccesses",
                            "type": "tuple[]",
                            "internalType": "struct VmSafe.StorageAccess[]",
                            "components": [
                                {
                                    "name": "account",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "slot",
                                    "type": "bytes32",
                                    "internalType": "bytes32",
                                },
                                {
                                    "name": "isWrite",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                                {
                                    "name": "previousValue",
                                    "type": "bytes32",
                                    "internalType": "bytes32",
                                },
                                {
                                    "name": "newValue",
                                    "type": "bytes32",
                                    "internalType": "bytes32",
                                },
                                {
                                    "name": "reverted",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                            ],
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopBroadcast",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopMappingRecording",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "toBase64",
            "inputs": [
                {"name": "data", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toBase64",
            "inputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toBase64URL",
            "inputs": [
                {"name": "data", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toBase64URL",
            "inputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toLowercase",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "bytes", "internalType": "bytes"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "int256", "internalType": "int256"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toUppercase",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "trim",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "tryFfi",
            "inputs": [
                {
                    "name": "commandInput",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "outputs": [
                {
                    "name": "result",
                    "type": "tuple",
                    "internalType": "struct VmSafe.FfiResult",
                    "components": [
                        {
                            "name": "exitCode",
                            "type": "int32",
                            "internalType": "int32",
                        },
                        {
                            "name": "stdout",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "stderr",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "unixTime",
            "inputs": [],
            "outputs": [
                {
                    "name": "milliseconds",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "data", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeFileBinary",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "data", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeLine",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "data", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeToml",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeToml",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
    ],
)


class VmSafeContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the VmSafe contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class VmSafeAccessesContractFunction0(PypechainContractFunction):
    """ContractFunction for the accesses(str) method."""

    _function_name = "accesses"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Accesses."""

        readSlots: list[bytes]
        writeSlots: list[bytes]

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [list[bytes], list[bytes]]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeAccessesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the accesses method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "accesses"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str) -> VmSafeAccessesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAccessesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAccessesContractFunction0._type_signature: VmSafeAccessesContractFunction0,
        }
        return out


class VmSafeAddrContractFunction0(PypechainContractFunction):
    """ContractFunction for the addr(int) method."""

    _function_name = "addr"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeAddrContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the addr method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "addr"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, privateKey: int) -> VmSafeAddrContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAddrContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAddrContractFunction0._type_signature: VmSafeAddrContractFunction0,
        }
        return out


class VmSafeAssertApproxEqAbsContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int,str) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int,str) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertApproxEqAbs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqAbs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxDelta: int) -> VmSafeAssertApproxEqAbsContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int) -> VmSafeAssertApproxEqAbsContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, error: str) -> VmSafeAssertApproxEqAbsContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, error: str) -> VmSafeAssertApproxEqAbsContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertApproxEqAbsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertApproxEqAbsContractFunction0._type_signature: VmSafeAssertApproxEqAbsContractFunction0,
            VmSafeAssertApproxEqAbsContractFunction1._type_signature: VmSafeAssertApproxEqAbsContractFunction1,
            VmSafeAssertApproxEqAbsContractFunction2._type_signature: VmSafeAssertApproxEqAbsContractFunction2,
            VmSafeAssertApproxEqAbsContractFunction3._type_signature: VmSafeAssertApproxEqAbsContractFunction3,
        }
        return out


class VmSafeAssertApproxEqAbsDecimalContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsDecimalContractFunction1(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsDecimalContractFunction2(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsDecimalContractFunction3(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqAbsDecimalContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the assertApproxEqAbsDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqAbsDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int) -> VmSafeAssertApproxEqAbsDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int) -> VmSafeAssertApproxEqAbsDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int, error: str) -> VmSafeAssertApproxEqAbsDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int, error: str) -> VmSafeAssertApproxEqAbsDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertApproxEqAbsDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertApproxEqAbsDecimalContractFunction0._type_signature: VmSafeAssertApproxEqAbsDecimalContractFunction0,
            VmSafeAssertApproxEqAbsDecimalContractFunction1._type_signature: VmSafeAssertApproxEqAbsDecimalContractFunction1,
            VmSafeAssertApproxEqAbsDecimalContractFunction2._type_signature: VmSafeAssertApproxEqAbsDecimalContractFunction2,
            VmSafeAssertApproxEqAbsDecimalContractFunction3._type_signature: VmSafeAssertApproxEqAbsDecimalContractFunction3,
        }
        return out


class VmSafeAssertApproxEqRelContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int,str) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int,str) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertApproxEqRel method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqRel"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, error: str) -> VmSafeAssertApproxEqRelContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int) -> VmSafeAssertApproxEqRelContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, error: str) -> VmSafeAssertApproxEqRelContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int) -> VmSafeAssertApproxEqRelContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertApproxEqRelContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertApproxEqRelContractFunction0._type_signature: VmSafeAssertApproxEqRelContractFunction0,
            VmSafeAssertApproxEqRelContractFunction1._type_signature: VmSafeAssertApproxEqRelContractFunction1,
            VmSafeAssertApproxEqRelContractFunction2._type_signature: VmSafeAssertApproxEqRelContractFunction2,
            VmSafeAssertApproxEqRelContractFunction3._type_signature: VmSafeAssertApproxEqRelContractFunction3,
        }
        return out


class VmSafeAssertApproxEqRelDecimalContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelDecimalContractFunction1(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelDecimalContractFunction2(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelDecimalContractFunction3(
    PypechainContractFunction
):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertApproxEqRelDecimalContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the assertApproxEqRelDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqRelDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int) -> VmSafeAssertApproxEqRelDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int, error: str) -> VmSafeAssertApproxEqRelDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int) -> VmSafeAssertApproxEqRelDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int, error: str) -> VmSafeAssertApproxEqRelDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertApproxEqRelDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertApproxEqRelDecimalContractFunction0._type_signature: VmSafeAssertApproxEqRelDecimalContractFunction0,
            VmSafeAssertApproxEqRelDecimalContractFunction1._type_signature: VmSafeAssertApproxEqRelDecimalContractFunction1,
            VmSafeAssertApproxEqRelDecimalContractFunction2._type_signature: VmSafeAssertApproxEqRelDecimalContractFunction2,
            VmSafeAssertApproxEqRelDecimalContractFunction3._type_signature: VmSafeAssertApproxEqRelDecimalContractFunction3,
        }
        return out


class VmSafeAssertEqContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction4(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction5(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction6(PypechainContractFunction):
    """ContractFunction for the assertEq(bool,bool,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["bool", "bool", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction7(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction8(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction9(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bool],list[bool]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction10(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction11(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction12(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction13(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction14(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction15(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction16(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction17(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction18(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction19(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction20(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction21(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bool],list[bool],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction22(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction23(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction24(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction25(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction26(PypechainContractFunction):
    """ContractFunction for the assertEq(bool,bool) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["bool", "bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction27(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertEq method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertEq"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmSafeAssertEqContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmSafeAssertEqContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmSafeAssertEqContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmSafeAssertEqContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmSafeAssertEqContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmSafeAssertEqContractFunction5:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool, error: str) -> VmSafeAssertEqContractFunction6:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmSafeAssertEqContractFunction7:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmSafeAssertEqContractFunction8:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool]) -> VmSafeAssertEqContractFunction9:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmSafeAssertEqContractFunction10:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertEqContractFunction11:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmSafeAssertEqContractFunction12:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertEqContractFunction13:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmSafeAssertEqContractFunction14:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmSafeAssertEqContractFunction15:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertEqContractFunction16:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmSafeAssertEqContractFunction17:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmSafeAssertEqContractFunction18:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmSafeAssertEqContractFunction19:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmSafeAssertEqContractFunction20:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool], error: str) -> VmSafeAssertEqContractFunction21:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmSafeAssertEqContractFunction22:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmSafeAssertEqContractFunction23:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmSafeAssertEqContractFunction24:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmSafeAssertEqContractFunction25:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool) -> VmSafeAssertEqContractFunction26:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertEqContractFunction27:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertEqContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertEqContractFunction0._type_signature: VmSafeAssertEqContractFunction0,
            VmSafeAssertEqContractFunction1._type_signature: VmSafeAssertEqContractFunction1,
            VmSafeAssertEqContractFunction2._type_signature: VmSafeAssertEqContractFunction2,
            VmSafeAssertEqContractFunction3._type_signature: VmSafeAssertEqContractFunction3,
            VmSafeAssertEqContractFunction4._type_signature: VmSafeAssertEqContractFunction4,
            VmSafeAssertEqContractFunction5._type_signature: VmSafeAssertEqContractFunction5,
            VmSafeAssertEqContractFunction6._type_signature: VmSafeAssertEqContractFunction6,
            VmSafeAssertEqContractFunction7._type_signature: VmSafeAssertEqContractFunction7,
            VmSafeAssertEqContractFunction8._type_signature: VmSafeAssertEqContractFunction8,
            VmSafeAssertEqContractFunction9._type_signature: VmSafeAssertEqContractFunction9,
            VmSafeAssertEqContractFunction10._type_signature: VmSafeAssertEqContractFunction10,
            VmSafeAssertEqContractFunction11._type_signature: VmSafeAssertEqContractFunction11,
            VmSafeAssertEqContractFunction12._type_signature: VmSafeAssertEqContractFunction12,
            VmSafeAssertEqContractFunction13._type_signature: VmSafeAssertEqContractFunction13,
            VmSafeAssertEqContractFunction14._type_signature: VmSafeAssertEqContractFunction14,
            VmSafeAssertEqContractFunction15._type_signature: VmSafeAssertEqContractFunction15,
            VmSafeAssertEqContractFunction16._type_signature: VmSafeAssertEqContractFunction16,
            VmSafeAssertEqContractFunction17._type_signature: VmSafeAssertEqContractFunction17,
            VmSafeAssertEqContractFunction18._type_signature: VmSafeAssertEqContractFunction18,
            VmSafeAssertEqContractFunction19._type_signature: VmSafeAssertEqContractFunction19,
            VmSafeAssertEqContractFunction20._type_signature: VmSafeAssertEqContractFunction20,
            VmSafeAssertEqContractFunction21._type_signature: VmSafeAssertEqContractFunction21,
            VmSafeAssertEqContractFunction22._type_signature: VmSafeAssertEqContractFunction22,
            VmSafeAssertEqContractFunction23._type_signature: VmSafeAssertEqContractFunction23,
            VmSafeAssertEqContractFunction24._type_signature: VmSafeAssertEqContractFunction24,
            VmSafeAssertEqContractFunction25._type_signature: VmSafeAssertEqContractFunction25,
            VmSafeAssertEqContractFunction26._type_signature: VmSafeAssertEqContractFunction26,
            VmSafeAssertEqContractFunction27._type_signature: VmSafeAssertEqContractFunction27,
        }
        return out


class VmSafeAssertEqDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int,str) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int,str) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertEqDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertEqDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertEqDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertEqDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertEqDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertEqDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertEqDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertEqDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertEqDecimalContractFunction0._type_signature: VmSafeAssertEqDecimalContractFunction0,
            VmSafeAssertEqDecimalContractFunction1._type_signature: VmSafeAssertEqDecimalContractFunction1,
            VmSafeAssertEqDecimalContractFunction2._type_signature: VmSafeAssertEqDecimalContractFunction2,
            VmSafeAssertEqDecimalContractFunction3._type_signature: VmSafeAssertEqDecimalContractFunction3,
        }
        return out


class VmSafeAssertFalseContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertFalse(bool,str) method."""

    _function_name = "assertFalse"
    _type_signature = expand_struct_type_str(tuple(["bool", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertFalseContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertFalse(bool) method."""

    _function_name = "assertFalse"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertFalseContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertFalse method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertFalse"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, condition: bool, error: str) -> VmSafeAssertFalseContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, condition: bool) -> VmSafeAssertFalseContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertFalseContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertFalseContractFunction0._type_signature: VmSafeAssertFalseContractFunction0,
            VmSafeAssertFalseContractFunction1._type_signature: VmSafeAssertFalseContractFunction1,
        }
        return out


class VmSafeAssertGeContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int,str) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int,str) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGe method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGe"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertGeContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertGeContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertGeContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertGeContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertGeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertGeContractFunction0._type_signature: VmSafeAssertGeContractFunction0,
            VmSafeAssertGeContractFunction1._type_signature: VmSafeAssertGeContractFunction1,
            VmSafeAssertGeContractFunction2._type_signature: VmSafeAssertGeContractFunction2,
            VmSafeAssertGeContractFunction3._type_signature: VmSafeAssertGeContractFunction3,
        }
        return out


class VmSafeAssertGeDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int,str) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int,str) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGeDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGeDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGeDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertGeDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertGeDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertGeDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertGeDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertGeDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertGeDecimalContractFunction0._type_signature: VmSafeAssertGeDecimalContractFunction0,
            VmSafeAssertGeDecimalContractFunction1._type_signature: VmSafeAssertGeDecimalContractFunction1,
            VmSafeAssertGeDecimalContractFunction2._type_signature: VmSafeAssertGeDecimalContractFunction2,
            VmSafeAssertGeDecimalContractFunction3._type_signature: VmSafeAssertGeDecimalContractFunction3,
        }
        return out


class VmSafeAssertGtContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int,str) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int,str) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertGtContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertGtContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertGtContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertGtContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertGtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertGtContractFunction0._type_signature: VmSafeAssertGtContractFunction0,
            VmSafeAssertGtContractFunction1._type_signature: VmSafeAssertGtContractFunction1,
            VmSafeAssertGtContractFunction2._type_signature: VmSafeAssertGtContractFunction2,
            VmSafeAssertGtContractFunction3._type_signature: VmSafeAssertGtContractFunction3,
        }
        return out


class VmSafeAssertGtDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int,str) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int,str) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertGtDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGtDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGtDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertGtDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertGtDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertGtDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertGtDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertGtDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertGtDecimalContractFunction0._type_signature: VmSafeAssertGtDecimalContractFunction0,
            VmSafeAssertGtDecimalContractFunction1._type_signature: VmSafeAssertGtDecimalContractFunction1,
            VmSafeAssertGtDecimalContractFunction2._type_signature: VmSafeAssertGtDecimalContractFunction2,
            VmSafeAssertGtDecimalContractFunction3._type_signature: VmSafeAssertGtDecimalContractFunction3,
        }
        return out


class VmSafeAssertLeContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int,str) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int,str) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLe method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLe"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertLeContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertLeContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertLeContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertLeContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertLeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertLeContractFunction0._type_signature: VmSafeAssertLeContractFunction0,
            VmSafeAssertLeContractFunction1._type_signature: VmSafeAssertLeContractFunction1,
            VmSafeAssertLeContractFunction2._type_signature: VmSafeAssertLeContractFunction2,
            VmSafeAssertLeContractFunction3._type_signature: VmSafeAssertLeContractFunction3,
        }
        return out


class VmSafeAssertLeDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int,str) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int,str) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLeDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLeDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLeDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertLeDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertLeDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertLeDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertLeDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertLeDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertLeDecimalContractFunction0._type_signature: VmSafeAssertLeDecimalContractFunction0,
            VmSafeAssertLeDecimalContractFunction1._type_signature: VmSafeAssertLeDecimalContractFunction1,
            VmSafeAssertLeDecimalContractFunction2._type_signature: VmSafeAssertLeDecimalContractFunction2,
            VmSafeAssertLeDecimalContractFunction3._type_signature: VmSafeAssertLeDecimalContractFunction3,
        }
        return out


class VmSafeAssertLtContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int,str) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int,str) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertLtContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertLtContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertLtContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertLtContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertLtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertLtContractFunction0._type_signature: VmSafeAssertLtContractFunction0,
            VmSafeAssertLtContractFunction1._type_signature: VmSafeAssertLtContractFunction1,
            VmSafeAssertLtContractFunction2._type_signature: VmSafeAssertLtContractFunction2,
            VmSafeAssertLtContractFunction3._type_signature: VmSafeAssertLtContractFunction3,
        }
        return out


class VmSafeAssertLtDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int,str) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int,str) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertLtDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLtDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLtDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertLtDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertLtDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertLtDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertLtDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertLtDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertLtDecimalContractFunction0._type_signature: VmSafeAssertLtDecimalContractFunction0,
            VmSafeAssertLtDecimalContractFunction1._type_signature: VmSafeAssertLtDecimalContractFunction1,
            VmSafeAssertLtDecimalContractFunction2._type_signature: VmSafeAssertLtDecimalContractFunction2,
            VmSafeAssertLtDecimalContractFunction3._type_signature: VmSafeAssertLtDecimalContractFunction3,
        }
        return out


class VmSafeAssertNotEqContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bool,bool,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["bool", "bool", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction4(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bool,bool) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["bool", "bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction5(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bool],list[bool]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction6(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction7(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction8(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction9(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction10(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bool],list[bool],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction11(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction12(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction13(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction14(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction15(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction16(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction17(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction18(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction19(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction20(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction21(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction22(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction23(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction24(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction25(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction26(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction27(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertNotEq method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertNotEq"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmSafeAssertNotEqContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmSafeAssertNotEqContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool, error: str) -> VmSafeAssertNotEqContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmSafeAssertNotEqContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool) -> VmSafeAssertNotEqContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool]) -> VmSafeAssertNotEqContractFunction5:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmSafeAssertNotEqContractFunction6:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmSafeAssertNotEqContractFunction7:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertNotEqContractFunction8:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmSafeAssertNotEqContractFunction9:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool], error: str) -> VmSafeAssertNotEqContractFunction10:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmSafeAssertNotEqContractFunction11:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmSafeAssertNotEqContractFunction12:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmSafeAssertNotEqContractFunction13:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmSafeAssertNotEqContractFunction14:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmSafeAssertNotEqContractFunction15:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmSafeAssertNotEqContractFunction16:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmSafeAssertNotEqContractFunction17:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmSafeAssertNotEqContractFunction18:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmSafeAssertNotEqContractFunction19:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmSafeAssertNotEqContractFunction20:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmSafeAssertNotEqContractFunction21:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertNotEqContractFunction22:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmSafeAssertNotEqContractFunction23:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmSafeAssertNotEqContractFunction24:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmSafeAssertNotEqContractFunction25:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmSafeAssertNotEqContractFunction26:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmSafeAssertNotEqContractFunction27:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertNotEqContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertNotEqContractFunction0._type_signature: VmSafeAssertNotEqContractFunction0,
            VmSafeAssertNotEqContractFunction1._type_signature: VmSafeAssertNotEqContractFunction1,
            VmSafeAssertNotEqContractFunction2._type_signature: VmSafeAssertNotEqContractFunction2,
            VmSafeAssertNotEqContractFunction3._type_signature: VmSafeAssertNotEqContractFunction3,
            VmSafeAssertNotEqContractFunction4._type_signature: VmSafeAssertNotEqContractFunction4,
            VmSafeAssertNotEqContractFunction5._type_signature: VmSafeAssertNotEqContractFunction5,
            VmSafeAssertNotEqContractFunction6._type_signature: VmSafeAssertNotEqContractFunction6,
            VmSafeAssertNotEqContractFunction7._type_signature: VmSafeAssertNotEqContractFunction7,
            VmSafeAssertNotEqContractFunction8._type_signature: VmSafeAssertNotEqContractFunction8,
            VmSafeAssertNotEqContractFunction9._type_signature: VmSafeAssertNotEqContractFunction9,
            VmSafeAssertNotEqContractFunction10._type_signature: VmSafeAssertNotEqContractFunction10,
            VmSafeAssertNotEqContractFunction11._type_signature: VmSafeAssertNotEqContractFunction11,
            VmSafeAssertNotEqContractFunction12._type_signature: VmSafeAssertNotEqContractFunction12,
            VmSafeAssertNotEqContractFunction13._type_signature: VmSafeAssertNotEqContractFunction13,
            VmSafeAssertNotEqContractFunction14._type_signature: VmSafeAssertNotEqContractFunction14,
            VmSafeAssertNotEqContractFunction15._type_signature: VmSafeAssertNotEqContractFunction15,
            VmSafeAssertNotEqContractFunction16._type_signature: VmSafeAssertNotEqContractFunction16,
            VmSafeAssertNotEqContractFunction17._type_signature: VmSafeAssertNotEqContractFunction17,
            VmSafeAssertNotEqContractFunction18._type_signature: VmSafeAssertNotEqContractFunction18,
            VmSafeAssertNotEqContractFunction19._type_signature: VmSafeAssertNotEqContractFunction19,
            VmSafeAssertNotEqContractFunction20._type_signature: VmSafeAssertNotEqContractFunction20,
            VmSafeAssertNotEqContractFunction21._type_signature: VmSafeAssertNotEqContractFunction21,
            VmSafeAssertNotEqContractFunction22._type_signature: VmSafeAssertNotEqContractFunction22,
            VmSafeAssertNotEqContractFunction23._type_signature: VmSafeAssertNotEqContractFunction23,
            VmSafeAssertNotEqContractFunction24._type_signature: VmSafeAssertNotEqContractFunction24,
            VmSafeAssertNotEqContractFunction25._type_signature: VmSafeAssertNotEqContractFunction25,
            VmSafeAssertNotEqContractFunction26._type_signature: VmSafeAssertNotEqContractFunction26,
            VmSafeAssertNotEqContractFunction27._type_signature: VmSafeAssertNotEqContractFunction27,
        }
        return out


class VmSafeAssertNotEqDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int,str) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int,str) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertNotEqDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertNotEqDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertNotEqDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertNotEqDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertNotEqDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmSafeAssertNotEqDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmSafeAssertNotEqDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertNotEqDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertNotEqDecimalContractFunction0._type_signature: VmSafeAssertNotEqDecimalContractFunction0,
            VmSafeAssertNotEqDecimalContractFunction1._type_signature: VmSafeAssertNotEqDecimalContractFunction1,
            VmSafeAssertNotEqDecimalContractFunction2._type_signature: VmSafeAssertNotEqDecimalContractFunction2,
            VmSafeAssertNotEqDecimalContractFunction3._type_signature: VmSafeAssertNotEqDecimalContractFunction3,
        }
        return out


class VmSafeAssertTrueContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertTrue(bool) method."""

    _function_name = "assertTrue"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertTrueContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertTrue(bool,str) method."""

    _function_name = "assertTrue"
    _type_signature = expand_struct_type_str(tuple(["bool", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssertTrueContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertTrue method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertTrue"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, condition: bool) -> VmSafeAssertTrueContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, condition: bool, error: str) -> VmSafeAssertTrueContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssertTrueContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssertTrueContractFunction0._type_signature: VmSafeAssertTrueContractFunction0,
            VmSafeAssertTrueContractFunction1._type_signature: VmSafeAssertTrueContractFunction1,
        }
        return out


class VmSafeAssumeContractFunction0(PypechainContractFunction):
    """ContractFunction for the assume(bool) method."""

    _function_name = "assume"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeAssumeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assume method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assume"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, condition: bool) -> VmSafeAssumeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeAssumeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeAssumeContractFunction0._type_signature: VmSafeAssumeContractFunction0,
        }
        return out


class VmSafeBreakpointContractFunction0(PypechainContractFunction):
    """ContractFunction for the breakpoint(str) method."""

    _function_name = "breakpoint"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeBreakpointContractFunction1(PypechainContractFunction):
    """ContractFunction for the breakpoint(str,bool) method."""

    _function_name = "breakpoint"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeBreakpointContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the breakpoint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "breakpoint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, char: str) -> VmSafeBreakpointContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, char: str, value: bool) -> VmSafeBreakpointContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeBreakpointContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeBreakpointContractFunction0._type_signature: VmSafeBreakpointContractFunction0,
            VmSafeBreakpointContractFunction1._type_signature: VmSafeBreakpointContractFunction1,
        }
        return out


class VmSafeBroadcastContractFunction0(PypechainContractFunction):
    """ContractFunction for the broadcast() method."""

    _function_name = "broadcast"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeBroadcastContractFunction1(PypechainContractFunction):
    """ContractFunction for the broadcast(str) method."""

    _function_name = "broadcast"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeBroadcastContractFunction2(PypechainContractFunction):
    """ContractFunction for the broadcast(int) method."""

    _function_name = "broadcast"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeBroadcastContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the broadcast method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "broadcast"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeBroadcastContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, signer: str) -> VmSafeBroadcastContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int) -> VmSafeBroadcastContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeBroadcastContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeBroadcastContractFunction0._type_signature: VmSafeBroadcastContractFunction0,
            VmSafeBroadcastContractFunction1._type_signature: VmSafeBroadcastContractFunction1,
            VmSafeBroadcastContractFunction2._type_signature: VmSafeBroadcastContractFunction2,
        }
        return out


class VmSafeCloseFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the closeFile(str) method."""

    _function_name = "closeFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeCloseFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the closeFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "closeFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeCloseFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeCloseFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeCloseFileContractFunction0._type_signature: VmSafeCloseFileContractFunction0,
        }
        return out


class VmSafeComputeCreate2AddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the computeCreate2Address(bytes,bytes) method."""

    _function_name = "computeCreate2Address"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeComputeCreate2AddressContractFunction1(PypechainContractFunction):
    """ContractFunction for the computeCreate2Address(bytes,bytes,str) method."""

    _function_name = "computeCreate2Address"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeComputeCreate2AddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the computeCreate2Address method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "computeCreate2Address"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, salt: bytes, initCodeHash: bytes) -> VmSafeComputeCreate2AddressContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, salt: bytes, initCodeHash: bytes, deployer: str) -> VmSafeComputeCreate2AddressContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeComputeCreate2AddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeComputeCreate2AddressContractFunction0._type_signature: VmSafeComputeCreate2AddressContractFunction0,
            VmSafeComputeCreate2AddressContractFunction1._type_signature: VmSafeComputeCreate2AddressContractFunction1,
        }
        return out


class VmSafeComputeCreateAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the computeCreateAddress(str,int) method."""

    _function_name = "computeCreateAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeComputeCreateAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the computeCreateAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "computeCreateAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, deployer: str, nonce: int) -> VmSafeComputeCreateAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeComputeCreateAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeComputeCreateAddressContractFunction0._type_signature: VmSafeComputeCreateAddressContractFunction0,
        }
        return out


class VmSafeCopyFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the copyFile(str,str) method."""

    _function_name = "copyFile"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeCopyFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the copyFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "copyFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _from: str, to: str) -> VmSafeCopyFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeCopyFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeCopyFileContractFunction0._type_signature: VmSafeCopyFileContractFunction0,
        }
        return out


class VmSafeCreateDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the createDir(str,bool) method."""

    _function_name = "createDir"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeCreateDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the createDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "createDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, recursive: bool) -> VmSafeCreateDirContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeCreateDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeCreateDirContractFunction0._type_signature: VmSafeCreateDirContractFunction0,
        }
        return out


class VmSafeCreateWalletContractFunction0(PypechainContractFunction):
    """ContractFunction for the createWallet(str) method."""

    _function_name = "createWallet"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.Wallet:
        """returns VmSafe.Wallet."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.Wallet

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.Wallet,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeCreateWalletContractFunction1(PypechainContractFunction):
    """ContractFunction for the createWallet(int) method."""

    _function_name = "createWallet"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.Wallet:
        """returns VmSafe.Wallet."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.Wallet

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.Wallet,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeCreateWalletContractFunction2(PypechainContractFunction):
    """ContractFunction for the createWallet(int,str) method."""

    _function_name = "createWallet"
    _type_signature = expand_struct_type_str(tuple(["int", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.Wallet:
        """returns VmSafe.Wallet."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.Wallet

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.Wallet,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeCreateWalletContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the createWallet method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "createWallet"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, walletLabel: str) -> VmSafeCreateWalletContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int) -> VmSafeCreateWalletContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int, walletLabel: str) -> VmSafeCreateWalletContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeCreateWalletContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeCreateWalletContractFunction0._type_signature: VmSafeCreateWalletContractFunction0,
            VmSafeCreateWalletContractFunction1._type_signature: VmSafeCreateWalletContractFunction1,
            VmSafeCreateWalletContractFunction2._type_signature: VmSafeCreateWalletContractFunction2,
        }
        return out


class VmSafeDeriveKeyContractFunction0(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,str,int,str) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeDeriveKeyContractFunction1(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,int,str) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeDeriveKeyContractFunction2(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,int) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeDeriveKeyContractFunction3(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,str,int) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeDeriveKeyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deriveKey method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deriveKey"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, mnemonic: str, derivationPath: str, index: int, language: str) -> VmSafeDeriveKeyContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, mnemonic: str, index: int, language: str) -> VmSafeDeriveKeyContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, mnemonic: str, index: int) -> VmSafeDeriveKeyContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, mnemonic: str, derivationPath: str, index: int) -> VmSafeDeriveKeyContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeDeriveKeyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeDeriveKeyContractFunction0._type_signature: VmSafeDeriveKeyContractFunction0,
            VmSafeDeriveKeyContractFunction1._type_signature: VmSafeDeriveKeyContractFunction1,
            VmSafeDeriveKeyContractFunction2._type_signature: VmSafeDeriveKeyContractFunction2,
            VmSafeDeriveKeyContractFunction3._type_signature: VmSafeDeriveKeyContractFunction3,
        }
        return out


class VmSafeEnvAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the envAddress(str) method."""

    _function_name = "envAddress"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvAddressContractFunction1(PypechainContractFunction):
    """ContractFunction for the envAddress(str,str) method."""

    _function_name = "envAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmSafeEnvAddressContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmSafeEnvAddressContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvAddressContractFunction0._type_signature: VmSafeEnvAddressContractFunction0,
            VmSafeEnvAddressContractFunction1._type_signature: VmSafeEnvAddressContractFunction1,
        }
        return out


class VmSafeEnvBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the envBool(str) method."""

    _function_name = "envBool"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvBoolContractFunction1(PypechainContractFunction):
    """ContractFunction for the envBool(str,str) method."""

    _function_name = "envBool"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmSafeEnvBoolContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmSafeEnvBoolContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvBoolContractFunction0._type_signature: VmSafeEnvBoolContractFunction0,
            VmSafeEnvBoolContractFunction1._type_signature: VmSafeEnvBoolContractFunction1,
        }
        return out


class VmSafeEnvBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the envBytes(str) method."""

    _function_name = "envBytes"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvBytesContractFunction1(PypechainContractFunction):
    """ContractFunction for the envBytes(str,str) method."""

    _function_name = "envBytes"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeEnvBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmSafeEnvBytesContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmSafeEnvBytesContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvBytesContractFunction0._type_signature: VmSafeEnvBytesContractFunction0,
            VmSafeEnvBytesContractFunction1._type_signature: VmSafeEnvBytesContractFunction1,
        }
        return out


class VmSafeEnvBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the envBytes32(str,str) method."""

    _function_name = "envBytes32"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeEnvBytes32ContractFunction1(PypechainContractFunction):
    """ContractFunction for the envBytes32(str) method."""

    _function_name = "envBytes32"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str) -> VmSafeEnvBytes32ContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str) -> VmSafeEnvBytes32ContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvBytes32ContractFunction0._type_signature: VmSafeEnvBytes32ContractFunction0,
            VmSafeEnvBytes32ContractFunction1._type_signature: VmSafeEnvBytes32ContractFunction1,
        }
        return out


class VmSafeEnvIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the envInt(str,str) method."""

    _function_name = "envInt"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvIntContractFunction1(PypechainContractFunction):
    """ContractFunction for the envInt(str) method."""

    _function_name = "envInt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str) -> VmSafeEnvIntContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str) -> VmSafeEnvIntContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvIntContractFunction0._type_signature: VmSafeEnvIntContractFunction0,
            VmSafeEnvIntContractFunction1._type_signature: VmSafeEnvIntContractFunction1,
        }
        return out


class VmSafeEnvOrContractFunction0(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[bytes]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeEnvOrContractFunction1(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[int]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction2(PypechainContractFunction):
    """ContractFunction for the envOr(str,bool) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction3(PypechainContractFunction):
    """ContractFunction for the envOr(str,str) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction4(PypechainContractFunction):
    """ContractFunction for the envOr(str,int) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction5(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[bytes]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeEnvOrContractFunction6(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[int]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction7(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[str]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction8(PypechainContractFunction):
    """ContractFunction for the envOr(str,bytes) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction9(PypechainContractFunction):
    """ContractFunction for the envOr(str,bytes) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction10(PypechainContractFunction):
    """ContractFunction for the envOr(str,int) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction11(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[str]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction12(PypechainContractFunction):
    """ContractFunction for the envOr(str,str) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction13(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[bool]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bool]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvOrContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envOr method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envOr"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[bytes]) -> VmSafeEnvOrContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[int]) -> VmSafeEnvOrContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: bool) -> VmSafeEnvOrContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: str) -> VmSafeEnvOrContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: int) -> VmSafeEnvOrContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[bytes]) -> VmSafeEnvOrContractFunction5:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[int]) -> VmSafeEnvOrContractFunction6:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[str]) -> VmSafeEnvOrContractFunction7:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: bytes) -> VmSafeEnvOrContractFunction8:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: bytes) -> VmSafeEnvOrContractFunction9:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: int) -> VmSafeEnvOrContractFunction10:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[str]) -> VmSafeEnvOrContractFunction11:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: str) -> VmSafeEnvOrContractFunction12:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[bool]) -> VmSafeEnvOrContractFunction13:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvOrContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvOrContractFunction0._type_signature: VmSafeEnvOrContractFunction0,
            VmSafeEnvOrContractFunction1._type_signature: VmSafeEnvOrContractFunction1,
            VmSafeEnvOrContractFunction2._type_signature: VmSafeEnvOrContractFunction2,
            VmSafeEnvOrContractFunction3._type_signature: VmSafeEnvOrContractFunction3,
            VmSafeEnvOrContractFunction4._type_signature: VmSafeEnvOrContractFunction4,
            VmSafeEnvOrContractFunction5._type_signature: VmSafeEnvOrContractFunction5,
            VmSafeEnvOrContractFunction6._type_signature: VmSafeEnvOrContractFunction6,
            VmSafeEnvOrContractFunction7._type_signature: VmSafeEnvOrContractFunction7,
            VmSafeEnvOrContractFunction8._type_signature: VmSafeEnvOrContractFunction8,
            VmSafeEnvOrContractFunction9._type_signature: VmSafeEnvOrContractFunction9,
            VmSafeEnvOrContractFunction10._type_signature: VmSafeEnvOrContractFunction10,
            VmSafeEnvOrContractFunction11._type_signature: VmSafeEnvOrContractFunction11,
            VmSafeEnvOrContractFunction12._type_signature: VmSafeEnvOrContractFunction12,
            VmSafeEnvOrContractFunction13._type_signature: VmSafeEnvOrContractFunction13,
        }
        return out


class VmSafeEnvStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the envString(str,str) method."""

    _function_name = "envString"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvStringContractFunction1(PypechainContractFunction):
    """ContractFunction for the envString(str) method."""

    _function_name = "envString"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str) -> VmSafeEnvStringContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str) -> VmSafeEnvStringContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvStringContractFunction0._type_signature: VmSafeEnvStringContractFunction0,
            VmSafeEnvStringContractFunction1._type_signature: VmSafeEnvStringContractFunction1,
        }
        return out


class VmSafeEnvUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the envUint(str) method."""

    _function_name = "envUint"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvUintContractFunction1(PypechainContractFunction):
    """ContractFunction for the envUint(str,str) method."""

    _function_name = "envUint"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeEnvUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmSafeEnvUintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmSafeEnvUintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEnvUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEnvUintContractFunction0._type_signature: VmSafeEnvUintContractFunction0,
            VmSafeEnvUintContractFunction1._type_signature: VmSafeEnvUintContractFunction1,
        }
        return out


class VmSafeEth_getLogsContractFunction0(PypechainContractFunction):
    """ContractFunction for the eth_getLogs(int,int,str,list[bytes]) method."""

    _function_name = "eth_getLogs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.EthGetLogs]:
        """returns list[VmSafe.EthGetLogs]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.EthGetLogs]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.EthGetLogs],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeEth_getLogsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the eth_getLogs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "eth_getLogs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, fromBlock: int, toBlock: int, target: str, topics: list[bytes]) -> VmSafeEth_getLogsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeEth_getLogsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeEth_getLogsContractFunction0._type_signature: VmSafeEth_getLogsContractFunction0,
        }
        return out


class VmSafeExistsContractFunction0(PypechainContractFunction):
    """ContractFunction for the exists(str) method."""

    _function_name = "exists"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeExistsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the exists method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "exists"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeExistsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeExistsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeExistsContractFunction0._type_signature: VmSafeExistsContractFunction0,
        }
        return out


class VmSafeFfiContractFunction0(PypechainContractFunction):
    """ContractFunction for the ffi(list[str]) method."""

    _function_name = "ffi"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeFfiContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the ffi method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ffi"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, commandInput: list[str]) -> VmSafeFfiContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeFfiContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeFfiContractFunction0._type_signature: VmSafeFfiContractFunction0,
        }
        return out


class VmSafeFsMetadataContractFunction0(PypechainContractFunction):
    """ContractFunction for the fsMetadata(str) method."""

    _function_name = "fsMetadata"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.FsMetadata:
        """returns VmSafe.FsMetadata."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.FsMetadata

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.FsMetadata,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeFsMetadataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the fsMetadata method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "fsMetadata"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeFsMetadataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeFsMetadataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeFsMetadataContractFunction0._type_signature: VmSafeFsMetadataContractFunction0,
        }
        return out


class VmSafeGetBlockNumberContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBlockNumber() method."""

    _function_name = "getBlockNumber"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetBlockNumberContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBlockNumber method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBlockNumber"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeGetBlockNumberContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetBlockNumberContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetBlockNumberContractFunction0._type_signature: VmSafeGetBlockNumberContractFunction0,
        }
        return out


class VmSafeGetBlockTimestampContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBlockTimestamp() method."""

    _function_name = "getBlockTimestamp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetBlockTimestampContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBlockTimestamp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBlockTimestamp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeGetBlockTimestampContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetBlockTimestampContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetBlockTimestampContractFunction0._type_signature: VmSafeGetBlockTimestampContractFunction0,
        }
        return out


class VmSafeGetCodeContractFunction0(PypechainContractFunction):
    """ContractFunction for the getCode(str) method."""

    _function_name = "getCode"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetCodeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getCode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getCode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, artifactPath: str) -> VmSafeGetCodeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetCodeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetCodeContractFunction0._type_signature: VmSafeGetCodeContractFunction0,
        }
        return out


class VmSafeGetDeployedCodeContractFunction0(PypechainContractFunction):
    """ContractFunction for the getDeployedCode(str) method."""

    _function_name = "getDeployedCode"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetDeployedCodeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getDeployedCode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getDeployedCode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, artifactPath: str) -> VmSafeGetDeployedCodeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetDeployedCodeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetDeployedCodeContractFunction0._type_signature: VmSafeGetDeployedCodeContractFunction0,
        }
        return out


class VmSafeGetLabelContractFunction0(PypechainContractFunction):
    """ContractFunction for the getLabel(str) method."""

    _function_name = "getLabel"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetLabelContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getLabel method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLabel"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> VmSafeGetLabelContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetLabelContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetLabelContractFunction0._type_signature: VmSafeGetLabelContractFunction0,
        }
        return out


class VmSafeGetMappingKeyAndParentOfContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the getMappingKeyAndParentOf(str,bytes) method."""

    _function_name = "getMappingKeyAndParentOf"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for GetMappingKeyAndParentOf."""

        found: bool
        key: bytes
        parent: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [bool, bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetMappingKeyAndParentOfContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the getMappingKeyAndParentOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getMappingKeyAndParentOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, elementSlot: bytes) -> VmSafeGetMappingKeyAndParentOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetMappingKeyAndParentOfContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetMappingKeyAndParentOfContractFunction0._type_signature: VmSafeGetMappingKeyAndParentOfContractFunction0,
        }
        return out


class VmSafeGetMappingLengthContractFunction0(PypechainContractFunction):
    """ContractFunction for the getMappingLength(str,bytes) method."""

    _function_name = "getMappingLength"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetMappingLengthContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getMappingLength method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getMappingLength"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, mappingSlot: bytes) -> VmSafeGetMappingLengthContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetMappingLengthContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetMappingLengthContractFunction0._type_signature: VmSafeGetMappingLengthContractFunction0,
        }
        return out


class VmSafeGetMappingSlotAtContractFunction0(PypechainContractFunction):
    """ContractFunction for the getMappingSlotAt(str,bytes,int) method."""

    _function_name = "getMappingSlotAt"
    _type_signature = expand_struct_type_str(
        tuple(["str", "bytes", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetMappingSlotAtContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getMappingSlotAt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getMappingSlotAt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, mappingSlot: bytes, idx: int) -> VmSafeGetMappingSlotAtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetMappingSlotAtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetMappingSlotAtContractFunction0._type_signature: VmSafeGetMappingSlotAtContractFunction0,
        }
        return out


class VmSafeGetNonceContractFunction0(PypechainContractFunction):
    """ContractFunction for the getNonce(str) method."""

    _function_name = "getNonce"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetNonceContractFunction1(PypechainContractFunction):
    """ContractFunction for the getNonce(VmSafe.Wallet) method."""

    _function_name = "getNonce"
    _type_signature = expand_struct_type_str(tuple(["VmSafe.Wallet"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeGetNonceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getNonce method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getNonce"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> VmSafeGetNonceContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, wallet: VmSafe.Wallet) -> VmSafeGetNonceContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetNonceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetNonceContractFunction0._type_signature: VmSafeGetNonceContractFunction0,
            VmSafeGetNonceContractFunction1._type_signature: VmSafeGetNonceContractFunction1,
        }
        return out


class VmSafeGetRecordedLogsContractFunction0(PypechainContractFunction):
    """ContractFunction for the getRecordedLogs() method."""

    _function_name = "getRecordedLogs"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.Log]:
        """returns list[VmSafe.Log]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.Log]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.Log],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeGetRecordedLogsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getRecordedLogs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRecordedLogs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeGetRecordedLogsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeGetRecordedLogsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeGetRecordedLogsContractFunction0._type_signature: VmSafeGetRecordedLogsContractFunction0,
        }
        return out


class VmSafeIsDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the isDir(str) method."""

    _function_name = "isDir"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeIsDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeIsDirContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeIsDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeIsDirContractFunction0._type_signature: VmSafeIsDirContractFunction0,
        }
        return out


class VmSafeIsFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the isFile(str) method."""

    _function_name = "isFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeIsFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeIsFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeIsFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeIsFileContractFunction0._type_signature: VmSafeIsFileContractFunction0,
        }
        return out


class VmSafeKeyExistsContractFunction0(PypechainContractFunction):
    """ContractFunction for the keyExists(str,str) method."""

    _function_name = "keyExists"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeKeyExistsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the keyExists method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "keyExists"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeKeyExistsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeKeyExistsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeKeyExistsContractFunction0._type_signature: VmSafeKeyExistsContractFunction0,
        }
        return out


class VmSafeKeyExistsJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the keyExistsJson(str,str) method."""

    _function_name = "keyExistsJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeKeyExistsJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the keyExistsJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "keyExistsJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeKeyExistsJsonContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeKeyExistsJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeKeyExistsJsonContractFunction0._type_signature: VmSafeKeyExistsJsonContractFunction0,
        }
        return out


class VmSafeKeyExistsTomlContractFunction0(PypechainContractFunction):
    """ContractFunction for the keyExistsToml(str,str) method."""

    _function_name = "keyExistsToml"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeKeyExistsTomlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the keyExistsToml method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "keyExistsToml"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeKeyExistsTomlContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeKeyExistsTomlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeKeyExistsTomlContractFunction0._type_signature: VmSafeKeyExistsTomlContractFunction0,
        }
        return out


class VmSafeLabelContractFunction0(PypechainContractFunction):
    """ContractFunction for the label(str,str) method."""

    _function_name = "label"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeLabelContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the label method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "label"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str, newLabel: str) -> VmSafeLabelContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeLabelContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeLabelContractFunction0._type_signature: VmSafeLabelContractFunction0,
        }
        return out


class VmSafeLoadContractFunction0(PypechainContractFunction):
    """ContractFunction for the load(str,bytes) method."""

    _function_name = "load"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeLoadContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the load method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "load"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, slot: bytes) -> VmSafeLoadContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeLoadContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeLoadContractFunction0._type_signature: VmSafeLoadContractFunction0,
        }
        return out


class VmSafeParseAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseAddress(str) method."""

    _function_name = "parseAddress"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmSafeParseAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseAddressContractFunction0._type_signature: VmSafeParseAddressContractFunction0,
        }
        return out


class VmSafeParseBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseBool(str) method."""

    _function_name = "parseBool"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmSafeParseBoolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseBoolContractFunction0._type_signature: VmSafeParseBoolContractFunction0,
        }
        return out


class VmSafeParseBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseBytes(str) method."""

    _function_name = "parseBytes"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmSafeParseBytesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseBytesContractFunction0._type_signature: VmSafeParseBytesContractFunction0,
        }
        return out


class VmSafeParseBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseBytes32(str) method."""

    _function_name = "parseBytes32"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmSafeParseBytes32ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseBytes32ContractFunction0._type_signature: VmSafeParseBytes32ContractFunction0,
        }
        return out


class VmSafeParseIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseInt(str) method."""

    _function_name = "parseInt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmSafeParseIntContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseIntContractFunction0._type_signature: VmSafeParseIntContractFunction0,
        }
        return out


class VmSafeParseJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJson(str) method."""

    _function_name = "parseJson"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonContractFunction1(PypechainContractFunction):
    """ContractFunction for the parseJson(str,str) method."""

    _function_name = "parseJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str) -> VmSafeParseJsonContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonContractFunction0._type_signature: VmSafeParseJsonContractFunction0,
            VmSafeParseJsonContractFunction1._type_signature: VmSafeParseJsonContractFunction1,
        }
        return out


class VmSafeParseJsonAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonAddress(str,str) method."""

    _function_name = "parseJsonAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonAddressContractFunction0._type_signature: VmSafeParseJsonAddressContractFunction0,
        }
        return out


class VmSafeParseJsonAddressArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonAddressArray(str,str) method."""

    _function_name = "parseJsonAddressArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonAddressArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonAddressArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonAddressArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonAddressArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonAddressArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonAddressArrayContractFunction0._type_signature: VmSafeParseJsonAddressArrayContractFunction0,
        }
        return out


class VmSafeParseJsonBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBool(str,str) method."""

    _function_name = "parseJsonBool"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonBoolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonBoolContractFunction0._type_signature: VmSafeParseJsonBoolContractFunction0,
        }
        return out


class VmSafeParseJsonBoolArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBoolArray(str,str) method."""

    _function_name = "parseJsonBoolArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonBoolArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBoolArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBoolArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonBoolArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonBoolArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonBoolArrayContractFunction0._type_signature: VmSafeParseJsonBoolArrayContractFunction0,
        }
        return out


class VmSafeParseJsonBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytes(str,str) method."""

    _function_name = "parseJsonBytes"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonBytesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonBytesContractFunction0._type_signature: VmSafeParseJsonBytesContractFunction0,
        }
        return out


class VmSafeParseJsonBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytes32(str,str) method."""

    _function_name = "parseJsonBytes32"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonBytes32ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonBytes32ContractFunction0._type_signature: VmSafeParseJsonBytes32ContractFunction0,
        }
        return out


class VmSafeParseJsonBytes32ArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytes32Array(str,str) method."""

    _function_name = "parseJsonBytes32Array"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeParseJsonBytes32ArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytes32Array method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytes32Array"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonBytes32ArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonBytes32ArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonBytes32ArrayContractFunction0._type_signature: VmSafeParseJsonBytes32ArrayContractFunction0,
        }
        return out


class VmSafeParseJsonBytesArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytesArray(str,str) method."""

    _function_name = "parseJsonBytesArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeParseJsonBytesArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytesArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytesArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonBytesArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonBytesArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonBytesArrayContractFunction0._type_signature: VmSafeParseJsonBytesArrayContractFunction0,
        }
        return out


class VmSafeParseJsonIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonInt(str,str) method."""

    _function_name = "parseJsonInt"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonIntContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonIntContractFunction0._type_signature: VmSafeParseJsonIntContractFunction0,
        }
        return out


class VmSafeParseJsonIntArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonIntArray(str,str) method."""

    _function_name = "parseJsonIntArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonIntArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonIntArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonIntArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonIntArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonIntArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonIntArrayContractFunction0._type_signature: VmSafeParseJsonIntArrayContractFunction0,
        }
        return out


class VmSafeParseJsonKeysContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonKeys(str,str) method."""

    _function_name = "parseJsonKeys"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonKeysContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonKeys method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonKeys"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonKeysContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonKeysContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonKeysContractFunction0._type_signature: VmSafeParseJsonKeysContractFunction0,
        }
        return out


class VmSafeParseJsonStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonString(str,str) method."""

    _function_name = "parseJsonString"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonStringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonStringContractFunction0._type_signature: VmSafeParseJsonStringContractFunction0,
        }
        return out


class VmSafeParseJsonStringArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonStringArray(str,str) method."""

    _function_name = "parseJsonStringArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonStringArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonStringArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonStringArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonStringArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonStringArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonStringArrayContractFunction0._type_signature: VmSafeParseJsonStringArrayContractFunction0,
        }
        return out


class VmSafeParseJsonUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonUint(str,str) method."""

    _function_name = "parseJsonUint"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonUintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonUintContractFunction0._type_signature: VmSafeParseJsonUintContractFunction0,
        }
        return out


class VmSafeParseJsonUintArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonUintArray(str,str) method."""

    _function_name = "parseJsonUintArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseJsonUintArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonUintArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonUintArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmSafeParseJsonUintArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseJsonUintArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseJsonUintArrayContractFunction0._type_signature: VmSafeParseJsonUintArrayContractFunction0,
        }
        return out


class VmSafeParseTomlContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseToml(str,str) method."""

    _function_name = "parseToml"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlContractFunction1(PypechainContractFunction):
    """ContractFunction for the parseToml(str) method."""

    _function_name = "parseToml"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseToml method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseToml"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, toml: str) -> VmSafeParseTomlContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlContractFunction0._type_signature: VmSafeParseTomlContractFunction0,
            VmSafeParseTomlContractFunction1._type_signature: VmSafeParseTomlContractFunction1,
        }
        return out


class VmSafeParseTomlAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlAddress(str,str) method."""

    _function_name = "parseTomlAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlAddressContractFunction0._type_signature: VmSafeParseTomlAddressContractFunction0,
        }
        return out


class VmSafeParseTomlAddressArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlAddressArray(str,str) method."""

    _function_name = "parseTomlAddressArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlAddressArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlAddressArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlAddressArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlAddressArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlAddressArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlAddressArrayContractFunction0._type_signature: VmSafeParseTomlAddressArrayContractFunction0,
        }
        return out


class VmSafeParseTomlBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBool(str,str) method."""

    _function_name = "parseTomlBool"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlBoolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlBoolContractFunction0._type_signature: VmSafeParseTomlBoolContractFunction0,
        }
        return out


class VmSafeParseTomlBoolArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBoolArray(str,str) method."""

    _function_name = "parseTomlBoolArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlBoolArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBoolArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBoolArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlBoolArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlBoolArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlBoolArrayContractFunction0._type_signature: VmSafeParseTomlBoolArrayContractFunction0,
        }
        return out


class VmSafeParseTomlBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytes(str,str) method."""

    _function_name = "parseTomlBytes"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlBytesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlBytesContractFunction0._type_signature: VmSafeParseTomlBytesContractFunction0,
        }
        return out


class VmSafeParseTomlBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytes32(str,str) method."""

    _function_name = "parseTomlBytes32"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlBytes32ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlBytes32ContractFunction0._type_signature: VmSafeParseTomlBytes32ContractFunction0,
        }
        return out


class VmSafeParseTomlBytes32ArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytes32Array(str,str) method."""

    _function_name = "parseTomlBytes32Array"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeParseTomlBytes32ArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytes32Array method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytes32Array"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlBytes32ArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlBytes32ArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlBytes32ArrayContractFunction0._type_signature: VmSafeParseTomlBytes32ArrayContractFunction0,
        }
        return out


class VmSafeParseTomlBytesArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytesArray(str,str) method."""

    _function_name = "parseTomlBytesArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeParseTomlBytesArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytesArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytesArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlBytesArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlBytesArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlBytesArrayContractFunction0._type_signature: VmSafeParseTomlBytesArrayContractFunction0,
        }
        return out


class VmSafeParseTomlIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlInt(str,str) method."""

    _function_name = "parseTomlInt"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlIntContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlIntContractFunction0._type_signature: VmSafeParseTomlIntContractFunction0,
        }
        return out


class VmSafeParseTomlIntArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlIntArray(str,str) method."""

    _function_name = "parseTomlIntArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlIntArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlIntArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlIntArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlIntArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlIntArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlIntArrayContractFunction0._type_signature: VmSafeParseTomlIntArrayContractFunction0,
        }
        return out


class VmSafeParseTomlKeysContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlKeys(str,str) method."""

    _function_name = "parseTomlKeys"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlKeysContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlKeys method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlKeys"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlKeysContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlKeysContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlKeysContractFunction0._type_signature: VmSafeParseTomlKeysContractFunction0,
        }
        return out


class VmSafeParseTomlStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlString(str,str) method."""

    _function_name = "parseTomlString"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlStringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlStringContractFunction0._type_signature: VmSafeParseTomlStringContractFunction0,
        }
        return out


class VmSafeParseTomlStringArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlStringArray(str,str) method."""

    _function_name = "parseTomlStringArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlStringArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlStringArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlStringArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlStringArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlStringArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlStringArrayContractFunction0._type_signature: VmSafeParseTomlStringArrayContractFunction0,
        }
        return out


class VmSafeParseTomlUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlUint(str,str) method."""

    _function_name = "parseTomlUint"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlUintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlUintContractFunction0._type_signature: VmSafeParseTomlUintContractFunction0,
        }
        return out


class VmSafeParseTomlUintArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlUintArray(str,str) method."""

    _function_name = "parseTomlUintArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseTomlUintArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlUintArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlUintArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmSafeParseTomlUintArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseTomlUintArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseTomlUintArrayContractFunction0._type_signature: VmSafeParseTomlUintArrayContractFunction0,
        }
        return out


class VmSafeParseUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseUint(str) method."""

    _function_name = "parseUint"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeParseUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmSafeParseUintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeParseUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeParseUintContractFunction0._type_signature: VmSafeParseUintContractFunction0,
        }
        return out


class VmSafePauseGasMeteringContractFunction0(PypechainContractFunction):
    """ContractFunction for the pauseGasMetering() method."""

    _function_name = "pauseGasMetering"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafePauseGasMeteringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the pauseGasMetering method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "pauseGasMetering"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafePauseGasMeteringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafePauseGasMeteringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafePauseGasMeteringContractFunction0._type_signature: VmSafePauseGasMeteringContractFunction0,
        }
        return out


class VmSafeProjectRootContractFunction0(PypechainContractFunction):
    """ContractFunction for the projectRoot() method."""

    _function_name = "projectRoot"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeProjectRootContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the projectRoot method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "projectRoot"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeProjectRootContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeProjectRootContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeProjectRootContractFunction0._type_signature: VmSafeProjectRootContractFunction0,
        }
        return out


class VmSafeReadDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the readDir(str,int) method."""

    _function_name = "readDir"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.DirEntry]:
        """returns list[VmSafe.DirEntry]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.DirEntry]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.DirEntry],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeReadDirContractFunction1(PypechainContractFunction):
    """ContractFunction for the readDir(str,int,bool) method."""

    _function_name = "readDir"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bool"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.DirEntry]:
        """returns list[VmSafe.DirEntry]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.DirEntry]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.DirEntry],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeReadDirContractFunction2(PypechainContractFunction):
    """ContractFunction for the readDir(str) method."""

    _function_name = "readDir"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.DirEntry]:
        """returns list[VmSafe.DirEntry]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.DirEntry]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.DirEntry],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeReadDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, maxDepth: int) -> VmSafeReadDirContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, path: str, maxDepth: int, followLinks: bool) -> VmSafeReadDirContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, path: str) -> VmSafeReadDirContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeReadDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeReadDirContractFunction0._type_signature: VmSafeReadDirContractFunction0,
            VmSafeReadDirContractFunction1._type_signature: VmSafeReadDirContractFunction1,
            VmSafeReadDirContractFunction2._type_signature: VmSafeReadDirContractFunction2,
        }
        return out


class VmSafeReadFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the readFile(str) method."""

    _function_name = "readFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeReadFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeReadFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeReadFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeReadFileContractFunction0._type_signature: VmSafeReadFileContractFunction0,
        }
        return out


class VmSafeReadFileBinaryContractFunction0(PypechainContractFunction):
    """ContractFunction for the readFileBinary(str) method."""

    _function_name = "readFileBinary"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeReadFileBinaryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readFileBinary method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readFileBinary"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeReadFileBinaryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeReadFileBinaryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeReadFileBinaryContractFunction0._type_signature: VmSafeReadFileBinaryContractFunction0,
        }
        return out


class VmSafeReadLineContractFunction0(PypechainContractFunction):
    """ContractFunction for the readLine(str) method."""

    _function_name = "readLine"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeReadLineContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readLine method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readLine"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeReadLineContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeReadLineContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeReadLineContractFunction0._type_signature: VmSafeReadLineContractFunction0,
        }
        return out


class VmSafeReadLinkContractFunction0(PypechainContractFunction):
    """ContractFunction for the readLink(str) method."""

    _function_name = "readLink"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeReadLinkContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readLink method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readLink"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, linkPath: str) -> VmSafeReadLinkContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeReadLinkContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeReadLinkContractFunction0._type_signature: VmSafeReadLinkContractFunction0,
        }
        return out


class VmSafeRecordContractFunction0(PypechainContractFunction):
    """ContractFunction for the record() method."""

    _function_name = "record"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeRecordContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the record method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "record"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeRecordContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRecordContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRecordContractFunction0._type_signature: VmSafeRecordContractFunction0,
        }
        return out


class VmSafeRecordLogsContractFunction0(PypechainContractFunction):
    """ContractFunction for the recordLogs() method."""

    _function_name = "recordLogs"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeRecordLogsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the recordLogs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "recordLogs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeRecordLogsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRecordLogsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRecordLogsContractFunction0._type_signature: VmSafeRecordLogsContractFunction0,
        }
        return out


class VmSafeRememberKeyContractFunction0(PypechainContractFunction):
    """ContractFunction for the rememberKey(int) method."""

    _function_name = "rememberKey"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeRememberKeyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rememberKey method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rememberKey"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, privateKey: int) -> VmSafeRememberKeyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRememberKeyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRememberKeyContractFunction0._type_signature: VmSafeRememberKeyContractFunction0,
        }
        return out


class VmSafeRemoveDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the removeDir(str,bool) method."""

    _function_name = "removeDir"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeRemoveDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the removeDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "removeDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, recursive: bool) -> VmSafeRemoveDirContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRemoveDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRemoveDirContractFunction0._type_signature: VmSafeRemoveDirContractFunction0,
        }
        return out


class VmSafeRemoveFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the removeFile(str) method."""

    _function_name = "removeFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeRemoveFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the removeFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "removeFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmSafeRemoveFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRemoveFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRemoveFileContractFunction0._type_signature: VmSafeRemoveFileContractFunction0,
        }
        return out


class VmSafeReplaceContractFunction0(PypechainContractFunction):
    """ContractFunction for the replace(str,str,str) method."""

    _function_name = "replace"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeReplaceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the replace method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "replace"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str, _from: str, to: str) -> VmSafeReplaceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeReplaceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeReplaceContractFunction0._type_signature: VmSafeReplaceContractFunction0,
        }
        return out


class VmSafeResumeGasMeteringContractFunction0(PypechainContractFunction):
    """ContractFunction for the resumeGasMetering() method."""

    _function_name = "resumeGasMetering"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeResumeGasMeteringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the resumeGasMetering method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "resumeGasMetering"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeResumeGasMeteringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeResumeGasMeteringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeResumeGasMeteringContractFunction0._type_signature: VmSafeResumeGasMeteringContractFunction0,
        }
        return out


class VmSafeRpcContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpc(str,str) method."""

    _function_name = "rpc"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeRpcContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpc method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpc"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, method: str, params: str) -> VmSafeRpcContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRpcContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRpcContractFunction0._type_signature: VmSafeRpcContractFunction0,
        }
        return out


class VmSafeRpcUrlContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpcUrl(str) method."""

    _function_name = "rpcUrl"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeRpcUrlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpcUrl method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpcUrl"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, rpcAlias: str) -> VmSafeRpcUrlContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRpcUrlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRpcUrlContractFunction0._type_signature: VmSafeRpcUrlContractFunction0,
        }
        return out


class VmSafeRpcUrlStructsContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpcUrlStructs() method."""

    _function_name = "rpcUrlStructs"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.Rpc]:
        """returns list[VmSafe.Rpc]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.Rpc]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.Rpc],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeRpcUrlStructsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpcUrlStructs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpcUrlStructs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeRpcUrlStructsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRpcUrlStructsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRpcUrlStructsContractFunction0._type_signature: VmSafeRpcUrlStructsContractFunction0,
        }
        return out


class VmSafeRpcUrlsContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpcUrls() method."""

    _function_name = "rpcUrls"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[list[str]]:
        """returns list[list[str]]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[list[str]]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[list[str]],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeRpcUrlsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpcUrls method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpcUrls"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeRpcUrlsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeRpcUrlsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeRpcUrlsContractFunction0._type_signature: VmSafeRpcUrlsContractFunction0,
        }
        return out


class VmSafeSerializeAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeAddress(str,str,list[str]) method."""

    _function_name = "serializeAddress"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeAddressContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeAddress(str,str,str) method."""

    _function_name = "serializeAddress"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[str]) -> VmSafeSerializeAddressContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: str) -> VmSafeSerializeAddressContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeAddressContractFunction0._type_signature: VmSafeSerializeAddressContractFunction0,
            VmSafeSerializeAddressContractFunction1._type_signature: VmSafeSerializeAddressContractFunction1,
        }
        return out


class VmSafeSerializeBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeBool(str,str,list[bool]) method."""

    _function_name = "serializeBool"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bool]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeBoolContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeBool(str,str,bool) method."""

    _function_name = "serializeBool"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bool"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[bool]) -> VmSafeSerializeBoolContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: bool) -> VmSafeSerializeBoolContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeBoolContractFunction0._type_signature: VmSafeSerializeBoolContractFunction0,
            VmSafeSerializeBoolContractFunction1._type_signature: VmSafeSerializeBoolContractFunction1,
        }
        return out


class VmSafeSerializeBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeBytes(str,str,list[bytes]) method."""

    _function_name = "serializeBytes"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeBytesContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeBytes(str,str,bytes) method."""

    _function_name = "serializeBytes"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[bytes]) -> VmSafeSerializeBytesContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: bytes) -> VmSafeSerializeBytesContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeBytesContractFunction0._type_signature: VmSafeSerializeBytesContractFunction0,
            VmSafeSerializeBytesContractFunction1._type_signature: VmSafeSerializeBytesContractFunction1,
        }
        return out


class VmSafeSerializeBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeBytes32(str,str,list[bytes]) method."""

    _function_name = "serializeBytes32"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeBytes32ContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeBytes32(str,str,bytes) method."""

    _function_name = "serializeBytes32"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[bytes]) -> VmSafeSerializeBytes32ContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: bytes) -> VmSafeSerializeBytes32ContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeBytes32ContractFunction0._type_signature: VmSafeSerializeBytes32ContractFunction0,
            VmSafeSerializeBytes32ContractFunction1._type_signature: VmSafeSerializeBytes32ContractFunction1,
        }
        return out


class VmSafeSerializeIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeInt(str,str,int) method."""

    _function_name = "serializeInt"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeIntContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeInt(str,str,list[int]) method."""

    _function_name = "serializeInt"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: int) -> VmSafeSerializeIntContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[int]) -> VmSafeSerializeIntContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeIntContractFunction0._type_signature: VmSafeSerializeIntContractFunction0,
            VmSafeSerializeIntContractFunction1._type_signature: VmSafeSerializeIntContractFunction1,
        }
        return out


class VmSafeSerializeJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeJson(str,str) method."""

    _function_name = "serializeJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, value: str) -> VmSafeSerializeJsonContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeJsonContractFunction0._type_signature: VmSafeSerializeJsonContractFunction0,
        }
        return out


class VmSafeSerializeStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeString(str,str,list[str]) method."""

    _function_name = "serializeString"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeStringContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeString(str,str,str) method."""

    _function_name = "serializeString"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[str]) -> VmSafeSerializeStringContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: str) -> VmSafeSerializeStringContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeStringContractFunction0._type_signature: VmSafeSerializeStringContractFunction0,
            VmSafeSerializeStringContractFunction1._type_signature: VmSafeSerializeStringContractFunction1,
        }
        return out


class VmSafeSerializeUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeUint(str,str,int) method."""

    _function_name = "serializeUint"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeUintContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeUint(str,str,list[int]) method."""

    _function_name = "serializeUint"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSerializeUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: int) -> VmSafeSerializeUintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[int]) -> VmSafeSerializeUintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSerializeUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSerializeUintContractFunction0._type_signature: VmSafeSerializeUintContractFunction0,
            VmSafeSerializeUintContractFunction1._type_signature: VmSafeSerializeUintContractFunction1,
        }
        return out


class VmSafeSetEnvContractFunction0(PypechainContractFunction):
    """ContractFunction for the setEnv(str,str) method."""

    _function_name = "setEnv"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeSetEnvContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setEnv method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setEnv"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, value: str) -> VmSafeSetEnvContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSetEnvContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSetEnvContractFunction0._type_signature: VmSafeSetEnvContractFunction0,
        }
        return out


class VmSafeSignContractFunction0(PypechainContractFunction):
    """ContractFunction for the sign(VmSafe.Wallet,bytes) method."""

    _function_name = "sign"
    _type_signature = expand_struct_type_str(
        tuple(["VmSafe.Wallet", "bytes"]), structs
    )
    _error_class = VmSafeContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Sign."""

        v: int
        r: bytes
        s: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSignContractFunction1(PypechainContractFunction):
    """ContractFunction for the sign(int,bytes) method."""

    _function_name = "sign"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Sign."""

        v: int
        r: bytes
        s: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSignContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the sign method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sign"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, wallet: VmSafe.Wallet, digest: bytes) -> VmSafeSignContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int, digest: bytes) -> VmSafeSignContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSignContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSignContractFunction0._type_signature: VmSafeSignContractFunction0,
            VmSafeSignContractFunction1._type_signature: VmSafeSignContractFunction1,
        }
        return out


class VmSafeSignP256ContractFunction0(PypechainContractFunction):
    """ContractFunction for the signP256(int,bytes) method."""

    _function_name = "signP256"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for SignP256."""

        r: bytes
        s: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSignP256ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the signP256 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "signP256"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, privateKey: int, digest: bytes) -> VmSafeSignP256ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSignP256ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSignP256ContractFunction0._type_signature: VmSafeSignP256ContractFunction0,
        }
        return out


class VmSafeSleepContractFunction0(PypechainContractFunction):
    """ContractFunction for the sleep(int) method."""

    _function_name = "sleep"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeSleepContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the sleep method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sleep"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, duration: int) -> VmSafeSleepContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSleepContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSleepContractFunction0._type_signature: VmSafeSleepContractFunction0,
        }
        return out


class VmSafeSplitContractFunction0(PypechainContractFunction):
    """ContractFunction for the split(str,str) method."""

    _function_name = "split"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeSplitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the split method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "split"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str, delimiter: str) -> VmSafeSplitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeSplitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeSplitContractFunction0._type_signature: VmSafeSplitContractFunction0,
        }
        return out


class VmSafeStartBroadcastContractFunction0(PypechainContractFunction):
    """ContractFunction for the startBroadcast() method."""

    _function_name = "startBroadcast"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeStartBroadcastContractFunction1(PypechainContractFunction):
    """ContractFunction for the startBroadcast(str) method."""

    _function_name = "startBroadcast"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeStartBroadcastContractFunction2(PypechainContractFunction):
    """ContractFunction for the startBroadcast(int) method."""

    _function_name = "startBroadcast"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeStartBroadcastContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the startBroadcast method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "startBroadcast"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeStartBroadcastContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, signer: str) -> VmSafeStartBroadcastContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int) -> VmSafeStartBroadcastContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeStartBroadcastContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeStartBroadcastContractFunction0._type_signature: VmSafeStartBroadcastContractFunction0,
            VmSafeStartBroadcastContractFunction1._type_signature: VmSafeStartBroadcastContractFunction1,
            VmSafeStartBroadcastContractFunction2._type_signature: VmSafeStartBroadcastContractFunction2,
        }
        return out


class VmSafeStartMappingRecordingContractFunction0(PypechainContractFunction):
    """ContractFunction for the startMappingRecording() method."""

    _function_name = "startMappingRecording"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeStartMappingRecordingContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the startMappingRecording method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "startMappingRecording"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeStartMappingRecordingContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeStartMappingRecordingContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeStartMappingRecordingContractFunction0._type_signature: VmSafeStartMappingRecordingContractFunction0,
        }
        return out


class VmSafeStartStateDiffRecordingContractFunction0(PypechainContractFunction):
    """ContractFunction for the startStateDiffRecording() method."""

    _function_name = "startStateDiffRecording"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeStartStateDiffRecordingContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the startStateDiffRecording method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "startStateDiffRecording"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeStartStateDiffRecordingContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeStartStateDiffRecordingContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeStartStateDiffRecordingContractFunction0._type_signature: VmSafeStartStateDiffRecordingContractFunction0,
        }
        return out


class VmSafeStopAndReturnStateDiffContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopAndReturnStateDiff() method."""

    _function_name = "stopAndReturnStateDiff"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.AccountAccess]:
        """returns list[VmSafe.AccountAccess]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.AccountAccess]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.AccountAccess],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeStopAndReturnStateDiffContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the stopAndReturnStateDiff method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopAndReturnStateDiff"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeStopAndReturnStateDiffContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeStopAndReturnStateDiffContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeStopAndReturnStateDiffContractFunction0._type_signature: VmSafeStopAndReturnStateDiffContractFunction0,
        }
        return out


class VmSafeStopBroadcastContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopBroadcast() method."""

    _function_name = "stopBroadcast"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeStopBroadcastContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the stopBroadcast method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopBroadcast"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeStopBroadcastContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeStopBroadcastContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeStopBroadcastContractFunction0._type_signature: VmSafeStopBroadcastContractFunction0,
        }
        return out


class VmSafeStopMappingRecordingContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopMappingRecording() method."""

    _function_name = "stopMappingRecording"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeStopMappingRecordingContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the stopMappingRecording method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopMappingRecording"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeStopMappingRecordingContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeStopMappingRecordingContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeStopMappingRecordingContractFunction0._type_signature: VmSafeStopMappingRecordingContractFunction0,
        }
        return out


class VmSafeToBase64ContractFunction0(PypechainContractFunction):
    """ContractFunction for the toBase64(str) method."""

    _function_name = "toBase64"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToBase64ContractFunction1(PypechainContractFunction):
    """ContractFunction for the toBase64(bytes) method."""

    _function_name = "toBase64"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToBase64ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toBase64 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toBase64"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, data: str) -> VmSafeToBase64ContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, data: bytes) -> VmSafeToBase64ContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeToBase64ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeToBase64ContractFunction0._type_signature: VmSafeToBase64ContractFunction0,
            VmSafeToBase64ContractFunction1._type_signature: VmSafeToBase64ContractFunction1,
        }
        return out


class VmSafeToBase64URLContractFunction0(PypechainContractFunction):
    """ContractFunction for the toBase64URL(str) method."""

    _function_name = "toBase64URL"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToBase64URLContractFunction1(PypechainContractFunction):
    """ContractFunction for the toBase64URL(bytes) method."""

    _function_name = "toBase64URL"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToBase64URLContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toBase64URL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toBase64URL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, data: str) -> VmSafeToBase64URLContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, data: bytes) -> VmSafeToBase64URLContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeToBase64URLContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeToBase64URLContractFunction0._type_signature: VmSafeToBase64URLContractFunction0,
            VmSafeToBase64URLContractFunction1._type_signature: VmSafeToBase64URLContractFunction1,
        }
        return out


class VmSafeToLowercaseContractFunction0(PypechainContractFunction):
    """ContractFunction for the toLowercase(str) method."""

    _function_name = "toLowercase"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToLowercaseContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toLowercase method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toLowercase"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str) -> VmSafeToLowercaseContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeToLowercaseContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeToLowercaseContractFunction0._type_signature: VmSafeToLowercaseContractFunction0,
        }
        return out


class VmSafeToStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the toString(str) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToStringContractFunction1(PypechainContractFunction):
    """ContractFunction for the toString(int) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToStringContractFunction2(PypechainContractFunction):
    """ContractFunction for the toString(bytes) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToStringContractFunction3(PypechainContractFunction):
    """ContractFunction for the toString(bool) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToStringContractFunction4(PypechainContractFunction):
    """ContractFunction for the toString(int) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToStringContractFunction5(PypechainContractFunction):
    """ContractFunction for the toString(bytes) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, value: str) -> VmSafeToStringContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, value: int) -> VmSafeToStringContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, value: bytes) -> VmSafeToStringContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, value: bool) -> VmSafeToStringContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, value: int) -> VmSafeToStringContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, value: bytes) -> VmSafeToStringContractFunction5:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeToStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeToStringContractFunction0._type_signature: VmSafeToStringContractFunction0,
            VmSafeToStringContractFunction1._type_signature: VmSafeToStringContractFunction1,
            VmSafeToStringContractFunction2._type_signature: VmSafeToStringContractFunction2,
            VmSafeToStringContractFunction3._type_signature: VmSafeToStringContractFunction3,
            VmSafeToStringContractFunction4._type_signature: VmSafeToStringContractFunction4,
            VmSafeToStringContractFunction5._type_signature: VmSafeToStringContractFunction5,
        }
        return out


class VmSafeToUppercaseContractFunction0(PypechainContractFunction):
    """ContractFunction for the toUppercase(str) method."""

    _function_name = "toUppercase"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeToUppercaseContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toUppercase method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toUppercase"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str) -> VmSafeToUppercaseContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeToUppercaseContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeToUppercaseContractFunction0._type_signature: VmSafeToUppercaseContractFunction0,
        }
        return out


class VmSafeTrimContractFunction0(PypechainContractFunction):
    """ContractFunction for the trim(str) method."""

    _function_name = "trim"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeTrimContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the trim method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "trim"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str) -> VmSafeTrimContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeTrimContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeTrimContractFunction0._type_signature: VmSafeTrimContractFunction0,
        }
        return out


class VmSafeTryFfiContractFunction0(PypechainContractFunction):
    """ContractFunction for the tryFfi(list[str]) method."""

    _function_name = "tryFfi"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.FfiResult:
        """returns VmSafe.FfiResult."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.FfiResult

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.FfiResult,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmSafeTryFfiContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the tryFfi method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "tryFfi"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, commandInput: list[str]) -> VmSafeTryFfiContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeTryFfiContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeTryFfiContractFunction0._type_signature: VmSafeTryFfiContractFunction0,
        }
        return out


class VmSafeUnixTimeContractFunction0(PypechainContractFunction):
    """ContractFunction for the unixTime() method."""

    _function_name = "unixTime"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSafeUnixTimeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the unixTime method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "unixTime"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSafeUnixTimeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeUnixTimeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeUnixTimeContractFunction0._type_signature: VmSafeUnixTimeContractFunction0,
        }
        return out


class VmSafeWriteFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeFile(str,str) method."""

    _function_name = "writeFile"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeWriteFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, data: str) -> VmSafeWriteFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeWriteFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeWriteFileContractFunction0._type_signature: VmSafeWriteFileContractFunction0,
        }
        return out


class VmSafeWriteFileBinaryContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeFileBinary(str,bytes) method."""

    _function_name = "writeFileBinary"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeWriteFileBinaryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeFileBinary method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeFileBinary"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, data: bytes) -> VmSafeWriteFileBinaryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeWriteFileBinaryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeWriteFileBinaryContractFunction0._type_signature: VmSafeWriteFileBinaryContractFunction0,
        }
        return out


class VmSafeWriteJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeJson(str,str,str) method."""

    _function_name = "writeJson"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeWriteJsonContractFunction1(PypechainContractFunction):
    """ContractFunction for the writeJson(str,str) method."""

    _function_name = "writeJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeWriteJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, path: str, valueKey: str) -> VmSafeWriteJsonContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, json: str, path: str) -> VmSafeWriteJsonContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeWriteJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeWriteJsonContractFunction0._type_signature: VmSafeWriteJsonContractFunction0,
            VmSafeWriteJsonContractFunction1._type_signature: VmSafeWriteJsonContractFunction1,
        }
        return out


class VmSafeWriteLineContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeLine(str,str) method."""

    _function_name = "writeLine"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeWriteLineContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeLine method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeLine"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, data: str) -> VmSafeWriteLineContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeWriteLineContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeWriteLineContractFunction0._type_signature: VmSafeWriteLineContractFunction0,
        }
        return out


class VmSafeWriteTomlContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeToml(str,str,str) method."""

    _function_name = "writeToml"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeWriteTomlContractFunction1(PypechainContractFunction):
    """ContractFunction for the writeToml(str,str) method."""

    _function_name = "writeToml"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmSafeContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSafeWriteTomlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeToml method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeToml"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, path: str, valueKey: str) -> VmSafeWriteTomlContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, json: str, path: str) -> VmSafeWriteTomlContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSafeWriteTomlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSafeWriteTomlContractFunction0._type_signature: VmSafeWriteTomlContractFunction0,
            VmSafeWriteTomlContractFunction1._type_signature: VmSafeWriteTomlContractFunction1,
        }
        return out


class VmSafeContractFunctions(ContractFunctions):
    """ContractFunctions for the VmSafe contract."""

    accesses: VmSafeAccessesContractFunction

    addr: VmSafeAddrContractFunction

    assertApproxEqAbs: VmSafeAssertApproxEqAbsContractFunction

    assertApproxEqAbsDecimal: VmSafeAssertApproxEqAbsDecimalContractFunction

    assertApproxEqRel: VmSafeAssertApproxEqRelContractFunction

    assertApproxEqRelDecimal: VmSafeAssertApproxEqRelDecimalContractFunction

    assertEq: VmSafeAssertEqContractFunction

    assertEqDecimal: VmSafeAssertEqDecimalContractFunction

    assertFalse: VmSafeAssertFalseContractFunction

    assertGe: VmSafeAssertGeContractFunction

    assertGeDecimal: VmSafeAssertGeDecimalContractFunction

    assertGt: VmSafeAssertGtContractFunction

    assertGtDecimal: VmSafeAssertGtDecimalContractFunction

    assertLe: VmSafeAssertLeContractFunction

    assertLeDecimal: VmSafeAssertLeDecimalContractFunction

    assertLt: VmSafeAssertLtContractFunction

    assertLtDecimal: VmSafeAssertLtDecimalContractFunction

    assertNotEq: VmSafeAssertNotEqContractFunction

    assertNotEqDecimal: VmSafeAssertNotEqDecimalContractFunction

    assertTrue: VmSafeAssertTrueContractFunction

    assume: VmSafeAssumeContractFunction

    breakpoint: VmSafeBreakpointContractFunction

    broadcast: VmSafeBroadcastContractFunction

    closeFile: VmSafeCloseFileContractFunction

    computeCreate2Address: VmSafeComputeCreate2AddressContractFunction

    computeCreateAddress: VmSafeComputeCreateAddressContractFunction

    copyFile: VmSafeCopyFileContractFunction

    createDir: VmSafeCreateDirContractFunction

    createWallet: VmSafeCreateWalletContractFunction

    deriveKey: VmSafeDeriveKeyContractFunction

    envAddress: VmSafeEnvAddressContractFunction

    envBool: VmSafeEnvBoolContractFunction

    envBytes: VmSafeEnvBytesContractFunction

    envBytes32: VmSafeEnvBytes32ContractFunction

    envInt: VmSafeEnvIntContractFunction

    envOr: VmSafeEnvOrContractFunction

    envString: VmSafeEnvStringContractFunction

    envUint: VmSafeEnvUintContractFunction

    eth_getLogs: VmSafeEth_getLogsContractFunction

    exists: VmSafeExistsContractFunction

    ffi: VmSafeFfiContractFunction

    fsMetadata: VmSafeFsMetadataContractFunction

    getBlockNumber: VmSafeGetBlockNumberContractFunction

    getBlockTimestamp: VmSafeGetBlockTimestampContractFunction

    getCode: VmSafeGetCodeContractFunction

    getDeployedCode: VmSafeGetDeployedCodeContractFunction

    getLabel: VmSafeGetLabelContractFunction

    getMappingKeyAndParentOf: VmSafeGetMappingKeyAndParentOfContractFunction

    getMappingLength: VmSafeGetMappingLengthContractFunction

    getMappingSlotAt: VmSafeGetMappingSlotAtContractFunction

    getNonce: VmSafeGetNonceContractFunction

    getRecordedLogs: VmSafeGetRecordedLogsContractFunction

    isDir: VmSafeIsDirContractFunction

    isFile: VmSafeIsFileContractFunction

    keyExists: VmSafeKeyExistsContractFunction

    keyExistsJson: VmSafeKeyExistsJsonContractFunction

    keyExistsToml: VmSafeKeyExistsTomlContractFunction

    label: VmSafeLabelContractFunction

    load: VmSafeLoadContractFunction

    parseAddress: VmSafeParseAddressContractFunction

    parseBool: VmSafeParseBoolContractFunction

    parseBytes: VmSafeParseBytesContractFunction

    parseBytes32: VmSafeParseBytes32ContractFunction

    parseInt: VmSafeParseIntContractFunction

    parseJson: VmSafeParseJsonContractFunction

    parseJsonAddress: VmSafeParseJsonAddressContractFunction

    parseJsonAddressArray: VmSafeParseJsonAddressArrayContractFunction

    parseJsonBool: VmSafeParseJsonBoolContractFunction

    parseJsonBoolArray: VmSafeParseJsonBoolArrayContractFunction

    parseJsonBytes: VmSafeParseJsonBytesContractFunction

    parseJsonBytes32: VmSafeParseJsonBytes32ContractFunction

    parseJsonBytes32Array: VmSafeParseJsonBytes32ArrayContractFunction

    parseJsonBytesArray: VmSafeParseJsonBytesArrayContractFunction

    parseJsonInt: VmSafeParseJsonIntContractFunction

    parseJsonIntArray: VmSafeParseJsonIntArrayContractFunction

    parseJsonKeys: VmSafeParseJsonKeysContractFunction

    parseJsonString: VmSafeParseJsonStringContractFunction

    parseJsonStringArray: VmSafeParseJsonStringArrayContractFunction

    parseJsonUint: VmSafeParseJsonUintContractFunction

    parseJsonUintArray: VmSafeParseJsonUintArrayContractFunction

    parseToml: VmSafeParseTomlContractFunction

    parseTomlAddress: VmSafeParseTomlAddressContractFunction

    parseTomlAddressArray: VmSafeParseTomlAddressArrayContractFunction

    parseTomlBool: VmSafeParseTomlBoolContractFunction

    parseTomlBoolArray: VmSafeParseTomlBoolArrayContractFunction

    parseTomlBytes: VmSafeParseTomlBytesContractFunction

    parseTomlBytes32: VmSafeParseTomlBytes32ContractFunction

    parseTomlBytes32Array: VmSafeParseTomlBytes32ArrayContractFunction

    parseTomlBytesArray: VmSafeParseTomlBytesArrayContractFunction

    parseTomlInt: VmSafeParseTomlIntContractFunction

    parseTomlIntArray: VmSafeParseTomlIntArrayContractFunction

    parseTomlKeys: VmSafeParseTomlKeysContractFunction

    parseTomlString: VmSafeParseTomlStringContractFunction

    parseTomlStringArray: VmSafeParseTomlStringArrayContractFunction

    parseTomlUint: VmSafeParseTomlUintContractFunction

    parseTomlUintArray: VmSafeParseTomlUintArrayContractFunction

    parseUint: VmSafeParseUintContractFunction

    pauseGasMetering: VmSafePauseGasMeteringContractFunction

    projectRoot: VmSafeProjectRootContractFunction

    readDir: VmSafeReadDirContractFunction

    readFile: VmSafeReadFileContractFunction

    readFileBinary: VmSafeReadFileBinaryContractFunction

    readLine: VmSafeReadLineContractFunction

    readLink: VmSafeReadLinkContractFunction

    record: VmSafeRecordContractFunction

    recordLogs: VmSafeRecordLogsContractFunction

    rememberKey: VmSafeRememberKeyContractFunction

    removeDir: VmSafeRemoveDirContractFunction

    removeFile: VmSafeRemoveFileContractFunction

    replace: VmSafeReplaceContractFunction

    resumeGasMetering: VmSafeResumeGasMeteringContractFunction

    rpc: VmSafeRpcContractFunction

    rpcUrl: VmSafeRpcUrlContractFunction

    rpcUrlStructs: VmSafeRpcUrlStructsContractFunction

    rpcUrls: VmSafeRpcUrlsContractFunction

    serializeAddress: VmSafeSerializeAddressContractFunction

    serializeBool: VmSafeSerializeBoolContractFunction

    serializeBytes: VmSafeSerializeBytesContractFunction

    serializeBytes32: VmSafeSerializeBytes32ContractFunction

    serializeInt: VmSafeSerializeIntContractFunction

    serializeJson: VmSafeSerializeJsonContractFunction

    serializeString: VmSafeSerializeStringContractFunction

    serializeUint: VmSafeSerializeUintContractFunction

    setEnv: VmSafeSetEnvContractFunction

    sign: VmSafeSignContractFunction

    signP256: VmSafeSignP256ContractFunction

    sleep: VmSafeSleepContractFunction

    split: VmSafeSplitContractFunction

    startBroadcast: VmSafeStartBroadcastContractFunction

    startMappingRecording: VmSafeStartMappingRecordingContractFunction

    startStateDiffRecording: VmSafeStartStateDiffRecordingContractFunction

    stopAndReturnStateDiff: VmSafeStopAndReturnStateDiffContractFunction

    stopBroadcast: VmSafeStopBroadcastContractFunction

    stopMappingRecording: VmSafeStopMappingRecordingContractFunction

    toBase64: VmSafeToBase64ContractFunction

    toBase64URL: VmSafeToBase64URLContractFunction

    toLowercase: VmSafeToLowercaseContractFunction

    toString: VmSafeToStringContractFunction

    toUppercase: VmSafeToUppercaseContractFunction

    trim: VmSafeTrimContractFunction

    tryFfi: VmSafeTryFfiContractFunction

    unixTime: VmSafeUnixTimeContractFunction

    writeFile: VmSafeWriteFileContractFunction

    writeFileBinary: VmSafeWriteFileBinaryContractFunction

    writeJson: VmSafeWriteJsonContractFunction

    writeLine: VmSafeWriteLineContractFunction

    writeToml: VmSafeWriteTomlContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.accesses = VmSafeAccessesContractFunction.factory(
            "accesses",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="accesses",
        )
        self.addr = VmSafeAddrContractFunction.factory(
            "addr",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="addr",
        )
        self.assertApproxEqAbs = (
            VmSafeAssertApproxEqAbsContractFunction.factory(
                "assertApproxEqAbs",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="assertApproxEqAbs",
            )
        )
        self.assertApproxEqAbsDecimal = (
            VmSafeAssertApproxEqAbsDecimalContractFunction.factory(
                "assertApproxEqAbsDecimal",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="assertApproxEqAbsDecimal",
            )
        )
        self.assertApproxEqRel = (
            VmSafeAssertApproxEqRelContractFunction.factory(
                "assertApproxEqRel",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="assertApproxEqRel",
            )
        )
        self.assertApproxEqRelDecimal = (
            VmSafeAssertApproxEqRelDecimalContractFunction.factory(
                "assertApproxEqRelDecimal",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="assertApproxEqRelDecimal",
            )
        )
        self.assertEq = VmSafeAssertEqContractFunction.factory(
            "assertEq",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertEq",
        )
        self.assertEqDecimal = VmSafeAssertEqDecimalContractFunction.factory(
            "assertEqDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertEqDecimal",
        )
        self.assertFalse = VmSafeAssertFalseContractFunction.factory(
            "assertFalse",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertFalse",
        )
        self.assertGe = VmSafeAssertGeContractFunction.factory(
            "assertGe",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGe",
        )
        self.assertGeDecimal = VmSafeAssertGeDecimalContractFunction.factory(
            "assertGeDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGeDecimal",
        )
        self.assertGt = VmSafeAssertGtContractFunction.factory(
            "assertGt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGt",
        )
        self.assertGtDecimal = VmSafeAssertGtDecimalContractFunction.factory(
            "assertGtDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGtDecimal",
        )
        self.assertLe = VmSafeAssertLeContractFunction.factory(
            "assertLe",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLe",
        )
        self.assertLeDecimal = VmSafeAssertLeDecimalContractFunction.factory(
            "assertLeDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLeDecimal",
        )
        self.assertLt = VmSafeAssertLtContractFunction.factory(
            "assertLt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLt",
        )
        self.assertLtDecimal = VmSafeAssertLtDecimalContractFunction.factory(
            "assertLtDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLtDecimal",
        )
        self.assertNotEq = VmSafeAssertNotEqContractFunction.factory(
            "assertNotEq",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertNotEq",
        )
        self.assertNotEqDecimal = (
            VmSafeAssertNotEqDecimalContractFunction.factory(
                "assertNotEqDecimal",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="assertNotEqDecimal",
            )
        )
        self.assertTrue = VmSafeAssertTrueContractFunction.factory(
            "assertTrue",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertTrue",
        )
        self.assume = VmSafeAssumeContractFunction.factory(
            "assume",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assume",
        )
        self.breakpoint = VmSafeBreakpointContractFunction.factory(
            "breakpoint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="breakpoint",
        )
        self.broadcast = VmSafeBroadcastContractFunction.factory(
            "broadcast",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="broadcast",
        )
        self.closeFile = VmSafeCloseFileContractFunction.factory(
            "closeFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="closeFile",
        )
        self.computeCreate2Address = (
            VmSafeComputeCreate2AddressContractFunction.factory(
                "computeCreate2Address",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="computeCreate2Address",
            )
        )
        self.computeCreateAddress = (
            VmSafeComputeCreateAddressContractFunction.factory(
                "computeCreateAddress",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="computeCreateAddress",
            )
        )
        self.copyFile = VmSafeCopyFileContractFunction.factory(
            "copyFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="copyFile",
        )
        self.createDir = VmSafeCreateDirContractFunction.factory(
            "createDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="createDir",
        )
        self.createWallet = VmSafeCreateWalletContractFunction.factory(
            "createWallet",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="createWallet",
        )
        self.deriveKey = VmSafeDeriveKeyContractFunction.factory(
            "deriveKey",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deriveKey",
        )
        self.envAddress = VmSafeEnvAddressContractFunction.factory(
            "envAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envAddress",
        )
        self.envBool = VmSafeEnvBoolContractFunction.factory(
            "envBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envBool",
        )
        self.envBytes = VmSafeEnvBytesContractFunction.factory(
            "envBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envBytes",
        )
        self.envBytes32 = VmSafeEnvBytes32ContractFunction.factory(
            "envBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envBytes32",
        )
        self.envInt = VmSafeEnvIntContractFunction.factory(
            "envInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envInt",
        )
        self.envOr = VmSafeEnvOrContractFunction.factory(
            "envOr",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envOr",
        )
        self.envString = VmSafeEnvStringContractFunction.factory(
            "envString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envString",
        )
        self.envUint = VmSafeEnvUintContractFunction.factory(
            "envUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envUint",
        )
        self.eth_getLogs = VmSafeEth_getLogsContractFunction.factory(
            "eth_getLogs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="eth_getLogs",
        )
        self.exists = VmSafeExistsContractFunction.factory(
            "exists",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="exists",
        )
        self.ffi = VmSafeFfiContractFunction.factory(
            "ffi",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="ffi",
        )
        self.fsMetadata = VmSafeFsMetadataContractFunction.factory(
            "fsMetadata",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="fsMetadata",
        )
        self.getBlockNumber = VmSafeGetBlockNumberContractFunction.factory(
            "getBlockNumber",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBlockNumber",
        )
        self.getBlockTimestamp = (
            VmSafeGetBlockTimestampContractFunction.factory(
                "getBlockTimestamp",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getBlockTimestamp",
            )
        )
        self.getCode = VmSafeGetCodeContractFunction.factory(
            "getCode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getCode",
        )
        self.getDeployedCode = VmSafeGetDeployedCodeContractFunction.factory(
            "getDeployedCode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getDeployedCode",
        )
        self.getLabel = VmSafeGetLabelContractFunction.factory(
            "getLabel",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getLabel",
        )
        self.getMappingKeyAndParentOf = (
            VmSafeGetMappingKeyAndParentOfContractFunction.factory(
                "getMappingKeyAndParentOf",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getMappingKeyAndParentOf",
            )
        )
        self.getMappingLength = VmSafeGetMappingLengthContractFunction.factory(
            "getMappingLength",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getMappingLength",
        )
        self.getMappingSlotAt = VmSafeGetMappingSlotAtContractFunction.factory(
            "getMappingSlotAt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getMappingSlotAt",
        )
        self.getNonce = VmSafeGetNonceContractFunction.factory(
            "getNonce",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getNonce",
        )
        self.getRecordedLogs = VmSafeGetRecordedLogsContractFunction.factory(
            "getRecordedLogs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getRecordedLogs",
        )
        self.isDir = VmSafeIsDirContractFunction.factory(
            "isDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isDir",
        )
        self.isFile = VmSafeIsFileContractFunction.factory(
            "isFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isFile",
        )
        self.keyExists = VmSafeKeyExistsContractFunction.factory(
            "keyExists",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="keyExists",
        )
        self.keyExistsJson = VmSafeKeyExistsJsonContractFunction.factory(
            "keyExistsJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="keyExistsJson",
        )
        self.keyExistsToml = VmSafeKeyExistsTomlContractFunction.factory(
            "keyExistsToml",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="keyExistsToml",
        )
        self.label = VmSafeLabelContractFunction.factory(
            "label",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="label",
        )
        self.load = VmSafeLoadContractFunction.factory(
            "load",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="load",
        )
        self.parseAddress = VmSafeParseAddressContractFunction.factory(
            "parseAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseAddress",
        )
        self.parseBool = VmSafeParseBoolContractFunction.factory(
            "parseBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseBool",
        )
        self.parseBytes = VmSafeParseBytesContractFunction.factory(
            "parseBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseBytes",
        )
        self.parseBytes32 = VmSafeParseBytes32ContractFunction.factory(
            "parseBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseBytes32",
        )
        self.parseInt = VmSafeParseIntContractFunction.factory(
            "parseInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseInt",
        )
        self.parseJson = VmSafeParseJsonContractFunction.factory(
            "parseJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJson",
        )
        self.parseJsonAddress = VmSafeParseJsonAddressContractFunction.factory(
            "parseJsonAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonAddress",
        )
        self.parseJsonAddressArray = (
            VmSafeParseJsonAddressArrayContractFunction.factory(
                "parseJsonAddressArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonAddressArray",
            )
        )
        self.parseJsonBool = VmSafeParseJsonBoolContractFunction.factory(
            "parseJsonBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonBool",
        )
        self.parseJsonBoolArray = (
            VmSafeParseJsonBoolArrayContractFunction.factory(
                "parseJsonBoolArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonBoolArray",
            )
        )
        self.parseJsonBytes = VmSafeParseJsonBytesContractFunction.factory(
            "parseJsonBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonBytes",
        )
        self.parseJsonBytes32 = VmSafeParseJsonBytes32ContractFunction.factory(
            "parseJsonBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonBytes32",
        )
        self.parseJsonBytes32Array = (
            VmSafeParseJsonBytes32ArrayContractFunction.factory(
                "parseJsonBytes32Array",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonBytes32Array",
            )
        )
        self.parseJsonBytesArray = (
            VmSafeParseJsonBytesArrayContractFunction.factory(
                "parseJsonBytesArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonBytesArray",
            )
        )
        self.parseJsonInt = VmSafeParseJsonIntContractFunction.factory(
            "parseJsonInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonInt",
        )
        self.parseJsonIntArray = (
            VmSafeParseJsonIntArrayContractFunction.factory(
                "parseJsonIntArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonIntArray",
            )
        )
        self.parseJsonKeys = VmSafeParseJsonKeysContractFunction.factory(
            "parseJsonKeys",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonKeys",
        )
        self.parseJsonString = VmSafeParseJsonStringContractFunction.factory(
            "parseJsonString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonString",
        )
        self.parseJsonStringArray = (
            VmSafeParseJsonStringArrayContractFunction.factory(
                "parseJsonStringArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonStringArray",
            )
        )
        self.parseJsonUint = VmSafeParseJsonUintContractFunction.factory(
            "parseJsonUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonUint",
        )
        self.parseJsonUintArray = (
            VmSafeParseJsonUintArrayContractFunction.factory(
                "parseJsonUintArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonUintArray",
            )
        )
        self.parseToml = VmSafeParseTomlContractFunction.factory(
            "parseToml",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseToml",
        )
        self.parseTomlAddress = VmSafeParseTomlAddressContractFunction.factory(
            "parseTomlAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlAddress",
        )
        self.parseTomlAddressArray = (
            VmSafeParseTomlAddressArrayContractFunction.factory(
                "parseTomlAddressArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlAddressArray",
            )
        )
        self.parseTomlBool = VmSafeParseTomlBoolContractFunction.factory(
            "parseTomlBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlBool",
        )
        self.parseTomlBoolArray = (
            VmSafeParseTomlBoolArrayContractFunction.factory(
                "parseTomlBoolArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlBoolArray",
            )
        )
        self.parseTomlBytes = VmSafeParseTomlBytesContractFunction.factory(
            "parseTomlBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlBytes",
        )
        self.parseTomlBytes32 = VmSafeParseTomlBytes32ContractFunction.factory(
            "parseTomlBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlBytes32",
        )
        self.parseTomlBytes32Array = (
            VmSafeParseTomlBytes32ArrayContractFunction.factory(
                "parseTomlBytes32Array",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlBytes32Array",
            )
        )
        self.parseTomlBytesArray = (
            VmSafeParseTomlBytesArrayContractFunction.factory(
                "parseTomlBytesArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlBytesArray",
            )
        )
        self.parseTomlInt = VmSafeParseTomlIntContractFunction.factory(
            "parseTomlInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlInt",
        )
        self.parseTomlIntArray = (
            VmSafeParseTomlIntArrayContractFunction.factory(
                "parseTomlIntArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlIntArray",
            )
        )
        self.parseTomlKeys = VmSafeParseTomlKeysContractFunction.factory(
            "parseTomlKeys",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlKeys",
        )
        self.parseTomlString = VmSafeParseTomlStringContractFunction.factory(
            "parseTomlString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlString",
        )
        self.parseTomlStringArray = (
            VmSafeParseTomlStringArrayContractFunction.factory(
                "parseTomlStringArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlStringArray",
            )
        )
        self.parseTomlUint = VmSafeParseTomlUintContractFunction.factory(
            "parseTomlUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlUint",
        )
        self.parseTomlUintArray = (
            VmSafeParseTomlUintArrayContractFunction.factory(
                "parseTomlUintArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlUintArray",
            )
        )
        self.parseUint = VmSafeParseUintContractFunction.factory(
            "parseUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseUint",
        )
        self.pauseGasMetering = VmSafePauseGasMeteringContractFunction.factory(
            "pauseGasMetering",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="pauseGasMetering",
        )
        self.projectRoot = VmSafeProjectRootContractFunction.factory(
            "projectRoot",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="projectRoot",
        )
        self.readDir = VmSafeReadDirContractFunction.factory(
            "readDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readDir",
        )
        self.readFile = VmSafeReadFileContractFunction.factory(
            "readFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readFile",
        )
        self.readFileBinary = VmSafeReadFileBinaryContractFunction.factory(
            "readFileBinary",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readFileBinary",
        )
        self.readLine = VmSafeReadLineContractFunction.factory(
            "readLine",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readLine",
        )
        self.readLink = VmSafeReadLinkContractFunction.factory(
            "readLink",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readLink",
        )
        self.record = VmSafeRecordContractFunction.factory(
            "record",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="record",
        )
        self.recordLogs = VmSafeRecordLogsContractFunction.factory(
            "recordLogs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="recordLogs",
        )
        self.rememberKey = VmSafeRememberKeyContractFunction.factory(
            "rememberKey",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rememberKey",
        )
        self.removeDir = VmSafeRemoveDirContractFunction.factory(
            "removeDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="removeDir",
        )
        self.removeFile = VmSafeRemoveFileContractFunction.factory(
            "removeFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="removeFile",
        )
        self.replace = VmSafeReplaceContractFunction.factory(
            "replace",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="replace",
        )
        self.resumeGasMetering = (
            VmSafeResumeGasMeteringContractFunction.factory(
                "resumeGasMetering",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="resumeGasMetering",
            )
        )
        self.rpc = VmSafeRpcContractFunction.factory(
            "rpc",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpc",
        )
        self.rpcUrl = VmSafeRpcUrlContractFunction.factory(
            "rpcUrl",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpcUrl",
        )
        self.rpcUrlStructs = VmSafeRpcUrlStructsContractFunction.factory(
            "rpcUrlStructs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpcUrlStructs",
        )
        self.rpcUrls = VmSafeRpcUrlsContractFunction.factory(
            "rpcUrls",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpcUrls",
        )
        self.serializeAddress = VmSafeSerializeAddressContractFunction.factory(
            "serializeAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeAddress",
        )
        self.serializeBool = VmSafeSerializeBoolContractFunction.factory(
            "serializeBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeBool",
        )
        self.serializeBytes = VmSafeSerializeBytesContractFunction.factory(
            "serializeBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeBytes",
        )
        self.serializeBytes32 = VmSafeSerializeBytes32ContractFunction.factory(
            "serializeBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeBytes32",
        )
        self.serializeInt = VmSafeSerializeIntContractFunction.factory(
            "serializeInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeInt",
        )
        self.serializeJson = VmSafeSerializeJsonContractFunction.factory(
            "serializeJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeJson",
        )
        self.serializeString = VmSafeSerializeStringContractFunction.factory(
            "serializeString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeString",
        )
        self.serializeUint = VmSafeSerializeUintContractFunction.factory(
            "serializeUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeUint",
        )
        self.setEnv = VmSafeSetEnvContractFunction.factory(
            "setEnv",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setEnv",
        )
        self.sign = VmSafeSignContractFunction.factory(
            "sign",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sign",
        )
        self.signP256 = VmSafeSignP256ContractFunction.factory(
            "signP256",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="signP256",
        )
        self.sleep = VmSafeSleepContractFunction.factory(
            "sleep",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sleep",
        )
        self.split = VmSafeSplitContractFunction.factory(
            "split",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="split",
        )
        self.startBroadcast = VmSafeStartBroadcastContractFunction.factory(
            "startBroadcast",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="startBroadcast",
        )
        self.startMappingRecording = (
            VmSafeStartMappingRecordingContractFunction.factory(
                "startMappingRecording",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="startMappingRecording",
            )
        )
        self.startStateDiffRecording = (
            VmSafeStartStateDiffRecordingContractFunction.factory(
                "startStateDiffRecording",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="startStateDiffRecording",
            )
        )
        self.stopAndReturnStateDiff = (
            VmSafeStopAndReturnStateDiffContractFunction.factory(
                "stopAndReturnStateDiff",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="stopAndReturnStateDiff",
            )
        )
        self.stopBroadcast = VmSafeStopBroadcastContractFunction.factory(
            "stopBroadcast",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="stopBroadcast",
        )
        self.stopMappingRecording = (
            VmSafeStopMappingRecordingContractFunction.factory(
                "stopMappingRecording",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="stopMappingRecording",
            )
        )
        self.toBase64 = VmSafeToBase64ContractFunction.factory(
            "toBase64",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toBase64",
        )
        self.toBase64URL = VmSafeToBase64URLContractFunction.factory(
            "toBase64URL",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toBase64URL",
        )
        self.toLowercase = VmSafeToLowercaseContractFunction.factory(
            "toLowercase",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toLowercase",
        )
        self.toString = VmSafeToStringContractFunction.factory(
            "toString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toString",
        )
        self.toUppercase = VmSafeToUppercaseContractFunction.factory(
            "toUppercase",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toUppercase",
        )
        self.trim = VmSafeTrimContractFunction.factory(
            "trim",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="trim",
        )
        self.tryFfi = VmSafeTryFfiContractFunction.factory(
            "tryFfi",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="tryFfi",
        )
        self.unixTime = VmSafeUnixTimeContractFunction.factory(
            "unixTime",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="unixTime",
        )
        self.writeFile = VmSafeWriteFileContractFunction.factory(
            "writeFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeFile",
        )
        self.writeFileBinary = VmSafeWriteFileBinaryContractFunction.factory(
            "writeFileBinary",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeFileBinary",
        )
        self.writeJson = VmSafeWriteJsonContractFunction.factory(
            "writeJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeJson",
        )
        self.writeLine = VmSafeWriteLineContractFunction.factory(
            "writeLine",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeLine",
        )
        self.writeToml = VmSafeWriteTomlContractFunction.factory(
            "writeToml",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeToml",
        )


class VmSafeContract(Contract):
    """A web3.py Contract class for the VmSafe contract."""

    abi: ABI = vmsafe_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = VmSafeContractFunctions(vmsafe_abi, self.w3, address)  # type: ignore

    functions: VmSafeContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = VmSafeContractFunctions(vmsafe_abi, w3, None)

        return contract
