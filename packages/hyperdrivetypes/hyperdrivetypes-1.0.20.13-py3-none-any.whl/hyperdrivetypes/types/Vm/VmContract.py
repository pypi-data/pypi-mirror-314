"""A web3.py Contract class for the Vm contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, NamedTuple, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractFunctions,
)
from web3.types import BlockIdentifier, StateOverride, TxParams

from ..VmSafe import VmSafeTypes as VmSafe

structs = {
    "VmSafe.Wallet": VmSafe.Wallet,
    "VmSafe.EthGetLogs": VmSafe.EthGetLogs,
    "VmSafe.FsMetadata": VmSafe.FsMetadata,
    "VmSafe.Log": VmSafe.Log,
    "VmSafe.DirEntry": VmSafe.DirEntry,
    "VmSafe.Rpc": VmSafe.Rpc,
    "VmSafe.ChainInfo": VmSafe.ChainInfo,
    "VmSafe.StorageAccess": VmSafe.StorageAccess,
    "VmSafe.AccountAccess": VmSafe.AccountAccess,
    "VmSafe.FfiResult": VmSafe.FfiResult,
}

vm_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "accesses",
            "inputs": [
                {"name": "target", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "readSlots",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "writeSlots",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "activeFork",
            "inputs": [],
            "outputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "addr",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {
                    "name": "keyAddr",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "allowCheatcodes",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbs",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqAbsDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRel",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertApproxEqRelDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "maxPercentDelta",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertFalse",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertFalse",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertGtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLe",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLeDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLt",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertLtDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool", "internalType": "bool"},
                {"name": "right", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bool[]", "internalType": "bool[]"},
                {"name": "right", "type": "bool[]", "internalType": "bool[]"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {
                    "name": "right",
                    "type": "address[]",
                    "internalType": "address[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "string", "internalType": "string"},
                {"name": "right", "type": "string", "internalType": "string"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes", "internalType": "bytes"},
                {"name": "right", "type": "bytes", "internalType": "bytes"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {
                    "name": "right",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "address", "internalType": "address"},
                {"name": "right", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes32", "internalType": "bytes32"},
                {"name": "right", "type": "bytes32", "internalType": "bytes32"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {
                    "name": "right",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "string[]",
                    "internalType": "string[]",
                },
                {
                    "name": "right",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {
                    "name": "left",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {
                    "name": "right",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "bytes[]", "internalType": "bytes[]"},
                {"name": "right", "type": "bytes[]", "internalType": "bytes[]"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEq",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "int256", "internalType": "int256"},
                {"name": "right", "type": "int256", "internalType": "int256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertNotEqDecimal",
            "inputs": [
                {"name": "left", "type": "uint256", "internalType": "uint256"},
                {"name": "right", "type": "uint256", "internalType": "uint256"},
                {
                    "name": "decimals",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertTrue",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assertTrue",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"},
                {"name": "error", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "assume",
            "inputs": [
                {"name": "condition", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "breakpoint",
            "inputs": [
                {"name": "char", "type": "string", "internalType": "string"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "breakpoint",
            "inputs": [
                {"name": "char", "type": "string", "internalType": "string"},
                {"name": "value", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "broadcast",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "broadcast",
            "inputs": [
                {"name": "signer", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "broadcast",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "chainId",
            "inputs": [
                {
                    "name": "newChainId",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "clearMockedCalls",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "closeFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "coinbase",
            "inputs": [
                {
                    "name": "newCoinbase",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "computeCreate2Address",
            "inputs": [
                {"name": "salt", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "initCodeHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "computeCreate2Address",
            "inputs": [
                {"name": "salt", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "initCodeHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {
                    "name": "deployer",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "computeCreateAddress",
            "inputs": [
                {
                    "name": "deployer",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "nonce", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "copyFile",
            "inputs": [
                {"name": "from", "type": "string", "internalType": "string"},
                {"name": "to", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "copied", "type": "uint64", "internalType": "uint64"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "recursive", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createFork",
            "inputs": [
                {
                    "name": "urlOrAlias",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createFork",
            "inputs": [
                {
                    "name": "urlOrAlias",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "blockNumber",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createFork",
            "inputs": [
                {
                    "name": "urlOrAlias",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "txHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createSelectFork",
            "inputs": [
                {
                    "name": "urlOrAlias",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "blockNumber",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createSelectFork",
            "inputs": [
                {
                    "name": "urlOrAlias",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "txHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createSelectFork",
            "inputs": [
                {
                    "name": "urlOrAlias",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createWallet",
            "inputs": [
                {
                    "name": "walletLabel",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createWallet",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "createWallet",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "walletLabel",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deal",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "newBalance",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deleteSnapshot",
            "inputs": [
                {
                    "name": "snapshotId",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "success", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deleteSnapshots",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "derivationPath",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
                {
                    "name": "language",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
                {
                    "name": "language",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "deriveKey",
            "inputs": [
                {
                    "name": "mnemonic",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "derivationPath",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "index", "type": "uint32", "internalType": "uint32"},
            ],
            "outputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "difficulty",
            "inputs": [
                {
                    "name": "newDifficulty",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "dumpState",
            "inputs": [
                {
                    "name": "pathToStateJson",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "envAddress",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envAddress",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBool",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBool",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "value", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "value", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes32",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envBytes32",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envInt",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "int256[]",
                    "internalType": "int256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envInt",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "int256[]",
                    "internalType": "int256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bool",
                    "internalType": "bool",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [
                {"name": "value", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [
                {"name": "value", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes[]",
                    "internalType": "bytes[]",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes",
                    "internalType": "bytes",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "int256",
                    "internalType": "int256",
                },
            ],
            "outputs": [
                {"name": "value", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {"name": "value", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envOr",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
                {
                    "name": "defaultValue",
                    "type": "bool[]",
                    "internalType": "bool[]",
                },
            ],
            "outputs": [
                {"name": "value", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envString",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envString",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envUint",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "value", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "envUint",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "delim", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "value",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "etch",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "newRuntimeBytecode",
                    "type": "bytes",
                    "internalType": "bytes",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "eth_getLogs",
            "inputs": [
                {
                    "name": "fromBlock",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "toBlock",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "topics",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [
                {
                    "name": "logs",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.EthGetLogs[]",
                    "components": [
                        {
                            "name": "emitter",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "topics",
                            "type": "bytes32[]",
                            "internalType": "bytes32[]",
                        },
                        {
                            "name": "data",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "blockHash",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                        {
                            "name": "blockNumber",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "transactionHash",
                            "type": "bytes32",
                            "internalType": "bytes32",
                        },
                        {
                            "name": "transactionIndex",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "logIndex",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "removed",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "exists",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "result", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "gas", "type": "uint64", "internalType": "uint64"},
                {"name": "data", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "gas", "type": "uint64", "internalType": "uint64"},
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {"name": "count", "type": "uint64", "internalType": "uint64"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {"name": "count", "type": "uint64", "internalType": "uint64"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {"name": "count", "type": "uint64", "internalType": "uint64"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCallMinGas",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "minGas", "type": "uint64", "internalType": "uint64"},
                {"name": "data", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectCallMinGas",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "minGas", "type": "uint64", "internalType": "uint64"},
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {"name": "count", "type": "uint64", "internalType": "uint64"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectEmit",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectEmit",
            "inputs": [
                {"name": "checkTopic1", "type": "bool", "internalType": "bool"},
                {"name": "checkTopic2", "type": "bool", "internalType": "bool"},
                {"name": "checkTopic3", "type": "bool", "internalType": "bool"},
                {"name": "checkData", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectEmit",
            "inputs": [
                {"name": "checkTopic1", "type": "bool", "internalType": "bool"},
                {"name": "checkTopic2", "type": "bool", "internalType": "bool"},
                {"name": "checkTopic3", "type": "bool", "internalType": "bool"},
                {"name": "checkData", "type": "bool", "internalType": "bool"},
                {
                    "name": "emitter",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectEmit",
            "inputs": [
                {
                    "name": "emitter",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectRevert",
            "inputs": [
                {
                    "name": "revertData",
                    "type": "bytes4",
                    "internalType": "bytes4",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectRevert",
            "inputs": [
                {"name": "revertData", "type": "bytes", "internalType": "bytes"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectRevert",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectSafeMemory",
            "inputs": [
                {"name": "min", "type": "uint64", "internalType": "uint64"},
                {"name": "max", "type": "uint64", "internalType": "uint64"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "expectSafeMemoryCall",
            "inputs": [
                {"name": "min", "type": "uint64", "internalType": "uint64"},
                {"name": "max", "type": "uint64", "internalType": "uint64"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "fee",
            "inputs": [
                {
                    "name": "newBasefee",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "ffi",
            "inputs": [
                {
                    "name": "commandInput",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "outputs": [
                {"name": "result", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "fsMetadata",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "metadata",
                    "type": "tuple",
                    "internalType": "struct VmSafe.FsMetadata",
                    "components": [
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "length",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "readOnly",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "modified",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "accessed",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "created",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBlockNumber",
            "inputs": [],
            "outputs": [
                {"name": "height", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getBlockTimestamp",
            "inputs": [],
            "outputs": [
                {
                    "name": "timestamp",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getCode",
            "inputs": [
                {
                    "name": "artifactPath",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "creationBytecode",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getDeployedCode",
            "inputs": [
                {
                    "name": "artifactPath",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "runtimeBytecode",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getLabel",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {
                    "name": "currentLabel",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getMappingKeyAndParentOf",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "elementSlot",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "found", "type": "bool", "internalType": "bool"},
                {"name": "key", "type": "bytes32", "internalType": "bytes32"},
                {
                    "name": "parent",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getMappingLength",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "mappingSlot",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "length", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getMappingSlotAt",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "mappingSlot",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
                {"name": "idx", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getNonce",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {"name": "nonce", "type": "uint64", "internalType": "uint64"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "getNonce",
            "inputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                }
            ],
            "outputs": [
                {"name": "nonce", "type": "uint64", "internalType": "uint64"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "getRecordedLogs",
            "inputs": [],
            "outputs": [
                {
                    "name": "logs",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.Log[]",
                    "components": [
                        {
                            "name": "topics",
                            "type": "bytes32[]",
                            "internalType": "bytes32[]",
                        },
                        {
                            "name": "data",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "emitter",
                            "type": "address",
                            "internalType": "address",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "isDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "result", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "isFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "result", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "isPersistent",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [
                {"name": "persistent", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "keyExists",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "keyExistsJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "keyExistsToml",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "label",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "newLabel",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "load",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "slot", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {"name": "data", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "loadAllocs",
            "inputs": [
                {
                    "name": "pathToAllocsJson",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "makePersistent",
            "inputs": [
                {
                    "name": "accounts",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "makePersistent",
            "inputs": [
                {
                    "name": "account0",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "account1",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "makePersistent",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "makePersistent",
            "inputs": [
                {
                    "name": "account0",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "account1",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "account2",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mockCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "returnData",
                    "type": "bytes",
                    "internalType": "bytes",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mockCall",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "returnData",
                    "type": "bytes",
                    "internalType": "bytes",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mockCallRevert",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "msgValue",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "revertData",
                    "type": "bytes",
                    "internalType": "bytes",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "mockCallRevert",
            "inputs": [
                {
                    "name": "callee",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "data", "type": "bytes", "internalType": "bytes"},
                {
                    "name": "revertData",
                    "type": "bytes",
                    "internalType": "bytes",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "parseAddress",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseBool",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {"name": "parsedValue", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseBytes",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseBytes32",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "bytes32",
                    "internalType": "bytes32",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseInt",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "int256",
                    "internalType": "int256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonAddress",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonAddressArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBool",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBoolArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytes",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bytes", "internalType": "bytes"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytes32",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytes32Array",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32[]", "internalType": "bytes32[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonBytesArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonInt",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonIntArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256[]", "internalType": "int256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonKeys",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "keys", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonString",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonStringArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonUint",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseJsonUintArray",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256[]", "internalType": "uint256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseToml",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseToml",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "abiEncodedData",
                    "type": "bytes",
                    "internalType": "bytes",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlAddress",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address", "internalType": "address"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlAddressArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "address[]", "internalType": "address[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBool",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBoolArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bool[]", "internalType": "bool[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytes",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [{"name": "", "type": "bytes", "internalType": "bytes"}],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytes32",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32", "internalType": "bytes32"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytes32Array",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes32[]", "internalType": "bytes32[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlBytesArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "bytes[]", "internalType": "bytes[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlInt",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256", "internalType": "int256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlIntArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "int256[]", "internalType": "int256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlKeys",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "keys", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlString",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlStringArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "string[]", "internalType": "string[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlUint",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseTomlUintArray",
            "inputs": [
                {"name": "toml", "type": "string", "internalType": "string"},
                {"name": "key", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "", "type": "uint256[]", "internalType": "uint256[]"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "parseUint",
            "inputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "outputs": [
                {
                    "name": "parsedValue",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "pauseGasMetering",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "prank",
            "inputs": [
                {
                    "name": "msgSender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "txOrigin",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "prank",
            "inputs": [
                {
                    "name": "msgSender",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "prevrandao",
            "inputs": [
                {
                    "name": "newPrevrandao",
                    "type": "bytes32",
                    "internalType": "bytes32",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "projectRoot",
            "inputs": [],
            "outputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readCallers",
            "inputs": [],
            "outputs": [
                {
                    "name": "callerMode",
                    "type": "uint8",
                    "internalType": "enum VmSafe.CallerMode",
                },
                {
                    "name": "msgSender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "txOrigin",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "readDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "maxDepth",
                    "type": "uint64",
                    "internalType": "uint64",
                },
            ],
            "outputs": [
                {
                    "name": "entries",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.DirEntry[]",
                    "components": [
                        {
                            "name": "errorMessage",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "maxDepth",
                    "type": "uint64",
                    "internalType": "uint64",
                },
                {"name": "followLinks", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {
                    "name": "entries",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.DirEntry[]",
                    "components": [
                        {
                            "name": "errorMessage",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "entries",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.DirEntry[]",
                    "components": [
                        {
                            "name": "errorMessage",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "path",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                        {
                            "name": "isDir",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isSymlink",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "data", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readFileBinary",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readLine",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "line", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "readLink",
            "inputs": [
                {"name": "linkPath", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {
                    "name": "targetPath",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "record",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "recordLogs",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rememberKey",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {
                    "name": "keyAddr",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "removeDir",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "recursive", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "removeFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "replace",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"},
                {"name": "from", "type": "string", "internalType": "string"},
                {"name": "to", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "resetNonce",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "resumeGasMetering",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "revertTo",
            "inputs": [
                {
                    "name": "snapshotId",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "success", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "revertToAndDelete",
            "inputs": [
                {
                    "name": "snapshotId",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [
                {"name": "success", "type": "bool", "internalType": "bool"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "revokePersistent",
            "inputs": [
                {
                    "name": "accounts",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "revokePersistent",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "roll",
            "inputs": [
                {
                    "name": "newHeight",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rollFork",
            "inputs": [
                {"name": "txHash", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rollFork",
            "inputs": [
                {
                    "name": "forkId",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "blockNumber",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rollFork",
            "inputs": [
                {
                    "name": "blockNumber",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rollFork",
            "inputs": [
                {
                    "name": "forkId",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "txHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rpc",
            "inputs": [
                {"name": "method", "type": "string", "internalType": "string"},
                {"name": "params", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "rpcUrl",
            "inputs": [
                {"name": "rpcAlias", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "rpcUrlStructs",
            "inputs": [],
            "outputs": [
                {
                    "name": "urls",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.Rpc[]",
                    "components": [
                        {
                            "name": "key",
                            "type": "string",
                            "internalType": "string",
                        },
                        {
                            "name": "url",
                            "type": "string",
                            "internalType": "string",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "rpcUrls",
            "inputs": [],
            "outputs": [
                {
                    "name": "urls",
                    "type": "string[2][]",
                    "internalType": "string[2][]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "selectFork",
            "inputs": [
                {"name": "forkId", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeAddress",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "address[]",
                    "internalType": "address[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeAddress",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBool",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "values", "type": "bool[]", "internalType": "bool[]"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBool",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "bytes[]",
                    "internalType": "bytes[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes32",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "bytes32[]",
                    "internalType": "bytes32[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeBytes32",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeInt",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "int256", "internalType": "int256"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeInt",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "int256[]",
                    "internalType": "int256[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeJson",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeString",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "string[]",
                    "internalType": "string[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeString",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "string", "internalType": "string"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeUint",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "serializeUint",
            "inputs": [
                {
                    "name": "objectKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
                {
                    "name": "values",
                    "type": "uint256[]",
                    "internalType": "uint256[]",
                },
            ],
            "outputs": [
                {"name": "json", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setEnv",
            "inputs": [
                {"name": "name", "type": "string", "internalType": "string"},
                {"name": "value", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setNonce",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "newNonce",
                    "type": "uint64",
                    "internalType": "uint64",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setNonceUnsafe",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "newNonce",
                    "type": "uint64",
                    "internalType": "uint64",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sign",
            "inputs": [
                {
                    "name": "wallet",
                    "type": "tuple",
                    "internalType": "struct VmSafe.Wallet",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "publicKeyX",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "publicKeyY",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "privateKey",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                },
                {
                    "name": "digest",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "v", "type": "uint8", "internalType": "uint8"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sign",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "digest",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "v", "type": "uint8", "internalType": "uint8"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "signP256",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "digest",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "skip",
            "inputs": [
                {"name": "skipTest", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "sleep",
            "inputs": [
                {
                    "name": "duration",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "snapshot",
            "inputs": [],
            "outputs": [
                {
                    "name": "snapshotId",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "split",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"},
                {
                    "name": "delimiter",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [
                {
                    "name": "outputs",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "startBroadcast",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startBroadcast",
            "inputs": [
                {"name": "signer", "type": "address", "internalType": "address"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startBroadcast",
            "inputs": [
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startMappingRecording",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startPrank",
            "inputs": [
                {
                    "name": "msgSender",
                    "type": "address",
                    "internalType": "address",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startPrank",
            "inputs": [
                {
                    "name": "msgSender",
                    "type": "address",
                    "internalType": "address",
                },
                {
                    "name": "txOrigin",
                    "type": "address",
                    "internalType": "address",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "startStateDiffRecording",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopAndReturnStateDiff",
            "inputs": [],
            "outputs": [
                {
                    "name": "accountAccesses",
                    "type": "tuple[]",
                    "internalType": "struct VmSafe.AccountAccess[]",
                    "components": [
                        {
                            "name": "chainInfo",
                            "type": "tuple",
                            "internalType": "struct VmSafe.ChainInfo",
                            "components": [
                                {
                                    "name": "forkId",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "chainId",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                        {
                            "name": "kind",
                            "type": "uint8",
                            "internalType": "enum VmSafe.AccountAccessKind",
                        },
                        {
                            "name": "account",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "accessor",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "initialized",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "oldBalance",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "newBalance",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "deployedCode",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "value",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "data",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "reverted",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "storageAccesses",
                            "type": "tuple[]",
                            "internalType": "struct VmSafe.StorageAccess[]",
                            "components": [
                                {
                                    "name": "account",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "slot",
                                    "type": "bytes32",
                                    "internalType": "bytes32",
                                },
                                {
                                    "name": "isWrite",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                                {
                                    "name": "previousValue",
                                    "type": "bytes32",
                                    "internalType": "bytes32",
                                },
                                {
                                    "name": "newValue",
                                    "type": "bytes32",
                                    "internalType": "bytes32",
                                },
                                {
                                    "name": "reverted",
                                    "type": "bool",
                                    "internalType": "bool",
                                },
                            ],
                        },
                        {
                            "name": "depth",
                            "type": "uint64",
                            "internalType": "uint64",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopBroadcast",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopExpectSafeMemory",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopMappingRecording",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "stopPrank",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "store",
            "inputs": [
                {
                    "name": "target",
                    "type": "address",
                    "internalType": "address",
                },
                {"name": "slot", "type": "bytes32", "internalType": "bytes32"},
                {"name": "value", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "toBase64",
            "inputs": [
                {"name": "data", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toBase64",
            "inputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toBase64URL",
            "inputs": [
                {"name": "data", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toBase64URL",
            "inputs": [
                {"name": "data", "type": "bytes", "internalType": "bytes"}
            ],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toLowercase",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "address", "internalType": "address"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "uint256", "internalType": "uint256"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "bytes", "internalType": "bytes"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "bool", "internalType": "bool"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "int256", "internalType": "int256"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toString",
            "inputs": [
                {"name": "value", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [
                {
                    "name": "stringifiedValue",
                    "type": "string",
                    "internalType": "string",
                }
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "toUppercase",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "transact",
            "inputs": [
                {
                    "name": "forkId",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "txHash",
                    "type": "bytes32",
                    "internalType": "bytes32",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transact",
            "inputs": [
                {"name": "txHash", "type": "bytes32", "internalType": "bytes32"}
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "trim",
            "inputs": [
                {"name": "input", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "output", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "pure",
        },
        {
            "type": "function",
            "name": "tryFfi",
            "inputs": [
                {
                    "name": "commandInput",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "outputs": [
                {
                    "name": "result",
                    "type": "tuple",
                    "internalType": "struct VmSafe.FfiResult",
                    "components": [
                        {
                            "name": "exitCode",
                            "type": "int32",
                            "internalType": "int32",
                        },
                        {
                            "name": "stdout",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "stderr",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "txGasPrice",
            "inputs": [
                {
                    "name": "newGasPrice",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "unixTime",
            "inputs": [],
            "outputs": [
                {
                    "name": "milliseconds",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "warp",
            "inputs": [
                {
                    "name": "newTimestamp",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeFile",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "data", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeFileBinary",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "data", "type": "bytes", "internalType": "bytes"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeJson",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeLine",
            "inputs": [
                {"name": "path", "type": "string", "internalType": "string"},
                {"name": "data", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeToml",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
                {
                    "name": "valueKey",
                    "type": "string",
                    "internalType": "string",
                },
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "writeToml",
            "inputs": [
                {"name": "json", "type": "string", "internalType": "string"},
                {"name": "path", "type": "string", "internalType": "string"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
    ],
)


class VmContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the Vm contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class VmAccessesContractFunction0(PypechainContractFunction):
    """ContractFunction for the accesses(str) method."""

    _function_name = "accesses"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Accesses."""

        readSlots: list[bytes]
        writeSlots: list[bytes]

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [list[bytes], list[bytes]]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmAccessesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the accesses method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "accesses"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str) -> VmAccessesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAccessesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAccessesContractFunction0._type_signature: VmAccessesContractFunction0,
        }
        return out


class VmActiveForkContractFunction0(PypechainContractFunction):
    """ContractFunction for the activeFork() method."""

    _function_name = "activeFork"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmActiveForkContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the activeFork method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "activeFork"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmActiveForkContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmActiveForkContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmActiveForkContractFunction0._type_signature: VmActiveForkContractFunction0,
        }
        return out


class VmAddrContractFunction0(PypechainContractFunction):
    """ContractFunction for the addr(int) method."""

    _function_name = "addr"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmAddrContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the addr method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "addr"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, privateKey: int) -> VmAddrContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAddrContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAddrContractFunction0._type_signature: VmAddrContractFunction0,
        }
        return out


class VmAllowCheatcodesContractFunction0(PypechainContractFunction):
    """ContractFunction for the allowCheatcodes(str) method."""

    _function_name = "allowCheatcodes"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAllowCheatcodesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the allowCheatcodes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "allowCheatcodes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> VmAllowCheatcodesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAllowCheatcodesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAllowCheatcodesContractFunction0._type_signature: VmAllowCheatcodesContractFunction0,
        }
        return out


class VmAssertApproxEqAbsContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int,str) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbs(int,int,int,str) method."""

    _function_name = "assertApproxEqAbs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertApproxEqAbs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqAbs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxDelta: int) -> VmAssertApproxEqAbsContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int) -> VmAssertApproxEqAbsContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, error: str) -> VmAssertApproxEqAbsContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, error: str) -> VmAssertApproxEqAbsContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertApproxEqAbsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertApproxEqAbsContractFunction0._type_signature: VmAssertApproxEqAbsContractFunction0,
            VmAssertApproxEqAbsContractFunction1._type_signature: VmAssertApproxEqAbsContractFunction1,
            VmAssertApproxEqAbsContractFunction2._type_signature: VmAssertApproxEqAbsContractFunction2,
            VmAssertApproxEqAbsContractFunction3._type_signature: VmAssertApproxEqAbsContractFunction3,
        }
        return out


class VmAssertApproxEqAbsDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertApproxEqAbsDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqAbsDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqAbsDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertApproxEqAbsDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqAbsDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int) -> VmAssertApproxEqAbsDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int) -> VmAssertApproxEqAbsDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int, error: str) -> VmAssertApproxEqAbsDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxDelta: int, decimals: int, error: str) -> VmAssertApproxEqAbsDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertApproxEqAbsDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertApproxEqAbsDecimalContractFunction0._type_signature: VmAssertApproxEqAbsDecimalContractFunction0,
            VmAssertApproxEqAbsDecimalContractFunction1._type_signature: VmAssertApproxEqAbsDecimalContractFunction1,
            VmAssertApproxEqAbsDecimalContractFunction2._type_signature: VmAssertApproxEqAbsDecimalContractFunction2,
            VmAssertApproxEqAbsDecimalContractFunction3._type_signature: VmAssertApproxEqAbsDecimalContractFunction3,
        }
        return out


class VmAssertApproxEqRelContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int,str) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int,str) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRel(int,int,int) method."""

    _function_name = "assertApproxEqRel"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertApproxEqRel method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqRel"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, error: str) -> VmAssertApproxEqRelContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int) -> VmAssertApproxEqRelContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, error: str) -> VmAssertApproxEqRelContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int) -> VmAssertApproxEqRelContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertApproxEqRelContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertApproxEqRelContractFunction0._type_signature: VmAssertApproxEqRelContractFunction0,
            VmAssertApproxEqRelContractFunction1._type_signature: VmAssertApproxEqRelContractFunction1,
            VmAssertApproxEqRelContractFunction2._type_signature: VmAssertApproxEqRelContractFunction2,
            VmAssertApproxEqRelContractFunction3._type_signature: VmAssertApproxEqRelContractFunction3,
        }
        return out


class VmAssertApproxEqRelDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertApproxEqRelDecimal(int,int,int,int,str) method."""

    _function_name = "assertApproxEqRelDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertApproxEqRelDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertApproxEqRelDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertApproxEqRelDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int) -> VmAssertApproxEqRelDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int, error: str) -> VmAssertApproxEqRelDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int) -> VmAssertApproxEqRelDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, maxPercentDelta: int, decimals: int, error: str) -> VmAssertApproxEqRelDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertApproxEqRelDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertApproxEqRelDecimalContractFunction0._type_signature: VmAssertApproxEqRelDecimalContractFunction0,
            VmAssertApproxEqRelDecimalContractFunction1._type_signature: VmAssertApproxEqRelDecimalContractFunction1,
            VmAssertApproxEqRelDecimalContractFunction2._type_signature: VmAssertApproxEqRelDecimalContractFunction2,
            VmAssertApproxEqRelDecimalContractFunction3._type_signature: VmAssertApproxEqRelDecimalContractFunction3,
        }
        return out


class VmAssertEqContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction4(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction5(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction6(PypechainContractFunction):
    """ContractFunction for the assertEq(bool,bool,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["bool", "bool", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction7(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction8(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction9(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bool],list[bool]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction10(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction11(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction12(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction13(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction14(PypechainContractFunction):
    """ContractFunction for the assertEq(list[int],list[int]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction15(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction16(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction17(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction18(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction19(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction20(PypechainContractFunction):
    """ContractFunction for the assertEq(bytes,bytes,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction21(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bool],list[bool],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction22(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes]) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction23(PypechainContractFunction):
    """ContractFunction for the assertEq(list[str],list[str],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction24(PypechainContractFunction):
    """ContractFunction for the assertEq(str,str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction25(PypechainContractFunction):
    """ContractFunction for the assertEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction26(PypechainContractFunction):
    """ContractFunction for the assertEq(bool,bool) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["bool", "bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction27(PypechainContractFunction):
    """ContractFunction for the assertEq(int,int) method."""

    _function_name = "assertEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertEq method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertEq"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmAssertEqContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmAssertEqContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmAssertEqContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmAssertEqContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmAssertEqContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmAssertEqContractFunction5:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool, error: str) -> VmAssertEqContractFunction6:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmAssertEqContractFunction7:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmAssertEqContractFunction8:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool]) -> VmAssertEqContractFunction9:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmAssertEqContractFunction10:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertEqContractFunction11:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmAssertEqContractFunction12:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertEqContractFunction13:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmAssertEqContractFunction14:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmAssertEqContractFunction15:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertEqContractFunction16:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmAssertEqContractFunction17:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmAssertEqContractFunction18:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmAssertEqContractFunction19:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmAssertEqContractFunction20:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool], error: str) -> VmAssertEqContractFunction21:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmAssertEqContractFunction22:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmAssertEqContractFunction23:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmAssertEqContractFunction24:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmAssertEqContractFunction25:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool) -> VmAssertEqContractFunction26:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertEqContractFunction27:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertEqContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertEqContractFunction0._type_signature: VmAssertEqContractFunction0,
            VmAssertEqContractFunction1._type_signature: VmAssertEqContractFunction1,
            VmAssertEqContractFunction2._type_signature: VmAssertEqContractFunction2,
            VmAssertEqContractFunction3._type_signature: VmAssertEqContractFunction3,
            VmAssertEqContractFunction4._type_signature: VmAssertEqContractFunction4,
            VmAssertEqContractFunction5._type_signature: VmAssertEqContractFunction5,
            VmAssertEqContractFunction6._type_signature: VmAssertEqContractFunction6,
            VmAssertEqContractFunction7._type_signature: VmAssertEqContractFunction7,
            VmAssertEqContractFunction8._type_signature: VmAssertEqContractFunction8,
            VmAssertEqContractFunction9._type_signature: VmAssertEqContractFunction9,
            VmAssertEqContractFunction10._type_signature: VmAssertEqContractFunction10,
            VmAssertEqContractFunction11._type_signature: VmAssertEqContractFunction11,
            VmAssertEqContractFunction12._type_signature: VmAssertEqContractFunction12,
            VmAssertEqContractFunction13._type_signature: VmAssertEqContractFunction13,
            VmAssertEqContractFunction14._type_signature: VmAssertEqContractFunction14,
            VmAssertEqContractFunction15._type_signature: VmAssertEqContractFunction15,
            VmAssertEqContractFunction16._type_signature: VmAssertEqContractFunction16,
            VmAssertEqContractFunction17._type_signature: VmAssertEqContractFunction17,
            VmAssertEqContractFunction18._type_signature: VmAssertEqContractFunction18,
            VmAssertEqContractFunction19._type_signature: VmAssertEqContractFunction19,
            VmAssertEqContractFunction20._type_signature: VmAssertEqContractFunction20,
            VmAssertEqContractFunction21._type_signature: VmAssertEqContractFunction21,
            VmAssertEqContractFunction22._type_signature: VmAssertEqContractFunction22,
            VmAssertEqContractFunction23._type_signature: VmAssertEqContractFunction23,
            VmAssertEqContractFunction24._type_signature: VmAssertEqContractFunction24,
            VmAssertEqContractFunction25._type_signature: VmAssertEqContractFunction25,
            VmAssertEqContractFunction26._type_signature: VmAssertEqContractFunction26,
            VmAssertEqContractFunction27._type_signature: VmAssertEqContractFunction27,
        }
        return out


class VmAssertEqDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int,str) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertEqDecimal(int,int,int,str) method."""

    _function_name = "assertEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertEqDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertEqDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertEqDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertEqDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertEqDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertEqDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertEqDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertEqDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertEqDecimalContractFunction0._type_signature: VmAssertEqDecimalContractFunction0,
            VmAssertEqDecimalContractFunction1._type_signature: VmAssertEqDecimalContractFunction1,
            VmAssertEqDecimalContractFunction2._type_signature: VmAssertEqDecimalContractFunction2,
            VmAssertEqDecimalContractFunction3._type_signature: VmAssertEqDecimalContractFunction3,
        }
        return out


class VmAssertFalseContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertFalse(bool,str) method."""

    _function_name = "assertFalse"
    _type_signature = expand_struct_type_str(tuple(["bool", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertFalseContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertFalse(bool) method."""

    _function_name = "assertFalse"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertFalseContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertFalse method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertFalse"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, condition: bool, error: str) -> VmAssertFalseContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, condition: bool) -> VmAssertFalseContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertFalseContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertFalseContractFunction0._type_signature: VmAssertFalseContractFunction0,
            VmAssertFalseContractFunction1._type_signature: VmAssertFalseContractFunction1,
        }
        return out


class VmAssertGeContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int,str) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGe(int,int,str) method."""

    _function_name = "assertGe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGe method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGe"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int) -> VmAssertGeContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertGeContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertGeContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertGeContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertGeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertGeContractFunction0._type_signature: VmAssertGeContractFunction0,
            VmAssertGeContractFunction1._type_signature: VmAssertGeContractFunction1,
            VmAssertGeContractFunction2._type_signature: VmAssertGeContractFunction2,
            VmAssertGeContractFunction3._type_signature: VmAssertGeContractFunction3,
        }
        return out


class VmAssertGeDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int,str) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int,str) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGeDecimal(int,int,int) method."""

    _function_name = "assertGeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGeDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGeDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGeDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertGeDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertGeDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertGeDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertGeDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertGeDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertGeDecimalContractFunction0._type_signature: VmAssertGeDecimalContractFunction0,
            VmAssertGeDecimalContractFunction1._type_signature: VmAssertGeDecimalContractFunction1,
            VmAssertGeDecimalContractFunction2._type_signature: VmAssertGeDecimalContractFunction2,
            VmAssertGeDecimalContractFunction3._type_signature: VmAssertGeDecimalContractFunction3,
        }
        return out


class VmAssertGtContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int,str) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGt(int,int,str) method."""

    _function_name = "assertGt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int) -> VmAssertGtContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertGtContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertGtContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertGtContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertGtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertGtContractFunction0._type_signature: VmAssertGtContractFunction0,
            VmAssertGtContractFunction1._type_signature: VmAssertGtContractFunction1,
            VmAssertGtContractFunction2._type_signature: VmAssertGtContractFunction2,
            VmAssertGtContractFunction3._type_signature: VmAssertGtContractFunction3,
        }
        return out


class VmAssertGtDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int,str) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int,str) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertGtDecimal(int,int,int) method."""

    _function_name = "assertGtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertGtDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertGtDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertGtDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertGtDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertGtDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertGtDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertGtDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertGtDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertGtDecimalContractFunction0._type_signature: VmAssertGtDecimalContractFunction0,
            VmAssertGtDecimalContractFunction1._type_signature: VmAssertGtDecimalContractFunction1,
            VmAssertGtDecimalContractFunction2._type_signature: VmAssertGtDecimalContractFunction2,
            VmAssertGtDecimalContractFunction3._type_signature: VmAssertGtDecimalContractFunction3,
        }
        return out


class VmAssertLeContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int,str) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLe(int,int,str) method."""

    _function_name = "assertLe"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLe method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLe"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertLeContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertLeContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertLeContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertLeContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertLeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertLeContractFunction0._type_signature: VmAssertLeContractFunction0,
            VmAssertLeContractFunction1._type_signature: VmAssertLeContractFunction1,
            VmAssertLeContractFunction2._type_signature: VmAssertLeContractFunction2,
            VmAssertLeContractFunction3._type_signature: VmAssertLeContractFunction3,
        }
        return out


class VmAssertLeDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int,str) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int,str) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLeDecimal(int,int,int) method."""

    _function_name = "assertLeDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLeDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLeDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLeDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertLeDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertLeDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertLeDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertLeDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertLeDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertLeDecimalContractFunction0._type_signature: VmAssertLeDecimalContractFunction0,
            VmAssertLeDecimalContractFunction1._type_signature: VmAssertLeDecimalContractFunction1,
            VmAssertLeDecimalContractFunction2._type_signature: VmAssertLeDecimalContractFunction2,
            VmAssertLeDecimalContractFunction3._type_signature: VmAssertLeDecimalContractFunction3,
        }
        return out


class VmAssertLtContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int,str) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int,str) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLt(int,int) method."""

    _function_name = "assertLt"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int) -> VmAssertLtContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertLtContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertLtContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertLtContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertLtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertLtContractFunction0._type_signature: VmAssertLtContractFunction0,
            VmAssertLtContractFunction1._type_signature: VmAssertLtContractFunction1,
            VmAssertLtContractFunction2._type_signature: VmAssertLtContractFunction2,
            VmAssertLtContractFunction3._type_signature: VmAssertLtContractFunction3,
        }
        return out


class VmAssertLtDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int,str) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int,str) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertLtDecimal(int,int,int) method."""

    _function_name = "assertLtDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertLtDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertLtDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertLtDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertLtDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertLtDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertLtDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertLtDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertLtDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertLtDecimalContractFunction0._type_signature: VmAssertLtDecimalContractFunction0,
            VmAssertLtDecimalContractFunction1._type_signature: VmAssertLtDecimalContractFunction1,
            VmAssertLtDecimalContractFunction2._type_signature: VmAssertLtDecimalContractFunction2,
            VmAssertLtDecimalContractFunction3._type_signature: VmAssertLtDecimalContractFunction3,
        }
        return out


class VmAssertNotEqContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bool,bool,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["bool", "bool", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction4(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bool,bool) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["bool", "bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction5(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bool],list[bool]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction6(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction7(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction8(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction9(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction10(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bool],list[bool],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bool]", "list[bool]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction11(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction12(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction13(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction14(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction15(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction16(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction17(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction18(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction19(PypechainContractFunction):
    """ContractFunction for the assertNotEq(str,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction20(PypechainContractFunction):
    """ContractFunction for the assertNotEq(bytes,bytes,str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction21(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction22(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction23(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction24(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[str],list[str]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[str]", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction25(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[int],list[int],str) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[int]", "list[int]", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction26(PypechainContractFunction):
    """ContractFunction for the assertNotEq(list[bytes],list[bytes]) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(
        tuple(["list[bytes]", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction27(PypechainContractFunction):
    """ContractFunction for the assertNotEq(int,int) method."""

    _function_name = "assertNotEq"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertNotEq method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertNotEq"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmAssertNotEqContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmAssertNotEqContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool, error: str) -> VmAssertNotEqContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmAssertNotEqContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, left: bool, right: bool) -> VmAssertNotEqContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool]) -> VmAssertNotEqContractFunction5:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmAssertNotEqContractFunction6:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmAssertNotEqContractFunction7:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertNotEqContractFunction8:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int]) -> VmAssertNotEqContractFunction9:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bool], right: list[bool], error: str) -> VmAssertNotEqContractFunction10:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmAssertNotEqContractFunction11:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmAssertNotEqContractFunction12:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmAssertNotEqContractFunction13:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str, error: str) -> VmAssertNotEqContractFunction14:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes) -> VmAssertNotEqContractFunction15:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmAssertNotEqContractFunction16:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, error: str) -> VmAssertNotEqContractFunction17:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmAssertNotEqContractFunction18:  # type: ignore
        ...

    @overload
    def __call__(self, left: str, right: str) -> VmAssertNotEqContractFunction19:  # type: ignore
        ...

    @overload
    def __call__(self, left: bytes, right: bytes, error: str) -> VmAssertNotEqContractFunction20:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str], error: str) -> VmAssertNotEqContractFunction21:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertNotEqContractFunction22:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes], error: str) -> VmAssertNotEqContractFunction23:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[str], right: list[str]) -> VmAssertNotEqContractFunction24:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[int], right: list[int], error: str) -> VmAssertNotEqContractFunction25:  # type: ignore
        ...

    @overload
    def __call__(self, left: list[bytes], right: list[bytes]) -> VmAssertNotEqContractFunction26:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int) -> VmAssertNotEqContractFunction27:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertNotEqContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertNotEqContractFunction0._type_signature: VmAssertNotEqContractFunction0,
            VmAssertNotEqContractFunction1._type_signature: VmAssertNotEqContractFunction1,
            VmAssertNotEqContractFunction2._type_signature: VmAssertNotEqContractFunction2,
            VmAssertNotEqContractFunction3._type_signature: VmAssertNotEqContractFunction3,
            VmAssertNotEqContractFunction4._type_signature: VmAssertNotEqContractFunction4,
            VmAssertNotEqContractFunction5._type_signature: VmAssertNotEqContractFunction5,
            VmAssertNotEqContractFunction6._type_signature: VmAssertNotEqContractFunction6,
            VmAssertNotEqContractFunction7._type_signature: VmAssertNotEqContractFunction7,
            VmAssertNotEqContractFunction8._type_signature: VmAssertNotEqContractFunction8,
            VmAssertNotEqContractFunction9._type_signature: VmAssertNotEqContractFunction9,
            VmAssertNotEqContractFunction10._type_signature: VmAssertNotEqContractFunction10,
            VmAssertNotEqContractFunction11._type_signature: VmAssertNotEqContractFunction11,
            VmAssertNotEqContractFunction12._type_signature: VmAssertNotEqContractFunction12,
            VmAssertNotEqContractFunction13._type_signature: VmAssertNotEqContractFunction13,
            VmAssertNotEqContractFunction14._type_signature: VmAssertNotEqContractFunction14,
            VmAssertNotEqContractFunction15._type_signature: VmAssertNotEqContractFunction15,
            VmAssertNotEqContractFunction16._type_signature: VmAssertNotEqContractFunction16,
            VmAssertNotEqContractFunction17._type_signature: VmAssertNotEqContractFunction17,
            VmAssertNotEqContractFunction18._type_signature: VmAssertNotEqContractFunction18,
            VmAssertNotEqContractFunction19._type_signature: VmAssertNotEqContractFunction19,
            VmAssertNotEqContractFunction20._type_signature: VmAssertNotEqContractFunction20,
            VmAssertNotEqContractFunction21._type_signature: VmAssertNotEqContractFunction21,
            VmAssertNotEqContractFunction22._type_signature: VmAssertNotEqContractFunction22,
            VmAssertNotEqContractFunction23._type_signature: VmAssertNotEqContractFunction23,
            VmAssertNotEqContractFunction24._type_signature: VmAssertNotEqContractFunction24,
            VmAssertNotEqContractFunction25._type_signature: VmAssertNotEqContractFunction25,
            VmAssertNotEqContractFunction26._type_signature: VmAssertNotEqContractFunction26,
            VmAssertNotEqContractFunction27._type_signature: VmAssertNotEqContractFunction27,
        }
        return out


class VmAssertNotEqDecimalContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqDecimalContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int,str) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqDecimalContractFunction2(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqDecimalContractFunction3(PypechainContractFunction):
    """ContractFunction for the assertNotEqDecimal(int,int,int,str) method."""

    _function_name = "assertNotEqDecimal"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertNotEqDecimalContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertNotEqDecimal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertNotEqDecimal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertNotEqDecimalContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertNotEqDecimalContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int) -> VmAssertNotEqDecimalContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, left: int, right: int, decimals: int, error: str) -> VmAssertNotEqDecimalContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertNotEqDecimalContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertNotEqDecimalContractFunction0._type_signature: VmAssertNotEqDecimalContractFunction0,
            VmAssertNotEqDecimalContractFunction1._type_signature: VmAssertNotEqDecimalContractFunction1,
            VmAssertNotEqDecimalContractFunction2._type_signature: VmAssertNotEqDecimalContractFunction2,
            VmAssertNotEqDecimalContractFunction3._type_signature: VmAssertNotEqDecimalContractFunction3,
        }
        return out


class VmAssertTrueContractFunction0(PypechainContractFunction):
    """ContractFunction for the assertTrue(bool) method."""

    _function_name = "assertTrue"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertTrueContractFunction1(PypechainContractFunction):
    """ContractFunction for the assertTrue(bool,str) method."""

    _function_name = "assertTrue"
    _type_signature = expand_struct_type_str(tuple(["bool", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssertTrueContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assertTrue method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assertTrue"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, condition: bool) -> VmAssertTrueContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, condition: bool, error: str) -> VmAssertTrueContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssertTrueContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssertTrueContractFunction0._type_signature: VmAssertTrueContractFunction0,
            VmAssertTrueContractFunction1._type_signature: VmAssertTrueContractFunction1,
        }
        return out


class VmAssumeContractFunction0(PypechainContractFunction):
    """ContractFunction for the assume(bool) method."""

    _function_name = "assume"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmAssumeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the assume method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "assume"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, condition: bool) -> VmAssumeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmAssumeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmAssumeContractFunction0._type_signature: VmAssumeContractFunction0,
        }
        return out


class VmBreakpointContractFunction0(PypechainContractFunction):
    """ContractFunction for the breakpoint(str) method."""

    _function_name = "breakpoint"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmBreakpointContractFunction1(PypechainContractFunction):
    """ContractFunction for the breakpoint(str,bool) method."""

    _function_name = "breakpoint"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmBreakpointContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the breakpoint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "breakpoint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, char: str) -> VmBreakpointContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, char: str, value: bool) -> VmBreakpointContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmBreakpointContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmBreakpointContractFunction0._type_signature: VmBreakpointContractFunction0,
            VmBreakpointContractFunction1._type_signature: VmBreakpointContractFunction1,
        }
        return out


class VmBroadcastContractFunction0(PypechainContractFunction):
    """ContractFunction for the broadcast() method."""

    _function_name = "broadcast"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmBroadcastContractFunction1(PypechainContractFunction):
    """ContractFunction for the broadcast(str) method."""

    _function_name = "broadcast"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmBroadcastContractFunction2(PypechainContractFunction):
    """ContractFunction for the broadcast(int) method."""

    _function_name = "broadcast"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmBroadcastContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the broadcast method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "broadcast"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmBroadcastContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, signer: str) -> VmBroadcastContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int) -> VmBroadcastContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmBroadcastContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmBroadcastContractFunction0._type_signature: VmBroadcastContractFunction0,
            VmBroadcastContractFunction1._type_signature: VmBroadcastContractFunction1,
            VmBroadcastContractFunction2._type_signature: VmBroadcastContractFunction2,
        }
        return out


class VmChainIdContractFunction0(PypechainContractFunction):
    """ContractFunction for the chainId(int) method."""

    _function_name = "chainId"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmChainIdContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the chainId method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "chainId"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newChainId: int) -> VmChainIdContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmChainIdContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmChainIdContractFunction0._type_signature: VmChainIdContractFunction0,
        }
        return out


class VmClearMockedCallsContractFunction0(PypechainContractFunction):
    """ContractFunction for the clearMockedCalls() method."""

    _function_name = "clearMockedCalls"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmClearMockedCallsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the clearMockedCalls method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "clearMockedCalls"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmClearMockedCallsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmClearMockedCallsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmClearMockedCallsContractFunction0._type_signature: VmClearMockedCallsContractFunction0,
        }
        return out


class VmCloseFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the closeFile(str) method."""

    _function_name = "closeFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmCloseFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the closeFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "closeFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmCloseFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmCloseFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmCloseFileContractFunction0._type_signature: VmCloseFileContractFunction0,
        }
        return out


class VmCoinbaseContractFunction0(PypechainContractFunction):
    """ContractFunction for the coinbase(str) method."""

    _function_name = "coinbase"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmCoinbaseContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the coinbase method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "coinbase"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newCoinbase: str) -> VmCoinbaseContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmCoinbaseContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmCoinbaseContractFunction0._type_signature: VmCoinbaseContractFunction0,
        }
        return out


class VmComputeCreate2AddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the computeCreate2Address(bytes,bytes) method."""

    _function_name = "computeCreate2Address"
    _type_signature = expand_struct_type_str(tuple(["bytes", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmComputeCreate2AddressContractFunction1(PypechainContractFunction):
    """ContractFunction for the computeCreate2Address(bytes,bytes,str) method."""

    _function_name = "computeCreate2Address"
    _type_signature = expand_struct_type_str(
        tuple(["bytes", "bytes", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmComputeCreate2AddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the computeCreate2Address method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "computeCreate2Address"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, salt: bytes, initCodeHash: bytes) -> VmComputeCreate2AddressContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, salt: bytes, initCodeHash: bytes, deployer: str) -> VmComputeCreate2AddressContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmComputeCreate2AddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmComputeCreate2AddressContractFunction0._type_signature: VmComputeCreate2AddressContractFunction0,
            VmComputeCreate2AddressContractFunction1._type_signature: VmComputeCreate2AddressContractFunction1,
        }
        return out


class VmComputeCreateAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the computeCreateAddress(str,int) method."""

    _function_name = "computeCreateAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmComputeCreateAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the computeCreateAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "computeCreateAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, deployer: str, nonce: int) -> VmComputeCreateAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmComputeCreateAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmComputeCreateAddressContractFunction0._type_signature: VmComputeCreateAddressContractFunction0,
        }
        return out


class VmCopyFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the copyFile(str,str) method."""

    _function_name = "copyFile"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmCopyFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the copyFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "copyFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _from: str, to: str) -> VmCopyFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmCopyFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmCopyFileContractFunction0._type_signature: VmCopyFileContractFunction0,
        }
        return out


class VmCreateDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the createDir(str,bool) method."""

    _function_name = "createDir"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmCreateDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the createDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "createDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, recursive: bool) -> VmCreateDirContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmCreateDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmCreateDirContractFunction0._type_signature: VmCreateDirContractFunction0,
        }
        return out


class VmCreateForkContractFunction0(PypechainContractFunction):
    """ContractFunction for the createFork(str) method."""

    _function_name = "createFork"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmCreateForkContractFunction1(PypechainContractFunction):
    """ContractFunction for the createFork(str,int) method."""

    _function_name = "createFork"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmCreateForkContractFunction2(PypechainContractFunction):
    """ContractFunction for the createFork(str,bytes) method."""

    _function_name = "createFork"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmCreateForkContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the createFork method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "createFork"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, urlOrAlias: str) -> VmCreateForkContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, urlOrAlias: str, blockNumber: int) -> VmCreateForkContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, urlOrAlias: str, txHash: bytes) -> VmCreateForkContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmCreateForkContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmCreateForkContractFunction0._type_signature: VmCreateForkContractFunction0,
            VmCreateForkContractFunction1._type_signature: VmCreateForkContractFunction1,
            VmCreateForkContractFunction2._type_signature: VmCreateForkContractFunction2,
        }
        return out


class VmCreateSelectForkContractFunction0(PypechainContractFunction):
    """ContractFunction for the createSelectFork(str,int) method."""

    _function_name = "createSelectFork"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmCreateSelectForkContractFunction1(PypechainContractFunction):
    """ContractFunction for the createSelectFork(str,bytes) method."""

    _function_name = "createSelectFork"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmCreateSelectForkContractFunction2(PypechainContractFunction):
    """ContractFunction for the createSelectFork(str) method."""

    _function_name = "createSelectFork"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmCreateSelectForkContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the createSelectFork method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "createSelectFork"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, urlOrAlias: str, blockNumber: int) -> VmCreateSelectForkContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, urlOrAlias: str, txHash: bytes) -> VmCreateSelectForkContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, urlOrAlias: str) -> VmCreateSelectForkContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmCreateSelectForkContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmCreateSelectForkContractFunction0._type_signature: VmCreateSelectForkContractFunction0,
            VmCreateSelectForkContractFunction1._type_signature: VmCreateSelectForkContractFunction1,
            VmCreateSelectForkContractFunction2._type_signature: VmCreateSelectForkContractFunction2,
        }
        return out


class VmCreateWalletContractFunction0(PypechainContractFunction):
    """ContractFunction for the createWallet(str) method."""

    _function_name = "createWallet"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.Wallet:
        """returns VmSafe.Wallet."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.Wallet

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.Wallet,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmCreateWalletContractFunction1(PypechainContractFunction):
    """ContractFunction for the createWallet(int) method."""

    _function_name = "createWallet"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.Wallet:
        """returns VmSafe.Wallet."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.Wallet

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.Wallet,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmCreateWalletContractFunction2(PypechainContractFunction):
    """ContractFunction for the createWallet(int,str) method."""

    _function_name = "createWallet"
    _type_signature = expand_struct_type_str(tuple(["int", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.Wallet:
        """returns VmSafe.Wallet."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.Wallet

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.Wallet,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmCreateWalletContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the createWallet method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "createWallet"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, walletLabel: str) -> VmCreateWalletContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int) -> VmCreateWalletContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int, walletLabel: str) -> VmCreateWalletContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmCreateWalletContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmCreateWalletContractFunction0._type_signature: VmCreateWalletContractFunction0,
            VmCreateWalletContractFunction1._type_signature: VmCreateWalletContractFunction1,
            VmCreateWalletContractFunction2._type_signature: VmCreateWalletContractFunction2,
        }
        return out


class VmDealContractFunction0(PypechainContractFunction):
    """ContractFunction for the deal(str,int) method."""

    _function_name = "deal"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmDealContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deal method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deal"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str, newBalance: int) -> VmDealContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmDealContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmDealContractFunction0._type_signature: VmDealContractFunction0,
        }
        return out


class VmDeleteSnapshotContractFunction0(PypechainContractFunction):
    """ContractFunction for the deleteSnapshot(int) method."""

    _function_name = "deleteSnapshot"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmDeleteSnapshotContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deleteSnapshot method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deleteSnapshot"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, snapshotId: int) -> VmDeleteSnapshotContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmDeleteSnapshotContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmDeleteSnapshotContractFunction0._type_signature: VmDeleteSnapshotContractFunction0,
        }
        return out


class VmDeleteSnapshotsContractFunction0(PypechainContractFunction):
    """ContractFunction for the deleteSnapshots() method."""

    _function_name = "deleteSnapshots"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmDeleteSnapshotsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deleteSnapshots method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deleteSnapshots"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmDeleteSnapshotsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmDeleteSnapshotsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmDeleteSnapshotsContractFunction0._type_signature: VmDeleteSnapshotsContractFunction0,
        }
        return out


class VmDeriveKeyContractFunction0(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,str,int,str) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmDeriveKeyContractFunction1(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,int,str) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmDeriveKeyContractFunction2(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,int) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmDeriveKeyContractFunction3(PypechainContractFunction):
    """ContractFunction for the deriveKey(str,str,int) method."""

    _function_name = "deriveKey"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmDeriveKeyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deriveKey method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deriveKey"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, mnemonic: str, derivationPath: str, index: int, language: str) -> VmDeriveKeyContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, mnemonic: str, index: int, language: str) -> VmDeriveKeyContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, mnemonic: str, index: int) -> VmDeriveKeyContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, mnemonic: str, derivationPath: str, index: int) -> VmDeriveKeyContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmDeriveKeyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmDeriveKeyContractFunction0._type_signature: VmDeriveKeyContractFunction0,
            VmDeriveKeyContractFunction1._type_signature: VmDeriveKeyContractFunction1,
            VmDeriveKeyContractFunction2._type_signature: VmDeriveKeyContractFunction2,
            VmDeriveKeyContractFunction3._type_signature: VmDeriveKeyContractFunction3,
        }
        return out


class VmDifficultyContractFunction0(PypechainContractFunction):
    """ContractFunction for the difficulty(int) method."""

    _function_name = "difficulty"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmDifficultyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the difficulty method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "difficulty"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newDifficulty: int) -> VmDifficultyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmDifficultyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmDifficultyContractFunction0._type_signature: VmDifficultyContractFunction0,
        }
        return out


class VmDumpStateContractFunction0(PypechainContractFunction):
    """ContractFunction for the dumpState(str) method."""

    _function_name = "dumpState"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmDumpStateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the dumpState method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "dumpState"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, pathToStateJson: str) -> VmDumpStateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmDumpStateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmDumpStateContractFunction0._type_signature: VmDumpStateContractFunction0,
        }
        return out


class VmEnvAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the envAddress(str) method."""

    _function_name = "envAddress"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvAddressContractFunction1(PypechainContractFunction):
    """ContractFunction for the envAddress(str,str) method."""

    _function_name = "envAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmEnvAddressContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmEnvAddressContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvAddressContractFunction0._type_signature: VmEnvAddressContractFunction0,
            VmEnvAddressContractFunction1._type_signature: VmEnvAddressContractFunction1,
        }
        return out


class VmEnvBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the envBool(str) method."""

    _function_name = "envBool"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvBoolContractFunction1(PypechainContractFunction):
    """ContractFunction for the envBool(str,str) method."""

    _function_name = "envBool"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmEnvBoolContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmEnvBoolContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvBoolContractFunction0._type_signature: VmEnvBoolContractFunction0,
            VmEnvBoolContractFunction1._type_signature: VmEnvBoolContractFunction1,
        }
        return out


class VmEnvBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the envBytes(str) method."""

    _function_name = "envBytes"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvBytesContractFunction1(PypechainContractFunction):
    """ContractFunction for the envBytes(str,str) method."""

    _function_name = "envBytes"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmEnvBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmEnvBytesContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmEnvBytesContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvBytesContractFunction0._type_signature: VmEnvBytesContractFunction0,
            VmEnvBytesContractFunction1._type_signature: VmEnvBytesContractFunction1,
        }
        return out


class VmEnvBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the envBytes32(str,str) method."""

    _function_name = "envBytes32"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmEnvBytes32ContractFunction1(PypechainContractFunction):
    """ContractFunction for the envBytes32(str) method."""

    _function_name = "envBytes32"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str) -> VmEnvBytes32ContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str) -> VmEnvBytes32ContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvBytes32ContractFunction0._type_signature: VmEnvBytes32ContractFunction0,
            VmEnvBytes32ContractFunction1._type_signature: VmEnvBytes32ContractFunction1,
        }
        return out


class VmEnvIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the envInt(str,str) method."""

    _function_name = "envInt"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvIntContractFunction1(PypechainContractFunction):
    """ContractFunction for the envInt(str) method."""

    _function_name = "envInt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str) -> VmEnvIntContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str) -> VmEnvIntContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvIntContractFunction0._type_signature: VmEnvIntContractFunction0,
            VmEnvIntContractFunction1._type_signature: VmEnvIntContractFunction1,
        }
        return out


class VmEnvOrContractFunction0(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[bytes]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmEnvOrContractFunction1(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[int]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction2(PypechainContractFunction):
    """ContractFunction for the envOr(str,bool) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction3(PypechainContractFunction):
    """ContractFunction for the envOr(str,str) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction4(PypechainContractFunction):
    """ContractFunction for the envOr(str,int) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction5(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[bytes]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmEnvOrContractFunction6(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[int]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction7(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[str]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction8(PypechainContractFunction):
    """ContractFunction for the envOr(str,bytes) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction9(PypechainContractFunction):
    """ContractFunction for the envOr(str,bytes) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction10(PypechainContractFunction):
    """ContractFunction for the envOr(str,int) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction11(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[str]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction12(PypechainContractFunction):
    """ContractFunction for the envOr(str,str) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction13(PypechainContractFunction):
    """ContractFunction for the envOr(str,str,list[bool]) method."""

    _function_name = "envOr"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bool]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvOrContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envOr method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envOr"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[bytes]) -> VmEnvOrContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[int]) -> VmEnvOrContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: bool) -> VmEnvOrContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: str) -> VmEnvOrContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: int) -> VmEnvOrContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[bytes]) -> VmEnvOrContractFunction5:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[int]) -> VmEnvOrContractFunction6:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[str]) -> VmEnvOrContractFunction7:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: bytes) -> VmEnvOrContractFunction8:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: bytes) -> VmEnvOrContractFunction9:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: int) -> VmEnvOrContractFunction10:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[str]) -> VmEnvOrContractFunction11:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, defaultValue: str) -> VmEnvOrContractFunction12:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str, defaultValue: list[bool]) -> VmEnvOrContractFunction13:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvOrContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvOrContractFunction0._type_signature: VmEnvOrContractFunction0,
            VmEnvOrContractFunction1._type_signature: VmEnvOrContractFunction1,
            VmEnvOrContractFunction2._type_signature: VmEnvOrContractFunction2,
            VmEnvOrContractFunction3._type_signature: VmEnvOrContractFunction3,
            VmEnvOrContractFunction4._type_signature: VmEnvOrContractFunction4,
            VmEnvOrContractFunction5._type_signature: VmEnvOrContractFunction5,
            VmEnvOrContractFunction6._type_signature: VmEnvOrContractFunction6,
            VmEnvOrContractFunction7._type_signature: VmEnvOrContractFunction7,
            VmEnvOrContractFunction8._type_signature: VmEnvOrContractFunction8,
            VmEnvOrContractFunction9._type_signature: VmEnvOrContractFunction9,
            VmEnvOrContractFunction10._type_signature: VmEnvOrContractFunction10,
            VmEnvOrContractFunction11._type_signature: VmEnvOrContractFunction11,
            VmEnvOrContractFunction12._type_signature: VmEnvOrContractFunction12,
            VmEnvOrContractFunction13._type_signature: VmEnvOrContractFunction13,
        }
        return out


class VmEnvStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the envString(str,str) method."""

    _function_name = "envString"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvStringContractFunction1(PypechainContractFunction):
    """ContractFunction for the envString(str) method."""

    _function_name = "envString"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, delim: str) -> VmEnvStringContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str) -> VmEnvStringContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvStringContractFunction0._type_signature: VmEnvStringContractFunction0,
            VmEnvStringContractFunction1._type_signature: VmEnvStringContractFunction1,
        }
        return out


class VmEnvUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the envUint(str) method."""

    _function_name = "envUint"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvUintContractFunction1(PypechainContractFunction):
    """ContractFunction for the envUint(str,str) method."""

    _function_name = "envUint"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmEnvUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the envUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "envUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str) -> VmEnvUintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, name: str, delim: str) -> VmEnvUintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEnvUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEnvUintContractFunction0._type_signature: VmEnvUintContractFunction0,
            VmEnvUintContractFunction1._type_signature: VmEnvUintContractFunction1,
        }
        return out


class VmEtchContractFunction0(PypechainContractFunction):
    """ContractFunction for the etch(str,bytes) method."""

    _function_name = "etch"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmEtchContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the etch method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "etch"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, newRuntimeBytecode: bytes) -> VmEtchContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEtchContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEtchContractFunction0._type_signature: VmEtchContractFunction0,
        }
        return out


class VmEth_getLogsContractFunction0(PypechainContractFunction):
    """ContractFunction for the eth_getLogs(int,int,str,list[bytes]) method."""

    _function_name = "eth_getLogs"
    _type_signature = expand_struct_type_str(
        tuple(["int", "int", "str", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.EthGetLogs]:
        """returns list[VmSafe.EthGetLogs]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.EthGetLogs]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.EthGetLogs],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmEth_getLogsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the eth_getLogs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "eth_getLogs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, fromBlock: int, toBlock: int, target: str, topics: list[bytes]) -> VmEth_getLogsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmEth_getLogsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmEth_getLogsContractFunction0._type_signature: VmEth_getLogsContractFunction0,
        }
        return out


class VmExistsContractFunction0(PypechainContractFunction):
    """ContractFunction for the exists(str) method."""

    _function_name = "exists"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmExistsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the exists method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "exists"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmExistsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmExistsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmExistsContractFunction0._type_signature: VmExistsContractFunction0,
        }
        return out


class VmExpectCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the expectCall(str,int,int,bytes) method."""

    _function_name = "expectCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallContractFunction1(PypechainContractFunction):
    """ContractFunction for the expectCall(str,int,int,bytes,int) method."""

    _function_name = "expectCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "bytes", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallContractFunction2(PypechainContractFunction):
    """ContractFunction for the expectCall(str,int,bytes,int) method."""

    _function_name = "expectCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bytes", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallContractFunction3(PypechainContractFunction):
    """ContractFunction for the expectCall(str,bytes) method."""

    _function_name = "expectCall"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallContractFunction4(PypechainContractFunction):
    """ContractFunction for the expectCall(str,bytes,int) method."""

    _function_name = "expectCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "bytes", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallContractFunction5(PypechainContractFunction):
    """ContractFunction for the expectCall(str,int,bytes) method."""

    _function_name = "expectCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the expectCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "expectCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, callee: str, msgValue: int, gas: int, data: bytes) -> VmExpectCallContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, msgValue: int, gas: int, data: bytes, count: int) -> VmExpectCallContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, msgValue: int, data: bytes, count: int) -> VmExpectCallContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, data: bytes) -> VmExpectCallContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, data: bytes, count: int) -> VmExpectCallContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, msgValue: int, data: bytes) -> VmExpectCallContractFunction5:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmExpectCallContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmExpectCallContractFunction0._type_signature: VmExpectCallContractFunction0,
            VmExpectCallContractFunction1._type_signature: VmExpectCallContractFunction1,
            VmExpectCallContractFunction2._type_signature: VmExpectCallContractFunction2,
            VmExpectCallContractFunction3._type_signature: VmExpectCallContractFunction3,
            VmExpectCallContractFunction4._type_signature: VmExpectCallContractFunction4,
            VmExpectCallContractFunction5._type_signature: VmExpectCallContractFunction5,
        }
        return out


class VmExpectCallMinGasContractFunction0(PypechainContractFunction):
    """ContractFunction for the expectCallMinGas(str,int,int,bytes) method."""

    _function_name = "expectCallMinGas"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallMinGasContractFunction1(PypechainContractFunction):
    """ContractFunction for the expectCallMinGas(str,int,int,bytes,int) method."""

    _function_name = "expectCallMinGas"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "int", "bytes", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectCallMinGasContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the expectCallMinGas method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "expectCallMinGas"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, callee: str, msgValue: int, minGas: int, data: bytes) -> VmExpectCallMinGasContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, msgValue: int, minGas: int, data: bytes, count: int) -> VmExpectCallMinGasContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmExpectCallMinGasContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmExpectCallMinGasContractFunction0._type_signature: VmExpectCallMinGasContractFunction0,
            VmExpectCallMinGasContractFunction1._type_signature: VmExpectCallMinGasContractFunction1,
        }
        return out


class VmExpectEmitContractFunction0(PypechainContractFunction):
    """ContractFunction for the expectEmit() method."""

    _function_name = "expectEmit"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectEmitContractFunction1(PypechainContractFunction):
    """ContractFunction for the expectEmit(bool,bool,bool,bool) method."""

    _function_name = "expectEmit"
    _type_signature = expand_struct_type_str(
        tuple(["bool", "bool", "bool", "bool"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectEmitContractFunction2(PypechainContractFunction):
    """ContractFunction for the expectEmit(bool,bool,bool,bool,str) method."""

    _function_name = "expectEmit"
    _type_signature = expand_struct_type_str(
        tuple(["bool", "bool", "bool", "bool", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectEmitContractFunction3(PypechainContractFunction):
    """ContractFunction for the expectEmit(str) method."""

    _function_name = "expectEmit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectEmitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the expectEmit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "expectEmit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmExpectEmitContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, checkTopic1: bool, checkTopic2: bool, checkTopic3: bool, checkData: bool) -> VmExpectEmitContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, checkTopic1: bool, checkTopic2: bool, checkTopic3: bool, checkData: bool, emitter: str) -> VmExpectEmitContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, emitter: str) -> VmExpectEmitContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmExpectEmitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmExpectEmitContractFunction0._type_signature: VmExpectEmitContractFunction0,
            VmExpectEmitContractFunction1._type_signature: VmExpectEmitContractFunction1,
            VmExpectEmitContractFunction2._type_signature: VmExpectEmitContractFunction2,
            VmExpectEmitContractFunction3._type_signature: VmExpectEmitContractFunction3,
        }
        return out


class VmExpectRevertContractFunction0(PypechainContractFunction):
    """ContractFunction for the expectRevert(bytes) method."""

    _function_name = "expectRevert"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectRevertContractFunction1(PypechainContractFunction):
    """ContractFunction for the expectRevert(bytes) method."""

    _function_name = "expectRevert"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectRevertContractFunction2(PypechainContractFunction):
    """ContractFunction for the expectRevert() method."""

    _function_name = "expectRevert"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectRevertContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the expectRevert method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "expectRevert"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, revertData: bytes) -> VmExpectRevertContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, revertData: bytes) -> VmExpectRevertContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self) -> VmExpectRevertContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmExpectRevertContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmExpectRevertContractFunction0._type_signature: VmExpectRevertContractFunction0,
            VmExpectRevertContractFunction1._type_signature: VmExpectRevertContractFunction1,
            VmExpectRevertContractFunction2._type_signature: VmExpectRevertContractFunction2,
        }
        return out


class VmExpectSafeMemoryContractFunction0(PypechainContractFunction):
    """ContractFunction for the expectSafeMemory(int,int) method."""

    _function_name = "expectSafeMemory"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectSafeMemoryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the expectSafeMemory method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "expectSafeMemory"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _min: int, _max: int) -> VmExpectSafeMemoryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmExpectSafeMemoryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmExpectSafeMemoryContractFunction0._type_signature: VmExpectSafeMemoryContractFunction0,
        }
        return out


class VmExpectSafeMemoryCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the expectSafeMemoryCall(int,int) method."""

    _function_name = "expectSafeMemoryCall"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmExpectSafeMemoryCallContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the expectSafeMemoryCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "expectSafeMemoryCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _min: int, _max: int) -> VmExpectSafeMemoryCallContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmExpectSafeMemoryCallContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmExpectSafeMemoryCallContractFunction0._type_signature: VmExpectSafeMemoryCallContractFunction0,
        }
        return out


class VmFeeContractFunction0(PypechainContractFunction):
    """ContractFunction for the fee(int) method."""

    _function_name = "fee"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmFeeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the fee method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "fee"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newBasefee: int) -> VmFeeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmFeeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmFeeContractFunction0._type_signature: VmFeeContractFunction0,
        }
        return out


class VmFfiContractFunction0(PypechainContractFunction):
    """ContractFunction for the ffi(list[str]) method."""

    _function_name = "ffi"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmFfiContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the ffi method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ffi"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, commandInput: list[str]) -> VmFfiContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmFfiContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmFfiContractFunction0._type_signature: VmFfiContractFunction0,
        }
        return out


class VmFsMetadataContractFunction0(PypechainContractFunction):
    """ContractFunction for the fsMetadata(str) method."""

    _function_name = "fsMetadata"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.FsMetadata:
        """returns VmSafe.FsMetadata."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.FsMetadata

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.FsMetadata,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmFsMetadataContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the fsMetadata method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "fsMetadata"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmFsMetadataContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmFsMetadataContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmFsMetadataContractFunction0._type_signature: VmFsMetadataContractFunction0,
        }
        return out


class VmGetBlockNumberContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBlockNumber() method."""

    _function_name = "getBlockNumber"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetBlockNumberContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBlockNumber method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBlockNumber"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmGetBlockNumberContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetBlockNumberContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetBlockNumberContractFunction0._type_signature: VmGetBlockNumberContractFunction0,
        }
        return out


class VmGetBlockTimestampContractFunction0(PypechainContractFunction):
    """ContractFunction for the getBlockTimestamp() method."""

    _function_name = "getBlockTimestamp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetBlockTimestampContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getBlockTimestamp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getBlockTimestamp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmGetBlockTimestampContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetBlockTimestampContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetBlockTimestampContractFunction0._type_signature: VmGetBlockTimestampContractFunction0,
        }
        return out


class VmGetCodeContractFunction0(PypechainContractFunction):
    """ContractFunction for the getCode(str) method."""

    _function_name = "getCode"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetCodeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getCode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getCode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, artifactPath: str) -> VmGetCodeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetCodeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetCodeContractFunction0._type_signature: VmGetCodeContractFunction0,
        }
        return out


class VmGetDeployedCodeContractFunction0(PypechainContractFunction):
    """ContractFunction for the getDeployedCode(str) method."""

    _function_name = "getDeployedCode"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetDeployedCodeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getDeployedCode method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getDeployedCode"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, artifactPath: str) -> VmGetDeployedCodeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetDeployedCodeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetDeployedCodeContractFunction0._type_signature: VmGetDeployedCodeContractFunction0,
        }
        return out


class VmGetLabelContractFunction0(PypechainContractFunction):
    """ContractFunction for the getLabel(str) method."""

    _function_name = "getLabel"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetLabelContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getLabel method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getLabel"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> VmGetLabelContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetLabelContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetLabelContractFunction0._type_signature: VmGetLabelContractFunction0,
        }
        return out


class VmGetMappingKeyAndParentOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the getMappingKeyAndParentOf(str,bytes) method."""

    _function_name = "getMappingKeyAndParentOf"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for GetMappingKeyAndParentOf."""

        found: bool
        key: bytes
        parent: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [bool, bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmGetMappingKeyAndParentOfContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getMappingKeyAndParentOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getMappingKeyAndParentOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, elementSlot: bytes) -> VmGetMappingKeyAndParentOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetMappingKeyAndParentOfContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetMappingKeyAndParentOfContractFunction0._type_signature: VmGetMappingKeyAndParentOfContractFunction0,
        }
        return out


class VmGetMappingLengthContractFunction0(PypechainContractFunction):
    """ContractFunction for the getMappingLength(str,bytes) method."""

    _function_name = "getMappingLength"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetMappingLengthContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getMappingLength method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getMappingLength"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, mappingSlot: bytes) -> VmGetMappingLengthContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetMappingLengthContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetMappingLengthContractFunction0._type_signature: VmGetMappingLengthContractFunction0,
        }
        return out


class VmGetMappingSlotAtContractFunction0(PypechainContractFunction):
    """ContractFunction for the getMappingSlotAt(str,bytes,int) method."""

    _function_name = "getMappingSlotAt"
    _type_signature = expand_struct_type_str(
        tuple(["str", "bytes", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetMappingSlotAtContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getMappingSlotAt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getMappingSlotAt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, mappingSlot: bytes, idx: int) -> VmGetMappingSlotAtContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetMappingSlotAtContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetMappingSlotAtContractFunction0._type_signature: VmGetMappingSlotAtContractFunction0,
        }
        return out


class VmGetNonceContractFunction0(PypechainContractFunction):
    """ContractFunction for the getNonce(str) method."""

    _function_name = "getNonce"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetNonceContractFunction1(PypechainContractFunction):
    """ContractFunction for the getNonce(VmSafe.Wallet) method."""

    _function_name = "getNonce"
    _type_signature = expand_struct_type_str(tuple(["VmSafe.Wallet"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmGetNonceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getNonce method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getNonce"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> VmGetNonceContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, wallet: VmSafe.Wallet) -> VmGetNonceContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetNonceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetNonceContractFunction0._type_signature: VmGetNonceContractFunction0,
            VmGetNonceContractFunction1._type_signature: VmGetNonceContractFunction1,
        }
        return out


class VmGetRecordedLogsContractFunction0(PypechainContractFunction):
    """ContractFunction for the getRecordedLogs() method."""

    _function_name = "getRecordedLogs"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.Log]:
        """returns list[VmSafe.Log]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.Log]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.Log],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmGetRecordedLogsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the getRecordedLogs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "getRecordedLogs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmGetRecordedLogsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmGetRecordedLogsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmGetRecordedLogsContractFunction0._type_signature: VmGetRecordedLogsContractFunction0,
        }
        return out


class VmIsDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the isDir(str) method."""

    _function_name = "isDir"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmIsDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmIsDirContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmIsDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmIsDirContractFunction0._type_signature: VmIsDirContractFunction0,
        }
        return out


class VmIsFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the isFile(str) method."""

    _function_name = "isFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmIsFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmIsFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmIsFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmIsFileContractFunction0._type_signature: VmIsFileContractFunction0,
        }
        return out


class VmIsPersistentContractFunction0(PypechainContractFunction):
    """ContractFunction for the isPersistent(str) method."""

    _function_name = "isPersistent"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmIsPersistentContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isPersistent method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isPersistent"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> VmIsPersistentContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmIsPersistentContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmIsPersistentContractFunction0._type_signature: VmIsPersistentContractFunction0,
        }
        return out


class VmKeyExistsContractFunction0(PypechainContractFunction):
    """ContractFunction for the keyExists(str,str) method."""

    _function_name = "keyExists"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmKeyExistsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the keyExists method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "keyExists"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmKeyExistsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmKeyExistsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmKeyExistsContractFunction0._type_signature: VmKeyExistsContractFunction0,
        }
        return out


class VmKeyExistsJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the keyExistsJson(str,str) method."""

    _function_name = "keyExistsJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmKeyExistsJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the keyExistsJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "keyExistsJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmKeyExistsJsonContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmKeyExistsJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmKeyExistsJsonContractFunction0._type_signature: VmKeyExistsJsonContractFunction0,
        }
        return out


class VmKeyExistsTomlContractFunction0(PypechainContractFunction):
    """ContractFunction for the keyExistsToml(str,str) method."""

    _function_name = "keyExistsToml"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmKeyExistsTomlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the keyExistsToml method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "keyExistsToml"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmKeyExistsTomlContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmKeyExistsTomlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmKeyExistsTomlContractFunction0._type_signature: VmKeyExistsTomlContractFunction0,
        }
        return out


class VmLabelContractFunction0(PypechainContractFunction):
    """ContractFunction for the label(str,str) method."""

    _function_name = "label"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmLabelContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the label method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "label"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str, newLabel: str) -> VmLabelContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmLabelContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmLabelContractFunction0._type_signature: VmLabelContractFunction0,
        }
        return out


class VmLoadContractFunction0(PypechainContractFunction):
    """ContractFunction for the load(str,bytes) method."""

    _function_name = "load"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmLoadContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the load method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "load"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, slot: bytes) -> VmLoadContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmLoadContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmLoadContractFunction0._type_signature: VmLoadContractFunction0,
        }
        return out


class VmLoadAllocsContractFunction0(PypechainContractFunction):
    """ContractFunction for the loadAllocs(str) method."""

    _function_name = "loadAllocs"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmLoadAllocsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the loadAllocs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "loadAllocs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, pathToAllocsJson: str) -> VmLoadAllocsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmLoadAllocsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmLoadAllocsContractFunction0._type_signature: VmLoadAllocsContractFunction0,
        }
        return out


class VmMakePersistentContractFunction0(PypechainContractFunction):
    """ContractFunction for the makePersistent(list[str]) method."""

    _function_name = "makePersistent"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMakePersistentContractFunction1(PypechainContractFunction):
    """ContractFunction for the makePersistent(str,str) method."""

    _function_name = "makePersistent"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMakePersistentContractFunction2(PypechainContractFunction):
    """ContractFunction for the makePersistent(str) method."""

    _function_name = "makePersistent"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMakePersistentContractFunction3(PypechainContractFunction):
    """ContractFunction for the makePersistent(str,str,str) method."""

    _function_name = "makePersistent"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMakePersistentContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the makePersistent method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "makePersistent"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, accounts: list[str]) -> VmMakePersistentContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, account0: str, account1: str) -> VmMakePersistentContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, account: str) -> VmMakePersistentContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, account0: str, account1: str, account2: str) -> VmMakePersistentContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmMakePersistentContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmMakePersistentContractFunction0._type_signature: VmMakePersistentContractFunction0,
            VmMakePersistentContractFunction1._type_signature: VmMakePersistentContractFunction1,
            VmMakePersistentContractFunction2._type_signature: VmMakePersistentContractFunction2,
            VmMakePersistentContractFunction3._type_signature: VmMakePersistentContractFunction3,
        }
        return out


class VmMockCallContractFunction0(PypechainContractFunction):
    """ContractFunction for the mockCall(str,int,bytes,bytes) method."""

    _function_name = "mockCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bytes", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMockCallContractFunction1(PypechainContractFunction):
    """ContractFunction for the mockCall(str,bytes,bytes) method."""

    _function_name = "mockCall"
    _type_signature = expand_struct_type_str(
        tuple(["str", "bytes", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMockCallContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mockCall method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mockCall"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, callee: str, msgValue: int, data: bytes, returnData: bytes) -> VmMockCallContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, data: bytes, returnData: bytes) -> VmMockCallContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmMockCallContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmMockCallContractFunction0._type_signature: VmMockCallContractFunction0,
            VmMockCallContractFunction1._type_signature: VmMockCallContractFunction1,
        }
        return out


class VmMockCallRevertContractFunction0(PypechainContractFunction):
    """ContractFunction for the mockCallRevert(str,int,bytes,bytes) method."""

    _function_name = "mockCallRevert"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bytes", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMockCallRevertContractFunction1(PypechainContractFunction):
    """ContractFunction for the mockCallRevert(str,bytes,bytes) method."""

    _function_name = "mockCallRevert"
    _type_signature = expand_struct_type_str(
        tuple(["str", "bytes", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmMockCallRevertContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mockCallRevert method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mockCallRevert"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, callee: str, msgValue: int, data: bytes, revertData: bytes) -> VmMockCallRevertContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, callee: str, data: bytes, revertData: bytes) -> VmMockCallRevertContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmMockCallRevertContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmMockCallRevertContractFunction0._type_signature: VmMockCallRevertContractFunction0,
            VmMockCallRevertContractFunction1._type_signature: VmMockCallRevertContractFunction1,
        }
        return out


class VmParseAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseAddress(str) method."""

    _function_name = "parseAddress"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmParseAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseAddressContractFunction0._type_signature: VmParseAddressContractFunction0,
        }
        return out


class VmParseBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseBool(str) method."""

    _function_name = "parseBool"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmParseBoolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseBoolContractFunction0._type_signature: VmParseBoolContractFunction0,
        }
        return out


class VmParseBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseBytes(str) method."""

    _function_name = "parseBytes"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmParseBytesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseBytesContractFunction0._type_signature: VmParseBytesContractFunction0,
        }
        return out


class VmParseBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseBytes32(str) method."""

    _function_name = "parseBytes32"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmParseBytes32ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseBytes32ContractFunction0._type_signature: VmParseBytes32ContractFunction0,
        }
        return out


class VmParseIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseInt(str) method."""

    _function_name = "parseInt"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmParseIntContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseIntContractFunction0._type_signature: VmParseIntContractFunction0,
        }
        return out


class VmParseJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJson(str) method."""

    _function_name = "parseJson"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonContractFunction1(PypechainContractFunction):
    """ContractFunction for the parseJson(str,str) method."""

    _function_name = "parseJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str) -> VmParseJsonContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonContractFunction0._type_signature: VmParseJsonContractFunction0,
            VmParseJsonContractFunction1._type_signature: VmParseJsonContractFunction1,
        }
        return out


class VmParseJsonAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonAddress(str,str) method."""

    _function_name = "parseJsonAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonAddressContractFunction0._type_signature: VmParseJsonAddressContractFunction0,
        }
        return out


class VmParseJsonAddressArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonAddressArray(str,str) method."""

    _function_name = "parseJsonAddressArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonAddressArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonAddressArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonAddressArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonAddressArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonAddressArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonAddressArrayContractFunction0._type_signature: VmParseJsonAddressArrayContractFunction0,
        }
        return out


class VmParseJsonBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBool(str,str) method."""

    _function_name = "parseJsonBool"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonBoolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonBoolContractFunction0._type_signature: VmParseJsonBoolContractFunction0,
        }
        return out


class VmParseJsonBoolArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBoolArray(str,str) method."""

    _function_name = "parseJsonBoolArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonBoolArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBoolArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBoolArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonBoolArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonBoolArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonBoolArrayContractFunction0._type_signature: VmParseJsonBoolArrayContractFunction0,
        }
        return out


class VmParseJsonBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytes(str,str) method."""

    _function_name = "parseJsonBytes"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonBytesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonBytesContractFunction0._type_signature: VmParseJsonBytesContractFunction0,
        }
        return out


class VmParseJsonBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytes32(str,str) method."""

    _function_name = "parseJsonBytes32"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonBytes32ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonBytes32ContractFunction0._type_signature: VmParseJsonBytes32ContractFunction0,
        }
        return out


class VmParseJsonBytes32ArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytes32Array(str,str) method."""

    _function_name = "parseJsonBytes32Array"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmParseJsonBytes32ArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytes32Array method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytes32Array"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonBytes32ArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonBytes32ArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonBytes32ArrayContractFunction0._type_signature: VmParseJsonBytes32ArrayContractFunction0,
        }
        return out


class VmParseJsonBytesArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonBytesArray(str,str) method."""

    _function_name = "parseJsonBytesArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmParseJsonBytesArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonBytesArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonBytesArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonBytesArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonBytesArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonBytesArrayContractFunction0._type_signature: VmParseJsonBytesArrayContractFunction0,
        }
        return out


class VmParseJsonIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonInt(str,str) method."""

    _function_name = "parseJsonInt"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonIntContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonIntContractFunction0._type_signature: VmParseJsonIntContractFunction0,
        }
        return out


class VmParseJsonIntArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonIntArray(str,str) method."""

    _function_name = "parseJsonIntArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonIntArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonIntArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonIntArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonIntArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonIntArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonIntArrayContractFunction0._type_signature: VmParseJsonIntArrayContractFunction0,
        }
        return out


class VmParseJsonKeysContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonKeys(str,str) method."""

    _function_name = "parseJsonKeys"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonKeysContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonKeys method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonKeys"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonKeysContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonKeysContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonKeysContractFunction0._type_signature: VmParseJsonKeysContractFunction0,
        }
        return out


class VmParseJsonStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonString(str,str) method."""

    _function_name = "parseJsonString"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonStringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonStringContractFunction0._type_signature: VmParseJsonStringContractFunction0,
        }
        return out


class VmParseJsonStringArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonStringArray(str,str) method."""

    _function_name = "parseJsonStringArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonStringArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonStringArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonStringArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonStringArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonStringArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonStringArrayContractFunction0._type_signature: VmParseJsonStringArrayContractFunction0,
        }
        return out


class VmParseJsonUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonUint(str,str) method."""

    _function_name = "parseJsonUint"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonUintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonUintContractFunction0._type_signature: VmParseJsonUintContractFunction0,
        }
        return out


class VmParseJsonUintArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseJsonUintArray(str,str) method."""

    _function_name = "parseJsonUintArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseJsonUintArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseJsonUintArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseJsonUintArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, key: str) -> VmParseJsonUintArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseJsonUintArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseJsonUintArrayContractFunction0._type_signature: VmParseJsonUintArrayContractFunction0,
        }
        return out


class VmParseTomlContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseToml(str,str) method."""

    _function_name = "parseToml"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlContractFunction1(PypechainContractFunction):
    """ContractFunction for the parseToml(str) method."""

    _function_name = "parseToml"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseToml method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseToml"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, toml: str) -> VmParseTomlContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlContractFunction0._type_signature: VmParseTomlContractFunction0,
            VmParseTomlContractFunction1._type_signature: VmParseTomlContractFunction1,
        }
        return out


class VmParseTomlAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlAddress(str,str) method."""

    _function_name = "parseTomlAddress"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlAddressContractFunction0._type_signature: VmParseTomlAddressContractFunction0,
        }
        return out


class VmParseTomlAddressArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlAddressArray(str,str) method."""

    _function_name = "parseTomlAddressArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlAddressArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlAddressArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlAddressArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlAddressArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlAddressArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlAddressArrayContractFunction0._type_signature: VmParseTomlAddressArrayContractFunction0,
        }
        return out


class VmParseTomlBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBool(str,str) method."""

    _function_name = "parseTomlBool"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlBoolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlBoolContractFunction0._type_signature: VmParseTomlBoolContractFunction0,
        }
        return out


class VmParseTomlBoolArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBoolArray(str,str) method."""

    _function_name = "parseTomlBoolArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bool]:
        """returns list[bool]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bool]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bool], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlBoolArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBoolArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBoolArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlBoolArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlBoolArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlBoolArrayContractFunction0._type_signature: VmParseTomlBoolArrayContractFunction0,
        }
        return out


class VmParseTomlBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytes(str,str) method."""

    _function_name = "parseTomlBytes"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlBytesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlBytesContractFunction0._type_signature: VmParseTomlBytesContractFunction0,
        }
        return out


class VmParseTomlBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytes32(str,str) method."""

    _function_name = "parseTomlBytes32"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlBytes32ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlBytes32ContractFunction0._type_signature: VmParseTomlBytes32ContractFunction0,
        }
        return out


class VmParseTomlBytes32ArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytes32Array(str,str) method."""

    _function_name = "parseTomlBytes32Array"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmParseTomlBytes32ArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytes32Array method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytes32Array"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlBytes32ArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlBytes32ArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlBytes32ArrayContractFunction0._type_signature: VmParseTomlBytes32ArrayContractFunction0,
        }
        return out


class VmParseTomlBytesArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlBytesArray(str,str) method."""

    _function_name = "parseTomlBytesArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[bytes]:
        """returns list[bytes]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[bytes],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmParseTomlBytesArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlBytesArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlBytesArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlBytesArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlBytesArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlBytesArrayContractFunction0._type_signature: VmParseTomlBytesArrayContractFunction0,
        }
        return out


class VmParseTomlIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlInt(str,str) method."""

    _function_name = "parseTomlInt"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlIntContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlIntContractFunction0._type_signature: VmParseTomlIntContractFunction0,
        }
        return out


class VmParseTomlIntArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlIntArray(str,str) method."""

    _function_name = "parseTomlIntArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlIntArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlIntArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlIntArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlIntArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlIntArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlIntArrayContractFunction0._type_signature: VmParseTomlIntArrayContractFunction0,
        }
        return out


class VmParseTomlKeysContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlKeys(str,str) method."""

    _function_name = "parseTomlKeys"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlKeysContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlKeys method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlKeys"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlKeysContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlKeysContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlKeysContractFunction0._type_signature: VmParseTomlKeysContractFunction0,
        }
        return out


class VmParseTomlStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlString(str,str) method."""

    _function_name = "parseTomlString"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlStringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlStringContractFunction0._type_signature: VmParseTomlStringContractFunction0,
        }
        return out


class VmParseTomlStringArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlStringArray(str,str) method."""

    _function_name = "parseTomlStringArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlStringArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlStringArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlStringArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlStringArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlStringArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlStringArrayContractFunction0._type_signature: VmParseTomlStringArrayContractFunction0,
        }
        return out


class VmParseTomlUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlUint(str,str) method."""

    _function_name = "parseTomlUint"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlUintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlUintContractFunction0._type_signature: VmParseTomlUintContractFunction0,
        }
        return out


class VmParseTomlUintArrayContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseTomlUintArray(str,str) method."""

    _function_name = "parseTomlUintArray"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[int]:
        """returns list[int]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[int], rename_returned_types(structs, return_types, raw_values)
        )


class VmParseTomlUintArrayContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseTomlUintArray method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseTomlUintArray"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, toml: str, key: str) -> VmParseTomlUintArrayContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseTomlUintArrayContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseTomlUintArrayContractFunction0._type_signature: VmParseTomlUintArrayContractFunction0,
        }
        return out


class VmParseUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the parseUint(str) method."""

    _function_name = "parseUint"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmParseUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the parseUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "parseUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, stringifiedValue: str) -> VmParseUintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmParseUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmParseUintContractFunction0._type_signature: VmParseUintContractFunction0,
        }
        return out


class VmPauseGasMeteringContractFunction0(PypechainContractFunction):
    """ContractFunction for the pauseGasMetering() method."""

    _function_name = "pauseGasMetering"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmPauseGasMeteringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the pauseGasMetering method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "pauseGasMetering"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmPauseGasMeteringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmPauseGasMeteringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmPauseGasMeteringContractFunction0._type_signature: VmPauseGasMeteringContractFunction0,
        }
        return out


class VmPrankContractFunction0(PypechainContractFunction):
    """ContractFunction for the prank(str,str) method."""

    _function_name = "prank"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmPrankContractFunction1(PypechainContractFunction):
    """ContractFunction for the prank(str) method."""

    _function_name = "prank"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmPrankContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the prank method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "prank"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, msgSender: str, txOrigin: str) -> VmPrankContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, msgSender: str) -> VmPrankContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmPrankContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmPrankContractFunction0._type_signature: VmPrankContractFunction0,
            VmPrankContractFunction1._type_signature: VmPrankContractFunction1,
        }
        return out


class VmPrevrandaoContractFunction0(PypechainContractFunction):
    """ContractFunction for the prevrandao(bytes) method."""

    _function_name = "prevrandao"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmPrevrandaoContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the prevrandao method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "prevrandao"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newPrevrandao: bytes) -> VmPrevrandaoContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmPrevrandaoContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmPrevrandaoContractFunction0._type_signature: VmPrevrandaoContractFunction0,
        }
        return out


class VmProjectRootContractFunction0(PypechainContractFunction):
    """ContractFunction for the projectRoot() method."""

    _function_name = "projectRoot"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmProjectRootContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the projectRoot method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "projectRoot"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmProjectRootContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmProjectRootContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmProjectRootContractFunction0._type_signature: VmProjectRootContractFunction0,
        }
        return out


class VmReadCallersContractFunction0(PypechainContractFunction):
    """ContractFunction for the readCallers() method."""

    _function_name = "readCallers"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for ReadCallers."""

        callerMode: int
        msgSender: str
        txOrigin: str

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, str, str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmReadCallersContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readCallers method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readCallers"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmReadCallersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmReadCallersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmReadCallersContractFunction0._type_signature: VmReadCallersContractFunction0,
        }
        return out


class VmReadDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the readDir(str,int) method."""

    _function_name = "readDir"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.DirEntry]:
        """returns list[VmSafe.DirEntry]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.DirEntry]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.DirEntry],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmReadDirContractFunction1(PypechainContractFunction):
    """ContractFunction for the readDir(str,int,bool) method."""

    _function_name = "readDir"
    _type_signature = expand_struct_type_str(
        tuple(["str", "int", "bool"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.DirEntry]:
        """returns list[VmSafe.DirEntry]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.DirEntry]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.DirEntry],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmReadDirContractFunction2(PypechainContractFunction):
    """ContractFunction for the readDir(str) method."""

    _function_name = "readDir"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.DirEntry]:
        """returns list[VmSafe.DirEntry]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.DirEntry]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.DirEntry],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmReadDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, maxDepth: int) -> VmReadDirContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, path: str, maxDepth: int, followLinks: bool) -> VmReadDirContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, path: str) -> VmReadDirContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmReadDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmReadDirContractFunction0._type_signature: VmReadDirContractFunction0,
            VmReadDirContractFunction1._type_signature: VmReadDirContractFunction1,
            VmReadDirContractFunction2._type_signature: VmReadDirContractFunction2,
        }
        return out


class VmReadFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the readFile(str) method."""

    _function_name = "readFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmReadFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmReadFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmReadFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmReadFileContractFunction0._type_signature: VmReadFileContractFunction0,
        }
        return out


class VmReadFileBinaryContractFunction0(PypechainContractFunction):
    """ContractFunction for the readFileBinary(str) method."""

    _function_name = "readFileBinary"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmReadFileBinaryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readFileBinary method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readFileBinary"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmReadFileBinaryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmReadFileBinaryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmReadFileBinaryContractFunction0._type_signature: VmReadFileBinaryContractFunction0,
        }
        return out


class VmReadLineContractFunction0(PypechainContractFunction):
    """ContractFunction for the readLine(str) method."""

    _function_name = "readLine"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmReadLineContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readLine method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readLine"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmReadLineContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmReadLineContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmReadLineContractFunction0._type_signature: VmReadLineContractFunction0,
        }
        return out


class VmReadLinkContractFunction0(PypechainContractFunction):
    """ContractFunction for the readLink(str) method."""

    _function_name = "readLink"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmReadLinkContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the readLink method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "readLink"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, linkPath: str) -> VmReadLinkContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmReadLinkContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmReadLinkContractFunction0._type_signature: VmReadLinkContractFunction0,
        }
        return out


class VmRecordContractFunction0(PypechainContractFunction):
    """ContractFunction for the record() method."""

    _function_name = "record"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRecordContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the record method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "record"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmRecordContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRecordContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRecordContractFunction0._type_signature: VmRecordContractFunction0,
        }
        return out


class VmRecordLogsContractFunction0(PypechainContractFunction):
    """ContractFunction for the recordLogs() method."""

    _function_name = "recordLogs"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRecordLogsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the recordLogs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "recordLogs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmRecordLogsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRecordLogsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRecordLogsContractFunction0._type_signature: VmRecordLogsContractFunction0,
        }
        return out


class VmRememberKeyContractFunction0(PypechainContractFunction):
    """ContractFunction for the rememberKey(int) method."""

    _function_name = "rememberKey"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmRememberKeyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rememberKey method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rememberKey"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, privateKey: int) -> VmRememberKeyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRememberKeyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRememberKeyContractFunction0._type_signature: VmRememberKeyContractFunction0,
        }
        return out


class VmRemoveDirContractFunction0(PypechainContractFunction):
    """ContractFunction for the removeDir(str,bool) method."""

    _function_name = "removeDir"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRemoveDirContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the removeDir method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "removeDir"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, recursive: bool) -> VmRemoveDirContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRemoveDirContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRemoveDirContractFunction0._type_signature: VmRemoveDirContractFunction0,
        }
        return out


class VmRemoveFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the removeFile(str) method."""

    _function_name = "removeFile"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRemoveFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the removeFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "removeFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str) -> VmRemoveFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRemoveFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRemoveFileContractFunction0._type_signature: VmRemoveFileContractFunction0,
        }
        return out


class VmReplaceContractFunction0(PypechainContractFunction):
    """ContractFunction for the replace(str,str,str) method."""

    _function_name = "replace"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmReplaceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the replace method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "replace"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str, _from: str, to: str) -> VmReplaceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmReplaceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmReplaceContractFunction0._type_signature: VmReplaceContractFunction0,
        }
        return out


class VmResetNonceContractFunction0(PypechainContractFunction):
    """ContractFunction for the resetNonce(str) method."""

    _function_name = "resetNonce"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmResetNonceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the resetNonce method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "resetNonce"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> VmResetNonceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmResetNonceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmResetNonceContractFunction0._type_signature: VmResetNonceContractFunction0,
        }
        return out


class VmResumeGasMeteringContractFunction0(PypechainContractFunction):
    """ContractFunction for the resumeGasMetering() method."""

    _function_name = "resumeGasMetering"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmResumeGasMeteringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the resumeGasMetering method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "resumeGasMetering"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmResumeGasMeteringContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmResumeGasMeteringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmResumeGasMeteringContractFunction0._type_signature: VmResumeGasMeteringContractFunction0,
        }
        return out


class VmRevertToContractFunction0(PypechainContractFunction):
    """ContractFunction for the revertTo(int) method."""

    _function_name = "revertTo"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmRevertToContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the revertTo method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "revertTo"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, snapshotId: int) -> VmRevertToContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRevertToContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRevertToContractFunction0._type_signature: VmRevertToContractFunction0,
        }
        return out


class VmRevertToAndDeleteContractFunction0(PypechainContractFunction):
    """ContractFunction for the revertToAndDelete(int) method."""

    _function_name = "revertToAndDelete"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class VmRevertToAndDeleteContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the revertToAndDelete method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "revertToAndDelete"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, snapshotId: int) -> VmRevertToAndDeleteContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRevertToAndDeleteContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRevertToAndDeleteContractFunction0._type_signature: VmRevertToAndDeleteContractFunction0,
        }
        return out


class VmRevokePersistentContractFunction0(PypechainContractFunction):
    """ContractFunction for the revokePersistent(list[str]) method."""

    _function_name = "revokePersistent"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRevokePersistentContractFunction1(PypechainContractFunction):
    """ContractFunction for the revokePersistent(str) method."""

    _function_name = "revokePersistent"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRevokePersistentContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the revokePersistent method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "revokePersistent"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, accounts: list[str]) -> VmRevokePersistentContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, account: str) -> VmRevokePersistentContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRevokePersistentContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRevokePersistentContractFunction0._type_signature: VmRevokePersistentContractFunction0,
            VmRevokePersistentContractFunction1._type_signature: VmRevokePersistentContractFunction1,
        }
        return out


class VmRollContractFunction0(PypechainContractFunction):
    """ContractFunction for the roll(int) method."""

    _function_name = "roll"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRollContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the roll method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "roll"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newHeight: int) -> VmRollContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRollContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRollContractFunction0._type_signature: VmRollContractFunction0,
        }
        return out


class VmRollForkContractFunction0(PypechainContractFunction):
    """ContractFunction for the rollFork(bytes) method."""

    _function_name = "rollFork"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRollForkContractFunction1(PypechainContractFunction):
    """ContractFunction for the rollFork(int,int) method."""

    _function_name = "rollFork"
    _type_signature = expand_struct_type_str(tuple(["int", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRollForkContractFunction2(PypechainContractFunction):
    """ContractFunction for the rollFork(int) method."""

    _function_name = "rollFork"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRollForkContractFunction3(PypechainContractFunction):
    """ContractFunction for the rollFork(int,bytes) method."""

    _function_name = "rollFork"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmRollForkContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rollFork method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rollFork"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, txHash: bytes) -> VmRollForkContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, forkId: int, blockNumber: int) -> VmRollForkContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, blockNumber: int) -> VmRollForkContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, forkId: int, txHash: bytes) -> VmRollForkContractFunction3:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRollForkContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRollForkContractFunction0._type_signature: VmRollForkContractFunction0,
            VmRollForkContractFunction1._type_signature: VmRollForkContractFunction1,
            VmRollForkContractFunction2._type_signature: VmRollForkContractFunction2,
            VmRollForkContractFunction3._type_signature: VmRollForkContractFunction3,
        }
        return out


class VmRpcContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpc(str,str) method."""

    _function_name = "rpc"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bytes, rename_returned_types(structs, return_types, raw_values)
        )


class VmRpcContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpc method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpc"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, method: str, params: str) -> VmRpcContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRpcContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRpcContractFunction0._type_signature: VmRpcContractFunction0,
        }
        return out


class VmRpcUrlContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpcUrl(str) method."""

    _function_name = "rpcUrl"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmRpcUrlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpcUrl method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpcUrl"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, rpcAlias: str) -> VmRpcUrlContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRpcUrlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRpcUrlContractFunction0._type_signature: VmRpcUrlContractFunction0,
        }
        return out


class VmRpcUrlStructsContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpcUrlStructs() method."""

    _function_name = "rpcUrlStructs"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.Rpc]:
        """returns list[VmSafe.Rpc]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.Rpc]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.Rpc],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmRpcUrlStructsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpcUrlStructs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpcUrlStructs"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmRpcUrlStructsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRpcUrlStructsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRpcUrlStructsContractFunction0._type_signature: VmRpcUrlStructsContractFunction0,
        }
        return out


class VmRpcUrlsContractFunction0(PypechainContractFunction):
    """ContractFunction for the rpcUrls() method."""

    _function_name = "rpcUrls"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[list[str]]:
        """returns list[list[str]]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[list[str]]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[list[str]],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmRpcUrlsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the rpcUrls method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "rpcUrls"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmRpcUrlsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmRpcUrlsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmRpcUrlsContractFunction0._type_signature: VmRpcUrlsContractFunction0,
        }
        return out


class VmSelectForkContractFunction0(PypechainContractFunction):
    """ContractFunction for the selectFork(int) method."""

    _function_name = "selectFork"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSelectForkContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the selectFork method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "selectFork"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, forkId: int) -> VmSelectForkContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSelectForkContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSelectForkContractFunction0._type_signature: VmSelectForkContractFunction0,
        }
        return out


class VmSerializeAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeAddress(str,str,list[str]) method."""

    _function_name = "serializeAddress"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeAddressContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeAddress(str,str,str) method."""

    _function_name = "serializeAddress"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[str]) -> VmSerializeAddressContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: str) -> VmSerializeAddressContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeAddressContractFunction0._type_signature: VmSerializeAddressContractFunction0,
            VmSerializeAddressContractFunction1._type_signature: VmSerializeAddressContractFunction1,
        }
        return out


class VmSerializeBoolContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeBool(str,str,list[bool]) method."""

    _function_name = "serializeBool"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bool]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeBoolContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeBool(str,str,bool) method."""

    _function_name = "serializeBool"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bool"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeBoolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeBool method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeBool"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[bool]) -> VmSerializeBoolContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: bool) -> VmSerializeBoolContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeBoolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeBoolContractFunction0._type_signature: VmSerializeBoolContractFunction0,
            VmSerializeBoolContractFunction1._type_signature: VmSerializeBoolContractFunction1,
        }
        return out


class VmSerializeBytesContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeBytes(str,str,list[bytes]) method."""

    _function_name = "serializeBytes"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeBytesContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeBytes(str,str,bytes) method."""

    _function_name = "serializeBytes"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeBytesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeBytes method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeBytes"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[bytes]) -> VmSerializeBytesContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: bytes) -> VmSerializeBytesContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeBytesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeBytesContractFunction0._type_signature: VmSerializeBytesContractFunction0,
            VmSerializeBytesContractFunction1._type_signature: VmSerializeBytesContractFunction1,
        }
        return out


class VmSerializeBytes32ContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeBytes32(str,str,list[bytes]) method."""

    _function_name = "serializeBytes32"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[bytes]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeBytes32ContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeBytes32(str,str,bytes) method."""

    _function_name = "serializeBytes32"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeBytes32ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeBytes32 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeBytes32"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[bytes]) -> VmSerializeBytes32ContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: bytes) -> VmSerializeBytes32ContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeBytes32ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeBytes32ContractFunction0._type_signature: VmSerializeBytes32ContractFunction0,
            VmSerializeBytes32ContractFunction1._type_signature: VmSerializeBytes32ContractFunction1,
        }
        return out


class VmSerializeIntContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeInt(str,str,int) method."""

    _function_name = "serializeInt"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeIntContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeInt(str,str,list[int]) method."""

    _function_name = "serializeInt"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeIntContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeInt method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeInt"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: int) -> VmSerializeIntContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[int]) -> VmSerializeIntContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeIntContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeIntContractFunction0._type_signature: VmSerializeIntContractFunction0,
            VmSerializeIntContractFunction1._type_signature: VmSerializeIntContractFunction1,
        }
        return out


class VmSerializeJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeJson(str,str) method."""

    _function_name = "serializeJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, value: str) -> VmSerializeJsonContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeJsonContractFunction0._type_signature: VmSerializeJsonContractFunction0,
        }
        return out


class VmSerializeStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeString(str,str,list[str]) method."""

    _function_name = "serializeString"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[str]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeStringContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeString(str,str,str) method."""

    _function_name = "serializeString"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[str]) -> VmSerializeStringContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: str) -> VmSerializeStringContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeStringContractFunction0._type_signature: VmSerializeStringContractFunction0,
            VmSerializeStringContractFunction1._type_signature: VmSerializeStringContractFunction1,
        }
        return out


class VmSerializeUintContractFunction0(PypechainContractFunction):
    """ContractFunction for the serializeUint(str,str,int) method."""

    _function_name = "serializeUint"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeUintContractFunction1(PypechainContractFunction):
    """ContractFunction for the serializeUint(str,str,list[int]) method."""

    _function_name = "serializeUint"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "list[int]"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmSerializeUintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the serializeUint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "serializeUint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, objectKey: str, valueKey: str, value: int) -> VmSerializeUintContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, objectKey: str, valueKey: str, values: list[int]) -> VmSerializeUintContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSerializeUintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSerializeUintContractFunction0._type_signature: VmSerializeUintContractFunction0,
            VmSerializeUintContractFunction1._type_signature: VmSerializeUintContractFunction1,
        }
        return out


class VmSetEnvContractFunction0(PypechainContractFunction):
    """ContractFunction for the setEnv(str,str) method."""

    _function_name = "setEnv"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSetEnvContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setEnv method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setEnv"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, name: str, value: str) -> VmSetEnvContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSetEnvContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSetEnvContractFunction0._type_signature: VmSetEnvContractFunction0,
        }
        return out


class VmSetNonceContractFunction0(PypechainContractFunction):
    """ContractFunction for the setNonce(str,int) method."""

    _function_name = "setNonce"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSetNonceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setNonce method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setNonce"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str, newNonce: int) -> VmSetNonceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSetNonceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSetNonceContractFunction0._type_signature: VmSetNonceContractFunction0,
        }
        return out


class VmSetNonceUnsafeContractFunction0(PypechainContractFunction):
    """ContractFunction for the setNonceUnsafe(str,int) method."""

    _function_name = "setNonceUnsafe"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSetNonceUnsafeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setNonceUnsafe method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setNonceUnsafe"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str, newNonce: int) -> VmSetNonceUnsafeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSetNonceUnsafeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSetNonceUnsafeContractFunction0._type_signature: VmSetNonceUnsafeContractFunction0,
        }
        return out


class VmSignContractFunction0(PypechainContractFunction):
    """ContractFunction for the sign(VmSafe.Wallet,bytes) method."""

    _function_name = "sign"
    _type_signature = expand_struct_type_str(
        tuple(["VmSafe.Wallet", "bytes"]), structs
    )
    _error_class = VmContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Sign."""

        v: int
        r: bytes
        s: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSignContractFunction1(PypechainContractFunction):
    """ContractFunction for the sign(int,bytes) method."""

    _function_name = "sign"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = VmContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Sign."""

        v: int
        r: bytes
        s: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSignContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the sign method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sign"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, wallet: VmSafe.Wallet, digest: bytes) -> VmSignContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int, digest: bytes) -> VmSignContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSignContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSignContractFunction0._type_signature: VmSignContractFunction0,
            VmSignContractFunction1._type_signature: VmSignContractFunction1,
        }
        return out


class VmSignP256ContractFunction0(PypechainContractFunction):
    """ContractFunction for the signP256(int,bytes) method."""

    _function_name = "signP256"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = VmContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for SignP256."""

        r: bytes
        s: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [bytes, bytes]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class VmSignP256ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the signP256 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "signP256"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, privateKey: int, digest: bytes) -> VmSignP256ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSignP256ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSignP256ContractFunction0._type_signature: VmSignP256ContractFunction0,
        }
        return out


class VmSkipContractFunction0(PypechainContractFunction):
    """ContractFunction for the skip(bool) method."""

    _function_name = "skip"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSkipContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the skip method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "skip"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, skipTest: bool) -> VmSkipContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSkipContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSkipContractFunction0._type_signature: VmSkipContractFunction0,
        }
        return out


class VmSleepContractFunction0(PypechainContractFunction):
    """ContractFunction for the sleep(int) method."""

    _function_name = "sleep"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmSleepContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the sleep method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "sleep"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, duration: int) -> VmSleepContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSleepContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSleepContractFunction0._type_signature: VmSleepContractFunction0,
        }
        return out


class VmSnapshotContractFunction0(PypechainContractFunction):
    """ContractFunction for the snapshot() method."""

    _function_name = "snapshot"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmSnapshotContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the snapshot method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "snapshot"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmSnapshotContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSnapshotContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSnapshotContractFunction0._type_signature: VmSnapshotContractFunction0,
        }
        return out


class VmSplitContractFunction0(PypechainContractFunction):
    """ContractFunction for the split(str,str) method."""

    _function_name = "split"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class VmSplitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the split method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "split"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str, delimiter: str) -> VmSplitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmSplitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmSplitContractFunction0._type_signature: VmSplitContractFunction0,
        }
        return out


class VmStartBroadcastContractFunction0(PypechainContractFunction):
    """ContractFunction for the startBroadcast() method."""

    _function_name = "startBroadcast"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStartBroadcastContractFunction1(PypechainContractFunction):
    """ContractFunction for the startBroadcast(str) method."""

    _function_name = "startBroadcast"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStartBroadcastContractFunction2(PypechainContractFunction):
    """ContractFunction for the startBroadcast(int) method."""

    _function_name = "startBroadcast"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStartBroadcastContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the startBroadcast method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "startBroadcast"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStartBroadcastContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, signer: str) -> VmStartBroadcastContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, privateKey: int) -> VmStartBroadcastContractFunction2:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStartBroadcastContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStartBroadcastContractFunction0._type_signature: VmStartBroadcastContractFunction0,
            VmStartBroadcastContractFunction1._type_signature: VmStartBroadcastContractFunction1,
            VmStartBroadcastContractFunction2._type_signature: VmStartBroadcastContractFunction2,
        }
        return out


class VmStartMappingRecordingContractFunction0(PypechainContractFunction):
    """ContractFunction for the startMappingRecording() method."""

    _function_name = "startMappingRecording"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStartMappingRecordingContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the startMappingRecording method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "startMappingRecording"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStartMappingRecordingContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStartMappingRecordingContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStartMappingRecordingContractFunction0._type_signature: VmStartMappingRecordingContractFunction0,
        }
        return out


class VmStartPrankContractFunction0(PypechainContractFunction):
    """ContractFunction for the startPrank(str) method."""

    _function_name = "startPrank"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStartPrankContractFunction1(PypechainContractFunction):
    """ContractFunction for the startPrank(str,str) method."""

    _function_name = "startPrank"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStartPrankContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the startPrank method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "startPrank"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, msgSender: str) -> VmStartPrankContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, msgSender: str, txOrigin: str) -> VmStartPrankContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStartPrankContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStartPrankContractFunction0._type_signature: VmStartPrankContractFunction0,
            VmStartPrankContractFunction1._type_signature: VmStartPrankContractFunction1,
        }
        return out


class VmStartStateDiffRecordingContractFunction0(PypechainContractFunction):
    """ContractFunction for the startStateDiffRecording() method."""

    _function_name = "startStateDiffRecording"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStartStateDiffRecordingContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the startStateDiffRecording method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "startStateDiffRecording"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStartStateDiffRecordingContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStartStateDiffRecordingContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStartStateDiffRecordingContractFunction0._type_signature: VmStartStateDiffRecordingContractFunction0,
        }
        return out


class VmStopAndReturnStateDiffContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopAndReturnStateDiff() method."""

    _function_name = "stopAndReturnStateDiff"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[VmSafe.AccountAccess]:
        """returns list[VmSafe.AccountAccess]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[VmSafe.AccountAccess]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[VmSafe.AccountAccess],
            rename_returned_types(structs, return_types, raw_values),
        )


class VmStopAndReturnStateDiffContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the stopAndReturnStateDiff method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopAndReturnStateDiff"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStopAndReturnStateDiffContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStopAndReturnStateDiffContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStopAndReturnStateDiffContractFunction0._type_signature: VmStopAndReturnStateDiffContractFunction0,
        }
        return out


class VmStopBroadcastContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopBroadcast() method."""

    _function_name = "stopBroadcast"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStopBroadcastContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the stopBroadcast method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopBroadcast"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStopBroadcastContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStopBroadcastContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStopBroadcastContractFunction0._type_signature: VmStopBroadcastContractFunction0,
        }
        return out


class VmStopExpectSafeMemoryContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopExpectSafeMemory() method."""

    _function_name = "stopExpectSafeMemory"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStopExpectSafeMemoryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the stopExpectSafeMemory method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopExpectSafeMemory"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStopExpectSafeMemoryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStopExpectSafeMemoryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStopExpectSafeMemoryContractFunction0._type_signature: VmStopExpectSafeMemoryContractFunction0,
        }
        return out


class VmStopMappingRecordingContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopMappingRecording() method."""

    _function_name = "stopMappingRecording"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStopMappingRecordingContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the stopMappingRecording method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopMappingRecording"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStopMappingRecordingContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStopMappingRecordingContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStopMappingRecordingContractFunction0._type_signature: VmStopMappingRecordingContractFunction0,
        }
        return out


class VmStopPrankContractFunction0(PypechainContractFunction):
    """ContractFunction for the stopPrank() method."""

    _function_name = "stopPrank"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStopPrankContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the stopPrank method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "stopPrank"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmStopPrankContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStopPrankContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStopPrankContractFunction0._type_signature: VmStopPrankContractFunction0,
        }
        return out


class VmStoreContractFunction0(PypechainContractFunction):
    """ContractFunction for the store(str,bytes,bytes) method."""

    _function_name = "store"
    _type_signature = expand_struct_type_str(
        tuple(["str", "bytes", "bytes"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmStoreContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the store method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "store"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, target: str, slot: bytes, value: bytes) -> VmStoreContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmStoreContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmStoreContractFunction0._type_signature: VmStoreContractFunction0,
        }
        return out


class VmToBase64ContractFunction0(PypechainContractFunction):
    """ContractFunction for the toBase64(str) method."""

    _function_name = "toBase64"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToBase64ContractFunction1(PypechainContractFunction):
    """ContractFunction for the toBase64(bytes) method."""

    _function_name = "toBase64"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToBase64ContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toBase64 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toBase64"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, data: str) -> VmToBase64ContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, data: bytes) -> VmToBase64ContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmToBase64ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmToBase64ContractFunction0._type_signature: VmToBase64ContractFunction0,
            VmToBase64ContractFunction1._type_signature: VmToBase64ContractFunction1,
        }
        return out


class VmToBase64URLContractFunction0(PypechainContractFunction):
    """ContractFunction for the toBase64URL(str) method."""

    _function_name = "toBase64URL"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToBase64URLContractFunction1(PypechainContractFunction):
    """ContractFunction for the toBase64URL(bytes) method."""

    _function_name = "toBase64URL"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToBase64URLContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toBase64URL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toBase64URL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, data: str) -> VmToBase64URLContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, data: bytes) -> VmToBase64URLContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmToBase64URLContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmToBase64URLContractFunction0._type_signature: VmToBase64URLContractFunction0,
            VmToBase64URLContractFunction1._type_signature: VmToBase64URLContractFunction1,
        }
        return out


class VmToLowercaseContractFunction0(PypechainContractFunction):
    """ContractFunction for the toLowercase(str) method."""

    _function_name = "toLowercase"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToLowercaseContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toLowercase method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toLowercase"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str) -> VmToLowercaseContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmToLowercaseContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmToLowercaseContractFunction0._type_signature: VmToLowercaseContractFunction0,
        }
        return out


class VmToStringContractFunction0(PypechainContractFunction):
    """ContractFunction for the toString(str) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToStringContractFunction1(PypechainContractFunction):
    """ContractFunction for the toString(int) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToStringContractFunction2(PypechainContractFunction):
    """ContractFunction for the toString(bytes) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToStringContractFunction3(PypechainContractFunction):
    """ContractFunction for the toString(bool) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["bool"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToStringContractFunction4(PypechainContractFunction):
    """ContractFunction for the toString(int) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToStringContractFunction5(PypechainContractFunction):
    """ContractFunction for the toString(bytes) method."""

    _function_name = "toString"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToStringContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toString method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toString"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, value: str) -> VmToStringContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, value: int) -> VmToStringContractFunction1:  # type: ignore
        ...

    @overload
    def __call__(self, value: bytes) -> VmToStringContractFunction2:  # type: ignore
        ...

    @overload
    def __call__(self, value: bool) -> VmToStringContractFunction3:  # type: ignore
        ...

    @overload
    def __call__(self, value: int) -> VmToStringContractFunction4:  # type: ignore
        ...

    @overload
    def __call__(self, value: bytes) -> VmToStringContractFunction5:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmToStringContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmToStringContractFunction0._type_signature: VmToStringContractFunction0,
            VmToStringContractFunction1._type_signature: VmToStringContractFunction1,
            VmToStringContractFunction2._type_signature: VmToStringContractFunction2,
            VmToStringContractFunction3._type_signature: VmToStringContractFunction3,
            VmToStringContractFunction4._type_signature: VmToStringContractFunction4,
            VmToStringContractFunction5._type_signature: VmToStringContractFunction5,
        }
        return out


class VmToUppercaseContractFunction0(PypechainContractFunction):
    """ContractFunction for the toUppercase(str) method."""

    _function_name = "toUppercase"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmToUppercaseContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the toUppercase method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "toUppercase"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str) -> VmToUppercaseContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmToUppercaseContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmToUppercaseContractFunction0._type_signature: VmToUppercaseContractFunction0,
        }
        return out


class VmTransactContractFunction0(PypechainContractFunction):
    """ContractFunction for the transact(int,bytes) method."""

    _function_name = "transact"
    _type_signature = expand_struct_type_str(tuple(["int", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmTransactContractFunction1(PypechainContractFunction):
    """ContractFunction for the transact(bytes) method."""

    _function_name = "transact"
    _type_signature = expand_struct_type_str(tuple(["bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmTransactContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transact method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transact"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, forkId: int, txHash: bytes) -> VmTransactContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, txHash: bytes) -> VmTransactContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmTransactContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmTransactContractFunction0._type_signature: VmTransactContractFunction0,
            VmTransactContractFunction1._type_signature: VmTransactContractFunction1,
        }
        return out


class VmTrimContractFunction0(PypechainContractFunction):
    """ContractFunction for the trim(str) method."""

    _function_name = "trim"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class VmTrimContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the trim method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "trim"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _input: str) -> VmTrimContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmTrimContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmTrimContractFunction0._type_signature: VmTrimContractFunction0,
        }
        return out


class VmTryFfiContractFunction0(PypechainContractFunction):
    """ContractFunction for the tryFfi(list[str]) method."""

    _function_name = "tryFfi"
    _type_signature = expand_struct_type_str(tuple(["list[str]"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> VmSafe.FfiResult:
        """returns VmSafe.FfiResult."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = VmSafe.FfiResult

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            VmSafe.FfiResult,
            rename_returned_types(structs, return_types, raw_values),
        )


class VmTryFfiContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the tryFfi method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "tryFfi"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, commandInput: list[str]) -> VmTryFfiContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmTryFfiContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmTryFfiContractFunction0._type_signature: VmTryFfiContractFunction0,
        }
        return out


class VmTxGasPriceContractFunction0(PypechainContractFunction):
    """ContractFunction for the txGasPrice(int) method."""

    _function_name = "txGasPrice"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmTxGasPriceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the txGasPrice method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "txGasPrice"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newGasPrice: int) -> VmTxGasPriceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmTxGasPriceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmTxGasPriceContractFunction0._type_signature: VmTxGasPriceContractFunction0,
        }
        return out


class VmUnixTimeContractFunction0(PypechainContractFunction):
    """ContractFunction for the unixTime() method."""

    _function_name = "unixTime"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class VmUnixTimeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the unixTime method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "unixTime"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> VmUnixTimeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmUnixTimeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmUnixTimeContractFunction0._type_signature: VmUnixTimeContractFunction0,
        }
        return out


class VmWarpContractFunction0(PypechainContractFunction):
    """ContractFunction for the warp(int) method."""

    _function_name = "warp"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWarpContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the warp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "warp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, newTimestamp: int) -> VmWarpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmWarpContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmWarpContractFunction0._type_signature: VmWarpContractFunction0,
        }
        return out


class VmWriteFileContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeFile(str,str) method."""

    _function_name = "writeFile"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWriteFileContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeFile method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeFile"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, data: str) -> VmWriteFileContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmWriteFileContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmWriteFileContractFunction0._type_signature: VmWriteFileContractFunction0,
        }
        return out


class VmWriteFileBinaryContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeFileBinary(str,bytes) method."""

    _function_name = "writeFileBinary"
    _type_signature = expand_struct_type_str(tuple(["str", "bytes"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWriteFileBinaryContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeFileBinary method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeFileBinary"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, data: bytes) -> VmWriteFileBinaryContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmWriteFileBinaryContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmWriteFileBinaryContractFunction0._type_signature: VmWriteFileBinaryContractFunction0,
        }
        return out


class VmWriteJsonContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeJson(str,str,str) method."""

    _function_name = "writeJson"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWriteJsonContractFunction1(PypechainContractFunction):
    """ContractFunction for the writeJson(str,str) method."""

    _function_name = "writeJson"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWriteJsonContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeJson method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeJson"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, path: str, valueKey: str) -> VmWriteJsonContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, json: str, path: str) -> VmWriteJsonContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmWriteJsonContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmWriteJsonContractFunction0._type_signature: VmWriteJsonContractFunction0,
            VmWriteJsonContractFunction1._type_signature: VmWriteJsonContractFunction1,
        }
        return out


class VmWriteLineContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeLine(str,str) method."""

    _function_name = "writeLine"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWriteLineContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeLine method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeLine"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, path: str, data: str) -> VmWriteLineContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmWriteLineContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmWriteLineContractFunction0._type_signature: VmWriteLineContractFunction0,
        }
        return out


class VmWriteTomlContractFunction0(PypechainContractFunction):
    """ContractFunction for the writeToml(str,str,str) method."""

    _function_name = "writeToml"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWriteTomlContractFunction1(PypechainContractFunction):
    """ContractFunction for the writeToml(str,str) method."""

    _function_name = "writeToml"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = VmContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class VmWriteTomlContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the writeToml method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "writeToml"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, json: str, path: str, valueKey: str) -> VmWriteTomlContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, json: str, path: str) -> VmWriteTomlContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> VmWriteTomlContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            VmWriteTomlContractFunction0._type_signature: VmWriteTomlContractFunction0,
            VmWriteTomlContractFunction1._type_signature: VmWriteTomlContractFunction1,
        }
        return out


class VmContractFunctions(ContractFunctions):
    """ContractFunctions for the Vm contract."""

    accesses: VmAccessesContractFunction

    activeFork: VmActiveForkContractFunction

    addr: VmAddrContractFunction

    allowCheatcodes: VmAllowCheatcodesContractFunction

    assertApproxEqAbs: VmAssertApproxEqAbsContractFunction

    assertApproxEqAbsDecimal: VmAssertApproxEqAbsDecimalContractFunction

    assertApproxEqRel: VmAssertApproxEqRelContractFunction

    assertApproxEqRelDecimal: VmAssertApproxEqRelDecimalContractFunction

    assertEq: VmAssertEqContractFunction

    assertEqDecimal: VmAssertEqDecimalContractFunction

    assertFalse: VmAssertFalseContractFunction

    assertGe: VmAssertGeContractFunction

    assertGeDecimal: VmAssertGeDecimalContractFunction

    assertGt: VmAssertGtContractFunction

    assertGtDecimal: VmAssertGtDecimalContractFunction

    assertLe: VmAssertLeContractFunction

    assertLeDecimal: VmAssertLeDecimalContractFunction

    assertLt: VmAssertLtContractFunction

    assertLtDecimal: VmAssertLtDecimalContractFunction

    assertNotEq: VmAssertNotEqContractFunction

    assertNotEqDecimal: VmAssertNotEqDecimalContractFunction

    assertTrue: VmAssertTrueContractFunction

    assume: VmAssumeContractFunction

    breakpoint: VmBreakpointContractFunction

    broadcast: VmBroadcastContractFunction

    chainId: VmChainIdContractFunction

    clearMockedCalls: VmClearMockedCallsContractFunction

    closeFile: VmCloseFileContractFunction

    coinbase: VmCoinbaseContractFunction

    computeCreate2Address: VmComputeCreate2AddressContractFunction

    computeCreateAddress: VmComputeCreateAddressContractFunction

    copyFile: VmCopyFileContractFunction

    createDir: VmCreateDirContractFunction

    createFork: VmCreateForkContractFunction

    createSelectFork: VmCreateSelectForkContractFunction

    createWallet: VmCreateWalletContractFunction

    deal: VmDealContractFunction

    deleteSnapshot: VmDeleteSnapshotContractFunction

    deleteSnapshots: VmDeleteSnapshotsContractFunction

    deriveKey: VmDeriveKeyContractFunction

    difficulty: VmDifficultyContractFunction

    dumpState: VmDumpStateContractFunction

    envAddress: VmEnvAddressContractFunction

    envBool: VmEnvBoolContractFunction

    envBytes: VmEnvBytesContractFunction

    envBytes32: VmEnvBytes32ContractFunction

    envInt: VmEnvIntContractFunction

    envOr: VmEnvOrContractFunction

    envString: VmEnvStringContractFunction

    envUint: VmEnvUintContractFunction

    etch: VmEtchContractFunction

    eth_getLogs: VmEth_getLogsContractFunction

    exists: VmExistsContractFunction

    expectCall: VmExpectCallContractFunction

    expectCallMinGas: VmExpectCallMinGasContractFunction

    expectEmit: VmExpectEmitContractFunction

    expectRevert: VmExpectRevertContractFunction

    expectSafeMemory: VmExpectSafeMemoryContractFunction

    expectSafeMemoryCall: VmExpectSafeMemoryCallContractFunction

    fee: VmFeeContractFunction

    ffi: VmFfiContractFunction

    fsMetadata: VmFsMetadataContractFunction

    getBlockNumber: VmGetBlockNumberContractFunction

    getBlockTimestamp: VmGetBlockTimestampContractFunction

    getCode: VmGetCodeContractFunction

    getDeployedCode: VmGetDeployedCodeContractFunction

    getLabel: VmGetLabelContractFunction

    getMappingKeyAndParentOf: VmGetMappingKeyAndParentOfContractFunction

    getMappingLength: VmGetMappingLengthContractFunction

    getMappingSlotAt: VmGetMappingSlotAtContractFunction

    getNonce: VmGetNonceContractFunction

    getRecordedLogs: VmGetRecordedLogsContractFunction

    isDir: VmIsDirContractFunction

    isFile: VmIsFileContractFunction

    isPersistent: VmIsPersistentContractFunction

    keyExists: VmKeyExistsContractFunction

    keyExistsJson: VmKeyExistsJsonContractFunction

    keyExistsToml: VmKeyExistsTomlContractFunction

    label: VmLabelContractFunction

    load: VmLoadContractFunction

    loadAllocs: VmLoadAllocsContractFunction

    makePersistent: VmMakePersistentContractFunction

    mockCall: VmMockCallContractFunction

    mockCallRevert: VmMockCallRevertContractFunction

    parseAddress: VmParseAddressContractFunction

    parseBool: VmParseBoolContractFunction

    parseBytes: VmParseBytesContractFunction

    parseBytes32: VmParseBytes32ContractFunction

    parseInt: VmParseIntContractFunction

    parseJson: VmParseJsonContractFunction

    parseJsonAddress: VmParseJsonAddressContractFunction

    parseJsonAddressArray: VmParseJsonAddressArrayContractFunction

    parseJsonBool: VmParseJsonBoolContractFunction

    parseJsonBoolArray: VmParseJsonBoolArrayContractFunction

    parseJsonBytes: VmParseJsonBytesContractFunction

    parseJsonBytes32: VmParseJsonBytes32ContractFunction

    parseJsonBytes32Array: VmParseJsonBytes32ArrayContractFunction

    parseJsonBytesArray: VmParseJsonBytesArrayContractFunction

    parseJsonInt: VmParseJsonIntContractFunction

    parseJsonIntArray: VmParseJsonIntArrayContractFunction

    parseJsonKeys: VmParseJsonKeysContractFunction

    parseJsonString: VmParseJsonStringContractFunction

    parseJsonStringArray: VmParseJsonStringArrayContractFunction

    parseJsonUint: VmParseJsonUintContractFunction

    parseJsonUintArray: VmParseJsonUintArrayContractFunction

    parseToml: VmParseTomlContractFunction

    parseTomlAddress: VmParseTomlAddressContractFunction

    parseTomlAddressArray: VmParseTomlAddressArrayContractFunction

    parseTomlBool: VmParseTomlBoolContractFunction

    parseTomlBoolArray: VmParseTomlBoolArrayContractFunction

    parseTomlBytes: VmParseTomlBytesContractFunction

    parseTomlBytes32: VmParseTomlBytes32ContractFunction

    parseTomlBytes32Array: VmParseTomlBytes32ArrayContractFunction

    parseTomlBytesArray: VmParseTomlBytesArrayContractFunction

    parseTomlInt: VmParseTomlIntContractFunction

    parseTomlIntArray: VmParseTomlIntArrayContractFunction

    parseTomlKeys: VmParseTomlKeysContractFunction

    parseTomlString: VmParseTomlStringContractFunction

    parseTomlStringArray: VmParseTomlStringArrayContractFunction

    parseTomlUint: VmParseTomlUintContractFunction

    parseTomlUintArray: VmParseTomlUintArrayContractFunction

    parseUint: VmParseUintContractFunction

    pauseGasMetering: VmPauseGasMeteringContractFunction

    prank: VmPrankContractFunction

    prevrandao: VmPrevrandaoContractFunction

    projectRoot: VmProjectRootContractFunction

    readCallers: VmReadCallersContractFunction

    readDir: VmReadDirContractFunction

    readFile: VmReadFileContractFunction

    readFileBinary: VmReadFileBinaryContractFunction

    readLine: VmReadLineContractFunction

    readLink: VmReadLinkContractFunction

    record: VmRecordContractFunction

    recordLogs: VmRecordLogsContractFunction

    rememberKey: VmRememberKeyContractFunction

    removeDir: VmRemoveDirContractFunction

    removeFile: VmRemoveFileContractFunction

    replace: VmReplaceContractFunction

    resetNonce: VmResetNonceContractFunction

    resumeGasMetering: VmResumeGasMeteringContractFunction

    revertTo: VmRevertToContractFunction

    revertToAndDelete: VmRevertToAndDeleteContractFunction

    revokePersistent: VmRevokePersistentContractFunction

    roll: VmRollContractFunction

    rollFork: VmRollForkContractFunction

    rpc: VmRpcContractFunction

    rpcUrl: VmRpcUrlContractFunction

    rpcUrlStructs: VmRpcUrlStructsContractFunction

    rpcUrls: VmRpcUrlsContractFunction

    selectFork: VmSelectForkContractFunction

    serializeAddress: VmSerializeAddressContractFunction

    serializeBool: VmSerializeBoolContractFunction

    serializeBytes: VmSerializeBytesContractFunction

    serializeBytes32: VmSerializeBytes32ContractFunction

    serializeInt: VmSerializeIntContractFunction

    serializeJson: VmSerializeJsonContractFunction

    serializeString: VmSerializeStringContractFunction

    serializeUint: VmSerializeUintContractFunction

    setEnv: VmSetEnvContractFunction

    setNonce: VmSetNonceContractFunction

    setNonceUnsafe: VmSetNonceUnsafeContractFunction

    sign: VmSignContractFunction

    signP256: VmSignP256ContractFunction

    skip: VmSkipContractFunction

    sleep: VmSleepContractFunction

    snapshot: VmSnapshotContractFunction

    split: VmSplitContractFunction

    startBroadcast: VmStartBroadcastContractFunction

    startMappingRecording: VmStartMappingRecordingContractFunction

    startPrank: VmStartPrankContractFunction

    startStateDiffRecording: VmStartStateDiffRecordingContractFunction

    stopAndReturnStateDiff: VmStopAndReturnStateDiffContractFunction

    stopBroadcast: VmStopBroadcastContractFunction

    stopExpectSafeMemory: VmStopExpectSafeMemoryContractFunction

    stopMappingRecording: VmStopMappingRecordingContractFunction

    stopPrank: VmStopPrankContractFunction

    store: VmStoreContractFunction

    toBase64: VmToBase64ContractFunction

    toBase64URL: VmToBase64URLContractFunction

    toLowercase: VmToLowercaseContractFunction

    toString: VmToStringContractFunction

    toUppercase: VmToUppercaseContractFunction

    transact: VmTransactContractFunction

    trim: VmTrimContractFunction

    tryFfi: VmTryFfiContractFunction

    txGasPrice: VmTxGasPriceContractFunction

    unixTime: VmUnixTimeContractFunction

    warp: VmWarpContractFunction

    writeFile: VmWriteFileContractFunction

    writeFileBinary: VmWriteFileBinaryContractFunction

    writeJson: VmWriteJsonContractFunction

    writeLine: VmWriteLineContractFunction

    writeToml: VmWriteTomlContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.accesses = VmAccessesContractFunction.factory(
            "accesses",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="accesses",
        )
        self.activeFork = VmActiveForkContractFunction.factory(
            "activeFork",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="activeFork",
        )
        self.addr = VmAddrContractFunction.factory(
            "addr",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="addr",
        )
        self.allowCheatcodes = VmAllowCheatcodesContractFunction.factory(
            "allowCheatcodes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="allowCheatcodes",
        )
        self.assertApproxEqAbs = VmAssertApproxEqAbsContractFunction.factory(
            "assertApproxEqAbs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertApproxEqAbs",
        )
        self.assertApproxEqAbsDecimal = (
            VmAssertApproxEqAbsDecimalContractFunction.factory(
                "assertApproxEqAbsDecimal",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="assertApproxEqAbsDecimal",
            )
        )
        self.assertApproxEqRel = VmAssertApproxEqRelContractFunction.factory(
            "assertApproxEqRel",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertApproxEqRel",
        )
        self.assertApproxEqRelDecimal = (
            VmAssertApproxEqRelDecimalContractFunction.factory(
                "assertApproxEqRelDecimal",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="assertApproxEqRelDecimal",
            )
        )
        self.assertEq = VmAssertEqContractFunction.factory(
            "assertEq",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertEq",
        )
        self.assertEqDecimal = VmAssertEqDecimalContractFunction.factory(
            "assertEqDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertEqDecimal",
        )
        self.assertFalse = VmAssertFalseContractFunction.factory(
            "assertFalse",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertFalse",
        )
        self.assertGe = VmAssertGeContractFunction.factory(
            "assertGe",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGe",
        )
        self.assertGeDecimal = VmAssertGeDecimalContractFunction.factory(
            "assertGeDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGeDecimal",
        )
        self.assertGt = VmAssertGtContractFunction.factory(
            "assertGt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGt",
        )
        self.assertGtDecimal = VmAssertGtDecimalContractFunction.factory(
            "assertGtDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertGtDecimal",
        )
        self.assertLe = VmAssertLeContractFunction.factory(
            "assertLe",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLe",
        )
        self.assertLeDecimal = VmAssertLeDecimalContractFunction.factory(
            "assertLeDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLeDecimal",
        )
        self.assertLt = VmAssertLtContractFunction.factory(
            "assertLt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLt",
        )
        self.assertLtDecimal = VmAssertLtDecimalContractFunction.factory(
            "assertLtDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertLtDecimal",
        )
        self.assertNotEq = VmAssertNotEqContractFunction.factory(
            "assertNotEq",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertNotEq",
        )
        self.assertNotEqDecimal = VmAssertNotEqDecimalContractFunction.factory(
            "assertNotEqDecimal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertNotEqDecimal",
        )
        self.assertTrue = VmAssertTrueContractFunction.factory(
            "assertTrue",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assertTrue",
        )
        self.assume = VmAssumeContractFunction.factory(
            "assume",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="assume",
        )
        self.breakpoint = VmBreakpointContractFunction.factory(
            "breakpoint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="breakpoint",
        )
        self.broadcast = VmBroadcastContractFunction.factory(
            "broadcast",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="broadcast",
        )
        self.chainId = VmChainIdContractFunction.factory(
            "chainId",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="chainId",
        )
        self.clearMockedCalls = VmClearMockedCallsContractFunction.factory(
            "clearMockedCalls",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="clearMockedCalls",
        )
        self.closeFile = VmCloseFileContractFunction.factory(
            "closeFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="closeFile",
        )
        self.coinbase = VmCoinbaseContractFunction.factory(
            "coinbase",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="coinbase",
        )
        self.computeCreate2Address = (
            VmComputeCreate2AddressContractFunction.factory(
                "computeCreate2Address",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="computeCreate2Address",
            )
        )
        self.computeCreateAddress = (
            VmComputeCreateAddressContractFunction.factory(
                "computeCreateAddress",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="computeCreateAddress",
            )
        )
        self.copyFile = VmCopyFileContractFunction.factory(
            "copyFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="copyFile",
        )
        self.createDir = VmCreateDirContractFunction.factory(
            "createDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="createDir",
        )
        self.createFork = VmCreateForkContractFunction.factory(
            "createFork",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="createFork",
        )
        self.createSelectFork = VmCreateSelectForkContractFunction.factory(
            "createSelectFork",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="createSelectFork",
        )
        self.createWallet = VmCreateWalletContractFunction.factory(
            "createWallet",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="createWallet",
        )
        self.deal = VmDealContractFunction.factory(
            "deal",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deal",
        )
        self.deleteSnapshot = VmDeleteSnapshotContractFunction.factory(
            "deleteSnapshot",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deleteSnapshot",
        )
        self.deleteSnapshots = VmDeleteSnapshotsContractFunction.factory(
            "deleteSnapshots",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deleteSnapshots",
        )
        self.deriveKey = VmDeriveKeyContractFunction.factory(
            "deriveKey",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deriveKey",
        )
        self.difficulty = VmDifficultyContractFunction.factory(
            "difficulty",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="difficulty",
        )
        self.dumpState = VmDumpStateContractFunction.factory(
            "dumpState",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="dumpState",
        )
        self.envAddress = VmEnvAddressContractFunction.factory(
            "envAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envAddress",
        )
        self.envBool = VmEnvBoolContractFunction.factory(
            "envBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envBool",
        )
        self.envBytes = VmEnvBytesContractFunction.factory(
            "envBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envBytes",
        )
        self.envBytes32 = VmEnvBytes32ContractFunction.factory(
            "envBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envBytes32",
        )
        self.envInt = VmEnvIntContractFunction.factory(
            "envInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envInt",
        )
        self.envOr = VmEnvOrContractFunction.factory(
            "envOr",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envOr",
        )
        self.envString = VmEnvStringContractFunction.factory(
            "envString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envString",
        )
        self.envUint = VmEnvUintContractFunction.factory(
            "envUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="envUint",
        )
        self.etch = VmEtchContractFunction.factory(
            "etch",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="etch",
        )
        self.eth_getLogs = VmEth_getLogsContractFunction.factory(
            "eth_getLogs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="eth_getLogs",
        )
        self.exists = VmExistsContractFunction.factory(
            "exists",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="exists",
        )
        self.expectCall = VmExpectCallContractFunction.factory(
            "expectCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="expectCall",
        )
        self.expectCallMinGas = VmExpectCallMinGasContractFunction.factory(
            "expectCallMinGas",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="expectCallMinGas",
        )
        self.expectEmit = VmExpectEmitContractFunction.factory(
            "expectEmit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="expectEmit",
        )
        self.expectRevert = VmExpectRevertContractFunction.factory(
            "expectRevert",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="expectRevert",
        )
        self.expectSafeMemory = VmExpectSafeMemoryContractFunction.factory(
            "expectSafeMemory",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="expectSafeMemory",
        )
        self.expectSafeMemoryCall = (
            VmExpectSafeMemoryCallContractFunction.factory(
                "expectSafeMemoryCall",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="expectSafeMemoryCall",
            )
        )
        self.fee = VmFeeContractFunction.factory(
            "fee",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="fee",
        )
        self.ffi = VmFfiContractFunction.factory(
            "ffi",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="ffi",
        )
        self.fsMetadata = VmFsMetadataContractFunction.factory(
            "fsMetadata",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="fsMetadata",
        )
        self.getBlockNumber = VmGetBlockNumberContractFunction.factory(
            "getBlockNumber",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBlockNumber",
        )
        self.getBlockTimestamp = VmGetBlockTimestampContractFunction.factory(
            "getBlockTimestamp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getBlockTimestamp",
        )
        self.getCode = VmGetCodeContractFunction.factory(
            "getCode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getCode",
        )
        self.getDeployedCode = VmGetDeployedCodeContractFunction.factory(
            "getDeployedCode",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getDeployedCode",
        )
        self.getLabel = VmGetLabelContractFunction.factory(
            "getLabel",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getLabel",
        )
        self.getMappingKeyAndParentOf = (
            VmGetMappingKeyAndParentOfContractFunction.factory(
                "getMappingKeyAndParentOf",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="getMappingKeyAndParentOf",
            )
        )
        self.getMappingLength = VmGetMappingLengthContractFunction.factory(
            "getMappingLength",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getMappingLength",
        )
        self.getMappingSlotAt = VmGetMappingSlotAtContractFunction.factory(
            "getMappingSlotAt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getMappingSlotAt",
        )
        self.getNonce = VmGetNonceContractFunction.factory(
            "getNonce",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getNonce",
        )
        self.getRecordedLogs = VmGetRecordedLogsContractFunction.factory(
            "getRecordedLogs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="getRecordedLogs",
        )
        self.isDir = VmIsDirContractFunction.factory(
            "isDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isDir",
        )
        self.isFile = VmIsFileContractFunction.factory(
            "isFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isFile",
        )
        self.isPersistent = VmIsPersistentContractFunction.factory(
            "isPersistent",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isPersistent",
        )
        self.keyExists = VmKeyExistsContractFunction.factory(
            "keyExists",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="keyExists",
        )
        self.keyExistsJson = VmKeyExistsJsonContractFunction.factory(
            "keyExistsJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="keyExistsJson",
        )
        self.keyExistsToml = VmKeyExistsTomlContractFunction.factory(
            "keyExistsToml",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="keyExistsToml",
        )
        self.label = VmLabelContractFunction.factory(
            "label",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="label",
        )
        self.load = VmLoadContractFunction.factory(
            "load",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="load",
        )
        self.loadAllocs = VmLoadAllocsContractFunction.factory(
            "loadAllocs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="loadAllocs",
        )
        self.makePersistent = VmMakePersistentContractFunction.factory(
            "makePersistent",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="makePersistent",
        )
        self.mockCall = VmMockCallContractFunction.factory(
            "mockCall",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mockCall",
        )
        self.mockCallRevert = VmMockCallRevertContractFunction.factory(
            "mockCallRevert",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mockCallRevert",
        )
        self.parseAddress = VmParseAddressContractFunction.factory(
            "parseAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseAddress",
        )
        self.parseBool = VmParseBoolContractFunction.factory(
            "parseBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseBool",
        )
        self.parseBytes = VmParseBytesContractFunction.factory(
            "parseBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseBytes",
        )
        self.parseBytes32 = VmParseBytes32ContractFunction.factory(
            "parseBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseBytes32",
        )
        self.parseInt = VmParseIntContractFunction.factory(
            "parseInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseInt",
        )
        self.parseJson = VmParseJsonContractFunction.factory(
            "parseJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJson",
        )
        self.parseJsonAddress = VmParseJsonAddressContractFunction.factory(
            "parseJsonAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonAddress",
        )
        self.parseJsonAddressArray = (
            VmParseJsonAddressArrayContractFunction.factory(
                "parseJsonAddressArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonAddressArray",
            )
        )
        self.parseJsonBool = VmParseJsonBoolContractFunction.factory(
            "parseJsonBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonBool",
        )
        self.parseJsonBoolArray = VmParseJsonBoolArrayContractFunction.factory(
            "parseJsonBoolArray",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonBoolArray",
        )
        self.parseJsonBytes = VmParseJsonBytesContractFunction.factory(
            "parseJsonBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonBytes",
        )
        self.parseJsonBytes32 = VmParseJsonBytes32ContractFunction.factory(
            "parseJsonBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonBytes32",
        )
        self.parseJsonBytes32Array = (
            VmParseJsonBytes32ArrayContractFunction.factory(
                "parseJsonBytes32Array",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonBytes32Array",
            )
        )
        self.parseJsonBytesArray = (
            VmParseJsonBytesArrayContractFunction.factory(
                "parseJsonBytesArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonBytesArray",
            )
        )
        self.parseJsonInt = VmParseJsonIntContractFunction.factory(
            "parseJsonInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonInt",
        )
        self.parseJsonIntArray = VmParseJsonIntArrayContractFunction.factory(
            "parseJsonIntArray",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonIntArray",
        )
        self.parseJsonKeys = VmParseJsonKeysContractFunction.factory(
            "parseJsonKeys",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonKeys",
        )
        self.parseJsonString = VmParseJsonStringContractFunction.factory(
            "parseJsonString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonString",
        )
        self.parseJsonStringArray = (
            VmParseJsonStringArrayContractFunction.factory(
                "parseJsonStringArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseJsonStringArray",
            )
        )
        self.parseJsonUint = VmParseJsonUintContractFunction.factory(
            "parseJsonUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonUint",
        )
        self.parseJsonUintArray = VmParseJsonUintArrayContractFunction.factory(
            "parseJsonUintArray",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseJsonUintArray",
        )
        self.parseToml = VmParseTomlContractFunction.factory(
            "parseToml",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseToml",
        )
        self.parseTomlAddress = VmParseTomlAddressContractFunction.factory(
            "parseTomlAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlAddress",
        )
        self.parseTomlAddressArray = (
            VmParseTomlAddressArrayContractFunction.factory(
                "parseTomlAddressArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlAddressArray",
            )
        )
        self.parseTomlBool = VmParseTomlBoolContractFunction.factory(
            "parseTomlBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlBool",
        )
        self.parseTomlBoolArray = VmParseTomlBoolArrayContractFunction.factory(
            "parseTomlBoolArray",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlBoolArray",
        )
        self.parseTomlBytes = VmParseTomlBytesContractFunction.factory(
            "parseTomlBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlBytes",
        )
        self.parseTomlBytes32 = VmParseTomlBytes32ContractFunction.factory(
            "parseTomlBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlBytes32",
        )
        self.parseTomlBytes32Array = (
            VmParseTomlBytes32ArrayContractFunction.factory(
                "parseTomlBytes32Array",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlBytes32Array",
            )
        )
        self.parseTomlBytesArray = (
            VmParseTomlBytesArrayContractFunction.factory(
                "parseTomlBytesArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlBytesArray",
            )
        )
        self.parseTomlInt = VmParseTomlIntContractFunction.factory(
            "parseTomlInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlInt",
        )
        self.parseTomlIntArray = VmParseTomlIntArrayContractFunction.factory(
            "parseTomlIntArray",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlIntArray",
        )
        self.parseTomlKeys = VmParseTomlKeysContractFunction.factory(
            "parseTomlKeys",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlKeys",
        )
        self.parseTomlString = VmParseTomlStringContractFunction.factory(
            "parseTomlString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlString",
        )
        self.parseTomlStringArray = (
            VmParseTomlStringArrayContractFunction.factory(
                "parseTomlStringArray",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="parseTomlStringArray",
            )
        )
        self.parseTomlUint = VmParseTomlUintContractFunction.factory(
            "parseTomlUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlUint",
        )
        self.parseTomlUintArray = VmParseTomlUintArrayContractFunction.factory(
            "parseTomlUintArray",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseTomlUintArray",
        )
        self.parseUint = VmParseUintContractFunction.factory(
            "parseUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="parseUint",
        )
        self.pauseGasMetering = VmPauseGasMeteringContractFunction.factory(
            "pauseGasMetering",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="pauseGasMetering",
        )
        self.prank = VmPrankContractFunction.factory(
            "prank",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="prank",
        )
        self.prevrandao = VmPrevrandaoContractFunction.factory(
            "prevrandao",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="prevrandao",
        )
        self.projectRoot = VmProjectRootContractFunction.factory(
            "projectRoot",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="projectRoot",
        )
        self.readCallers = VmReadCallersContractFunction.factory(
            "readCallers",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readCallers",
        )
        self.readDir = VmReadDirContractFunction.factory(
            "readDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readDir",
        )
        self.readFile = VmReadFileContractFunction.factory(
            "readFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readFile",
        )
        self.readFileBinary = VmReadFileBinaryContractFunction.factory(
            "readFileBinary",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readFileBinary",
        )
        self.readLine = VmReadLineContractFunction.factory(
            "readLine",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readLine",
        )
        self.readLink = VmReadLinkContractFunction.factory(
            "readLink",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="readLink",
        )
        self.record = VmRecordContractFunction.factory(
            "record",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="record",
        )
        self.recordLogs = VmRecordLogsContractFunction.factory(
            "recordLogs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="recordLogs",
        )
        self.rememberKey = VmRememberKeyContractFunction.factory(
            "rememberKey",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rememberKey",
        )
        self.removeDir = VmRemoveDirContractFunction.factory(
            "removeDir",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="removeDir",
        )
        self.removeFile = VmRemoveFileContractFunction.factory(
            "removeFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="removeFile",
        )
        self.replace = VmReplaceContractFunction.factory(
            "replace",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="replace",
        )
        self.resetNonce = VmResetNonceContractFunction.factory(
            "resetNonce",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="resetNonce",
        )
        self.resumeGasMetering = VmResumeGasMeteringContractFunction.factory(
            "resumeGasMetering",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="resumeGasMetering",
        )
        self.revertTo = VmRevertToContractFunction.factory(
            "revertTo",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="revertTo",
        )
        self.revertToAndDelete = VmRevertToAndDeleteContractFunction.factory(
            "revertToAndDelete",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="revertToAndDelete",
        )
        self.revokePersistent = VmRevokePersistentContractFunction.factory(
            "revokePersistent",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="revokePersistent",
        )
        self.roll = VmRollContractFunction.factory(
            "roll",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="roll",
        )
        self.rollFork = VmRollForkContractFunction.factory(
            "rollFork",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rollFork",
        )
        self.rpc = VmRpcContractFunction.factory(
            "rpc",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpc",
        )
        self.rpcUrl = VmRpcUrlContractFunction.factory(
            "rpcUrl",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpcUrl",
        )
        self.rpcUrlStructs = VmRpcUrlStructsContractFunction.factory(
            "rpcUrlStructs",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpcUrlStructs",
        )
        self.rpcUrls = VmRpcUrlsContractFunction.factory(
            "rpcUrls",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="rpcUrls",
        )
        self.selectFork = VmSelectForkContractFunction.factory(
            "selectFork",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="selectFork",
        )
        self.serializeAddress = VmSerializeAddressContractFunction.factory(
            "serializeAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeAddress",
        )
        self.serializeBool = VmSerializeBoolContractFunction.factory(
            "serializeBool",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeBool",
        )
        self.serializeBytes = VmSerializeBytesContractFunction.factory(
            "serializeBytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeBytes",
        )
        self.serializeBytes32 = VmSerializeBytes32ContractFunction.factory(
            "serializeBytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeBytes32",
        )
        self.serializeInt = VmSerializeIntContractFunction.factory(
            "serializeInt",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeInt",
        )
        self.serializeJson = VmSerializeJsonContractFunction.factory(
            "serializeJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeJson",
        )
        self.serializeString = VmSerializeStringContractFunction.factory(
            "serializeString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeString",
        )
        self.serializeUint = VmSerializeUintContractFunction.factory(
            "serializeUint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="serializeUint",
        )
        self.setEnv = VmSetEnvContractFunction.factory(
            "setEnv",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setEnv",
        )
        self.setNonce = VmSetNonceContractFunction.factory(
            "setNonce",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setNonce",
        )
        self.setNonceUnsafe = VmSetNonceUnsafeContractFunction.factory(
            "setNonceUnsafe",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setNonceUnsafe",
        )
        self.sign = VmSignContractFunction.factory(
            "sign",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sign",
        )
        self.signP256 = VmSignP256ContractFunction.factory(
            "signP256",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="signP256",
        )
        self.skip = VmSkipContractFunction.factory(
            "skip",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="skip",
        )
        self.sleep = VmSleepContractFunction.factory(
            "sleep",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="sleep",
        )
        self.snapshot = VmSnapshotContractFunction.factory(
            "snapshot",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="snapshot",
        )
        self.split = VmSplitContractFunction.factory(
            "split",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="split",
        )
        self.startBroadcast = VmStartBroadcastContractFunction.factory(
            "startBroadcast",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="startBroadcast",
        )
        self.startMappingRecording = (
            VmStartMappingRecordingContractFunction.factory(
                "startMappingRecording",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="startMappingRecording",
            )
        )
        self.startPrank = VmStartPrankContractFunction.factory(
            "startPrank",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="startPrank",
        )
        self.startStateDiffRecording = (
            VmStartStateDiffRecordingContractFunction.factory(
                "startStateDiffRecording",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="startStateDiffRecording",
            )
        )
        self.stopAndReturnStateDiff = (
            VmStopAndReturnStateDiffContractFunction.factory(
                "stopAndReturnStateDiff",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="stopAndReturnStateDiff",
            )
        )
        self.stopBroadcast = VmStopBroadcastContractFunction.factory(
            "stopBroadcast",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="stopBroadcast",
        )
        self.stopExpectSafeMemory = (
            VmStopExpectSafeMemoryContractFunction.factory(
                "stopExpectSafeMemory",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="stopExpectSafeMemory",
            )
        )
        self.stopMappingRecording = (
            VmStopMappingRecordingContractFunction.factory(
                "stopMappingRecording",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="stopMappingRecording",
            )
        )
        self.stopPrank = VmStopPrankContractFunction.factory(
            "stopPrank",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="stopPrank",
        )
        self.store = VmStoreContractFunction.factory(
            "store",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="store",
        )
        self.toBase64 = VmToBase64ContractFunction.factory(
            "toBase64",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toBase64",
        )
        self.toBase64URL = VmToBase64URLContractFunction.factory(
            "toBase64URL",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toBase64URL",
        )
        self.toLowercase = VmToLowercaseContractFunction.factory(
            "toLowercase",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toLowercase",
        )
        self.toString = VmToStringContractFunction.factory(
            "toString",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toString",
        )
        self.toUppercase = VmToUppercaseContractFunction.factory(
            "toUppercase",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="toUppercase",
        )
        self.transact = VmTransactContractFunction.factory(
            "transact",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transact",
        )
        self.trim = VmTrimContractFunction.factory(
            "trim",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="trim",
        )
        self.tryFfi = VmTryFfiContractFunction.factory(
            "tryFfi",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="tryFfi",
        )
        self.txGasPrice = VmTxGasPriceContractFunction.factory(
            "txGasPrice",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="txGasPrice",
        )
        self.unixTime = VmUnixTimeContractFunction.factory(
            "unixTime",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="unixTime",
        )
        self.warp = VmWarpContractFunction.factory(
            "warp",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="warp",
        )
        self.writeFile = VmWriteFileContractFunction.factory(
            "writeFile",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeFile",
        )
        self.writeFileBinary = VmWriteFileBinaryContractFunction.factory(
            "writeFileBinary",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeFileBinary",
        )
        self.writeJson = VmWriteJsonContractFunction.factory(
            "writeJson",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeJson",
        )
        self.writeLine = VmWriteLineContractFunction.factory(
            "writeLine",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeLine",
        )
        self.writeToml = VmWriteTomlContractFunction.factory(
            "writeToml",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="writeToml",
        )


class VmContract(Contract):
    """A web3.py Contract class for the Vm contract."""

    abi: ABI = vm_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = VmContractFunctions(vm_abi, self.w3, address)  # type: ignore

    functions: VmContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = VmContractFunctions(vm_abi, w3, None)

        return contract
