"""A web3.py Contract class for the HyperdriveCheckpointRewarderTest contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractEvent,
    ContractEvents,
    ContractFunctions,
)
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from ..StdInvariant import StdInvariantTypes as StdInvariant
from .HyperdriveCheckpointRewarderTestTypes import (
    AdminUpdatedEvent,
    CheckpointRewardClaimedEvent,
    Log_addressEvent,
    Log_arrayEvent,
    Log_bytes32Event,
    Log_bytesEvent,
    Log_intEvent,
    Log_named_addressEvent,
    Log_named_arrayEvent,
    Log_named_bytes32Event,
    Log_named_bytesEvent,
    Log_named_decimal_intEvent,
    Log_named_decimal_uintEvent,
    Log_named_intEvent,
    Log_named_stringEvent,
    Log_named_uintEvent,
    Log_stringEvent,
    Log_uintEvent,
    LogEvent,
    LogsEvent,
    SubrewarderUpdatedEvent,
)

structs = {
    "StdInvariant.FuzzSelector": StdInvariant.FuzzSelector,
    "StdInvariant.FuzzInterface": StdInvariant.FuzzInterface,
}

hyperdrivecheckpointrewardertest_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "IS_TEST",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "createUser",
            "inputs": [
                {"name": "_name", "type": "string", "internalType": "string"}
            ],
            "outputs": [
                {"name": "user", "type": "address", "internalType": "address"},
                {
                    "name": "privateKey",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "excludeArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "excludeSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "excludedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "failed",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setUp",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "targetArtifactSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifactSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetArtifacts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedArtifacts_",
                    "type": "string[]",
                    "internalType": "string[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetContracts",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedContracts_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetInterfaces",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedInterfaces_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzInterface[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "artifacts",
                            "type": "string[]",
                            "internalType": "string[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSelectors",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSelectors_",
                    "type": "tuple[]",
                    "internalType": "struct StdInvariant.FuzzSelector[]",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "selectors",
                            "type": "bytes4[]",
                            "internalType": "bytes4[]",
                        },
                    ],
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "targetSenders",
            "inputs": [],
            "outputs": [
                {
                    "name": "targetedSenders_",
                    "type": "address[]",
                    "internalType": "address[]",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "test_claimCheckpointReward_success_nonZeroAmount",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_claimCheckpointReward_success_zeroAmount",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateAdmin_failure_onlyAdmin",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateAdmin_success",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateSubrewarder_failure_onlyAdmin",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "test_updateSubrewarder_success",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "whaleTransfer",
            "inputs": [
                {"name": "whale", "type": "address", "internalType": "address"},
                {
                    "name": "token",
                    "type": "address",
                    "internalType": "contract IERC20",
                },
                {"name": "to", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "whaleTransfer",
            "inputs": [
                {"name": "whale", "type": "address", "internalType": "address"},
                {
                    "name": "token",
                    "type": "address",
                    "internalType": "contract IERC20",
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {"name": "to", "type": "address", "internalType": "address"},
            ],
            "outputs": [
                {"name": "", "type": "uint256", "internalType": "uint256"}
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "AdminUpdated",
            "inputs": [
                {
                    "name": "admin",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "CheckpointRewardClaimed",
            "inputs": [
                {
                    "name": "instance",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "claimant",
                    "type": "address",
                    "indexed": True,
                    "internalType": "address",
                },
                {
                    "name": "isTrader",
                    "type": "bool",
                    "indexed": True,
                    "internalType": "bool",
                },
                {
                    "name": "checkpointTime",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "rewardToken",
                    "type": "address",
                    "indexed": False,
                    "internalType": "contract IERC20",
                },
                {
                    "name": "rewardAmount",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "SubrewarderUpdated",
            "inputs": [
                {
                    "name": "subrewarder",
                    "type": "address",
                    "indexed": True,
                    "internalType": "contract IHyperdriveCheckpointSubrewarder",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_address",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_array",
            "inputs": [
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_bytes32",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_int",
            "inputs": [
                {
                    "name": "",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_address",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address",
                    "indexed": False,
                    "internalType": "address",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256[]",
                    "indexed": False,
                    "internalType": "uint256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256[]",
                    "indexed": False,
                    "internalType": "int256[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_array",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "address[]",
                    "indexed": False,
                    "internalType": "address[]",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_bytes32",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "bytes32",
                    "indexed": False,
                    "internalType": "bytes32",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_decimal_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
                {
                    "name": "decimals",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_int",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "int256",
                    "indexed": False,
                    "internalType": "int256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_string",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_named_uint",
            "inputs": [
                {
                    "name": "key",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                },
                {
                    "name": "val",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                },
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_string",
            "inputs": [
                {
                    "name": "",
                    "type": "string",
                    "indexed": False,
                    "internalType": "string",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "log_uint",
            "inputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "indexed": False,
                    "internalType": "uint256",
                }
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "logs",
            "inputs": [
                {
                    "name": "",
                    "type": "bytes",
                    "indexed": False,
                    "internalType": "bytes",
                }
            ],
            "anonymous": False,
        },
        {"type": "error", "name": "WhaleBalanceExceeded", "inputs": []},
        {"type": "error", "name": "WhaleIsContract", "inputs": []},
    ],
)


class HyperdriveCheckpointRewarderTestWhaleBalanceExceededContractError(
    PypechainBaseError
):
    """ContractError for WhaleBalanceExceeded."""

    # Error name
    name: str = "WhaleBalanceExceeded"
    # 4 byte error selector
    selector: str = "0xc4649d28"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "WhaleBalanceExceeded()"
    # Error input types
    abi: ABI = hyperdrivecheckpointrewardertest_abi


class HyperdriveCheckpointRewarderTestWhaleIsContractContractError(
    PypechainBaseError
):
    """ContractError for WhaleIsContract."""

    # Error name
    name: str = "WhaleIsContract"
    # 4 byte error selector
    selector: str = "0x98d85a67"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "WhaleIsContract()"
    # Error input types
    abi: ABI = hyperdrivecheckpointrewardertest_abi


class HyperdriveCheckpointRewarderTestContractErrors(
    PypechainBaseContractErrors
):
    """ContractErrors for the HyperdriveCheckpointRewarderTest contract."""

    WhaleBalanceExceeded: (
        HyperdriveCheckpointRewarderTestWhaleBalanceExceededContractError
    )

    WhaleIsContract: (
        HyperdriveCheckpointRewarderTestWhaleIsContractContractError
    )

    def __init__(
        self,
    ) -> None:
        self.WhaleBalanceExceeded = (
            HyperdriveCheckpointRewarderTestWhaleBalanceExceededContractError()
        )
        self.WhaleIsContract = (
            HyperdriveCheckpointRewarderTestWhaleIsContractContractError()
        )

        self._all = [
            self.WhaleBalanceExceeded,
            self.WhaleIsContract,
        ]


class HyperdriveCheckpointRewarderTestIS_TESTContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the IS_TEST() method."""

    _function_name = "IS_TEST"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestIS_TESTContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the IS_TEST method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "IS_TEST"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestIS_TESTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestIS_TESTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestIS_TESTContractFunction0._type_signature: HyperdriveCheckpointRewarderTestIS_TESTContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestCreateUserContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the createUser(str) method."""

    _function_name = "createUser"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for CreateUser."""

        user: str
        privateKey: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [str, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestCreateUserContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the createUser method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "createUser"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _name: str) -> HyperdriveCheckpointRewarderTestCreateUserContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestCreateUserContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestCreateUserContractFunction0._type_signature: HyperdriveCheckpointRewarderTestCreateUserContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeArtifacts() method."""

    _function_name = "excludeArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction0._type_signature: HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestExcludeContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeContracts() method."""

    _function_name = "excludeContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestExcludeContractsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestExcludeContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestExcludeContractsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestExcludeContractsContractFunction0._type_signature: HyperdriveCheckpointRewarderTestExcludeContractsContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestExcludeSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the excludeSenders() method."""

    _function_name = "excludeSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestExcludeSendersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the excludeSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "excludeSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestExcludeSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestExcludeSendersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestExcludeSendersContractFunction0._type_signature: HyperdriveCheckpointRewarderTestExcludeSendersContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestFailedContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the failed() method."""

    _function_name = "failed"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            bool, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestFailedContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the failed method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "failed"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestFailedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestFailedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestFailedContractFunction0._type_signature: HyperdriveCheckpointRewarderTestFailedContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestSetUpContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the setUp() method."""

    _function_name = "setUp"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveCheckpointRewarderTestSetUpContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the setUp method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setUp"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestSetUpContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestSetUpContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestSetUpContractFunction0._type_signature: HyperdriveCheckpointRewarderTestSetUpContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifactSelectors() method."""

    _function_name = "targetArtifactSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetArtifactSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifactSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetArtifacts() method."""

    _function_name = "targetArtifacts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetArtifacts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetArtifacts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTargetContractsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetContracts() method."""

    _function_name = "targetContracts"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestTargetContractsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetContracts method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetContracts"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTargetContractsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTargetContractsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTargetContractsContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTargetContractsContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetInterfaces() method."""

    _function_name = "targetInterfaces"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzInterface]:
        """returns list[StdInvariant.FuzzInterface]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzInterface]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzInterface],
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetInterfaces method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetInterfaces"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSelectors() method."""

    _function_name = "targetSelectors"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[StdInvariant.FuzzSelector]:
        """returns list[StdInvariant.FuzzSelector]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[StdInvariant.FuzzSelector]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[StdInvariant.FuzzSelector],
            rename_returned_types(structs, return_types, raw_values),
        )


class HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetSelectors method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSelectors"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTargetSendersContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the targetSenders() method."""

    _function_name = "targetSenders"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> list[str]:
        """returns list[str]."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = list[str]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            list[str], rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestTargetSendersContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the targetSenders method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "targetSenders"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTargetSendersContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTargetSendersContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTargetSendersContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTargetSendersContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_claimCheckpointReward_success_nonZeroAmount() method."""

    _function_name = "test_claimCheckpointReward_success_nonZeroAmount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_claimCheckpointReward_success_nonZeroAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_claimCheckpointReward_success_nonZeroAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_claimCheckpointReward_success_zeroAmount() method."""

    _function_name = "test_claimCheckpointReward_success_zeroAmount"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_claimCheckpointReward_success_zeroAmount method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_claimCheckpointReward_success_zeroAmount"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateAdmin_failure_onlyAdmin() method."""

    _function_name = "test_updateAdmin_failure_onlyAdmin"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_updateAdmin_failure_onlyAdmin method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateAdmin_failure_onlyAdmin"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateAdmin_success() method."""

    _function_name = "test_updateAdmin_success"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_updateAdmin_success method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateAdmin_success"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateSubrewarder_failure_onlyAdmin() method."""

    _function_name = "test_updateSubrewarder_failure_onlyAdmin"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_updateSubrewarder_failure_onlyAdmin method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateSubrewarder_failure_onlyAdmin"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the test_updateSubrewarder_success() method."""

    _function_name = "test_updateSubrewarder_success"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )


class HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the test_updateSubrewarder_success method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "test_updateSubrewarder_success"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction0._type_signature: HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction0,
        }
        return out


class HyperdriveCheckpointRewarderTestWhaleTransferContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the whaleTransfer(str,str,str) method."""

    _function_name = "whaleTransfer"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "str"]), structs
    )
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestWhaleTransferContractFunction1(
    PypechainContractFunction
):
    """ContractFunction for the whaleTransfer(str,str,int,str) method."""

    _function_name = "whaleTransfer"
    _type_signature = expand_struct_type_str(
        tuple(["str", "str", "int", "str"]), structs
    )
    _error_class = HyperdriveCheckpointRewarderTestContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class HyperdriveCheckpointRewarderTestWhaleTransferContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the whaleTransfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "whaleTransfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, whale: str, token: str, to: str) -> HyperdriveCheckpointRewarderTestWhaleTransferContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, whale: str, token: str, amount: int, to: str) -> HyperdriveCheckpointRewarderTestWhaleTransferContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> HyperdriveCheckpointRewarderTestWhaleTransferContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            HyperdriveCheckpointRewarderTestWhaleTransferContractFunction0._type_signature: HyperdriveCheckpointRewarderTestWhaleTransferContractFunction0,
            HyperdriveCheckpointRewarderTestWhaleTransferContractFunction1._type_signature: HyperdriveCheckpointRewarderTestWhaleTransferContractFunction1,
        }
        return out


class HyperdriveCheckpointRewarderTestContractFunctions(ContractFunctions):
    """ContractFunctions for the HyperdriveCheckpointRewarderTest contract."""

    IS_TEST: HyperdriveCheckpointRewarderTestIS_TESTContractFunction

    createUser: HyperdriveCheckpointRewarderTestCreateUserContractFunction

    excludeArtifacts: (
        HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction
    )

    excludeContracts: (
        HyperdriveCheckpointRewarderTestExcludeContractsContractFunction
    )

    excludeSenders: (
        HyperdriveCheckpointRewarderTestExcludeSendersContractFunction
    )

    failed: HyperdriveCheckpointRewarderTestFailedContractFunction

    setUp: HyperdriveCheckpointRewarderTestSetUpContractFunction

    targetArtifactSelectors: (
        HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction
    )

    targetArtifacts: (
        HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction
    )

    targetContracts: (
        HyperdriveCheckpointRewarderTestTargetContractsContractFunction
    )

    targetInterfaces: (
        HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction
    )

    targetSelectors: (
        HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction
    )

    targetSenders: HyperdriveCheckpointRewarderTestTargetSendersContractFunction

    test_claimCheckpointReward_success_nonZeroAmount: HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction

    test_claimCheckpointReward_success_zeroAmount: HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction

    test_updateAdmin_failure_onlyAdmin: HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction

    test_updateAdmin_success: (
        HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction
    )

    test_updateSubrewarder_failure_onlyAdmin: HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction

    test_updateSubrewarder_success: HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction

    whaleTransfer: HyperdriveCheckpointRewarderTestWhaleTransferContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.IS_TEST = (
            HyperdriveCheckpointRewarderTestIS_TESTContractFunction.factory(
                "IS_TEST",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="IS_TEST",
            )
        )
        self.createUser = (
            HyperdriveCheckpointRewarderTestCreateUserContractFunction.factory(
                "createUser",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="createUser",
            )
        )
        self.excludeArtifacts = HyperdriveCheckpointRewarderTestExcludeArtifactsContractFunction.factory(
            "excludeArtifacts",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="excludeArtifacts",
        )
        self.excludeContracts = HyperdriveCheckpointRewarderTestExcludeContractsContractFunction.factory(
            "excludeContracts",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="excludeContracts",
        )
        self.excludeSenders = HyperdriveCheckpointRewarderTestExcludeSendersContractFunction.factory(
            "excludeSenders",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="excludeSenders",
        )
        self.failed = (
            HyperdriveCheckpointRewarderTestFailedContractFunction.factory(
                "failed",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="failed",
            )
        )
        self.setUp = (
            HyperdriveCheckpointRewarderTestSetUpContractFunction.factory(
                "setUp",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="setUp",
            )
        )
        self.targetArtifactSelectors = HyperdriveCheckpointRewarderTestTargetArtifactSelectorsContractFunction.factory(
            "targetArtifactSelectors",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="targetArtifactSelectors",
        )
        self.targetArtifacts = HyperdriveCheckpointRewarderTestTargetArtifactsContractFunction.factory(
            "targetArtifacts",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="targetArtifacts",
        )
        self.targetContracts = HyperdriveCheckpointRewarderTestTargetContractsContractFunction.factory(
            "targetContracts",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="targetContracts",
        )
        self.targetInterfaces = HyperdriveCheckpointRewarderTestTargetInterfacesContractFunction.factory(
            "targetInterfaces",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="targetInterfaces",
        )
        self.targetSelectors = HyperdriveCheckpointRewarderTestTargetSelectorsContractFunction.factory(
            "targetSelectors",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="targetSelectors",
        )
        self.targetSenders = HyperdriveCheckpointRewarderTestTargetSendersContractFunction.factory(
            "targetSenders",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="targetSenders",
        )
        self.test_claimCheckpointReward_success_nonZeroAmount = HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_nonZeroAmountContractFunction.factory(
            "test_claimCheckpointReward_success_nonZeroAmount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_claimCheckpointReward_success_nonZeroAmount",
        )
        self.test_claimCheckpointReward_success_zeroAmount = HyperdriveCheckpointRewarderTestTest_claimCheckpointReward_success_zeroAmountContractFunction.factory(
            "test_claimCheckpointReward_success_zeroAmount",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_claimCheckpointReward_success_zeroAmount",
        )
        self.test_updateAdmin_failure_onlyAdmin = HyperdriveCheckpointRewarderTestTest_updateAdmin_failure_onlyAdminContractFunction.factory(
            "test_updateAdmin_failure_onlyAdmin",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateAdmin_failure_onlyAdmin",
        )
        self.test_updateAdmin_success = HyperdriveCheckpointRewarderTestTest_updateAdmin_successContractFunction.factory(
            "test_updateAdmin_success",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateAdmin_success",
        )
        self.test_updateSubrewarder_failure_onlyAdmin = HyperdriveCheckpointRewarderTestTest_updateSubrewarder_failure_onlyAdminContractFunction.factory(
            "test_updateSubrewarder_failure_onlyAdmin",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateSubrewarder_failure_onlyAdmin",
        )
        self.test_updateSubrewarder_success = HyperdriveCheckpointRewarderTestTest_updateSubrewarder_successContractFunction.factory(
            "test_updateSubrewarder_success",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="test_updateSubrewarder_success",
        )
        self.whaleTransfer = HyperdriveCheckpointRewarderTestWhaleTransferContractFunction.factory(
            "whaleTransfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="whaleTransfer",
        )


class HyperdriveCheckpointRewarderTestAdminUpdatedContractEvent(ContractEvent):
    """ContractEvent for AdminUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[AdminUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AdminUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AdminUpdatedEvent.AdminUpdatedEventArgs(
                    admin=abi_event.args["admin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[AdminUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            AdminUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=AdminUpdatedEvent.AdminUpdatedEventArgs(
                    admin=abi_event.args["admin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestCheckpointRewardClaimedContractEvent(
    ContractEvent
):
    """ContractEvent for CheckpointRewardClaimed."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[CheckpointRewardClaimedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            CheckpointRewardClaimedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=CheckpointRewardClaimedEvent.CheckpointRewardClaimedEventArgs(
                    instance=abi_event.args["instance"],
                    claimant=abi_event.args["claimant"],
                    isTrader=abi_event.args["isTrader"],
                    checkpointTime=abi_event.args["checkpointTime"],
                    rewardToken=abi_event.args["rewardToken"],
                    rewardAmount=abi_event.args["rewardAmount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[CheckpointRewardClaimedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            CheckpointRewardClaimedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=CheckpointRewardClaimedEvent.CheckpointRewardClaimedEventArgs(
                    instance=abi_event.args["instance"],
                    claimant=abi_event.args["claimant"],
                    isTrader=abi_event.args["isTrader"],
                    checkpointTime=abi_event.args["checkpointTime"],
                    rewardToken=abi_event.args["rewardToken"],
                    rewardAmount=abi_event.args["rewardAmount"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestSubrewarderUpdatedContractEvent(
    ContractEvent
):
    """ContractEvent for SubrewarderUpdated."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[SubrewarderUpdatedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SubrewarderUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SubrewarderUpdatedEvent.SubrewarderUpdatedEventArgs(
                    subrewarder=abi_event.args["subrewarder"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[SubrewarderUpdatedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            SubrewarderUpdatedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=SubrewarderUpdatedEvent.SubrewarderUpdatedEventArgs(
                    subrewarder=abi_event.args["subrewarder"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLogContractEvent(ContractEvent):
    """ContractEvent for log."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogEvent.LogEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_addressContractEvent(ContractEvent):
    """ContractEvent for log_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_addressEvent.Log_addressEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_arrayContractEvent(ContractEvent):
    """ContractEvent for log_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_arrayEvent.Log_arrayEventArgs(
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_bytesContractEvent(ContractEvent):
    """ContractEvent for log_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytesEvent.Log_bytesEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_bytes32ContractEvent(ContractEvent):
    """ContractEvent for log_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_bytes32Event.Log_bytes32EventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_intContractEvent(ContractEvent):
    """ContractEvent for log_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_intEvent.Log_intEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_addressContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_address."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_addressEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_addressEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_addressEvent.Log_named_addressEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_arrayContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_array."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_arrayEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_arrayEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_arrayEvent.Log_named_arrayEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_bytesContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_bytes."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytesEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytesEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytesEvent.Log_named_bytesEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_bytes32ContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_bytes32."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_bytes32Event]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_bytes32Event(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_bytes32Event.Log_named_bytes32EventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_decimal_intContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_decimal_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_intEvent.Log_named_decimal_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_decimal_uintContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_decimal_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_decimal_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_decimal_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_decimal_uintEvent.Log_named_decimal_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                    decimals=abi_event.args["decimals"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_intContractEvent(ContractEvent):
    """ContractEvent for log_named_int."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_intEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_intEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_intEvent.Log_named_intEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_stringContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_stringEvent.Log_named_stringEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_named_uintContractEvent(
    ContractEvent
):
    """ContractEvent for log_named_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_named_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_named_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_named_uintEvent.Log_named_uintEventArgs(
                    key=abi_event.args["key"],
                    val=abi_event.args["val"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_stringContractEvent(ContractEvent):
    """ContractEvent for log_string."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_stringEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_stringEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_stringEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_stringEvent.Log_stringEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLog_uintContractEvent(ContractEvent):
    """ContractEvent for log_uint."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[Log_uintEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[Log_uintEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            Log_uintEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=Log_uintEvent.Log_uintEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestLogsContractEvent(ContractEvent):
    """ContractEvent for logs."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[LogsEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters,
            from_block=from_block,
            to_block=to_block,
            block_hash=block_hash,
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[LogsEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            LogsEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=LogsEvent.LogsEventArgs(
                    arg1=abi_event.args["arg1"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class HyperdriveCheckpointRewarderTestContractEvents(ContractEvents):
    """ContractEvents for the HyperdriveCheckpointRewarderTest contract."""

    AdminUpdated: HyperdriveCheckpointRewarderTestAdminUpdatedContractEvent

    CheckpointRewardClaimed: (
        HyperdriveCheckpointRewarderTestCheckpointRewardClaimedContractEvent
    )

    SubrewarderUpdated: (
        HyperdriveCheckpointRewarderTestSubrewarderUpdatedContractEvent
    )

    log: HyperdriveCheckpointRewarderTestLogContractEvent

    log_address: HyperdriveCheckpointRewarderTestLog_addressContractEvent

    log_array: HyperdriveCheckpointRewarderTestLog_arrayContractEvent

    log_bytes: HyperdriveCheckpointRewarderTestLog_bytesContractEvent

    log_bytes32: HyperdriveCheckpointRewarderTestLog_bytes32ContractEvent

    log_int: HyperdriveCheckpointRewarderTestLog_intContractEvent

    log_named_address: (
        HyperdriveCheckpointRewarderTestLog_named_addressContractEvent
    )

    log_named_array: (
        HyperdriveCheckpointRewarderTestLog_named_arrayContractEvent
    )

    log_named_bytes: (
        HyperdriveCheckpointRewarderTestLog_named_bytesContractEvent
    )

    log_named_bytes32: (
        HyperdriveCheckpointRewarderTestLog_named_bytes32ContractEvent
    )

    log_named_decimal_int: (
        HyperdriveCheckpointRewarderTestLog_named_decimal_intContractEvent
    )

    log_named_decimal_uint: (
        HyperdriveCheckpointRewarderTestLog_named_decimal_uintContractEvent
    )

    log_named_int: HyperdriveCheckpointRewarderTestLog_named_intContractEvent

    log_named_string: (
        HyperdriveCheckpointRewarderTestLog_named_stringContractEvent
    )

    log_named_uint: HyperdriveCheckpointRewarderTestLog_named_uintContractEvent

    log_string: HyperdriveCheckpointRewarderTestLog_stringContractEvent

    log_uint: HyperdriveCheckpointRewarderTestLog_uintContractEvent

    logs: HyperdriveCheckpointRewarderTestLogsContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.AdminUpdated = (
            HyperdriveCheckpointRewarderTestAdminUpdatedContractEvent.factory(
                "AdminUpdated",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="AdminUpdated",
            )
        )
        self.CheckpointRewardClaimed = HyperdriveCheckpointRewarderTestCheckpointRewardClaimedContractEvent.factory(
            "CheckpointRewardClaimed",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="CheckpointRewardClaimed",
        )
        self.SubrewarderUpdated = HyperdriveCheckpointRewarderTestSubrewarderUpdatedContractEvent.factory(
            "SubrewarderUpdated",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="SubrewarderUpdated",
        )
        self.log = HyperdriveCheckpointRewarderTestLogContractEvent.factory(
            "log", w3=w3, contract_abi=abi, address=address, event_name="log"
        )
        self.log_address = (
            HyperdriveCheckpointRewarderTestLog_addressContractEvent.factory(
                "log_address",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_address",
            )
        )
        self.log_array = (
            HyperdriveCheckpointRewarderTestLog_arrayContractEvent.factory(
                "log_array",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_array",
            )
        )
        self.log_bytes = (
            HyperdriveCheckpointRewarderTestLog_bytesContractEvent.factory(
                "log_bytes",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_bytes",
            )
        )
        self.log_bytes32 = (
            HyperdriveCheckpointRewarderTestLog_bytes32ContractEvent.factory(
                "log_bytes32",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_bytes32",
            )
        )
        self.log_int = (
            HyperdriveCheckpointRewarderTestLog_intContractEvent.factory(
                "log_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_int",
            )
        )
        self.log_named_address = HyperdriveCheckpointRewarderTestLog_named_addressContractEvent.factory(
            "log_named_address",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_named_address",
        )
        self.log_named_array = HyperdriveCheckpointRewarderTestLog_named_arrayContractEvent.factory(
            "log_named_array",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_named_array",
        )
        self.log_named_bytes = HyperdriveCheckpointRewarderTestLog_named_bytesContractEvent.factory(
            "log_named_bytes",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_named_bytes",
        )
        self.log_named_bytes32 = HyperdriveCheckpointRewarderTestLog_named_bytes32ContractEvent.factory(
            "log_named_bytes32",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_named_bytes32",
        )
        self.log_named_decimal_int = HyperdriveCheckpointRewarderTestLog_named_decimal_intContractEvent.factory(
            "log_named_decimal_int",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_named_decimal_int",
        )
        self.log_named_decimal_uint = HyperdriveCheckpointRewarderTestLog_named_decimal_uintContractEvent.factory(
            "log_named_decimal_uint",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_named_decimal_uint",
        )
        self.log_named_int = (
            HyperdriveCheckpointRewarderTestLog_named_intContractEvent.factory(
                "log_named_int",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_int",
            )
        )
        self.log_named_string = HyperdriveCheckpointRewarderTestLog_named_stringContractEvent.factory(
            "log_named_string",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="log_named_string",
        )
        self.log_named_uint = (
            HyperdriveCheckpointRewarderTestLog_named_uintContractEvent.factory(
                "log_named_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_named_uint",
            )
        )
        self.log_string = (
            HyperdriveCheckpointRewarderTestLog_stringContractEvent.factory(
                "log_string",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_string",
            )
        )
        self.log_uint = (
            HyperdriveCheckpointRewarderTestLog_uintContractEvent.factory(
                "log_uint",
                w3=w3,
                contract_abi=abi,
                address=address,
                event_name="log_uint",
            )
        )
        self.logs = HyperdriveCheckpointRewarderTestLogsContractEvent.factory(
            "logs", w3=w3, contract_abi=abi, address=address, event_name="logs"
        )


class HyperdriveCheckpointRewarderTestContract(Contract):
    """A web3.py Contract class for the HyperdriveCheckpointRewarderTest contract."""

    abi: ABI = hyperdrivecheckpointrewardertest_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x60806040819052600c8054600160ff199182168117909255601e8054909116909117905563f877cb1960e01b90526020608452601060a4526f105490925514955357d49410d7d5549360821b60c4525f805160206200405a83398151915263f877cb1960e45f60405180830381865afa1580156200007f573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052620000a8919081019062000408565b603990620000b7908262000560565b5060405163f877cb1960e01b815260206004820152600c60248201526b109054d157d49410d7d5549360a21b60448201525f805160206200405a8339815191529063f877cb19906064015f60405180830381865afa1580156200011c573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405262000145919081019062000408565b603a9062000154908262000560565b5060405163f877cb1960e01b815260206004820152601460248201527f474e4f5349535f434841494e5f5250435f55524c00000000000000000000000060448201525f805160206200405a8339815191529063f877cb19906064015f60405180830381865afa158015620001ca573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052620001f3919081019062000408565b603b9062000202908262000560565b5060405163f877cb1960e01b815260206004820152600d60248201526c131253915057d49410d7d55493609a1b60448201525f805160206200405a8339815191529063f877cb19906064015f60405180830381865afa15801562000268573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405262000291919081019062000408565b603c90620002a0908262000560565b5060405163f877cb1960e01b815260206004820152600f60248201526e1350525393915517d49410d7d55493608a1b60448201525f805160206200405a8339815191529063f877cb19906064015f60405180830381865afa15801562000308573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405262000331919081019062000408565b603d9062000340908262000560565b5060405163f877cb1960e01b815260206004820152600f60248201526e14d15413d3125057d49410d7d55493608a1b60448201525f805160206200405a8339815191529063f877cb19906064015f60405180830381865afa158015620003a8573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052620003d1919081019062000408565b603e90620003e0908262000560565b50348015620003ed575f80fd5b506200062c565b634e487b7160e01b5f52604160045260245ffd5b5f60208083850312156200041a575f80fd5b82516001600160401b038082111562000431575f80fd5b818501915085601f83011262000445575f80fd5b8151818111156200045a576200045a620003f4565b604051601f8201601f19908116603f01168101908382118183101715620004855762000485620003f4565b8160405282815288868487010111156200049d575f80fd5b5f93505b82841015620004c05784840186015181850187015292850192620004a1565b5f86848301015280965050505050505092915050565b600181811c90821680620004eb57607f821691505b6020821081036200050a57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156200055b57805f5260205f20601f840160051c81016020851015620005375750805b601f840160051c820191505b8181101562000558575f815560010162000543565b50505b505050565b81516001600160401b038111156200057c576200057c620003f4565b62000594816200058d8454620004d6565b8462000510565b602080601f831160018114620005ca575f8415620005b25750858301515b5f19600386901b1c1916600185901b17855562000624565b5f85815260208120601f198616915b82811015620005fa57888601518255948401946001909101908401620005d9565b50858210156200061857878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b613a20806200063a5f395ff3fe608060405234801562000010575f80fd5b50600436106200014c575f3560e01c80634c2f2f2e11620000c35780639df880b611620000835780639df880b6146200027e578063b5508aa91462000288578063ba414fa61462000292578063e20c9f7114620002ad578063f5a8778814620002b7578063fa7626d414620002c1575f80fd5b80634c2f2f2e1462000201578063507ffba5146200020b57806366d9a9a0146200024257806385226c81146200025b578063916a17c61462000274575f80fd5b80632ade3880116200010f5780632ade388014620001b35780632b34ebf014620001cc5780633e5e0d2614620001d65780633e5e3c2314620001ed5780633f7286f414620001f7575f80fd5b80630663cad31462000150578063089cf7c4146200015c5780630a9254e414620001665780631071676014620001705780631ed7831c146200019a575b5f80fd5b6200015a620002cf565b005b6200015a62000716565b6200015a6200089d565b6200018762000181366004620026d2565b62000ca1565b6040519081526020015b60405180910390f35b620001a462000d28565b60405162000191919062002721565b620001bd62000d8a565b604051620001919190620027c0565b6200015a62000ed2565b62000187620001e736600462002883565b6200119e565b620001a4620013e5565b620001a462001445565b6200015a620014a5565b620002226200021c36600462002978565b62001769565b604080516001600160a01b03909316835260208301919091520162000191565b6200024c620017f5565b604051620001919190620029fa565b62000265620018da565b60405162000191919062002aaf565b6200024c620019af565b6200015a62001a94565b6200026562001c1d565b6200029c62001cf2565b604051901515815260200162000191565b620001a462001d90565b6200015a62001df0565b601e546200029c9060ff1681565b5f80516020620039cb8339815191525f1c6001600160a01b03166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b15801562000318575f80fd5b505af11580156200032b573d5f803e3d5ffd5b50506020546040516303223eab60e11b81526001600160a01b0390911660048201525f80516020620039ab83398151915292506306447d5691506024015f604051808303815f87803b15801562000380575f80fd5b505af115801562000393573d5f803e3d5ffd5b505050505f80516020620039cb8339815191525f1c6001600160a01b03166341af2f526040518163ffffffff1660e01b81526004015f604051808303815f87803b158015620003e0575f80fd5b505af1158015620003f3573d5f803e3d5ffd5b5050604080546022549151633488a6a760e11b81526001600160a01b03928316600482015242602482015260016044820152911692506369114d4e91506064015f604051808303815f87803b1580156200044b575f80fd5b505af11580156200045e573d5f803e3d5ffd5b505050505f620005057f458cb4864d237cf3ef21835340aeec96759e685bd06793180e8cf7a7cd69cd5e5f80516020620039cb8339815191525f1c6001600160a01b031663191553a46040518163ffffffff1660e01b81526004015f604051808303815f875af1158015620004d5573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052620004fe919081019062002ba2565b9062001fa0565b90506200051581516001620020be565b5f815f815181106200052b576200052b62002d1e565b602002602001015190506200056f815f015160018151811062000552576200055262002d1e565b60209081029190910181015190546001600160a01b031662002125565b620005a9815f01516002815181106200058c576200058c62002d1e565b60209081029190910101516022546001600160a01b031662002125565b620005da5f825f0151600381518110620005c757620005c762002d1e565b60200260200101515f1c11600162002168565b5f805f8360200151806020019051810190620005f7919062002d32565b925092509250620006098342620020be565b6200068c82603f60019054906101000a90046001600160a01b03166001600160a01b031663f7c618c16040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000660573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000686919062002d6b565b62002125565b6200070f81603f60019054906101000a90046001600160a01b03166001600160a01b031663f7b2a7be6040518163ffffffff1660e01b8152600401602060405180830381865afa158015620006e3573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000709919062002d89565b620020be565b5050505050565b5f80516020620039cb8339815191525f1c6001600160a01b03166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156200075f575f80fd5b505af115801562000772573d5f803e3d5ffd5b50506020546040516303223eab60e11b81526001600160a01b0390911660048201525f80516020620039ab83398151915292506306447d5691506024015f604051808303815f87803b158015620007c7575f80fd5b505af1158015620007da573d5f803e3d5ffd5b5050604051630618f58760e51b81526282b42960e81b600482015263deadbeef92505f80516020620039ab833981519152915063c31eb0e0906024015f604051808303815f87803b1580156200082e575f80fd5b505af115801562000841573d5f803e3d5ffd5b5050604080549051639b06ae4960e01b81526001600160a01b0385811660048301529091169250639b06ae4991506024015f604051808303815f87803b1580156200088a575f80fd5b505af11580156200070f573d5f803e3d5ffd5b620008a7620021a4565b5f80516020620039cb8339815191525f1c6001600160a01b03166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b158015620008f0575f80fd5b505af115801562000903573d5f803e3d5ffd5b5050601e546040516303223eab60e11b81526101009091046001600160a01b031660048201525f80516020620039ab83398151915292506306447d5691506024015f604051808303815f87803b1580156200095c575f80fd5b505af11580156200096f573d5f803e3d5ffd5b5050505063deadbeef670de0b6b3a76400006040516200098f90620026a1565b6001600160a01b0390921682526020820152604001604051809103905ff080158015620009be573d5f803e3d5ffd5b50603f8054610100600160a81b0319166101006001600160a01b0393841681029190911791829055604080518082018252601c81527f48797065726472697665436865636b706f696e7452657761726465720000000060208201529051909391909204169062000a2e90620026af565b62000a3b92919062002da1565b604051809103905ff08015801562000a55573d5f803e3d5ffd5b50604080546001600160a01b0319166001600160a01b0392909216918217815580516303e1469160e61b8152905162000aef929163f851a4409160048083019260209291908290030181865afa15801562000ab2573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000ad8919062002d6b565b601e5461010090046001600160a01b031662002125565b62000ba860405f9054906101000a90046001600160a01b03166001600160a01b03166306fdde036040518163ffffffff1660e01b81526004015f60405180830381865afa15801562000b43573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405262000b6c919081019062002dcc565b6040518060400160405280601c81526020017f48797065726472697665436865636b706f696e7452657761726465720000000081525062002595565b62000bfc60405f9054906101000a90046001600160a01b03166001600160a01b03166304baa00b6040518163ffffffff1660e01b81526004015f60405180830381865afa15801562000b43573d5f803e3d5ffd5b62000c9f60405f9054906101000a90046001600160a01b03166001600160a01b03166354fd4d506040518163ffffffff1660e01b81526004015f60405180830381865afa15801562000c50573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405262000c79919081019062002dcc565b60405180604001604052806007815260200166076312e302e32360cc1b81525062002595565b565b6040516370a0823160e01b81526001600160a01b0380851660048301525f9162000d1e91869186918216906370a0823190602401602060405180830381865afa15801562000cf1573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000d17919062002d89565b856200119e565b90505b9392505050565b6060601680548060200260200160405190810160405280929190818152602001828054801562000d8057602002820191905f5260205f20905b81546001600160a01b0316815260019091019060200180831162000d61575b5050505050905090565b6060601d805480602002602001604051908101604052809291908181526020015f905b8282101562000ec9575f84815260208082206040805180820182526002870290920180546001600160a01b03168352600181018054835181870281018701909452808452939591948681019491929084015b8282101562000eb1578382905f5260205f2001805462000e1f9062002e1e565b80601f016020809104026020016040519081016040528092919081815260200182805462000e4d9062002e1e565b801562000e9c5780601f1062000e725761010080835404028352916020019162000e9c565b820191905f5260205f20905b81548152906001019060200180831162000e7e57829003601f168201915b50505050508152602001906001019062000dff565b50505050815250508152602001906001019062000dad565b50505050905090565b5f80516020620039cb8339815191525f1c6001600160a01b03166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b15801562000f1b575f80fd5b505af115801562000f2e573d5f803e3d5ffd5b50506040805481516303e1469160e61b815291515f80516020620039ab83398151915294506306447d5693506001600160a01b039091169163f851a4409160048083019260209291908290030181865afa15801562000f8f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000fb5919062002d6b565b6040516001600160e01b031960e084901b1681526001600160a01b0390911660048201526024015f604051808303815f87803b15801562000ff4575f80fd5b505af115801562001007573d5f803e3d5ffd5b505060405163248e63e160e11b8152600160048201819052602482018190526044820181905260648201525f80516020620039ab833981519152925063491cc7c291506084015f604051808303815f87803b15801562001065575f80fd5b505af115801562001078573d5f803e3d5ffd5b50506020546040516001600160a01b0390911692507f54e4612788f90384e6843298d7854436f3a585b2c3831ab66abf1de63bfa6c2d91505f90a260408054602054915163e2f273bd60e01b81526001600160a01b03928316600482015291169063e2f273bd906024015f604051808303815f87803b158015620010fa575f80fd5b505af11580156200110d573d5f803e3d5ffd5b5050505062000c9f60405f9054906101000a90046001600160a01b03166001600160a01b031663f851a4406040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001166573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906200118c919062002d6b565b6020546001600160a01b031662002125565b6040516370a0823160e01b81526001600160a01b0385811660048301525f9182918616906370a0823190602401602060405180830381865afa158015620011e7573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906200120d919062002d89565b905080841115620012315760405163188c93a560e31b815260040160405180910390fd5b5f80516020620039cb8339815191525f1c6001600160a01b03166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b1580156200127a575f80fd5b505af11580156200128d573d5f803e3d5ffd5b50506040516303223eab60e11b81526001600160a01b03891660048201525f80516020620039ab83398151915292506306447d5691506024015f604051808303815f87803b158015620012de575f80fd5b505af1158015620012f1573d5f803e3d5ffd5b505060405163c88a5e6d60e01b81526001600160a01b0389166004820152670de0b6b3a764000060248201525f80516020620039ab833981519152925063c88a5e6d91506044015f604051808303815f87803b15801562001350575f80fd5b505af115801562001363573d5f803e3d5ffd5b505060405163a9059cbb60e01b81526001600160a01b038681166004830152602482018890528816925063a9059cbb91506044016020604051808303815f875af1158015620013b4573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620013da919062002e58565b509295945050505050565b6060601880548060200260200160405190810160405280929190818152602001828054801562000d8057602002820191905f5260205f209081546001600160a01b0316815260019091019060200180831162000d61575050505050905090565b6060601780548060200260200160405190810160405280929190818152602001828054801562000d8057602002820191905f5260205f209081546001600160a01b0316815260019091019060200180831162000d61575050505050905090565b5f80516020620039cb8339815191525f1c6001600160a01b03166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b158015620014ee575f80fd5b505af115801562001501573d5f803e3d5ffd5b50506040805481516303e1469160e61b815291515f80516020620039ab83398151915294506306447d5693506001600160a01b039091169163f851a4409160048083019260209291908290030181865afa15801562001562573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062001588919062002d6b565b6040516001600160e01b031960e084901b1681526001600160a01b0390911660048201526024015f604051808303815f87803b158015620015c7575f80fd5b505af1158015620015da573d5f803e3d5ffd5b505060405163248e63e160e11b81526001600482018190526024820181905260448201819052606482015263deadbeef92505f80516020620039ab833981519152915063491cc7c2906084015f604051808303815f87803b1580156200163e575f80fd5b505af115801562001651573d5f803e3d5ffd5b50506040516001600160a01b03841692507f4a847489062ccada272e291a747bfecff5d74ded500da0a156faca0bd8394dc691505f90a2604080549051639b06ae4960e01b81526001600160a01b03838116600483015290911690639b06ae49906024015f604051808303815f87803b158015620016cd575f80fd5b505af1158015620016e0573d5f803e3d5ffd5b505050506200176660405f9054906101000a90046001600160a01b03166001600160a01b0316633d7f7b246040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001739573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906200175f919062002d6b565b8262002125565b50565b5f806200177683620025ca565b60405163c88a5e6d60e01b81526001600160a01b038316600482015269021e19e0c9bab2400000602482015291935091505f80516020620039ab8339815191529063c88a5e6d906044015b5f604051808303815f87803b158015620017d9575f80fd5b505af1158015620017ec573d5f803e3d5ffd5b50505050915091565b6060601b805480602002602001604051908101604052809291908181526020015f905b8282101562000ec9575f8481526020908190206040805180820182526002860290920180546001600160a01b03168352600181018054835181870281018701909452808452939491938583019392830182828015620018c157602002820191905f5260205f20905f905b82829054906101000a900460e01b6001600160e01b03191681526020019060040190602082600301049283019260010382029150808411620018825790505b5050505050815250508152602001906001019062001818565b6060601a805480602002602001604051908101604052809291908181526020015f905b8282101562000ec9578382905f5260205f200180546200191d9062002e1e565b80601f01602080910402602001604051908101604052809291908181526020018280546200194b9062002e1e565b80156200199a5780601f1062001970576101008083540402835291602001916200199a565b820191905f5260205f20905b8154815290600101906020018083116200197c57829003601f168201915b505050505081526020019060010190620018fd565b6060601c805480602002602001604051908101604052809291908181526020015f905b8282101562000ec9575f8481526020908190206040805180820182526002860290920180546001600160a01b0316835260018101805483518187028101870190945280845293949193858301939283018282801562001a7b57602002820191905f5260205f20905f905b82829054906101000a900460e01b6001600160e01b0319168152602001906004019060208260030104928301926001038202915080841162001a3c5790505b50505050508152505081526020019060010190620019d2565b5f80516020620039cb8339815191525f1c6001600160a01b03166390c5013b6040518163ffffffff1660e01b81526004015f604051808303815f87803b15801562001add575f80fd5b505af115801562001af0573d5f803e3d5ffd5b50506020546040516303223eab60e11b81526001600160a01b0390911660048201525f80516020620039ab83398151915292506306447d5691506024015f604051808303815f87803b15801562001b45575f80fd5b505af115801562001b58573d5f803e3d5ffd5b5050604051630618f58760e51b81526282b42960e81b60048201525f80516020620039ab833981519152925063c31eb0e091506024015f604051808303815f87803b15801562001ba6575f80fd5b505af115801562001bb9573d5f803e3d5ffd5b505060408054602054915163e2f273bd60e01b81526001600160a01b0392831660048201529116925063e2f273bd91506024015f604051808303815f87803b15801562001c04575f80fd5b505af115801562001c17573d5f803e3d5ffd5b50505050565b60606019805480602002602001604051908101604052809291908181526020015f905b8282101562000ec9578382905f5260205f2001805462001c609062002e1e565b80601f016020809104026020016040519081016040528092919081815260200182805462001c8e9062002e1e565b801562001cdd5780601f1062001cb35761010080835404028352916020019162001cdd565b820191905f5260205f20905b81548152906001019060200180831162001cbf57829003601f168201915b50505050508152602001906001019062001c40565b6008545f9060ff161562001d0a575060085460ff1690565b604051630667f9d760e41b81525f80516020620039ab833981519152600482018190526519985a5b195960d21b60248301525f9163667f9d7090604401602060405180830381865afa15801562001d63573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062001d89919062002d89565b1415905090565b6060601580548060200260200160405190810160405280929190818152602001828054801562000d8057602002820191905f5260205f209081546001600160a01b0316815260019091019060200180831162000d61575050505050905090565b603f54604051631514cb4f60e31b81525f60048201526101009091046001600160a01b03169063a8a65a78906024015f604051808303815f87803b15801562001e37575f80fd5b505af115801562001e4a573d5f803e3d5ffd5b505050505f80516020620039cb8339815191525f1c6001600160a01b03166341af2f526040518163ffffffff1660e01b81526004015f604051808303815f87803b15801562001e97575f80fd5b505af115801562001eaa573d5f803e3d5ffd5b505060408054601e549151633488a6a760e11b81526101009092046001600160a01b039081166004840152426024840152600160448401521692506369114d4e91506064015f604051808303815f87803b15801562001f07575f80fd5b505af115801562001f1a573d5f803e3d5ffd5b505050505f62001f917f458cb4864d237cf3ef21835340aeec96759e685bd06793180e8cf7a7cd69cd5e5f80516020620039cb8339815191525f1c6001600160a01b031663191553a46040518163ffffffff1660e01b81526004015f604051808303815f875af1158015620004d5573d5f803e3d5ffd5b90506200176681515f620020be565b60605f835167ffffffffffffffff81111562001fc05762001fc0620028da565b6040519080825280602002602001820160405280156200200e57816020015b604080516060808201835280825260208201525f9181019190915281526020019060019003908162001fdf5790505b5091505f5b8451811015620020b5578385828151811062002033576200203362002d1e565b60200260200101515f01515f8151811062002052576200205262002d1e565b602002602001015103620020ac5784818151811062002075576200207562002d1e565b60200260200101518383806200208b9062002e79565b945081518110620020a057620020a062002d1e565b60200260200101819052505b60010162002013565b50815292915050565b60405163260a5b1560e21b815260048101839052602481018290525f80516020620039ab833981519152906398296c54906044015b5f6040518083038186803b1580156200210a575f80fd5b505afa1580156200211d573d5f803e3d5ffd5b505050505050565b6040516328a9b0fb60e11b81526001600160a01b038084166004830152821660248201525f80516020620039ab8339815191529063515361f690604401620020f3565b60405163f7fe347760e01b8152821515600482015281151560248201525f80516020620039ab8339815191529063f7fe347790604401620020f3565b620021cc60405180604001604052806005815260200164616c69636560d81b81525062001769565b601f55601e80546001600160a01b0390921661010002610100600160a81b03199092169190911790556040805180820190915260038152623137b160e91b60208201526200221a9062001769565b602155602080546001600160a01b0319166001600160a01b039290921691909117815560408051808201909152600681526563656c696e6560d01b91810191909152620022679062001769565b602355602280546001600160a01b0319166001600160a01b03929092169190911790556040805180820190915260038152623230b760e91b6020820152620022af9062001769565b602555602480546001600160a01b0319166001600160a01b039290921691909117905560408051808201909152600381526265766560e81b6020820152620022f79062001769565b602755602680546001600160a01b0319166001600160a01b03929092169190911790556040805180820190915260088152673232b83637bcb2b960c11b6020820152620023449062001769565b602b55602a80546001600160a01b0319166001600160a01b039290921691909117905560408051808201909152600681526536b4b73a32b960d11b60208201526200238f9062001769565b602955602880546001600160a01b0319166001600160a01b039290921691909117905560408051808201909152600c81526b3332b2a1b7b63632b1ba37b960a11b6020820152620023e09062001769565b602d55602c80546001600160a01b0319166001600160a01b039290921691909117905560408051808201909152600e81526d39bbb2b2b821b7b63632b1ba37b960911b6020820152620024339062001769565b602f55602e80546001600160a01b0319166001600160a01b039290921691909117905560408051808201909152600a815269676f7665726e616e636560b01b6020820152620024829062001769565b603155603080546001600160a01b0319166001600160a01b03929092169190911790556040805180820190915260068152653830bab9b2b960d11b6020820152620024cd9062001769565b603355603280546001600160a01b0319166001600160a01b03929092169190911790556040805180820190915260098152683932b3b4b9ba3930b960b91b60208201526200251b9062001769565b603555603480546001600160a01b0319166001600160a01b039290921691909117905560408051808201909152600c81526b726577617264536f7572636560a01b60208201526200256c9062001769565b603755603680546001600160a01b0319166001600160a01b039290921691909117905542603855565b60405163f320d96360e01b81525f80516020620039ab8339815191529063f320d96390620020f3908590859060040162002e9e565b5f8082604051602001620025df919062002ecf565b60408051808303601f190181529082905280516020909101206001625e79b760e01b031982526004820181905291505f80516020620039ab8339815191529063ffa1864990602401602060405180830381865afa15801562002643573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062002669919062002d6b565b6040516318caf8e360e31b81529092505f80516020620039ab8339815191529063c657c71890620017c1908590879060040162002eec565b61029e8062002f1283390190565b6107fb80620031b083390190565b6001600160a01b038116811462001766575f80fd5b5f805f60608486031215620026e5575f80fd5b8335620026f281620026bd565b925060208401356200270481620026bd565b915060408401356200271681620026bd565b809150509250925092565b602080825282518282018190525f9190848201906040850190845b81811015620027635783516001600160a01b0316835292840192918401916001016200273c565b50909695505050505050565b5f5b838110156200278b57818101518382015260200162002771565b50505f910152565b5f8151808452620027ac8160208601602086016200276f565b601f01601f19169290920160200192915050565b602080825282518282018190525f919060409081850190600581811b87018401888601875b848110156200287457603f198a8403018652815180516001600160a01b03168452880151888401889052805188850181905290890190606081871b8601810191908601905f5b818110156200285d57605f198885030183526200284a84865162002793565b948d01949350918c01916001016200282b565b5050509689019693505090870190600101620027e5565b50909998505050505050505050565b5f805f806080858703121562002897575f80fd5b8435620028a481620026bd565b93506020850135620028b681620026bd565b9250604085013591506060850135620028cf81620026bd565b939692955090935050565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff81118282101715620029145762002914620028da565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715620029465762002946620028da565b604052919050565b5f67ffffffffffffffff8211156200296a576200296a620028da565b50601f01601f191660200190565b5f6020828403121562002989575f80fd5b813567ffffffffffffffff811115620029a0575f80fd5b8201601f81018413620029b1575f80fd5b8035620029c8620029c2826200294e565b6200291a565b818152856020838501011115620029dd575f80fd5b816020840160208301375f91810160200191909152949350505050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b8381101562002aa157888303603f19018552815180516001600160a01b031684528701518784018790528051878501819052908801905f9060608601905b8083101562002a8b5783516001600160e01b0319168252928a019260019290920191908a019062002a5f565b5096890196945050509086019060010162002a21565b509098975050505050505050565b5f60208083016020845280855180835260408601915060408160051b8701019250602087015f5b8281101562002b0857603f1988860301845262002af585835162002793565b9450928501929085019060010162002ad6565b5092979650505050505050565b5f67ffffffffffffffff82111562002b315762002b31620028da565b5060051b60200190565b5f62002b4b620029c2846200294e565b905082815283838301111562002b5f575f80fd5b62000d218360208301846200276f565b5f82601f83011262002b7f575f80fd5b62000d218383516020850162002b3b565b805162002b9d81620026bd565b919050565b5f602080838503121562002bb4575f80fd5b825167ffffffffffffffff8082111562002bcc575f80fd5b818501915085601f83011262002be0575f80fd5b815162002bf1620029c28262002b15565b81815260059190911b8301840190848101908883111562002c10575f80fd5b8585015b8381101562002d115780518581111562002c2c575f80fd5b86016060818c03601f1901121562002c42575f80fd5b62002c4c620028ee565b888201518781111562002c5d575f80fd5b8201603f81018d1362002c6e575f80fd5b8981015162002c81620029c28262002b15565b81815260059190911b8201604001908b8101908f83111562002ca1575f80fd5b6040840193505b8284101562002cc35783518252928c0192908c019062002ca8565b845250505060408201518781111562002cda575f80fd5b62002cea8d8b8386010162002b6f565b8a8301525062002cfd6060830162002b90565b604082015284525091860191860162002c14565b5098975050505050505050565b634e487b7160e01b5f52603260045260245ffd5b5f805f6060848603121562002d45575f80fd5b83519250602084015162002d5981620026bd565b80925050604084015190509250925092565b5f6020828403121562002d7c575f80fd5b815162000d2181620026bd565b5f6020828403121562002d9a575f80fd5b5051919050565b604081525f62002db5604083018562002793565b905060018060a01b03831660208301529392505050565b5f6020828403121562002ddd575f80fd5b815167ffffffffffffffff81111562002df4575f80fd5b8201601f8101841362002e05575f80fd5b62002e168482516020840162002b3b565b949350505050565b600181811c9082168062002e3357607f821691505b60208210810362002e5257634e487b7160e01b5f52602260045260245ffd5b50919050565b5f6020828403121562002e69575f80fd5b8151801515811462000d21575f80fd5b5f6001820162002e9757634e487b7160e01b5f52601160045260245ffd5b5060010190565b604081525f62002eb2604083018562002793565b828103602084015262002ec6818562002793565b95945050505050565b5f825162002ee28184602087016200276f565b9190910192915050565b6001600160a01b03831681526040602082018190525f9062000d1e908301846200279356fe608060405234801561000f575f80fd5b5060405161029e38038061029e83398101604081905261002e91610056565b5f80546001600160a01b0319166001600160a01b03939093169290921790915560015561008d565b5f8060408385031215610067575f80fd5b82516001600160a01b038116811461007d575f80fd5b6020939093015192949293505050565b6102048061009a5f395ff3fe608060405234801561000f575f80fd5b5060043610610055575f3560e01c80638aee812714610059578063a8a65a781461008a578063e9f460411461009d578063f7b2a7be146100e9578063f7c618c114610100575b5f80fd5b610088610067366004610141565b5f80546001600160a01b0319166001600160a01b0392909216919091179055565b005b610088610098366004610163565b600155565b6100c56100ab36600461017a565b5f546001546001600160a01b039091169094509492505050565b604080516001600160a01b0390931683526020830191909152015b60405180910390f35b6100f260015481565b6040519081526020016100e0565b5f54610112906001600160a01b031681565b6040516001600160a01b0390911681526020016100e0565b6001600160a01b038116811461013e575f80fd5b50565b5f60208284031215610151575f80fd5b813561015c8161012a565b9392505050565b5f60208284031215610173575f80fd5b5035919050565b5f805f806080858703121561018d575f80fd5b84356101988161012a565b935060208501356101a88161012a565b925060408501359150606085013580151581146101c3575f80fd5b93969295509093505056fea26469706673582212209b07aa936fe2888f7ad84515a4336bb77942a5f344caa7db6aa506ab522708f764736f6c63430008180033608060405234801561000f575f80fd5b506040516107fb3803806107fb83398101604081905261002e91610099565b60018054336001600160a01b031991821617909155600280549091166001600160a01b0383161790555f61006283826101f0565b5050506102af565b634e487b7160e01b5f52604160045260245ffd5b80516001600160a01b0381168114610094575f80fd5b919050565b5f80604083850312156100aa575f80fd5b82516001600160401b03808211156100c0575f80fd5b818501915085601f8301126100d3575f80fd5b8151818111156100e5576100e561006a565b604051601f8201601f19908116603f0116810190838211818310171561010d5761010d61006a565b81604052828152602093508884848701011115610128575f80fd5b5f91505b82821015610149578482018401518183018501529083019061012c565b5f84848301015280965050505061016181860161007e565b925050509250929050565b600181811c9082168061018057607f821691505b60208210810361019e57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156101eb57805f5260205f20601f840160051c810160208510156101c95750805b601f840160051c820191505b818110156101e8575f81556001016101d5565b50505b505050565b81516001600160401b038111156102095761020961006a565b61021d81610217845461016c565b846101a4565b602080601f831160018114610250575f84156102395750858301515b5f19600386901b1c1916600185901b1785556102a7565b5f85815260208120601f198616915b8281101561027e5788860151825594840194600190910190840161025f565b508582101561029b57878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b61053f806102bc5f395ff3fe608060405234801561000f575f80fd5b5060043610610085575f3560e01c806369114d4e1161005857806369114d4e146101345780639b06ae4914610149578063e2f273bd1461015c578063f851a4401461016f575f80fd5b806304baa00b1461008957806306fdde03146100db5780633d7f7b24146100e357806354fd4d501461010e575b5f80fd5b6100c56040518060400160405280601c81526020017f48797065726472697665436865636b706f696e7452657761726465720000000081525081565b6040516100d291906103dd565b60405180910390f35b6100c5610182565b6002546100f6906001600160a01b031681565b6040516001600160a01b0390911681526020016100d2565b6100c560405180604001604052806007815260200166076312e302e32360cc1b81525081565b610147610142366004610440565b61020d565b005b610147610157366004610483565b6102f7565b61014761016a366004610483565b61036a565b6001546100f6906001600160a01b031681565b5f805461018e906104a5565b80601f01602080910402602001604051908101604052809291908181526020018280546101ba906104a5565b80156102055780601f106101dc57610100808354040283529160200191610205565b820191905f5260205f20905b8154815290600101906020018083116101e857829003601f168201915b505050505081565b60025460405163e9f4604160e01b81523360048201526001600160a01b0385811660248301526044820185905283151560648301525f92839291169063e9f460419060840160408051808303815f875af115801561026d573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061029191906104dd565b909250905080156102f057604080518581526001600160a01b0384811660208301529181018390528415159187169033907f458cb4864d237cf3ef21835340aeec96759e685bd06793180e8cf7a7cd69cd5e9060600160405180910390a45b5050505050565b6001546001600160a01b03163314610321576040516282b42960e81b815260040160405180910390fd5b600280546001600160a01b0319166001600160a01b0383169081179091556040517f4a847489062ccada272e291a747bfecff5d74ded500da0a156faca0bd8394dc6905f90a250565b6001546001600160a01b03163314610394576040516282b42960e81b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b0383169081179091556040517f54e4612788f90384e6843298d7854436f3a585b2c3831ab66abf1de63bfa6c2d905f90a250565b5f602080835283518060208501525f5b81811015610409578581018301518582016040015282016103ed565b505f604082860101526040601f19601f8301168501019250505092915050565b6001600160a01b038116811461043d575f80fd5b50565b5f805f60608486031215610452575f80fd5b833561045d81610429565b92506020840135915060408401358015158114610478575f80fd5b809150509250925092565b5f60208284031215610493575f80fd5b813561049e81610429565b9392505050565b600181811c908216806104b957607f821691505b6020821081036104d757634e487b7160e01b5f52602260045260245ffd5b50919050565b5f80604083850312156104ee575f80fd5b82516104f981610429565b602093909301519294929350505056fea26469706673582212201fd1074b95e22ed5ace72d73a5cf78fd8e22eff5ba300b6d663967416dcfbc8764736f6c634300081800330000000000000000000000007109709ecfa91a80626ff3989d68f67f5b1dd12d885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12da2646970667358221220e24a4e76572863772ebcc8896aee8cfb9158f32d7ded4c3c1e042873784d0dc264736f6c634300081800330000000000000000000000007109709ecfa91a80626ff3989d68f67f5b1dd12d"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = HyperdriveCheckpointRewarderTestContractFunctions(hyperdrivecheckpointrewardertest_abi, self.w3, address)  # type: ignore
        self.events = HyperdriveCheckpointRewarderTestContractEvents(hyperdrivecheckpointrewardertest_abi, self.w3, address)  # type: ignore
        self.errors = HyperdriveCheckpointRewarderTestContractErrors()

    events: HyperdriveCheckpointRewarderTestContractEvents

    errors: HyperdriveCheckpointRewarderTestContractErrors = (
        HyperdriveCheckpointRewarderTestContractErrors()
    )

    functions: HyperdriveCheckpointRewarderTestContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = HyperdriveCheckpointRewarderTestContractFunctions(
            hyperdrivecheckpointrewardertest_abi, w3, None
        )
        contract.errors = HyperdriveCheckpointRewarderTestContractErrors()

        return contract
