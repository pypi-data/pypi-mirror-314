"""A web3.py Contract class for the IUniV3Zap contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, NamedTuple, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainBaseError,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractFunctions,
)
from web3.types import BlockIdentifier, StateOverride, TxParams

from ..IHyperdrive import IHyperdriveTypes as IHyperdrive
from ..ISwapRouter import ISwapRouterTypes as ISwapRouter
from ..IUniV3Zap import IUniV3ZapTypes as IUniV3Zap

structs = {
    "IHyperdrive.Options": IHyperdrive.Options,
    "ISwapRouter.ExactInputParams": ISwapRouter.ExactInputParams,
    "IUniV3Zap.ZapInOptions": IUniV3Zap.ZapInOptions,
}

iuniv3zap_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "addLiquidityZap",
            "inputs": [
                {
                    "name": "_hyperdrive",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "_minLpSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_minApr",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_maxApr",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_hyperdriveOptions",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_zapInOptions",
                    "type": "tuple",
                    "internalType": "struct IUniV3Zap.ZapInOptions",
                    "components": [
                        {
                            "name": "swapParams",
                            "type": "tuple",
                            "internalType": "struct ISwapRouter.ExactInputParams",
                            "components": [
                                {
                                    "name": "path",
                                    "type": "bytes",
                                    "internalType": "bytes",
                                },
                                {
                                    "name": "recipient",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "deadline",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "amountIn",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "amountOutMinimum",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                        {
                            "name": "sourceAsset",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "sourceAmount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "shouldWrap",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isRebasing",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                },
            ],
            "outputs": [
                {
                    "name": "lpShares",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "closeLongZap",
            "inputs": [
                {
                    "name": "_hyperdrive",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "_maturityTime",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_bondAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_minOutput",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_swapParams",
                    "type": "tuple",
                    "internalType": "struct ISwapRouter.ExactInputParams",
                    "components": [
                        {
                            "name": "path",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "recipient",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "deadline",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountIn",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountOutMinimum",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                },
                {"name": "_shouldWrap", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {
                    "name": "proceeds",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "closeShortZap",
            "inputs": [
                {
                    "name": "_hyperdrive",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "_maturityTime",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_bondAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_minOutput",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_swapParams",
                    "type": "tuple",
                    "internalType": "struct ISwapRouter.ExactInputParams",
                    "components": [
                        {
                            "name": "path",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "recipient",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "deadline",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountIn",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountOutMinimum",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                },
                {"name": "_shouldWrap", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {
                    "name": "proceeds",
                    "type": "uint256",
                    "internalType": "uint256",
                }
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "kind",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "openLongZap",
            "inputs": [
                {
                    "name": "_hyperdrive",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "_minOutput",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_minVaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_hyperdriveOptions",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_zapInOptions",
                    "type": "tuple",
                    "internalType": "struct IUniV3Zap.ZapInOptions",
                    "components": [
                        {
                            "name": "swapParams",
                            "type": "tuple",
                            "internalType": "struct ISwapRouter.ExactInputParams",
                            "components": [
                                {
                                    "name": "path",
                                    "type": "bytes",
                                    "internalType": "bytes",
                                },
                                {
                                    "name": "recipient",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "deadline",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "amountIn",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "amountOutMinimum",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                        {
                            "name": "sourceAsset",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "sourceAmount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "shouldWrap",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isRebasing",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                },
            ],
            "outputs": [
                {
                    "name": "maturityTime",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "longAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "openShortZap",
            "inputs": [
                {
                    "name": "_hyperdrive",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "_bondAmount",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_maxDeposit",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_minVaultSharePrice",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_hyperdriveOptions",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_zapInOptions",
                    "type": "tuple",
                    "internalType": "struct IUniV3Zap.ZapInOptions",
                    "components": [
                        {
                            "name": "swapParams",
                            "type": "tuple",
                            "internalType": "struct ISwapRouter.ExactInputParams",
                            "components": [
                                {
                                    "name": "path",
                                    "type": "bytes",
                                    "internalType": "bytes",
                                },
                                {
                                    "name": "recipient",
                                    "type": "address",
                                    "internalType": "address",
                                },
                                {
                                    "name": "deadline",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "amountIn",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                                {
                                    "name": "amountOutMinimum",
                                    "type": "uint256",
                                    "internalType": "uint256",
                                },
                            ],
                        },
                        {
                            "name": "sourceAsset",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "sourceAmount",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "shouldWrap",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "isRebasing",
                            "type": "bool",
                            "internalType": "bool",
                        },
                    ],
                },
            ],
            "outputs": [
                {
                    "name": "maturityTime",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "deposit",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "payable",
        },
        {
            "type": "function",
            "name": "redeemWithdrawalSharesZap",
            "inputs": [
                {
                    "name": "_hyperdrive",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "_withdrawalShares",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_minOutputPerShare",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_swapParams",
                    "type": "tuple",
                    "internalType": "struct ISwapRouter.ExactInputParams",
                    "components": [
                        {
                            "name": "path",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "recipient",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "deadline",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountIn",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountOutMinimum",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                },
                {"name": "_shouldWrap", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {
                    "name": "proceeds",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "withdrawalSharesRedeemed",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "removeLiquidityZap",
            "inputs": [
                {
                    "name": "_hyperdrive",
                    "type": "address",
                    "internalType": "contract IHyperdrive",
                },
                {
                    "name": "_lpShares",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_minOutputPerShare",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "_options",
                    "type": "tuple",
                    "internalType": "struct IHyperdrive.Options",
                    "components": [
                        {
                            "name": "destination",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "asBase",
                            "type": "bool",
                            "internalType": "bool",
                        },
                        {
                            "name": "extraData",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                    ],
                },
                {
                    "name": "_swapParams",
                    "type": "tuple",
                    "internalType": "struct ISwapRouter.ExactInputParams",
                    "components": [
                        {
                            "name": "path",
                            "type": "bytes",
                            "internalType": "bytes",
                        },
                        {
                            "name": "recipient",
                            "type": "address",
                            "internalType": "address",
                        },
                        {
                            "name": "deadline",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountIn",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                        {
                            "name": "amountOutMinimum",
                            "type": "uint256",
                            "internalType": "uint256",
                        },
                    ],
                },
                {"name": "_shouldWrap", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [
                {
                    "name": "proceeds",
                    "type": "uint256",
                    "internalType": "uint256",
                },
                {
                    "name": "withdrawalShares",
                    "type": "uint256",
                    "internalType": "uint256",
                },
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "swapRouter",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "contract ISwapRouter",
                }
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "version",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {"type": "error", "name": "InvalidInputToken", "inputs": []},
        {"type": "error", "name": "InvalidOutputToken", "inputs": []},
        {"type": "error", "name": "InvalidRecipient", "inputs": []},
        {"type": "error", "name": "InvalidSourceAmount", "inputs": []},
        {"type": "error", "name": "InvalidSourceAsset", "inputs": []},
        {"type": "error", "name": "InvalidSwap", "inputs": []},
        {"type": "error", "name": "InvalidTransfer", "inputs": []},
        {"type": "error", "name": "NotPayable", "inputs": []},
        {"type": "error", "name": "ShouldWrapAssets", "inputs": []},
        {"type": "error", "name": "TransferFailed", "inputs": []},
    ],
)


class IUniV3ZapInvalidInputTokenContractError(PypechainBaseError):
    """ContractError for InvalidInputToken."""

    # Error name
    name: str = "InvalidInputToken"
    # 4 byte error selector
    selector: str = "0x2df9739b"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidInputToken()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapInvalidOutputTokenContractError(PypechainBaseError):
    """ContractError for InvalidOutputToken."""

    # Error name
    name: str = "InvalidOutputToken"
    # 4 byte error selector
    selector: str = "0x06202020"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidOutputToken()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapInvalidRecipientContractError(PypechainBaseError):
    """ContractError for InvalidRecipient."""

    # Error name
    name: str = "InvalidRecipient"
    # 4 byte error selector
    selector: str = "0x9c8d2cd2"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidRecipient()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapInvalidSourceAmountContractError(PypechainBaseError):
    """ContractError for InvalidSourceAmount."""

    # Error name
    name: str = "InvalidSourceAmount"
    # 4 byte error selector
    selector: str = "0x97e0deb1"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidSourceAmount()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapInvalidSourceAssetContractError(PypechainBaseError):
    """ContractError for InvalidSourceAsset."""

    # Error name
    name: str = "InvalidSourceAsset"
    # 4 byte error selector
    selector: str = "0x005605b7"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidSourceAsset()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapInvalidSwapContractError(PypechainBaseError):
    """ContractError for InvalidSwap."""

    # Error name
    name: str = "InvalidSwap"
    # 4 byte error selector
    selector: str = "0x11157667"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidSwap()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapInvalidTransferContractError(PypechainBaseError):
    """ContractError for InvalidTransfer."""

    # Error name
    name: str = "InvalidTransfer"
    # 4 byte error selector
    selector: str = "0x2f352531"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "InvalidTransfer()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapNotPayableContractError(PypechainBaseError):
    """ContractError for NotPayable."""

    # Error name
    name: str = "NotPayable"
    # 4 byte error selector
    selector: str = "0x1574f9f3"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "NotPayable()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapShouldWrapAssetsContractError(PypechainBaseError):
    """ContractError for ShouldWrapAssets."""

    # Error name
    name: str = "ShouldWrapAssets"
    # 4 byte error selector
    selector: str = "0x7e4e2a42"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "ShouldWrapAssets()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapTransferFailedContractError(PypechainBaseError):
    """ContractError for TransferFailed."""

    # Error name
    name: str = "TransferFailed"
    # 4 byte error selector
    selector: str = "0x90b8ec18"
    # error signature, i.e. CustomError(uint256,bool)
    signature: str = "TransferFailed()"
    # Error input types
    abi: ABI = iuniv3zap_abi


class IUniV3ZapContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the IUniV3Zap contract."""

    InvalidInputToken: IUniV3ZapInvalidInputTokenContractError

    InvalidOutputToken: IUniV3ZapInvalidOutputTokenContractError

    InvalidRecipient: IUniV3ZapInvalidRecipientContractError

    InvalidSourceAmount: IUniV3ZapInvalidSourceAmountContractError

    InvalidSourceAsset: IUniV3ZapInvalidSourceAssetContractError

    InvalidSwap: IUniV3ZapInvalidSwapContractError

    InvalidTransfer: IUniV3ZapInvalidTransferContractError

    NotPayable: IUniV3ZapNotPayableContractError

    ShouldWrapAssets: IUniV3ZapShouldWrapAssetsContractError

    TransferFailed: IUniV3ZapTransferFailedContractError

    def __init__(
        self,
    ) -> None:
        self.InvalidInputToken = IUniV3ZapInvalidInputTokenContractError()
        self.InvalidOutputToken = IUniV3ZapInvalidOutputTokenContractError()
        self.InvalidRecipient = IUniV3ZapInvalidRecipientContractError()
        self.InvalidSourceAmount = IUniV3ZapInvalidSourceAmountContractError()
        self.InvalidSourceAsset = IUniV3ZapInvalidSourceAssetContractError()
        self.InvalidSwap = IUniV3ZapInvalidSwapContractError()
        self.InvalidTransfer = IUniV3ZapInvalidTransferContractError()
        self.NotPayable = IUniV3ZapNotPayableContractError()
        self.ShouldWrapAssets = IUniV3ZapShouldWrapAssetsContractError()
        self.TransferFailed = IUniV3ZapTransferFailedContractError()

        self._all = [
            self.InvalidInputToken,
            self.InvalidOutputToken,
            self.InvalidRecipient,
            self.InvalidSourceAmount,
            self.InvalidSourceAsset,
            self.InvalidSwap,
            self.InvalidTransfer,
            self.NotPayable,
            self.ShouldWrapAssets,
            self.TransferFailed,
        ]


class IUniV3ZapAddLiquidityZapContractFunction0(PypechainContractFunction):
    """ContractFunction for the addLiquidityZap(str,int,int,int,IHyperdrive.Options,IUniV3Zap.ZapInOptions) method."""

    _function_name = "addLiquidityZap"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "int",
                "int",
                "int",
                "IHyperdrive.Options",
                "IUniV3Zap.ZapInOptions",
            ]
        ),
        structs,
    )
    _error_class = IUniV3ZapContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapAddLiquidityZapContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the addLiquidityZap method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "addLiquidityZap"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hyperdrive: str, _minLpSharePrice: int, _minApr: int, _maxApr: int, _hyperdriveOptions: IHyperdrive.Options, _zapInOptions: IUniV3Zap.ZapInOptions) -> IUniV3ZapAddLiquidityZapContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapAddLiquidityZapContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapAddLiquidityZapContractFunction0._type_signature: IUniV3ZapAddLiquidityZapContractFunction0,
        }
        return out


class IUniV3ZapCloseLongZapContractFunction0(PypechainContractFunction):
    """ContractFunction for the closeLongZap(str,int,int,int,IHyperdrive.Options,ISwapRouter.ExactInputParams,bool) method."""

    _function_name = "closeLongZap"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "int",
                "int",
                "int",
                "IHyperdrive.Options",
                "ISwapRouter.ExactInputParams",
                "bool",
            ]
        ),
        structs,
    )
    _error_class = IUniV3ZapContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapCloseLongZapContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the closeLongZap method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "closeLongZap"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hyperdrive: str, _maturityTime: int, _bondAmount: int, _minOutput: int, _options: IHyperdrive.Options, _swapParams: ISwapRouter.ExactInputParams, _shouldWrap: bool) -> IUniV3ZapCloseLongZapContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapCloseLongZapContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapCloseLongZapContractFunction0._type_signature: IUniV3ZapCloseLongZapContractFunction0,
        }
        return out


class IUniV3ZapCloseShortZapContractFunction0(PypechainContractFunction):
    """ContractFunction for the closeShortZap(str,int,int,int,IHyperdrive.Options,ISwapRouter.ExactInputParams,bool) method."""

    _function_name = "closeShortZap"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "int",
                "int",
                "int",
                "IHyperdrive.Options",
                "ISwapRouter.ExactInputParams",
                "bool",
            ]
        ),
        structs,
    )
    _error_class = IUniV3ZapContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            int, rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapCloseShortZapContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the closeShortZap method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "closeShortZap"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hyperdrive: str, _maturityTime: int, _bondAmount: int, _minOutput: int, _options: IHyperdrive.Options, _swapParams: ISwapRouter.ExactInputParams, _shouldWrap: bool) -> IUniV3ZapCloseShortZapContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapCloseShortZapContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapCloseShortZapContractFunction0._type_signature: IUniV3ZapCloseShortZapContractFunction0,
        }
        return out


class IUniV3ZapKindContractFunction0(PypechainContractFunction):
    """ContractFunction for the kind() method."""

    _function_name = "kind"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IUniV3ZapContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapKindContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the kind method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "kind"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IUniV3ZapKindContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapKindContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapKindContractFunction0._type_signature: IUniV3ZapKindContractFunction0,
        }
        return out


class IUniV3ZapNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IUniV3ZapContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapNameContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IUniV3ZapNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapNameContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapNameContractFunction0._type_signature: IUniV3ZapNameContractFunction0,
        }
        return out


class IUniV3ZapOpenLongZapContractFunction0(PypechainContractFunction):
    """ContractFunction for the openLongZap(str,int,int,IHyperdrive.Options,IUniV3Zap.ZapInOptions) method."""

    _function_name = "openLongZap"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "int",
                "int",
                "IHyperdrive.Options",
                "IUniV3Zap.ZapInOptions",
            ]
        ),
        structs,
    )
    _error_class = IUniV3ZapContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for OpenLongZap."""

        maturityTime: int
        longAmount: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapOpenLongZapContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the openLongZap method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "openLongZap"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hyperdrive: str, _minOutput: int, _minVaultSharePrice: int, _hyperdriveOptions: IHyperdrive.Options, _zapInOptions: IUniV3Zap.ZapInOptions) -> IUniV3ZapOpenLongZapContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapOpenLongZapContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapOpenLongZapContractFunction0._type_signature: IUniV3ZapOpenLongZapContractFunction0,
        }
        return out


class IUniV3ZapOpenShortZapContractFunction0(PypechainContractFunction):
    """ContractFunction for the openShortZap(str,int,int,int,IHyperdrive.Options,IUniV3Zap.ZapInOptions) method."""

    _function_name = "openShortZap"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "int",
                "int",
                "int",
                "IHyperdrive.Options",
                "IUniV3Zap.ZapInOptions",
            ]
        ),
        structs,
    )
    _error_class = IUniV3ZapContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for OpenShortZap."""

        maturityTime: int
        deposit: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapOpenShortZapContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the openShortZap method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "openShortZap"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hyperdrive: str, _bondAmount: int, _maxDeposit: int, _minVaultSharePrice: int, _hyperdriveOptions: IHyperdrive.Options, _zapInOptions: IUniV3Zap.ZapInOptions) -> IUniV3ZapOpenShortZapContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapOpenShortZapContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapOpenShortZapContractFunction0._type_signature: IUniV3ZapOpenShortZapContractFunction0,
        }
        return out


class IUniV3ZapRedeemWithdrawalSharesZapContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the redeemWithdrawalSharesZap(str,int,int,IHyperdrive.Options,ISwapRouter.ExactInputParams,bool) method."""

    _function_name = "redeemWithdrawalSharesZap"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "int",
                "int",
                "IHyperdrive.Options",
                "ISwapRouter.ExactInputParams",
                "bool",
            ]
        ),
        structs,
    )
    _error_class = IUniV3ZapContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for RedeemWithdrawalSharesZap."""

        proceeds: int
        withdrawalSharesRedeemed: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapRedeemWithdrawalSharesZapContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the redeemWithdrawalSharesZap method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "redeemWithdrawalSharesZap"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hyperdrive: str, _withdrawalShares: int, _minOutputPerShare: int, _options: IHyperdrive.Options, _swapParams: ISwapRouter.ExactInputParams, _shouldWrap: bool) -> IUniV3ZapRedeemWithdrawalSharesZapContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapRedeemWithdrawalSharesZapContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapRedeemWithdrawalSharesZapContractFunction0._type_signature: IUniV3ZapRedeemWithdrawalSharesZapContractFunction0,
        }
        return out


class IUniV3ZapRemoveLiquidityZapContractFunction0(PypechainContractFunction):
    """ContractFunction for the removeLiquidityZap(str,int,int,IHyperdrive.Options,ISwapRouter.ExactInputParams,bool) method."""

    _function_name = "removeLiquidityZap"
    _type_signature = expand_struct_type_str(
        tuple(
            [
                "str",
                "int",
                "int",
                "IHyperdrive.Options",
                "ISwapRouter.ExactInputParams",
                "bool",
            ]
        ),
        structs,
    )
    _error_class = IUniV3ZapContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for RemoveLiquidityZap."""

        proceeds: int
        withdrawalShares: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int]

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return self.ReturnValues(
            *rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapRemoveLiquidityZapContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the removeLiquidityZap method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "removeLiquidityZap"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _hyperdrive: str, _lpShares: int, _minOutputPerShare: int, _options: IHyperdrive.Options, _swapParams: ISwapRouter.ExactInputParams, _shouldWrap: bool) -> IUniV3ZapRemoveLiquidityZapContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapRemoveLiquidityZapContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapRemoveLiquidityZapContractFunction0._type_signature: IUniV3ZapRemoveLiquidityZapContractFunction0,
        }
        return out


class IUniV3ZapSwapRouterContractFunction0(PypechainContractFunction):
    """ContractFunction for the swapRouter() method."""

    _function_name = "swapRouter"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IUniV3ZapContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapSwapRouterContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the swapRouter method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "swapRouter"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IUniV3ZapSwapRouterContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapSwapRouterContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapSwapRouterContractFunction0._type_signature: IUniV3ZapSwapRouterContractFunction0,
        }
        return out


class IUniV3ZapVersionContractFunction0(PypechainContractFunction):
    """ContractFunction for the version() method."""

    _function_name = "version"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IUniV3ZapContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class IUniV3ZapVersionContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the version method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "version"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IUniV3ZapVersionContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IUniV3ZapVersionContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IUniV3ZapVersionContractFunction0._type_signature: IUniV3ZapVersionContractFunction0,
        }
        return out


class IUniV3ZapContractFunctions(ContractFunctions):
    """ContractFunctions for the IUniV3Zap contract."""

    addLiquidityZap: IUniV3ZapAddLiquidityZapContractFunction

    closeLongZap: IUniV3ZapCloseLongZapContractFunction

    closeShortZap: IUniV3ZapCloseShortZapContractFunction

    kind: IUniV3ZapKindContractFunction

    name: IUniV3ZapNameContractFunction

    openLongZap: IUniV3ZapOpenLongZapContractFunction

    openShortZap: IUniV3ZapOpenShortZapContractFunction

    redeemWithdrawalSharesZap: (
        IUniV3ZapRedeemWithdrawalSharesZapContractFunction
    )

    removeLiquidityZap: IUniV3ZapRemoveLiquidityZapContractFunction

    swapRouter: IUniV3ZapSwapRouterContractFunction

    version: IUniV3ZapVersionContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.addLiquidityZap = IUniV3ZapAddLiquidityZapContractFunction.factory(
            "addLiquidityZap",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="addLiquidityZap",
        )
        self.closeLongZap = IUniV3ZapCloseLongZapContractFunction.factory(
            "closeLongZap",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="closeLongZap",
        )
        self.closeShortZap = IUniV3ZapCloseShortZapContractFunction.factory(
            "closeShortZap",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="closeShortZap",
        )
        self.kind = IUniV3ZapKindContractFunction.factory(
            "kind",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="kind",
        )
        self.name = IUniV3ZapNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.openLongZap = IUniV3ZapOpenLongZapContractFunction.factory(
            "openLongZap",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="openLongZap",
        )
        self.openShortZap = IUniV3ZapOpenShortZapContractFunction.factory(
            "openShortZap",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="openShortZap",
        )
        self.redeemWithdrawalSharesZap = (
            IUniV3ZapRedeemWithdrawalSharesZapContractFunction.factory(
                "redeemWithdrawalSharesZap",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="redeemWithdrawalSharesZap",
            )
        )
        self.removeLiquidityZap = (
            IUniV3ZapRemoveLiquidityZapContractFunction.factory(
                "removeLiquidityZap",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="removeLiquidityZap",
            )
        )
        self.swapRouter = IUniV3ZapSwapRouterContractFunction.factory(
            "swapRouter",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="swapRouter",
        )
        self.version = IUniV3ZapVersionContractFunction.factory(
            "version",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="version",
        )


class IUniV3ZapContract(Contract):
    """A web3.py Contract class for the IUniV3Zap contract."""

    abi: ABI = iuniv3zap_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = IUniV3ZapContractFunctions(iuniv3zap_abi, self.w3, address)  # type: ignore

        self.errors = IUniV3ZapContractErrors()

    errors: IUniV3ZapContractErrors = IUniV3ZapContractErrors()

    functions: IUniV3ZapContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = IUniV3ZapContractFunctions(iuniv3zap_abi, w3, None)
        contract.errors = IUniV3ZapContractErrors()

        return contract
