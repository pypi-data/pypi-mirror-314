import inspect
import typing as tp
import logging

from flask import Response
import flask
from satella.coding import run_when_iterator_completes, wraps
from satella.time import measure

logger = logging.getLogger(__name__)
__version__ = '1.1'


def dont_log_me(fun):
    """
    A decorator to disable logging of given metric.

    Use as follows:

    >>> @dont_log_me
    >>> def my_flask_view():
    >>>     ...
    """
    @wraps(fun)
    def inner(*args, **kwargs):
        return fun(*args, **kwargs)


def FlaskRequestsLogging(app, default_level_mapping: tp.Optional[tp.Dict[int, int]] = None,
                         log_template: str = 'Request {method} {path} finished with {status_code} elapsed {elapsed}',
                         exception_template: str = 'Got exception while processing {method} {path} elapsed {elapsed}',
                         log_unhandled_exceptions_as: int = logging.ERROR,
                         pass_as_extras: bool = True,
                         configure_logger: bool = True):
    """
    Instantiate Flask-Requests-Logging

    Your flask's requests will gain a new attribute :code:`time_elapsed`, calling
    which will return the amount of time that it took to execute given request.

    Exceptions will emit two log entries, one for log_template and one for
    unhandled_exception_template, only if given exception is unhandled. A exception log
    entry WILL NOT be generated for a handled exception. Dump their traces there.

    :param app: app to use
    :param default_level_mapping: a mapping of either leftmost digit to error code, or entire
        error code to level mapping. Default is log 2xx and 3xx with INFO, 4xx with WARN
        and 5xx with ERROR. If not given, request will be logged with INFO.
    :param log_template: a string template to format the log as. Following variables will be available:
        {method} {path} {status_code} {elapsed}
    :param exception_template: a string template that accepts following variables:
        {method} {path} {elapsed} {exception}
    :param log_unhandled_exceptions_as: logging level to log unhandled exceptions as
    :param pass_as_extras: if True, extra dictionary generated by extra_args_gen will be passed as
        value of the extra keyword, if False it will be passed as kwargs to logging handler.
    :param configure_logger: this will automatically configure the logger to emit all of the notices
    """
    default_level_mapping = default_level_mapping or {2: logging.INFO,
                                                      3: logging.INFO,
                                                      4: logging.WARN,
                                                      5: logging.ERROR}

    if configure_logger:
        logging.getLogger('flask_requests_logging').setLevel(min(default_level_mapping.values()))

    @app.before_request
    def before_request():
        flask.request.time_elapsed = measure()

    @app.after_request
    def after_request(resp: Response):
        def log(extras):
            time_elapsed = extras.pop('elapsed')
            time_elapsed.stop()
            extras['elapsed'] = time_elapsed.get_time_elapsed()
            level = logging.INFO
            if resp.status_code in default_level_mapping:
                level = default_level_mapping[resp.status_code]
            else:
                p = resp.status_code // 100
                if p in default_level_mapping:
                    level = default_level_mapping[p]
            if pass_as_extras:
                msg = log_template.format(**extras)
                logger.log(level, msg, extra=extras)
            else:
                logger.log(level, log_template, **extras)

        extras = {
            'path': flask.request.url,
            'method': flask.request.method,
            'status_code': resp.status_code,
            'elapsed': flask.request.time_elapsed
        }

        if inspect.isgenerator(resp.response):
            resp.response = run_when_iterator_completes(resp.response, log, None, extras)
        else:
            log(extras)
        return resp

    @app.teardown_request
    def teardown_request(e: tp.Optional[Exception] = None):
        if e is None:
            return

        extras = {
            'path': flask.request.url,
            'method': flask.request.method,
            'exception': e,
            'elapsed': flask.request.time_elapsed.get_time_elapsed()
        }

        if pass_as_extras:
            msg = exception_template.format(**extras)
            logger.log(log_unhandled_exceptions_as, msg, exc_info=e, extra=extras)
        else:
            logger.log(log_unhandled_exceptions_as, log_template, exc_info=e, **extras)
