"use strict";(self.webpackChunkjupyterlite_scheme_kernel=self.webpackChunkjupyterlite_scheme_kernel||[]).push([[509],{509:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0});const r=t(50),s=t(716),o=[{id:"scheme-kernel-extension:kernel",autoStart:!0,requires:[r.IKernelSpecs],activate:(e,n)=>{n.register({spec:{name:"scheme",display_name:"scheme",language:"scheme",argv:[],resources:{"logo-32x32":"","logo-64x64":""}},create:async e=>new s.SchemeKernel(e)})}}];n.default=o},716:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.SchemeKernel=void 0;const r=t(50),s=t(438),o=t(5);class a extends r.BaseKernel{constructor(e){super(e)}async kernelInfoRequest(){return{implementation:"Scheme",implementation_version:"0.4.1",language_info:{codemirror_mode:{name:"scheme"},file_extension:".scm",mimetype:"text/x-scheme",name:"scheme",version:"10.2.0",pygments_lexer:"scheme"},protocol_version:"5.3",status:"ok",banner:"Scheme kernel using ChezScheme",help_links:[{text:"Scheme Kernel",url:"https://github.com/bencode/jupyterlite-scheme-kernel"}]}}async executeRequest(e){var n;const{code:t}=e;try{const e=/^\s*%%html\s/;if(e.test(t)){const n=t.replace(e,"");return this.publishExecuteResult({execution_count:this.executionCount,data:{"text/html":n},metadata:{}}),{status:"ok",execution_count:this.executionCount,user_expressions:{}}}if(!this.evaluator){const e=e=>{const n="error"===e.type?"stderr":"stdout",t=`${e.message}\n`;this.stream({name:n,text:t})};this.evaluator=await(0,s.createEvaluator)({onMessage:e}),this.evaluator.install(o.library)}const n=this.evaluator.evaluate(t);if(n.success)return this.publishExecuteResult({execution_count:this.executionCount,data:{"text/plain":n.value},metadata:{}}),{status:"ok",execution_count:this.executionCount,user_expressions:{}};const r=n.value;return this.publishExecuteError({ename:"Evaluation Error",evalue:r,traceback:[]}),{status:"error",execution_count:this.executionCount,ename:"Evaluation Error",evalue:r,traceback:[]}}catch(e){const t=e,r=t.message||String(e),s=(null===(n=null==t?void 0:t.stack)||void 0===n?void 0:n.split("\n"))||[];return this.publishExecuteError({ename:"Evaluation Error",evalue:r,traceback:s}),{status:"error",execution_count:this.executionCount,ename:"Evaluation Error",evalue:r,traceback:s}}}async completeRequest(e){return{matches:[],cursor_start:e.cursor_pos,cursor_end:e.cursor_pos,metadata:{},status:"ok"}}async inspectRequest(e){return{status:"ok",found:!1,data:{},metadata:{}}}async isCompleteRequest(e){return{status:"complete"}}async commInfoRequest(e){return{comms:{},status:"ok"}}inputReply(e){}async commOpen(e){}async commMsg(e){}async commClose(e){}}n.SchemeKernel=a},5:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.library=void 0,n.library='\n\n(begin\n\n(define *last-error* #f)\n\n(define (format-error-message msg irritants)\n  (if (and (string? msg) (list? irritants))\n      (apply format msg irritants)\n      msg))\n\n(define (handle-condition con prefix)\n  (let ([who (and (who-condition? con) (condition-who con))]\n        [msg (and (message-condition? con) (condition-message con))]\n        [irr (and (irritants-condition? con) (condition-irritants con))])\n    (with-output-to-string\n      (lambda ()\n        (when prefix\n          (display prefix)\n          (display ": "))\n        (cond\n          [msg\n           (when who\n             (display who)\n             (display ": "))\n           (display (format-error-message msg irr))]\n          [else\n            (if (violation? con)\n                (begin\n                  (display "Violation")\n                  (when who\n                    (display " in ")\n                    (display who))\n                  (when irr\n                    (display ": ")\n                    (display (format-error-message msg irr))))\n                (write con))])))))\n\n(define (safe-read port)\n  (guard (con\n         [(condition? con)\n          (set! *last-error* (handle-condition con "Syntax error"))\n          #f])\n    (read port)))\n\n(define (safe-eval expr env)\n  (guard (con\n         [(condition? con)\n          (set! *last-error* (handle-condition con #f))\n          #f])\n    (eval expr env)))\n\n(define (get-last-error)\n  (let ([err *last-error*])\n    (set! *last-error* #f)\n    err))\n\n(define (write-to-string value)\n  (with-output-to-string\n    (lambda ()\n      (write value))))\n\n)\n\n\n'}}]);