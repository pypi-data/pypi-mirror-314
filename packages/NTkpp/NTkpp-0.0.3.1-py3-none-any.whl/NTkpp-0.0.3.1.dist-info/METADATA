Metadata-Version: 2.1
Name: NTkpp
Version: 0.0.3.1
Summary: Простая библиотека для полносвязных нейронных сетей
Author: Тихонов Иван
Author-email: tihonovivan737@gmail.com
Requires-Python: >=3.6
Description-Content-Type: text/markdown
Requires-Dist: numpy

﻿NeuralPy - Библиотека для построения и обучения нейронных сетей

Описание:

NeuralPy - это простая и интуитивно понятная библиотека для работы с нейронными сетями. Она предоставляет полный набор инструментов для создания, обучения и оптимизации нейронных сетей. Библиотека ориентирована как на новичков, так и на опытных разработчиков, которым требуется гибкость и возможность тонкой настройки.

Основные возможности:

Построение нейронных сетей:

Создание моделей с использованием класса NeuralNetwork и добавление произвольного количества слоев (DenseLayer).

Функции активации:

Поддержка популярных функций активации, таких как ReLU, Sigmoid, Softmax, и гиперболический тангенс.

Функции потерь:

Реализация MSE (средняя квадратичная ошибка) и кросс-энтропии для задач регрессии и классификации.

Оптимизация:

Поддержка популярных алгоритмов оптимизации, включая SGD, RMSProp, AdaGrad, Adam, и AdaDelta.

Гибкость и кастомизация:

Инициализация весов: random, xavier, he, normal.

Настраиваемые параметры скорости обучения, коэффициента затухания и регуляризации.

Возможность выбора метода обновления весов для каждого слоя.

Обучение:

Функция train поддерживает обучение с использованием полного набора данных или мини-батчей. Также возможна интеграция пользовательских оптимизаторов.

Пример использования:

python

Копировать код

import numpy as np

from NeuralPy import NeuralNetwork, DenseLayer, train

from NeuralPy.losses import MeanSquaredError

\# Создание модели

model = NeuralNetwork(learning\_rate=0.01)

model.add\_layer(DenseLayer(input\_size=2, output\_size=4, activation\_func='relu'))

model.add\_layer(DenseLayer(input\_size=4, output\_size=1, activation\_func='sigmoid'))

\# Генерация данных

x\_train = np.random.rand(100, 2)

y\_train = np.random.randint(0, 2, (100, 1))

\# Определение функции потерь

loss = MeanSquaredError()

\# Обучение модели

train(model, x\_train, y\_train, loss\_func=loss, epochs=10, batch\_size=16)

\# Прогнозирование

predictions = model.forward(x\_train)
