# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'BlockStorageVolumeSnapshotTarget',
    'BlockStorageVolumeSnapshotTimeouts',
    'BlockStorageVolumeSnapshotVolume',
    'BlockStorageVolumeTimeouts',
    'ComputeInstanceNetworkInterface',
    'DatabaseGrafana',
    'DatabaseKafka',
    'DatabaseMysql',
    'DatabaseOpensearch',
    'DatabaseOpensearchDashboards',
    'DatabaseOpensearchIndexPattern',
    'DatabaseOpensearchIndexTemplate',
    'DatabasePg',
    'DatabaseRedis',
    'DatabaseTimeouts',
    'ElasticIpHealthcheck',
    'IamApiKeyTimeouts',
    'IamOrgPolicyServices',
    'IamOrgPolicyServicesRule',
    'IamOrgPolicyTimeouts',
    'IamRolePolicy',
    'IamRolePolicyServices',
    'IamRolePolicyServicesRule',
    'IamRoleTimeouts',
    'InstancePoolInstance',
    'NlbServiceHealthcheck',
    'SksClusterOidc',
    'SksNodepoolKubeletImageGc',
    'GetBlockStorageVolumeInstanceResult',
    'GetBlockStorageVolumeSnapshotResult',
    'GetBlockStorageVolumeSnapshotTimeoutsResult',
    'GetBlockStorageVolumeSnapshotVolumeResult',
    'GetBlockStorageVolumeTimeoutsResult',
    'GetComputeInstanceListInstanceResult',
    'GetDatabaseUriTimeoutsResult',
    'GetDomainRecordFilterResult',
    'GetDomainRecordRecordResult',
    'GetElasticIpHealthcheckResult',
    'GetIamApiKeyTimeoutsResult',
    'GetIamOrgPolicyServicesResult',
    'GetIamOrgPolicyServicesRuleResult',
    'GetIamOrgPolicyTimeoutsResult',
    'GetIamRolePolicyResult',
    'GetIamRolePolicyServicesResult',
    'GetIamRolePolicyServicesRuleResult',
    'GetIamRoleTimeoutsResult',
    'GetInstancePoolInstanceResult',
    'GetInstancePoolListPoolResult',
    'GetInstancePoolListPoolInstanceResult',
    'GetNlbServiceListServiceResult',
    'GetNlbServiceListServiceHealthcheckResult',
    'GetNlbServiceListTimeoutsResult',
    'GetSksClusterListClusterResult',
    'GetSksClusterListClusterOidcResult',
    'GetSksClusterOidcResult',
    'GetSksNodepoolKubeletImageGcResult',
    'GetSksNodepoolListNodepoolResult',
    'GetSksNodepoolListNodepoolKubeletImageGcResult',
]

@pulumi.output_type
class BlockStorageVolumeSnapshotTarget(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: Snapshot ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BlockStorageVolumeSnapshotTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class BlockStorageVolumeSnapshotVolume(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Snapshot ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BlockStorageVolumeTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class ComputeInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 ip_address: Optional[str] = None,
                 mac_address: Optional[str] = None):
        """
        :param str network_id: The exoscale*private*network (ID) to attach to the instance.
        :param str ip_address: The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        :param str mac_address: MAC address
        """
        pulumi.set(__self__, "network_id", network_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        The exoscale*private*network (ID) to attach to the instance.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")


@pulumi.output_type
class DatabaseGrafana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grafanaSettings":
            suggest = "grafana_settings"
        elif key == "ipFilters":
            suggest = "ip_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseGrafana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grafana_settings: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None):
        """
        :param str grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        if grafana_settings is not None:
            pulumi.set(__self__, "grafana_settings", grafana_settings)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[str]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")


@pulumi.output_type
class DatabaseKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCertAuth":
            suggest = "enable_cert_auth"
        elif key == "enableKafkaConnect":
            suggest = "enable_kafka_connect"
        elif key == "enableKafkaRest":
            suggest = "enable_kafka_rest"
        elif key == "enableSaslAuth":
            suggest = "enable_sasl_auth"
        elif key == "enableSchemaRegistry":
            suggest = "enable_schema_registry"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnectSettings":
            suggest = "kafka_connect_settings"
        elif key == "kafkaRestSettings":
            suggest = "kafka_rest_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "schemaRegistrySettings":
            suggest = "schema_registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cert_auth: Optional[bool] = None,
                 enable_kafka_connect: Optional[bool] = None,
                 enable_kafka_rest: Optional[bool] = None,
                 enable_sasl_auth: Optional[bool] = None,
                 enable_schema_registry: Optional[bool] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect_settings: Optional[str] = None,
                 kafka_rest_settings: Optional[str] = None,
                 kafka_settings: Optional[str] = None,
                 schema_registry_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param bool enable_cert_auth: Enable certificate-based authentication method.
        :param bool enable_kafka_connect: Enable Kafka Connect.
        :param bool enable_kafka_rest: Enable Kafka REST.
        :param bool enable_sasl_auth: Enable SASL-based authentication method.
        :param bool enable_schema_registry: Enable Schema Registry.
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param str kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param str kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param str schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param str version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[bool]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[bool]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[bool]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[bool]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[bool]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[str]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[str]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[str]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[str]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 mysql_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password (may only be set at creation time).
        :param str admin_username: A custom administrator account username (may only be set at creation time).
        :param str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param str version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[str]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forkFromService":
            suggest = "fork_from_service"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "recoveryBackupName":
            suggest = "recovery_backup_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Optional['outputs.DatabaseOpensearchDashboards'] = None,
                 fork_from_service: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']] = None,
                 index_template: Optional['outputs.DatabaseOpensearchIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[bool] = None,
                 max_index_count: Optional[int] = None,
                 recovery_backup_name: Optional[str] = None,
                 settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param 'DatabaseOpensearchDashboardsArgs' dashboards: OpenSearch Dashboards settings
        :param str fork_from_service: ❗ Service name
        :param Sequence['DatabaseOpensearchIndexPatternArgs'] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param 'DatabaseOpensearchIndexTemplateArgs' index_template: Template settings for all new indexes
        :param Sequence[str] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param bool keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param int max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param str recovery_backup_name: ❗ Name of a backup to recover from
        :param str settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param str version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if fork_from_service is not None:
            pulumi.set(__self__, "fork_from_service", fork_from_service)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if recovery_backup_name is not None:
            pulumi.set(__self__, "recovery_backup_name", recovery_backup_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional['outputs.DatabaseOpensearchDashboards']:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[str]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.DatabaseOpensearchIndexTemplate']:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[bool]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[str]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 max_old_space_size: Optional[int] = None,
                 request_timeout: Optional[int] = None):
        """
        :param bool enabled: Enable or disable OpenSearch Dashboards (default: true).
        :param int max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        :param int request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[int]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class DatabaseOpensearchIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[int] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        """
        :param int max_index_count: Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        :param str pattern: fnmatch pattern
        :param str sorting_algorithm: `alphabetical` or `creation_date`.
        """
        if max_index_count is not None:
            pulumi.set(__self__, "max_index_count", max_index_count)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if sorting_algorithm is not None:
            pulumi.set(__self__, "sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        fnmatch pattern
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        """
        `alphabetical` or `creation_date`.
        """
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class DatabaseOpensearchIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[int] = None,
                 number_of_replicas: Optional[int] = None,
                 number_of_shards: Optional[int] = None):
        """
        :param int mapping_nested_objects_limit: The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        :param int number_of_replicas: The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        :param int number_of_shards: The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[int]:
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[int]:
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[int]:
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class DatabasePg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgSettings":
            suggest = "pg_settings"
        elif key == "pgbouncerSettings":
            suggest = "pgbouncer_settings"
        elif key == "pglookoutSettings":
            suggest = "pglookout_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 pg_settings: Optional[str] = None,
                 pgbouncer_settings: Optional[str] = None,
                 pglookout_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password (may only be set at creation time).
        :param str admin_username: A custom administrator account username (may only be set at creation time).
        :param str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param str pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param str pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param str version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[str]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[str]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[str]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "redisSettings":
            suggest = "redis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 redis_settings: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[str]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")


@pulumi.output_type
class DatabaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 read: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ElasticIpHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "strikesFail":
            suggest = "strikes_fail"
        elif key == "strikesOk":
            suggest = "strikes_ok"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"
        elif key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticIpHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticIpHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticIpHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 port: int,
                 interval: Optional[int] = None,
                 strikes_fail: Optional[int] = None,
                 strikes_ok: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_skip_verify: Optional[bool] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str mode: The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        :param int port: The healthcheck target port (must be between `1` and `65535`).
        :param int interval: The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        :param int strikes_fail: The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        :param int strikes_ok: The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        :param int timeout: The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        :param bool tls_skip_verify: Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        :param str tls_sni: The healthcheck server name to present with SNI in `https` mode.
        :param str uri: The healthcheck target URI (required in `http(s)` modes).
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if strikes_fail is not None:
            pulumi.set(__self__, "strikes_fail", strikes_fail)
        if strikes_ok is not None:
            pulumi.set(__self__, "strikes_ok", strikes_ok)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The healthcheck target port (must be between `1` and `65535`).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> Optional[int]:
        """
        The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        """
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> Optional[int]:
        """
        The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        """
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[bool]:
        """
        Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The healthcheck target URI (required in `http(s)` modes).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class IamApiKeyTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class IamOrgPolicyServices(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.IamOrgPolicyServicesRule']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['IamOrgPolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.IamOrgPolicyServicesRule']]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IamOrgPolicyServicesRule(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 expression: Optional[str] = None,
                 resources: Optional[Sequence[str]] = None):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is not suported. Specify resources using CEL expressions.""")
    def resources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class IamOrgPolicyTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class IamRolePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultServiceStrategy":
            suggest = "default_service_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamRolePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamRolePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamRolePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_service_strategy: Optional[str] = None,
                 services: Optional[Mapping[str, 'outputs.IamRolePolicyServices']] = None):
        """
        :param str default_service_strategy: Default service strategy (`allow` or `deny`).
        :param Mapping[str, 'IamRolePolicyServicesArgs'] services: IAM policy services.
        """
        if default_service_strategy is not None:
            pulumi.set(__self__, "default_service_strategy", default_service_strategy)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="defaultServiceStrategy")
    def default_service_strategy(self) -> Optional[str]:
        """
        Default service strategy (`allow` or `deny`).
        """
        return pulumi.get(self, "default_service_strategy")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.IamRolePolicyServices']]:
        """
        IAM policy services.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class IamRolePolicyServices(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.IamRolePolicyServicesRule']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['IamRolePolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.IamRolePolicyServicesRule']]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IamRolePolicyServicesRule(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 expression: Optional[str] = None,
                 resources: Optional[Sequence[str]] = None):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is not suported. Specify resources using CEL expressions.""")
    def resources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class IamRoleTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class InstancePoolInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 ipv6_address: Optional[str] = None,
                 name: Optional[str] = None,
                 public_ip_address: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str ipv6_address: The instance (main network interface) IPv6 address.
        :param str name: The instance name.
        :param str public_ip_address: The instance (main network interface) IPv4 address.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[str]:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class NlbServiceHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlbServiceHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlbServiceHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlbServiceHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 interval: Optional[int] = None,
                 mode: Optional[str] = None,
                 retries: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param int port: The NLB service (TCP/UDP) port.
        :param int interval: The healthcheck interval in seconds (default: `10`).
        :param str mode: The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        :param int retries: The healthcheck retries (default: `1`).
        :param int timeout: The healthcheck timeout (seconds; default: `5`).
        :param str tls_sni: The healthcheck TLS SNI server name (only if `mode` is `https`).
        :param str uri: The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The NLB service (TCP/UDP) port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The healthcheck interval in seconds (default: `10`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The healthcheck retries (default: `1`).
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The healthcheck timeout (seconds; default: `5`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        """
        The healthcheck TLS SNI server name (only if `mode` is `https`).
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class SksClusterOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "groupsClaim":
            suggest = "groups_claim"
        elif key == "groupsPrefix":
            suggest = "groups_prefix"
        elif key == "requiredClaim":
            suggest = "required_claim"
        elif key == "usernameClaim":
            suggest = "username_claim"
        elif key == "usernamePrefix":
            suggest = "username_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SksClusterOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SksClusterOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SksClusterOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class SksNodepoolKubeletImageGc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highThreshold":
            suggest = "high_threshold"
        elif key == "lowThreshold":
            suggest = "low_threshold"
        elif key == "minAge":
            suggest = "min_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SksNodepoolKubeletImageGc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SksNodepoolKubeletImageGc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SksNodepoolKubeletImageGc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_threshold: Optional[int] = None,
                 low_threshold: Optional[int] = None,
                 min_age: Optional[str] = None):
        """
        :param int high_threshold: The percent of disk usage after which image garbage collection is always run
        :param int low_threshold: The percent of disk usage before which image garbage collection is never run
        :param str min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[int]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[int]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")


@pulumi.output_type
class GetBlockStorageVolumeInstanceResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Instance ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBlockStorageVolumeSnapshotResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Snapshot ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Snapshot ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBlockStorageVolumeSnapshotTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetBlockStorageVolumeSnapshotVolumeResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Volume ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Volume ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBlockStorageVolumeTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetComputeInstanceListInstanceResult(dict):
    def __init__(__self__, *,
                 anti_affinity_group_ids: Sequence[str],
                 created_at: str,
                 deploy_target_id: str,
                 disk_size: int,
                 elastic_ip_ids: Sequence[str],
                 ipv6: bool,
                 ipv6_address: str,
                 labels: Mapping[str, str],
                 manager_id: str,
                 manager_type: str,
                 private_network_ids: Sequence[str],
                 public_ip_address: str,
                 reverse_dns: str,
                 security_group_ids: Sequence[str],
                 ssh_key: str,
                 state: str,
                 template_id: str,
                 type: str,
                 user_data: str,
                 zone: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] anti_affinity_group_ids: The list of attached AntiAffinityGroup (IDs).
        :param str created_at: The compute instance creation date.
        :param str deploy_target_id: A deploy target ID.
        :param int disk_size: The instance disk size (GiB).
        :param Sequence[str] elastic_ip_ids: The list of attached ElasticIp (IDs).
        :param bool ipv6: Whether IPv6 is enabled on the instance.
        :param str ipv6_address: The instance (main network interface) IPv6 address (if enabled).
        :param Mapping[str, str] labels: A map of key/value labels.
        :param str manager_id: The instance manager ID, if any.
        :param str manager_type: The instance manager type (instance pool, SKS node pool, etc.), if any.
        :param Sequence[str] private_network_ids: The list of attached PrivateNetwork (IDs).
        :param str public_ip_address: The instance (main network interface) IPv4 address.
        :param str reverse_dns: Domain name for reverse DNS record.
        :param Sequence[str] security_group_ids: The list of attached SecurityGroup (IDs).
        :param str ssh_key: The SshKey (name) authorized on the instance.
        :param str state: The instance state.
        :param str template_id: The instance get_template ID.
        :param str type: The instance type.
        :param str user_data: The instance [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        :param str zone: The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        :param str id: The compute instance ID to match (conflicts with `name`).
        :param str name: The instance name to match (conflicts with `id`).
        """
        pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "elastic_ip_ids", elastic_ip_ids)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "manager_id", manager_id)
        pulumi.set(__self__, "manager_type", manager_type)
        pulumi.set(__self__, "private_network_ids", private_network_ids)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "reverse_dns", reverse_dns)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "zone", zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Sequence[str]:
        """
        The list of attached AntiAffinityGroup (IDs).
        """
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The compute instance creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> str:
        """
        A deploy target ID.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        The instance disk size (GiB).
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[str]:
        """
        The list of attached ElasticIp (IDs).
        """
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        """
        Whether IPv6 is enabled on the instance.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        The instance (main network interface) IPv6 address (if enabled).
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> str:
        """
        The instance manager ID, if any.
        """
        return pulumi.get(self, "manager_id")

    @property
    @pulumi.getter(name="managerType")
    def manager_type(self) -> str:
        """
        The instance manager type (instance pool, SKS node pool, etc.), if any.
        """
        return pulumi.get(self, "manager_type")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Sequence[str]:
        """
        The list of attached PrivateNetwork (IDs).
        """
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="reverseDns")
    def reverse_dns(self) -> str:
        """
        Domain name for reverse DNS record.
        """
        return pulumi.get(self, "reverse_dns")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        The list of attached SecurityGroup (IDs).
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        The SshKey (name) authorized on the instance.
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The instance state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        """
        The instance get_template ID.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The instance type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> str:
        """
        The instance [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The compute instance ID to match (conflicts with `name`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The instance name to match (conflicts with `id`).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseUriTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetDomainRecordFilterResult(dict):
    def __init__(__self__, *,
                 content_regex: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 record_type: Optional[str] = None):
        """
        :param str content_regex: A regular expression to match the record content.
        :param str id: The record ID to match.
        :param str name: The domain record name to match.
        :param str record_type: The record type to match.
        """
        if content_regex is not None:
            pulumi.set(__self__, "content_regex", content_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="contentRegex")
    def content_regex(self) -> Optional[str]:
        """
        A regular expression to match the record content.
        """
        return pulumi.get(self, "content_regex")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The record ID to match.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The domain record name to match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        The record type to match.
        """
        return pulumi.get(self, "record_type")


@pulumi.output_type
class GetDomainRecordRecordResult(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 domain: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 prio: Optional[int] = None,
                 record_type: Optional[str] = None,
                 ttl: Optional[int] = None):
        """
        :param str content: Content of the Record
        :param str domain: Domain of the Record
        :param str id: ID of the Record
        :param str name: Name of the Record
        :param int prio: Priority of the Record
        :param str record_type: Type of the Record
        :param int ttl: TTL of the Record
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prio is not None:
            pulumi.set(__self__, "prio", prio)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Content of the Record
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain of the Record
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the Record
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Record
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prio(self) -> Optional[int]:
        """
        Priority of the Record
        """
        return pulumi.get(self, "prio")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        Type of the Record
        """
        return pulumi.get(self, "record_type")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        TTL of the Record
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetElasticIpHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: int,
                 mode: str,
                 port: int,
                 strikes_fail: int,
                 strikes_ok: int,
                 timeout: int,
                 tls_skip_verify: bool,
                 tls_sni: str,
                 uri: str):
        """
        :param int interval: The healthcheck interval in seconds.
        :param str mode: The healthcheck mode.
        :param int port: The healthcheck target port.
        :param int strikes_fail: The number of failed healthcheck attempts before considering the target unhealthy.
        :param int strikes_ok: The number of successful healthcheck attempts before considering the target healthy.
        :param int timeout: The time in seconds before considering a healthcheck probing failed.
        :param bool tls_skip_verify: Disable TLS certificate verification for healthcheck in `https` mode.
        :param str tls_sni: The healthcheck server name to present with SNI in `https` mode.
        :param str uri: The healthcheck URI.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "strikes_fail", strikes_fail)
        pulumi.set(__self__, "strikes_ok", strikes_ok)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        pulumi.set(__self__, "tls_sni", tls_sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The healthcheck interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The healthcheck mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The healthcheck target port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> int:
        """
        The number of failed healthcheck attempts before considering the target unhealthy.
        """
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> int:
        """
        The number of successful healthcheck attempts before considering the target healthy.
        """
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The time in seconds before considering a healthcheck probing failed.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> bool:
        """
        Disable TLS certificate verification for healthcheck in `https` mode.
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> str:
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The healthcheck URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetIamApiKeyTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetIamOrgPolicyServicesResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetIamOrgPolicyServicesRuleResult'],
                 type: str):
        """
        :param Sequence['GetIamOrgPolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetIamOrgPolicyServicesRuleResult']:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIamOrgPolicyServicesRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 expression: str,
                 resources: Sequence[str]):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is no longer suported.""")
    def resources(self) -> Sequence[str]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetIamOrgPolicyTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetIamRolePolicyResult(dict):
    def __init__(__self__, *,
                 default_service_strategy: str,
                 services: Mapping[str, 'outputs.GetIamRolePolicyServicesResult']):
        """
        :param str default_service_strategy: Default service strategy (`allow` or `deny`).
        :param Mapping[str, 'GetIamRolePolicyServicesArgs'] services: IAM policy services.
        """
        pulumi.set(__self__, "default_service_strategy", default_service_strategy)
        pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="defaultServiceStrategy")
    def default_service_strategy(self) -> str:
        """
        Default service strategy (`allow` or `deny`).
        """
        return pulumi.get(self, "default_service_strategy")

    @property
    @pulumi.getter
    def services(self) -> Mapping[str, 'outputs.GetIamRolePolicyServicesResult']:
        """
        IAM policy services.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class GetIamRolePolicyServicesResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetIamRolePolicyServicesRuleResult'],
                 type: str):
        """
        :param Sequence['GetIamRolePolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetIamRolePolicyServicesRuleResult']:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIamRolePolicyServicesRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 expression: str,
                 resources: Sequence[str]):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This field is no longer suported.""")
    def resources(self) -> Sequence[str]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetIamRoleTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetInstancePoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: str,
                 public_ip_address: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str ipv6_address: The instance (main network interface) IPv6 address.
        :param str public_ip_address: The instance (main network interface) IPv4 address.
        :param str id: The compute instance ID.
        :param str name: The instance name.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The compute instance ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolResult(dict):
    def __init__(__self__, *,
                 affinity_group_ids: Sequence[str],
                 anti_affinity_group_ids: Sequence[str],
                 deploy_target_id: str,
                 description: str,
                 disk_size: int,
                 elastic_ip_ids: Sequence[str],
                 instance_prefix: str,
                 instance_type: str,
                 instances: Sequence['outputs.GetInstancePoolListPoolInstanceResult'],
                 ipv6: bool,
                 key_pair: str,
                 network_ids: Sequence[str],
                 security_group_ids: Sequence[str],
                 size: int,
                 state: str,
                 template_id: str,
                 user_data: str,
                 zone: str,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] affinity_group_ids: The list of attached AntiAffinityGroup (IDs). Use anti_affinity_group_ids instead.
        :param Sequence[str] anti_affinity_group_ids: The list of attached AntiAffinityGroup (IDs).
        :param str deploy_target_id: The deploy target ID.
        :param str description: The instance pool description.
        :param int disk_size: The managed instances disk size.
        :param Sequence[str] elastic_ip_ids: The list of attached ElasticIp (IDs).
        :param str instance_prefix: The string used to prefix the managed instances name.
        :param str instance_type: The managed instances type.
        :param Sequence['GetInstancePoolListPoolInstanceArgs'] instances: The list of managed instances. Structure is documented below.
        :param bool ipv6: Whether IPv6 is enabled on managed instances.
        :param str key_pair: The SshKey (name) authorized on the managed instances.
        :param Sequence[str] network_ids: The list of attached PrivateNetwork (IDs).
        :param Sequence[str] security_group_ids: The list of attached SecurityGroup (IDs).
        :param int size: The number managed instances.
        :param str state: The pool state.
        :param str template_id: The managed instances get_template ID.
        :param str user_data: [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        :param str zone: The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        :param str id: The instance pool ID to match (conflicts with `name`).
        :param Mapping[str, str] labels: A map of key/value labels.
        :param str name: The pool name to match (conflicts with `id`).
        """
        pulumi.set(__self__, "affinity_group_ids", affinity_group_ids)
        pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "elastic_ip_ids", elastic_ip_ids)
        pulumi.set(__self__, "instance_prefix", instance_prefix)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "key_pair", key_pair)
        pulumi.set(__self__, "network_ids", network_ids)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "zone", zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="affinityGroupIds")
    @_utilities.deprecated("""Use anti_affinity_group_ids instead.""")
    def affinity_group_ids(self) -> Sequence[str]:
        """
        The list of attached AntiAffinityGroup (IDs). Use anti_affinity_group_ids instead.
        """
        return pulumi.get(self, "affinity_group_ids")

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Sequence[str]:
        """
        The list of attached AntiAffinityGroup (IDs).
        """
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> str:
        """
        The deploy target ID.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The instance pool description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        The managed instances disk size.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[str]:
        """
        The list of attached ElasticIp (IDs).
        """
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> str:
        """
        The string used to prefix the managed instances name.
        """
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        The managed instances type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetInstancePoolListPoolInstanceResult']:
        """
        The list of managed instances. Structure is documented below.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        """
        Whether IPv6 is enabled on managed instances.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> str:
        """
        The SshKey (name) authorized on the managed instances.
        """
        return pulumi.get(self, "key_pair")

    @property
    @pulumi.getter(name="networkIds")
    def network_ids(self) -> Sequence[str]:
        """
        The list of attached PrivateNetwork (IDs).
        """
        return pulumi.get(self, "network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        The list of attached SecurityGroup (IDs).
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The number managed instances.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The pool state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        """
        The managed instances get_template ID.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> str:
        """
        [cloud-init](http://cloudinit.readthedocs.io/en/latest/) configuration.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The Exoscale [Zone](https://www.exoscale.com/datacenters/) name.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The instance pool ID to match (conflicts with `name`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The pool name to match (conflicts with `id`).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: str,
                 public_ip_address: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str ipv6_address: The instance (main network interface) IPv6 address.
        :param str public_ip_address: The instance (main network interface) IPv4 address.
        :param str id: The compute instance ID.
        :param str name: The instance name.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The compute instance ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNlbServiceListServiceResult(dict):
    def __init__(__self__, *,
                 description: str,
                 healthcheck: 'outputs.GetNlbServiceListServiceHealthcheckResult',
                 id: str,
                 instance_pool_id: str,
                 name: str,
                 port: int,
                 protocol: str,
                 state: str,
                 strategy: str,
                 target_port: int):
        """
        :param str description: NLB service description.
        :param str id: NLB service ID.
        :param str instance_pool_id: The exoscale*instance*pool (ID) to forward traffic to.
        :param str name: NLB Service name.
        :param int port: Port exposed on the NLB's public IP.
        :param str protocol: Network traffic protocol.
        :param str state: NLB Service State.
        :param str strategy: The strategy (`round-robin`|`source-hash`).
        :param int target_port: Port on which the network traffic will be forwarded to on the receiving instance.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        NLB service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetNlbServiceListServiceHealthcheckResult':
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        NLB service ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        """
        The exoscale*instance*pool (ID) to forward traffic to.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        NLB Service name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port exposed on the NLB's public IP.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Network traffic protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        NLB Service State.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The strategy (`round-robin`|`source-hash`).
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> int:
        """
        Port on which the network traffic will be forwarded to on the receiving instance.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetNlbServiceListServiceHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: int,
                 mode: str,
                 port: int,
                 retries: int,
                 timeout: int,
                 tls_sni: str,
                 uri: str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "tls_sni", tls_sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def retries(self) -> int:
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> str:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetNlbServiceListTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetSksClusterListClusterResult(dict):
    def __init__(__self__, *,
                 addons: Sequence[str],
                 aggregation_ca: str,
                 control_plane_ca: str,
                 created_at: str,
                 endpoint: str,
                 kubelet_ca: str,
                 nodepools: Sequence[str],
                 oidc: 'outputs.GetSksClusterListClusterOidcResult',
                 state: str,
                 version: str,
                 zone: str,
                 auto_upgrade: Optional[bool] = None,
                 cni: Optional[str] = None,
                 description: Optional[str] = None,
                 exoscale_ccm: Optional[bool] = None,
                 exoscale_csi: Optional[bool] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 metrics_server: Optional[bool] = None,
                 name: Optional[str] = None,
                 service_level: Optional[str] = None):
        """
        :param str aggregation_ca: The CA certificate (in PEM format) for TLS communications between the control plane and the aggregation layer (e.g. `metrics-server`).
        :param str control_plane_ca: The CA certificate (in PEM format) for TLS communications between control plane components.
        :param str created_at: The cluster creation date.
        :param str endpoint: The cluster API endpoint.
        :param str kubelet_ca: The CA certificate (in PEM format) for TLS communications between kubelets and the control plane.
        :param Sequence[str] nodepools: The list of SksNodepool (IDs) attached to the cluster.
        :param 'GetSksClusterListClusterOidcArgs' oidc: An OpenID Connect configuration to provide to the Kubernetes API server (may only be set at creation time). Structure is documented below.
        :param str state: The cluster state.
        :param str version: The version of the control plane (default: latest version available from the API; see `exo compute sks versions` for reference; may only be set at creation time).
        :param bool auto_upgrade: Enable automatic upgrading of the control plane version.
        :param str cni: The CNI plugin that is to be used. Available options are "calico" or "cilium". Defaults to "calico". Setting empty string will result in a cluster with no CNI.
        :param str description: A free-form text describing the cluster.
        :param bool exoscale_ccm: Deploy the Exoscale [Cloud Controller Manager](https://github.com/exoscale/exoscale-cloud-controller-manager/) in the control plane (boolean; default: `true`; may only be set at creation time).
        :param bool exoscale_csi: Deploy the Exoscale [Container Storage Interface](https://github.com/exoscale/exoscale-csi-driver/) on worker nodes (boolean; default: `false`; requires the CCM to be enabled).
        :param Mapping[str, str] labels: A map of key/value labels.
        :param bool metrics_server: Deploy the [Kubernetes Metrics Server](https://github.com/kubernetes-sigs/metrics-server/) in the control plane (boolean; default: `true`; may only be set at creation time).
        :param str service_level: The service level of the control plane (`pro` or `starter`; default: `pro`; may only be set at creation time).
        """
        pulumi.set(__self__, "addons", addons)
        pulumi.set(__self__, "aggregation_ca", aggregation_ca)
        pulumi.set(__self__, "control_plane_ca", control_plane_ca)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "kubelet_ca", kubelet_ca)
        pulumi.set(__self__, "nodepools", nodepools)
        pulumi.set(__self__, "oidc", oidc)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zone", zone)
        if auto_upgrade is not None:
            pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if cni is not None:
            pulumi.set(__self__, "cni", cni)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exoscale_ccm is not None:
            pulumi.set(__self__, "exoscale_ccm", exoscale_ccm)
        if exoscale_csi is not None:
            pulumi.set(__self__, "exoscale_csi", exoscale_csi)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metrics_server is not None:
            pulumi.set(__self__, "metrics_server", metrics_server)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_level is not None:
            pulumi.set(__self__, "service_level", service_level)

    @property
    @pulumi.getter
    @_utilities.deprecated("""This attribute has been replaced by `exoscale_ccm`/`metrics_server` attributes, it will be removed in a future release.""")
    def addons(self) -> Sequence[str]:
        return pulumi.get(self, "addons")

    @property
    @pulumi.getter(name="aggregationCa")
    def aggregation_ca(self) -> str:
        """
        The CA certificate (in PEM format) for TLS communications between the control plane and the aggregation layer (e.g. `metrics-server`).
        """
        return pulumi.get(self, "aggregation_ca")

    @property
    @pulumi.getter(name="controlPlaneCa")
    def control_plane_ca(self) -> str:
        """
        The CA certificate (in PEM format) for TLS communications between control plane components.
        """
        return pulumi.get(self, "control_plane_ca")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The cluster creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The cluster API endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kubeletCa")
    def kubelet_ca(self) -> str:
        """
        The CA certificate (in PEM format) for TLS communications between kubelets and the control plane.
        """
        return pulumi.get(self, "kubelet_ca")

    @property
    @pulumi.getter
    def nodepools(self) -> Sequence[str]:
        """
        The list of SksNodepool (IDs) attached to the cluster.
        """
        return pulumi.get(self, "nodepools")

    @property
    @pulumi.getter
    def oidc(self) -> 'outputs.GetSksClusterListClusterOidcResult':
        """
        An OpenID Connect configuration to provide to the Kubernetes API server (may only be set at creation time). Structure is documented below.
        """
        return pulumi.get(self, "oidc")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The cluster state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the control plane (default: latest version available from the API; see `exo compute sks versions` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[bool]:
        """
        Enable automatic upgrading of the control plane version.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter
    def cni(self) -> Optional[str]:
        """
        The CNI plugin that is to be used. Available options are "calico" or "cilium". Defaults to "calico". Setting empty string will result in a cluster with no CNI.
        """
        return pulumi.get(self, "cni")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A free-form text describing the cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="exoscaleCcm")
    def exoscale_ccm(self) -> Optional[bool]:
        """
        Deploy the Exoscale [Cloud Controller Manager](https://github.com/exoscale/exoscale-cloud-controller-manager/) in the control plane (boolean; default: `true`; may only be set at creation time).
        """
        return pulumi.get(self, "exoscale_ccm")

    @property
    @pulumi.getter(name="exoscaleCsi")
    def exoscale_csi(self) -> Optional[bool]:
        """
        Deploy the Exoscale [Container Storage Interface](https://github.com/exoscale/exoscale-csi-driver/) on worker nodes (boolean; default: `false`; requires the CCM to be enabled).
        """
        return pulumi.get(self, "exoscale_csi")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[bool]:
        """
        Deploy the [Kubernetes Metrics Server](https://github.com/kubernetes-sigs/metrics-server/) in the control plane (boolean; default: `true`; may only be set at creation time).
        """
        return pulumi.get(self, "metrics_server")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[str]:
        """
        The service level of the control plane (`pro` or `starter`; default: `pro`; may only be set at creation time).
        """
        return pulumi.get(self, "service_level")


@pulumi.output_type
class GetSksClusterListClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSksClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSksNodepoolKubeletImageGcResult(dict):
    def __init__(__self__, *,
                 high_threshold: Optional[int] = None,
                 low_threshold: Optional[int] = None,
                 min_age: Optional[str] = None):
        """
        :param int high_threshold: The percent of disk usage after which image garbage collection is always run
        :param int low_threshold: The percent of disk usage before which image garbage collection is never run
        :param str min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[int]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[int]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")


@pulumi.output_type
class GetSksNodepoolListNodepoolResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 created_at: str,
                 instance_pool_id: str,
                 state: str,
                 template_id: str,
                 version: str,
                 zone: str,
                 anti_affinity_group_ids: Optional[Sequence[str]] = None,
                 deploy_target_id: Optional[str] = None,
                 description: Optional[str] = None,
                 disk_size: Optional[int] = None,
                 id: Optional[str] = None,
                 instance_prefix: Optional[str] = None,
                 instance_type: Optional[str] = None,
                 kubelet_image_gcs: Optional[Sequence['outputs.GetSksNodepoolListNodepoolKubeletImageGcResult']] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 private_network_ids: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 size: Optional[int] = None,
                 storage_lvm: Optional[bool] = None,
                 taints: Optional[Mapping[str, str]] = None):
        """
        :param str created_at: The pool creation date.
        :param str instance_pool_id: The underlying InstancePool ID.
        :param str state: The current pool state.
        :param str template_id: The managed instances template ID.
        :param str version: The managed instances version.
        :param Sequence[str] anti_affinity_group_ids: A list of AntiAffinityGroup (IDs) to be attached to the managed instances.
        :param str deploy_target_id: A deploy target ID.
        :param str description: A free-form text describing the pool.
        :param int disk_size: The managed instances disk size (GiB; default: `50`).
        :param str instance_prefix: The string used to prefix the managed instances name (default `pool`).
        :param str instance_type: The managed compute instances type (`<family>.<size>`, e.g. `standard.medium`; use the [Exoscale CLI](https://github.com/exoscale/cli/) - `exo compute instance-type list` - for the list of available types).
        :param Sequence['GetSksNodepoolListNodepoolKubeletImageGcArgs'] kubelet_image_gcs: Configuration for this nodepool's kubelet image garbage collector
        :param Mapping[str, str] labels: A map of key/value labels.
        :param Sequence[str] private_network_ids: A list of PrivateNetwork (IDs) to be attached to the managed instances.
        :param Sequence[str] security_group_ids: A list of SecurityGroup (IDs) to be attached to the managed instances.
        :param bool storage_lvm: Create nodes with non-standard partitioning for persistent storage (requires min 100G of disk space) (may only be set at creation time).
        :param Mapping[str, str] taints: A map of key/value Kubernetes [taints](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/) ('taints = { <key> = "<value>:<effect>" }').
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zone", zone)
        if anti_affinity_group_ids is not None:
            pulumi.set(__self__, "anti_affinity_group_ids", anti_affinity_group_ids)
        if deploy_target_id is not None:
            pulumi.set(__self__, "deploy_target_id", deploy_target_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_prefix is not None:
            pulumi.set(__self__, "instance_prefix", instance_prefix)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kubelet_image_gcs is not None:
            pulumi.set(__self__, "kubelet_image_gcs", kubelet_image_gcs)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_network_ids is not None:
            pulumi.set(__self__, "private_network_ids", private_network_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if storage_lvm is not None:
            pulumi.set(__self__, "storage_lvm", storage_lvm)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The pool creation date.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        """
        The underlying InstancePool ID.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current pool state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        """
        The managed instances template ID.
        """
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The managed instances version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of AntiAffinityGroup (IDs) to be attached to the managed instances.
        """
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> Optional[str]:
        """
        A deploy target ID.
        """
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A free-form text describing the pool.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        The managed instances disk size (GiB; default: `50`).
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> Optional[str]:
        """
        The string used to prefix the managed instances name (default `pool`).
        """
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The managed compute instances type (`<family>.<size>`, e.g. `standard.medium`; use the [Exoscale CLI](https://github.com/exoscale/cli/) - `exo compute instance-type list` - for the list of available types).
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="kubeletImageGcs")
    def kubelet_image_gcs(self) -> Optional[Sequence['outputs.GetSksNodepoolListNodepoolKubeletImageGcResult']]:
        """
        Configuration for this nodepool's kubelet image garbage collector
        """
        return pulumi.get(self, "kubelet_image_gcs")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value labels.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[Sequence[str]]:
        """
        A list of PrivateNetwork (IDs) to be attached to the managed instances.
        """
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of SecurityGroup (IDs) to be attached to the managed instances.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="storageLvm")
    def storage_lvm(self) -> Optional[bool]:
        """
        Create nodes with non-standard partitioning for persistent storage (requires min 100G of disk space) (may only be set at creation time).
        """
        return pulumi.get(self, "storage_lvm")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value Kubernetes [taints](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/) ('taints = { <key> = "<value>:<effect>" }').
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class GetSksNodepoolListNodepoolKubeletImageGcResult(dict):
    def __init__(__self__, *,
                 high_threshold: Optional[int] = None,
                 low_threshold: Optional[int] = None,
                 min_age: Optional[str] = None):
        """
        :param int high_threshold: The percent of disk usage after which image garbage collection is always run
        :param int low_threshold: The percent of disk usage before which image garbage collection is never run
        :param str min_age: The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        if high_threshold is not None:
            pulumi.set(__self__, "high_threshold", high_threshold)
        if low_threshold is not None:
            pulumi.set(__self__, "low_threshold", low_threshold)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="highThreshold")
    def high_threshold(self) -> Optional[int]:
        """
        The percent of disk usage after which image garbage collection is always run
        """
        return pulumi.get(self, "high_threshold")

    @property
    @pulumi.getter(name="lowThreshold")
    def low_threshold(self) -> Optional[int]:
        """
        The percent of disk usage before which image garbage collection is never run
        """
        return pulumi.get(self, "low_threshold")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        The minimum age for an unused image before it is garbage collected (k8s duration format, eg. 1h)
        """
        return pulumi.get(self, "min_age")


