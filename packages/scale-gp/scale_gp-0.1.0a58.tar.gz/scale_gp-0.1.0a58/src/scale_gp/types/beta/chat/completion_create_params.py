# File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

from __future__ import annotations

from typing import Dict, List, Union, Iterable
from typing_extensions import Literal, Required, TypeAlias, TypedDict

__all__ = [
    "CompletionCreateParamsBase",
    "Message",
    "MessageUserMessage",
    "MessageUserMessageContent",
    "MessageUserMessageContentChatCompletionContentPartTextParam",
    "MessageUserMessageContentChatCompletionContentPartImageParam",
    "MessageUserMessageContentChatCompletionContentPartImageParamImageURL",
    "MessageUserMessageContentChatCompletionContentPartParam",
    "MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartTextParam",
    "MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartImageParam",
    "MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartImageParamImageURL",
    "MessageToolMessage",
    "MessageSystemMessage",
    "MessageAssistantMessage",
    "MessageAssistantMessageToolCall",
    "MessageAssistantMessageToolCallFunction",
    "MessageMessage",
    "MessageMessageFunctionCall",
    "MessageMessageAudio",
    "Audio",
    "MemoryStrategy",
    "ResponseFormat",
    "ResponseFormatResponseFormatText",
    "ResponseFormatResponseFormatJsonObject",
    "ResponseFormatResponseFormatJsonSchema",
    "ResponseFormatResponseFormatJsonSchemaJsonSchema",
    "ToolChoice",
    "ToolChoiceChatCompletionNamedToolChoiceParam",
    "ToolChoiceChatCompletionNamedToolChoiceParamFunction",
    "Tool",
    "ToolFunction",
    "ToolCacheControl",
    "CompletionCreateParamsNonStreaming",
    "CompletionCreateParamsStreaming",
]


class CompletionCreateParamsBase(TypedDict, total=False):
    messages: Required[Iterable[Message]]
    """The list of messages in the conversation.

    Expand each message type to see how it works and when to use it. Most
    conversations should begin with a single `user` message.
    """

    model: Required[str]
    """The name of the model.

    Should be formatted as `vendor/model_name` or `vendor/model_name/deployment`
    (ie: `openai/gpt-3.5-turbo`).
    """

    audio: Audio
    """Audio-related parameters for chat completion"""

    best_of: int
    """
    Generates best_of completions server-side and returns the `best` (the one with
    the highest log probability per token). Results cannot be streamed.
    """

    chat_template: str
    """A Jinja template to use for this conversion.

    As of transformers v4.44, default chat template is no longer allowed, so you
    must provide a chat template if the model's tokenizer does not define one and no
    override template is given
    """

    chat_template_kwargs: object
    """Additional kwargs to pass to the template renderer.

    Will be accessible by the chat template.
    """

    frequency_penalty: float
    """Number between -2.0 and 2.0.

    Positive values penalize new tokens based on their existing frequency in the
    text so far, decreasing the model's likelihood to repeat the same line verbatim.
    """

    guided_choice: List[str]
    """Choices for guided decoding. Only supported in vllm."""

    guided_decoding_backend: str
    """
    If specified, will override the default guided decoding backend of the server
    for this specific request. If set, must be either 'outlines' /
    'lm-format-enforcer'
    """

    guided_grammar: str
    """Context-free grammar for guided decoding. Only supported in vllm."""

    guided_json: object
    """JSON schema for guided decoding. Only supported in vllm."""

    guided_regex: str
    """Regex for guided decoding. Only supported in vllm."""

    guided_whitespace_pattern: str
    """
    If specified, will override the default whitespace pattern for guided json
    decoding.
    """

    include_stop_str_in_output: bool
    """Whether to include the stop string in the output."""

    inference_extra_headers: object
    """Additional headers to be included in the API request"""

    inference_extra_params: object
    """Additional params to be included in the API request"""

    inference_timeout: Union[float, str]
    """Timeout for the API request"""

    logit_bias: Dict[str, int]
    """Modify the likelihood of specified tokens appearing in the completion.

    Accepts a JSON object that maps tokens (specified by their token ID in the
    tokenizer) to an associated bias value from -100 to 100. Mathematically, the
    bias is added to the logits generated by the model prior to sampling. The exact
    effect will vary per model, but values between -1 and 1 should decrease or
    increase likelihood of selection; values like -100 or 100 should result in a ban
    or exclusive selection of the relevant token.
    """

    logprobs: bool
    """
    Whether to return log probabilities of the output tokens or not. If true,
    returns the log probabilities of each output token returned in the content of
    message.
    """

    max_completion_tokens: int
    """Maximum number of tokens to generate in the completion"""

    max_tokens: int
    """The maximum number of tokens that can be generated.

    The token count of your prompt plus max_tokens cannot exceed the model's context
    length.
    """

    memory_strategy: MemoryStrategy
    """The memory strategy to use for the conversation.

    A memory strategy is a way to prevent the underlying LLM's context limit from
    being exceeded. Only the `last_k` memory strategy is supported at this time.
    """

    modalities: List[Literal["text", "audio"]]
    """List of modalities for the chat completion"""

    n: int
    """How many completions to generate for each prompt.

    Note: Because this parameter generates many completions, it can quickly consume
    your token quota. Use carefully and ensure that you have reasonable settings for
    max_tokens and stop.
    """

    parallel_tool_calls: bool
    """Currently only supported for OpenAI models.Enables calling tools in parallel."""

    prediction: object
    """Configure a predicted output to reduce latency"""

    presence_penalty: float
    """Number between -2.0 and 2.0.

    Positive values penalize new tokens based on whether they appear in the text so
    far, increasing the model's likelihood to talk about new topics.
    """

    response_format: ResponseFormat
    """An object specifying the format that the model must output"""

    seed: int
    """
    If specified, our system will make a best effort to sample deterministically,
    such that repeated requests with the same seed and parameters should return the
    same result.
    """

    stop: Union[str, List[str]]
    """Up to 4 sequences where the API will stop generating further tokens."""

    stream_options: object
    """Customize streaming behavior"""

    suffix: str
    """
    The suffix that comes after a completion of inserted text.This parameter is only
    supported for gpt-3.5-turbo-instruct.
    """

    temperature: float
    """The sampling temperature to use for the completion.

    Higher values mean the model will take more risks.
    """

    tool_choice: ToolChoice
    """
    Currently only supported for OpenAI and Anthropic models.Controls which (if any)
    tool is called by the model.
    """

    tools: Iterable[Tool]
    """
    Currently only supported for OpenAI and Anthropic models.A list of tools the
    model may call.Currently, only functions are supported as a tool.Use this to
    provide a list of functions the model may generate JSON inputs for.
    """

    top_k: int
    """Only sample from the top K options for each subsequent token"""

    top_logprobs: int
    """
    An integer between 0 and 20 specifying the number of most likely tokens to
    return at each token position, each with an associated log probability. logprobs
    must be set to true if this parameter is used.
    """

    top_p: float
    """
    An alternative to sampling with temperature, called nucleus sampling, where the
    model considers the results of the tokens with top_p probability mass. So 0.1
    means only the tokens comprising the top 10% probability mass are considered.

    It is generally recommended to alter this or temperature but not both.
    """

    user: str
    """A unique identifier representing your end-user."""


class MessageUserMessageContentChatCompletionContentPartTextParam(TypedDict, total=False):
    text: Required[str]
    """The text content."""

    type: Required[Literal["text"]]


class MessageUserMessageContentChatCompletionContentPartImageParamImageURL(TypedDict, total=False):
    url: Required[str]
    """Either a URL of the image or the base64 encoded image data.

    Must be b64 encoded if using Anthropic Models.
    """

    detail: Literal["auto", "low", "high"]
    """Specifies the detail level of the image.

    Learn more in the
    [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
    """

    media_type: Literal["image/jpeg", "image/png", "image/gif", "image/webp"]
    """Required for Anthropic Models. The media type of the image."""


class MessageUserMessageContentChatCompletionContentPartImageParam(TypedDict, total=False):
    image_url: Required[MessageUserMessageContentChatCompletionContentPartImageParamImageURL]

    type: Required[Literal["image_url"]]


class MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartTextParam(TypedDict, total=False):
    text: Required[str]
    """The text content."""

    type: Required[Literal["text"]]


class MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartImageParamImageURL(
    TypedDict, total=False
):
    url: Required[str]
    """Either a URL of the image or the base64 encoded image data.

    Must be b64 encoded if using Anthropic Models.
    """

    detail: Literal["auto", "low", "high"]
    """Specifies the detail level of the image.

    Learn more in the
    [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
    """

    media_type: Literal["image/jpeg", "image/png", "image/gif", "image/webp"]
    """Required for Anthropic Models. The media type of the image."""


class MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartImageParam(
    TypedDict, total=False
):
    image_url: Required[
        MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartImageParamImageURL
    ]

    type: Required[Literal["image_url"]]


MessageUserMessageContentChatCompletionContentPartParam: TypeAlias = Union[
    MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartTextParam,
    MessageUserMessageContentChatCompletionContentPartParamChatCompletionContentPartImageParam,
]

MessageUserMessageContent: TypeAlias = Union[
    str,
    MessageUserMessageContentChatCompletionContentPartTextParam,
    MessageUserMessageContentChatCompletionContentPartImageParam,
    Iterable[MessageUserMessageContentChatCompletionContentPartParam],
]


class MessageUserMessage(TypedDict, total=False):
    content: Required[MessageUserMessageContent]

    name: str
    """An optional name for the participant."""

    role: Literal["user"]


class MessageToolMessage(TypedDict, total=False):
    content: Required[str]
    """The contents of the tool message."""

    tool_call_id: Required[str]
    """Tool call that this message is responding to."""

    role: Literal["tool"]


class MessageSystemMessage(TypedDict, total=False):
    content: Required[str]

    name: str
    """An optional name for the participant."""

    role: Literal["system"]


class MessageAssistantMessageToolCallFunction(TypedDict, total=False):
    name: Required[str]
    """The name of the function to be called."""

    arguments: str
    """
    The arguments to call the function with, as generated by the model in JSON
    format.Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """


class MessageAssistantMessageToolCall(TypedDict, total=False):
    id: Required[str]
    """The ID of the tool call."""

    function: Required[MessageAssistantMessageToolCallFunction]
    """The function that the model called."""

    type: Required[Literal["function"]]


class MessageAssistantMessage(TypedDict, total=False):
    content: str
    """The contents of the assistant message.

    Required unless `tool_calls` is specified.
    """

    role: Literal["assistant"]

    tool_calls: Iterable[MessageAssistantMessageToolCall]
    """The tool calls generated by the model, such as function calls."""


class MessageMessageFunctionCallTyped(TypedDict, total=False):
    arguments: Required[str]

    name: str


MessageMessageFunctionCall: TypeAlias = Union[MessageMessageFunctionCallTyped, Dict[str, object]]


class MessageMessageAudioTyped(TypedDict, total=False):
    id: Required[str]

    data: Required[str]

    expires_at: Required[int]

    transcript: Required[str]


MessageMessageAudio: TypeAlias = Union[MessageMessageAudioTyped, Dict[str, object]]


class MessageMessageTyped(TypedDict, total=False):
    content: Required[str]

    function_call: Required[MessageMessageFunctionCall]

    role: Required[Literal["assistant", "user", "system", "tool", "function"]]

    tool_calls: Required[Iterable[Dict[str, object]]]

    audio: MessageMessageAudio


MessageMessage: TypeAlias = Union[MessageMessageTyped, Dict[str, object]]

Message: TypeAlias = Union[
    MessageUserMessage, MessageToolMessage, MessageSystemMessage, MessageAssistantMessage, MessageMessage
]


class Audio(TypedDict, total=False):
    format: Required[Literal["wav", "mp3", "flac", "opus", "pcm16"]]

    voice: Required[Literal["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse"]]


class MemoryStrategy(TypedDict, total=False):
    k: Required[int]

    name: Literal["last_k"]


class ResponseFormatResponseFormatText(TypedDict, total=False):
    type: Required[Literal["text"]]


class ResponseFormatResponseFormatJsonObject(TypedDict, total=False):
    type: Required[Literal["json_object"]]


class ResponseFormatResponseFormatJsonSchemaJsonSchema(TypedDict, total=False):
    name: Required[str]

    description: str

    schema: object

    strict: bool


class ResponseFormatResponseFormatJsonSchema(TypedDict, total=False):
    json_schema: Required[ResponseFormatResponseFormatJsonSchemaJsonSchema]

    type: Required[Literal["json_schema"]]


ResponseFormat: TypeAlias = Union[
    ResponseFormatResponseFormatText,
    ResponseFormatResponseFormatJsonObject,
    ResponseFormatResponseFormatJsonSchema,
    object,
]


class ToolChoiceChatCompletionNamedToolChoiceParamFunction(TypedDict, total=False):
    name: Required[str]


class ToolChoiceChatCompletionNamedToolChoiceParam(TypedDict, total=False):
    function: Required[ToolChoiceChatCompletionNamedToolChoiceParamFunction]

    type: Required[Literal["function"]]


ToolChoice: TypeAlias = Union[Literal["none", "auto", "required"], ToolChoiceChatCompletionNamedToolChoiceParam]


class ToolFunction(TypedDict, total=False):
    name: Required[str]

    description: str

    parameters: object


class ToolCacheControl(TypedDict, total=False):
    type: Required[Literal["ephemeral"]]


class Tool(TypedDict, total=False):
    function: Required[ToolFunction]

    type: Required[Union[Literal["function"], str]]

    cache_control: ToolCacheControl


class CompletionCreateParamsNonStreaming(CompletionCreateParamsBase, total=False):
    stream: Literal[False]
    """Whether or not to stream the response.

    Setting this to True will stream the response in real-time.
    """


class CompletionCreateParamsStreaming(CompletionCreateParamsBase):
    stream: Required[Literal[True]]
    """Whether or not to stream the response.

    Setting this to True will stream the response in real-time.
    """


CompletionCreateParams = Union[CompletionCreateParamsNonStreaming, CompletionCreateParamsStreaming]
