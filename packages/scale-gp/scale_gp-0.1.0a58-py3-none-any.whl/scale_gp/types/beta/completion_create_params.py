# File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

from __future__ import annotations

from typing import Dict, List, Union, Iterable
from typing_extensions import Literal, Required, TypeAlias, TypedDict

__all__ = [
    "CompletionCreateParamsBase",
    "Audio",
    "ResponseFormat",
    "ResponseFormatResponseFormatText",
    "ResponseFormatResponseFormatJsonObject",
    "ResponseFormatResponseFormatJsonSchema",
    "ResponseFormatResponseFormatJsonSchemaJsonSchema",
    "ToolChoice",
    "ToolChoiceChatCompletionNamedToolChoiceParam",
    "ToolChoiceChatCompletionNamedToolChoiceParamFunction",
    "Tool",
    "ToolFunction",
    "ToolCacheControl",
    "CompletionCreateParamsNonStreaming",
    "CompletionCreateParamsStreaming",
]


class CompletionCreateParamsBase(TypedDict, total=False):
    model: Required[str]
    """The name of the model.

    Should be formatted as `vendor/model_name` or `vendor/model_name/deployment`
    (ie: `openai/gpt-3.5-turbo`).
    """

    prompt: Required[str]
    """Prompt for which to generate the completion.

    Good prompt engineering is crucial to getting performant results from the model.
    If you are having trouble getting the model to perform well, try writing a more
    specific prompt here before trying more expensive techniques such as swapping in
    other models or finetuning the underlying LLM.
    """

    audio: Audio
    """Audio-related parameters for chat completion"""

    best_of: int
    """
    Generates best_of completions server-side and returns the `best` (the one with
    the highest log probability per token). Results cannot be streamed.
    """

    frequency_penalty: float
    """Number between -2.0 and 2.0.

    Positive values penalize new tokens based on their existing frequency in the
    text so far, decreasing the model's likelihood to repeat the same line verbatim.
    """

    guided_choice: List[str]

    guided_grammar: str

    guided_json: object

    guided_regex: str

    include_stop_str_in_output: bool

    inference_extra_headers: object
    """Additional headers to be included in the API request"""

    inference_extra_params: object
    """Additional params to be included in the API request"""

    inference_timeout: Union[float, str]
    """Timeout for the API request"""

    logit_bias: Dict[str, int]
    """Modify the likelihood of specified tokens appearing in the completion.

    Accepts a JSON object that maps tokens (specified by their token ID in the
    tokenizer) to an associated bias value from -100 to 100. Mathematically, the
    bias is added to the logits generated by the model prior to sampling. The exact
    effect will vary per model, but values between -1 and 1 should decrease or
    increase likelihood of selection; values like -100 or 100 should result in a ban
    or exclusive selection of the relevant token.
    """

    logprobs: bool
    """
    Whether to return log probabilities of the output tokens or not. If true,
    returns the log probabilities of each output token returned in the content of
    message.
    """

    max_completion_tokens: int
    """Maximum number of tokens to generate in the completion"""

    max_new_tokens: int

    max_tokens: int
    """The maximum number of tokens that can be generated.

    The token count of your prompt plus max_tokens cannot exceed the model's context
    length.
    """

    modalities: List[Literal["text", "audio"]]
    """List of modalities for the chat completion"""

    n: int
    """How many completions to generate for each prompt.

    Note: Because this parameter generates many completions, it can quickly consume
    your token quota. Use carefully and ensure that you have reasonable settings for
    max_tokens and stop.
    """

    parallel_tool_calls: bool
    """Currently only supported for OpenAI models.Enables calling tools in parallel."""

    prediction: object
    """Configure a predicted output to reduce latency"""

    presence_penalty: float
    """Number between -2.0 and 2.0.

    Positive values penalize new tokens based on whether they appear in the text so
    far, increasing the model's likelihood to talk about new topics.
    """

    response_format: ResponseFormat
    """An object specifying the format that the model must output"""

    return_token_log_probs: bool

    seed: int
    """
    If specified, our system will make a best effort to sample deterministically,
    such that repeated requests with the same seed and parameters should return the
    same result.
    """

    stop: Union[str, List[str]]
    """Up to 4 sequences where the API will stop generating further tokens."""

    stop_sequences: List[str]

    stream_options: object
    """Customize streaming behavior"""

    suffix: str
    """
    The suffix that comes after a completion of inserted text.This parameter is only
    supported for gpt-3.5-turbo-instruct.
    """

    temperature: float
    """The sampling temperature to use for the completion.

    Higher values mean the model will take more risks.
    """

    tool_choice: ToolChoice
    """
    Currently only supported for OpenAI and Anthropic models.Controls which (if any)
    tool is called by the model.
    """

    tools: Iterable[Tool]
    """
    Currently only supported for OpenAI and Anthropic models.A list of tools the
    model may call.Currently, only functions are supported as a tool.Use this to
    provide a list of functions the model may generate JSON inputs for.
    """

    top_k: int
    """Only sample from the top K options for each subsequent token"""

    top_logprobs: int
    """
    An integer between 0 and 20 specifying the number of most likely tokens to
    return at each token position, each with an associated log probability. logprobs
    must be set to true if this parameter is used.
    """

    top_p: float
    """
    An alternative to sampling with temperature, called nucleus sampling, where the
    model considers the results of the tokens with top_p probability mass. So 0.1
    means only the tokens comprising the top 10% probability mass are considered.

    It is generally recommended to alter this or temperature but not both.
    """

    user: str
    """A unique identifier representing your end-user."""


class Audio(TypedDict, total=False):
    format: Required[Literal["wav", "mp3", "flac", "opus", "pcm16"]]

    voice: Required[Literal["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse"]]


class ResponseFormatResponseFormatText(TypedDict, total=False):
    type: Required[Literal["text"]]


class ResponseFormatResponseFormatJsonObject(TypedDict, total=False):
    type: Required[Literal["json_object"]]


class ResponseFormatResponseFormatJsonSchemaJsonSchema(TypedDict, total=False):
    name: Required[str]

    description: str

    schema: object

    strict: bool


class ResponseFormatResponseFormatJsonSchema(TypedDict, total=False):
    json_schema: Required[ResponseFormatResponseFormatJsonSchemaJsonSchema]

    type: Required[Literal["json_schema"]]


ResponseFormat: TypeAlias = Union[
    ResponseFormatResponseFormatText,
    ResponseFormatResponseFormatJsonObject,
    ResponseFormatResponseFormatJsonSchema,
    object,
]


class ToolChoiceChatCompletionNamedToolChoiceParamFunction(TypedDict, total=False):
    name: Required[str]


class ToolChoiceChatCompletionNamedToolChoiceParam(TypedDict, total=False):
    function: Required[ToolChoiceChatCompletionNamedToolChoiceParamFunction]

    type: Required[Literal["function"]]


ToolChoice: TypeAlias = Union[Literal["none", "auto", "required"], ToolChoiceChatCompletionNamedToolChoiceParam]


class ToolFunction(TypedDict, total=False):
    name: Required[str]

    description: str

    parameters: object


class ToolCacheControl(TypedDict, total=False):
    type: Required[Literal["ephemeral"]]


class Tool(TypedDict, total=False):
    function: Required[ToolFunction]

    type: Required[Union[Literal["function"], str]]

    cache_control: ToolCacheControl


class CompletionCreateParamsNonStreaming(CompletionCreateParamsBase, total=False):
    stream: Literal[False]
    """Whether or not to stream the response.

    Setting this to True will stream the response in real-time.
    """


class CompletionCreateParamsStreaming(CompletionCreateParamsBase):
    stream: Required[Literal[True]]
    """Whether or not to stream the response.

    Setting this to True will stream the response in real-time.
    """


CompletionCreateParams = Union[CompletionCreateParamsNonStreaming, CompletionCreateParamsStreaming]
