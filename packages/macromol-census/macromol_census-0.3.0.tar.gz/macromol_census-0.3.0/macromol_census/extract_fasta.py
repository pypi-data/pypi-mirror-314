"""\
Usage:
    extract_fasta <in:db> <in:type> [<out:fasta>] [-l <length>] [-f]

Arguments:
    <in:db>
        The path to a database generated by `mmc_ingest_mmcif`.

    <in:type>
        What kinds of sequences to include in the output file.  Below is a list 
        of the types that can be specified, along with the list of PDB polymer 
        types (specifically: `_entity_poly.type`) that each corresponds to:

        protein:
            polypeptide(L)
            
        d-protein:
            polypeptide(D)

        dna:
            polydeoxyribonucleotide

        rna:
            polyribonucleotide

        nucleic-acid:
            polydeoxyribonucleotide
            polyribonucleotide
            polydeoxyribonucleotide/polyribonucleotide hybrid

    <out:fasta>
        The path where the output fasta file should be written.  If not 
        specified, the pattern `{db.stem}_{type}.fasta` will be used.

Options:
    -l --min-length <int>       [default: 0]
        Only include sequences that are longer than the given length

    -f --force
        If the output file already exists, overwrite it.
"""

from .database_io import open_db
from .error import UsageError
from pathlib import Path
from difflib import get_close_matches

TYPES = {
        'protein': [
            'polypeptide(L)',
        ],
        'd-protein': [
            'polypeptide(D)',
        ],
        'dna': [
            'polydeoxyribonucleotide',
        ],
        'rna': [
            'polyribonucleotide',
        ],
        'nucleic-acid': [
            'polydeoxyribonucleotide',
            'polyribonucleotide',
            'polydeoxyribonucleotide/polyribonucleotide hybrid',
        ],
}

def main():
    import docopt

    args = docopt.docopt(__doc__)
    db = open_db(db_cli := args['<in:db>'])
    types = get_types(type_cli := args['<in:type>'])
    fasta = Path(args['<out:fasta>'] or f'{Path(db_cli).stem}_{type_cli}.fasta'.replace('-', '_'))
    min_length = int(args['--min-length'])

    if fasta.exists() and not args['--force']:
        print(f'abort: file already exists: {fasta}')
        raise SystemExit

    df = select_entity_sequences(
            db, types,
            min_length=min_length,
    )
    write_fasta(df, fasta)

def get_types(user_type):
    try:
        return TYPES[user_type]

    except KeyError:
        err = UsageError(
                type=user_type,
                did_you_mean=get_close_matches(user_type, TYPES)
        )
        err.brief = "unknown sequence type {type!r}"
        err.hints += lambda e: f"did you mean: {','.join(map(repr, e['did_you_mean']))}"
        raise err from None

def select_entity_sequences(db, types, *, min_length):
    return db.execute(f'''\
            SELECT 
                entity.id AS entity_id,
                structure.pdb_id AS struct_pdb_id,
                entity.pdb_id AS entity_pdb_id,
                list(chain.pdb_id) AS chain_pdb_ids,
                arbitrary(sequence) AS sequence,
            FROM entity_polymer
            JOIN entity ON (entity.id == entity_polymer.entity_id)
            JOIN structure ON (structure.id == entity.struct_id)
            JOIN subchain ON (entity.id == subchain.entity_id)
            JOIN chain ON (chain.id == subchain.chain_id)
            WHERE entity_polymer.type IN ({', '.join('?' * len(types))})
            AND length(sequence) > ?
            GROUP BY entity.id, structure.pdb_id, entity.pdb_id
            ORDER BY structure.pdb_id, entity.pdb_id
    ''', (*types, min_length,)).pl()

def write_fasta(df, out_path):
    from Bio import SeqIO
    from Bio.Seq import Seq
    from Bio.SeqRecord import SeqRecord

    # It would be a little simpler for my code if I referred to entities by 
    # their primary key id, instead of their composite PDB ids.  However, the 
    # latter format is compatible with the clusters distributed by the PDB 
    # itself, which I think might be valuable.  It's also more intuitive for 
    # users, and possibly easier to use with third party tools.

    SeqIO.write(
            (
                SeqRecord(
                    Seq(row['sequence']),
                    id='{struct_pdb_id}_{entity_pdb_id}'.format_map(row),
                    description=f'chains={",".join(row["chain_pdb_ids"])}',
                )
                for row in df.iter_rows(named=True)
            ),
            out_path,
            'fasta',
    )

