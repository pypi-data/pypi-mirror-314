from collections.abc import Callable, Coroutine
from logging import Logger
from typing import Any, NotRequired, TypedDict, Unpack

from fastapi import BackgroundTasks, Request, Response, status
from fastapi.exceptions import HTTPException
from fastapi.responses import JSONResponse
from pydantic_core import ErrorDetails

from fastapi_batteries.utils import types_utils


class ProblemJSON(TypedDict):
    """Data to send while raising the ProblemDetails exception.

    ProblemJSON schema: https://www.rfc-editor.org/rfc/rfc9457.html#appendix-A
    """

    type: NotRequired[str]
    title: str
    status: int
    detail: NotRequired[str]
    instance: NotRequired[str]
    extensions: NotRequired[dict[str, types_utils.JSONType | list[ErrorDetails]]]


class APIException(HTTPException):
    """Exception class that follows RFC 9457 Problem Details for HTTP APIs.

    Ref: https://www.rfc-editor.org/rfc/rfc9457.html
    """

    def __init__(
        self,
        *,
        headers: dict[str, str] | None = None,
        exc_note: str | None = None,
        **problem_json: Unpack[ProblemJSON],
    ) -> None:
        """APIException class that follows RFC 9457 Problem Details for HTTP APIs.

        Args:
            problem_json: Problem Details JSON object.

            problem_json["title"]: A short, human-readable summary of the problem type.
                  SHOULD NOT change from occurrence to occurrence of the problem.
            problem_json["status"]: The HTTP status code generated by the origin server for this problem.
                   MUST match the status code in the HTTP response.
            problem_json["type"]: A URI reference that identifies the problem type.
                 When dereferenced, it SHOULD provide human-readable documentation.
                 Optional - defaults to "about:blank".
            problem_json["detail"]: A human-readable explanation specific to this occurrence of the problem.
                   Supplements the title and provides more specific details.
            problem_json["instance"]: A URI reference that identifies the specific occurrence of the problem.
                     Optional - may be reused by other documentation.
            problem_json["extensions"]: Additional members holding problem type-specific details.
                      Can include custom fields or validation errors.

            headers: Additional HTTP headers to include in the response.
                    Content-Type is automatically set to application/problem+json.
            exc_note: Internal detailed note/message to be logged for debugging purposes.
                     Not included in the response sent to the client.

        """
        # Add content-type header as per RFC
        headers = headers or {}
        headers["content-type"] = "application/problem+json"

        if exc_note:
            self.add_note(exc_note)

        # Add status code to detail as per RFC
        super().__init__(
            status_code=problem_json["status"],
            detail=problem_json | problem_json.get("extensions", {}),
            headers=headers,
        )


def get_api_exception_handler(
    *,
    api_exception_logger: Logger | None = None,
    send_mail_callable: Callable[..., BackgroundTasks] | None = None,
) -> Callable[[Request, Exception], Coroutine[Any, Any, Response]]:
    """Get the APIException handler for FastAPI that converts response to RFC 9457.

    Currently FastAPI has no built-in support for RFC 9457 Problem Details for HTTP APIs.
    We created custom APIException class should be used in conjunction with this handler.

    Args:
        api_exception_logger: Logger instance to log API exceptions.
        send_mail_callable: Callable that returns BackgroundTasks to send email on 5xx errors.

    Returns:
        A coroutine that handles APIException and returns a JSONResponse with RFC 9457 format.

    Examples:
        Without Arguments:
        ```python
        from fastapi import FastAPI
        from fastapi.responses import JSONResponse
        from fastapi_batteries.utils.exceptions import APIException, get_api_exception_handler

        app = FastAPI()

        # Add the APIException handler
        app.add_exception_handler(APIException, get_api_exception_handler())

        @app.get("/raises-exception")
        async def raises_exception():
            raise APIException(
                title="Test exception",
                status=400,
                exc_note="This is a test exception note",
            )
        ```

        With Arguments:
        ```python
        from fastapi import FastAPI
        from fastapi.responses import JSONResponse
        from fastapi_batteries.utils.exceptions import APIException, get_api_exception_handler

        def send_mail_on_5xx_errors() -> BackgroundTasks:
            tasks = BackgroundTasks()

            mail_content = f'''\
            There's new unhandled exception is thrown.

            {traceback.format_exc()}
            '''

            tasks.add_task(
                your_send_mail_callable,
                "MyApp - Unhandled Exception",
                ["admin@mail.com"],  # List of email recipients
                "Your email content",
            )

            return tasks

        app = FastAPI()

        # Add the APIException handler
        app.add_exception_handler(
            APIException,
            get_api_exception_handler(
                api_exception_logger=logger,
                send_mail_callable=send_mail_on_5xx_errors,
            )
        )

        @app.get("/raises-exception")
        async def raises_exception():
            raise APIException(
                title="Test exception",
                status=400,
                exc_note="This is a test exception note",
            )
        ```

    """

    async def api_exception_handler(request: Request, exc: Exception) -> Response:
        """Handle ApiException by logging it and returning the error response."""
        if isinstance(exc, APIException):
            # Log the API exception with full traceback
            if api_exception_logger:
                api_exception_logger.exception(exc)

            tasks: None | BackgroundTasks = None
            if send_mail_callable and exc.status_code >= status.HTTP_500_INTERNAL_SERVER_ERROR:
                tasks = send_mail_callable()

            return JSONResponse(
                headers=exc.headers,
                status_code=exc.status_code,
                content=exc.detail,
                background=tasks,
            )

        # Let other exceptions pass through
        raise exc

    return api_exception_handler
